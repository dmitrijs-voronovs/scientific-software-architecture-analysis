id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889:37,Availability,error,errors,37,"Wow this is an amazing black hole of errors. So now that we know Multiary is better, we can actually compute a bit more of the viscous dissipation than we thought, eg:. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2)); ```. But there be dragons... ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. amazingly, the error continues to morph. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889:350,Availability,ERROR,ERROR,350,"Wow this is an amazing black hole of errors. So now that we know Multiary is better, we can actually compute a bit more of the viscous dissipation than we thought, eg:. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2)); ```. But there be dragons... ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. amazingly, the error continues to morph. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889:362,Availability,error,error,362,"Wow this is an amazing black hole of errors. So now that we know Multiary is better, we can actually compute a bit more of the viscous dissipation than we thought, eg:. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2)); ```. But there be dragons... ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. amazingly, the error continues to morph. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889:453,Availability,error,error,453,"Wow this is an amazing black hole of errors. So now that we know Multiary is better, we can actually compute a bit more of the viscous dissipation than we thought, eg:. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2)); ```. But there be dragons... ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. amazingly, the error continues to morph. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889:570,Availability,ERROR,ERROR,570,"el image is invalid (code 200, ERROR_INVALID_IMAGE); ```. amazingly, the error continues to morph. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889:582,Availability,error,error,582,"el image is invalid (code 200, ERROR_INVALID_IMAGE); ```. amazingly, the error continues to morph. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889:688,Availability,error,error,688,"el image is invalid (code 200, ERROR_INVALID_IMAGE); ```. amazingly, the error continues to morph. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889:2369,Availability,error,errors,2369,"el image is invalid (code 200, ERROR_INVALID_IMAGE); ```. amazingly, the error continues to morph. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889:2354,Safety,abort,aborted,2354,"el image is invalid (code 200, ERROR_INVALID_IMAGE); ```. amazingly, the error continues to morph. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:50,Availability,error,errors,50,"In summary, we can encounter at least 3 different errors:. ### 1. Dynamic function invocation. ```; julia> compute!(ComputedField(u + v - w)); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),...; Reason: unsupported dynamic function invocation...; ```. Solution: probably the compiler isn't inferring types correctly. I think we can use Cthulhu to fully diagnose this error (though we may still need to be creative to solve the problem). ### 2. device kernel image is invalid?!?!. ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:143,Availability,ERROR,ERROR,143,"In summary, we can encounter at least 3 different errors:. ### 1. Dynamic function invocation. ```; julia> compute!(ComputedField(u + v - w)); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),...; Reason: unsupported dynamic function invocation...; ```. Solution: probably the compiler isn't inferring types correctly. I think we can use Cthulhu to fully diagnose this error (though we may still need to be creative to solve the problem). ### 2. device kernel image is invalid?!?!. ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:420,Availability,error,error,420,"In summary, we can encounter at least 3 different errors:. ### 1. Dynamic function invocation. ```; julia> compute!(ComputedField(u + v - w)); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),...; Reason: unsupported dynamic function invocation...; ```. Solution: probably the compiler isn't inferring types correctly. I think we can use Cthulhu to fully diagnose this error (though we may still need to be creative to solve the problem). ### 2. device kernel image is invalid?!?!. ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:609,Availability,ERROR,ERROR,609,"In summary, we can encounter at least 3 different errors:. ### 1. Dynamic function invocation. ```; julia> compute!(ComputedField(u + v - w)); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),...; Reason: unsupported dynamic function invocation...; ```. Solution: probably the compiler isn't inferring types correctly. I think we can use Cthulhu to fully diagnose this error (though we may still need to be creative to solve the problem). ### 2. device kernel image is invalid?!?!. ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:621,Availability,error,error,621,"In summary, we can encounter at least 3 different errors:. ### 1. Dynamic function invocation. ```; julia> compute!(ComputedField(u + v - w)); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),...; Reason: unsupported dynamic function invocation...; ```. Solution: probably the compiler isn't inferring types correctly. I think we can use Cthulhu to fully diagnose this error (though we may still need to be creative to solve the problem). ### 2. device kernel image is invalid?!?!. ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:856,Availability,ERROR,ERROR,856,"; ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. Solution: probably som",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:868,Availability,error,error,868,"; ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. Solution: probably som",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:974,Availability,error,error,974,"; ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. Solution: probably som",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:2655,Availability,error,errors,2655,"CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. Solution: probably some of the suggestions on #746 are useful; we might need to submit a PR to CUDA.jl for this. I think this might be the toughest of all (more argument for also resolving #1246)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:150,Performance,Load,LoadError,150,"In summary, we can encounter at least 3 different errors:. ### 1. Dynamic function invocation. ```; julia> compute!(ComputedField(u + v - w)); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),...; Reason: unsupported dynamic function invocation...; ```. Solution: probably the compiler isn't inferring types correctly. I think we can use Cthulhu to fully diagnose this error (though we may still need to be creative to solve the problem). ### 2. device kernel image is invalid?!?!. ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:2640,Safety,abort,aborted,2640,"CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. Solution: probably some of the suggestions on #746 are useful; we might need to submit a PR to CUDA.jl for this. I think this might be the toughest of all (more argument for also resolving #1246)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738871561:15,Availability,error,error,15,Haha that last error might actually be worth framing on a wall!. RIP PTX assembler,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738871561
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-746668137:24,Availability,error,errors,24,Can you please post the errors that you obtain in each case?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-746668137
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-746683879:229,Testability,test,testing,229,"Hmm, I can't reproduce the same results exactly. All I did before was honestly open a Julia session and just paste the examples you guys posted one by one. Here's [a pastebin](https://pastebin.com/gC5k5n7X) with my whole session testing the commands I got in the previous post. (The comments of course don't reflect the outcome anymore.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-746683879
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-747098083:47,Availability,error,errors,47,"Awesome, thank you, that's helpful. Stochastic errors are troubling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-747098083
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:1299,Availability,error,error,1299,"= 80; topology = (Periodic, Bounded, Bounded); grid = RegularRectilinearGrid(size=(1, 512, 8), x=(0, Lx), y=(0, Ly), z=(-Lz, 0),; topology=(Periodic, Bounded, Bounded)). model = IncompressibleModel(architecture = GPU(),; grid = grid,; ). w_ic(x, y, z) = 0.01*y; v_ic(x, y, z) = 0.01*x; set!(model, w=w_ic, v=v_ic). import Oceananigans.Fields: ComputedField, KernelComputedField; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.Grids: Center, Face. u, v, w = model.velocities. function naive_calc(); p = sum(model.pressures); wp = @at (Center, Center, Face) w*p; dwpdz = (1/1024) * ∂z(wp); println(dwpdz); return ComputedField(dwpdz); end. function nested_calc(); p = ComputedField(sum(model.pressures)); wp = ComputedField(@at (Center, Center, Face) w*p); dwpdz = (1/1024) * ∂z(wp); println(dwpdz); return ComputedField(dwpdz); end; ```. I can include this script in the REPL after which I get the following results. First, when trying to compute the naive calculation using a GPU I get an error, which is expected at this point:. ```julia; julia> dwpdz_naive = naive_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── * at (Center, Center, Face) via identity;          ├── Field located at (Center, Center, Face);          └── + at (Center, Center, Center) via identity;             ├── Field located at (Center, Center, Center);             └── Field located at (Center, Center, Center); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8);",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:2393,Availability,ERROR,ERROR,2393,"er, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── * at (Center, Center, Face) via identity;          ├── Field located at (Center, Center, Face);          └── + at (Center, Center, Center) via identity;             ├── Field located at (Center, Center, Center);             └── Field located at (Center, Center, Center); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_naive); ERROR: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 512, 8)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 2, 8)},KernelAbstractions.NDIteration.StaticSize{(1, 256, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(*),Float64,Oceananigans.AbstractOperations.Derivative{Center,Center,Center,typeof(Oceananigans.Operators.∂zᵃᵃᶜ),Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Face,typeof(*),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,1}},Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(+),Offset",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:5120,Availability,error,error,5120,"StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub(overdub_context::Cassette.Context, overdub_arguments...) in Cassette at /glade/u/home/tomasc/.julia/packages/Cassette/Wjztv/src/overdub.jl:595); Stacktrace:; [1] getindex at /glade/u/home/tomasc/.julia/packages/Oceananigans/WSSHu/src/AbstractOperations/binary_operations.jl:34; [2] macro expansion at /glade/u/home/tomasc/.julia/packages/Oceananigans/WSSHu/src/Fields/computed_field.jl:114; [3] gpu__compute! at /glade/u/home/tomasc/.julia/packages/KernelAbstractions/mKsXc/src/macros.jl:80; [4] overdub at /glade/u/home/tomasc/.julia/packages/Cassette/Wjztv/src/overdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, int",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6088,Energy Efficiency,Adapt,Adapt,6088,"verdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.002765",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6102,Energy Efficiency,adapt,adapt,6102,"d = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.00276553 -0.00220933 -0.00157462 -0.00105926 -0.000692536 -0.000446557 -0.00028606 … 0.00062928 0.000993307 0.0015715 0.00249751 0.00400184 0.00649",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:5126,Integrability,message,message,5126,"StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub(overdub_context::Cassette.Context, overdub_arguments...) in Cassette at /glade/u/home/tomasc/.julia/packages/Cassette/Wjztv/src/overdub.jl:595); Stacktrace:; [1] getindex at /glade/u/home/tomasc/.julia/packages/Oceananigans/WSSHu/src/AbstractOperations/binary_operations.jl:34; [2] macro expansion at /glade/u/home/tomasc/.julia/packages/Oceananigans/WSSHu/src/Fields/computed_field.jl:114; [3] gpu__compute! at /glade/u/home/tomasc/.julia/packages/KernelAbstractions/mKsXc/src/macros.jl:80; [4] overdub at /glade/u/home/tomasc/.julia/packages/Cassette/Wjztv/src/overdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, int",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6088,Modifiability,Adapt,Adapt,6088,"verdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.002765",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6102,Modifiability,adapt,adapt,6102,"d = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.00276553 -0.00220933 -0.00157462 -0.00105926 -0.000692536 -0.000446557 -0.00028606 … 0.00062928 0.000993307 0.0015715 0.00249751 0.00400184 0.00649",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:7948,Testability,test,tests,7948,"1 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.00276553 -0.00220933 -0.00157462 -0.00105926 -0.000692536 -0.000446557 -0.00028606 … 0.00062928 0.000993307 0.0015715 0.00249751 0.00400184 0.0064944 0.0106821. [:, :, 6] =; -0.00852329 -0.00657626 -0.00455259 -0.00300401 -0.00193944 -0.00123966 -0.000788713 … -0.000470821 -0.000722127 -0.00106354 -0.00141766 -0.00138651 0.000390487. [:, :, 7] =; -0.0156445 -0.0109965 -0.0071831 -0.00459454 -0.00291877 -0.00184967 -0.00117105 … -0.00143385 -0.00226136 -0.00355998 -0.00557919 -0.00863921 -0.0129097 -0.0170153. [:, :, 8] =; -0.0260963 -0.0148272 -0.00893539 -0.00552894 -0.00346128 -0.00217808 -0.00137374 … -0.00251345 -0.00397508 -0.00630142 -0.0100415 -0.0161907 -0.0268075 -0.0470868. ```. (Btw, the example above obviously works fine with `architecture=CPU()`, where I can check that `dwpdz_nested` actually produces the correct result.). I even ran some other tests with even increased complexity. And they all appear to work on GPUs. For example this one:. ```julia; function crazy_calc(); p = ComputedField(sum(model.pressures)); wp = ComputedField(@at (Center, Center, Face) w*p); dwpdz = (1/1024) * ∂z(wp); println(dwpdz); dwpdz = ComputedField(dwpdz); dwpdz2 = ComputedField(dwpdz^2); return ComputedField(dwpdz2+dwpdz); end; ```. I'd appreciate if some of you could try to reproduce this result on other machines. I ran this in one of NCAR's Tesla V100s. If you can reproduce this behavior, then this kinda makes `KernelComputedField`s obsolete, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:133,Usability,feedback,feedback,133,"I'm not sure if people are still thinking about this, but I may have some relevant information (Good news!) that I'd appreciate some feedback on. Consider the following MWE:. ```julia; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Fields. Lx = 150; Ly = 6000; Lz = 80; topology = (Periodic, Bounded, Bounded); grid = RegularRectilinearGrid(size=(1, 512, 8), x=(0, Lx), y=(0, Ly), z=(-Lz, 0),; topology=(Periodic, Bounded, Bounded)). model = IncompressibleModel(architecture = GPU(),; grid = grid,; ). w_ic(x, y, z) = 0.01*y; v_ic(x, y, z) = 0.01*x; set!(model, w=w_ic, v=v_ic). import Oceananigans.Fields: ComputedField, KernelComputedField; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.Grids: Center, Face. u, v, w = model.velocities. function naive_calc(); p = sum(model.pressures); wp = @at (Center, Center, Face) w*p; dwpdz = (1/1024) * ∂z(wp); println(dwpdz); return ComputedField(dwpdz); end. function nested_calc(); p = ComputedField(sum(model.pressures)); wp = ComputedField(@at (Center, Center, Face) w*p); dwpdz = (1/1024) * ∂z(wp); println(dwpdz); return ComputedField(dwpdz); end; ```. I can include this script in the REPL after which I get the following results. First, when trying to compute the naive calculation using a GPU I get an error, which is expected at this point:. ```julia; julia> dwpdz_naive = naive_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── * at (Center, Center, Face) via identity;          ├── Field located at (Center, Center, Face);          └── + at (Center, Center, Center) via identity;             ├── Field located at (Center, Center, Center);             └── Field located at (Center, Center, Center)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:770,Availability,avail,available,770,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:1285,Modifiability,variab,variables,1285,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:644,Performance,optimiz,optimization,644,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:974,Performance,optimiz,optimize,974,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:1227,Performance,perform,performance,1227,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:661,Safety,avoid,avoiding,661,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:877,Safety,avoid,avoids,877,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:2128,Availability,ERROR,ERROR,2128,"Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux), v = Field located at (Center, Face, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 3, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux), w = Field located at (Center, Center, Face); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 3, 4); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=NormalFlow, top=NormalFlow)). julia> compute!(ComputedField(u + v - w)) # Now this works. julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)) # still doesnt work; ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)) # still doesn't work; ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 802; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI6CenterS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity222RegularRectilinearGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int6410_identity310_identity410_identity5S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:2140,Availability,error,error,2140,"Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux), v = Field located at (Center, Face, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 3, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux), w = Field located at (Center, Center, Face); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 3, 4); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=NormalFlow, top=NormalFlow)). julia> compute!(ComputedField(u + v - w)) # Now this works. julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)) # still doesnt work; ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)) # still doesn't work; ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 802; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI6CenterS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity222RegularRectilinearGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int6410_identity310_identity410_identity5S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:2313,Availability,ERROR,ERROR,2313,"el image is invalid (code 200, ERROR_INVALID_IMAGE). julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)) # still doesn't work; ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 802; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI6CenterS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity222RegularRectilinearGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int6410_identity310_identity410_identity5S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity1S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S25_S26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES27_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S29_S18_S25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S27_S29_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S28_S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S26_S27_S29_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S25_S26_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:2325,Availability,error,error,2325,"el image is invalid (code 200, ERROR_INVALID_IMAGE). julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)) # still doesn't work; ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 802; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI6CenterS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity222RegularRectilinearGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int6410_identity310_identity410_identity5S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity1S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S25_S26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES27_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S29_S18_S25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S27_S29_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S28_S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S26_S27_S29_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S25_S26_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:2431,Availability,error,error,2431,"el image is invalid (code 200, ERROR_INVALID_IMAGE). julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)) # still doesn't work; ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 802; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI6CenterS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity222RegularRectilinearGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int6410_identity310_identity410_identity5S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity1S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S25_S26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES27_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S29_S18_S25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S27_S29_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S28_S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S26_S27_S29_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S25_S26_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:4150,Availability,error,errors,4150,"9_Li3ES10_IS9_Li3ELi1EEE10_identity1S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S25_S26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES27_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S29_S18_S25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S27_S29_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S28_S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S26_S27_S29_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S25_S26_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. We haven't discussed the problem with `AveragedField` on this thread. I think we need a new issue for that (can't remember if there already is one). It actually looks like some, but not all of the issue there have been solved. A minimal example is:. ```julia; julia> U = AveragedField(u, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (1, 1, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── dims: (1, 2); ├── operand: Field located at (Face, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(u - U)). julia> compute!(ComputedField((u - U)^2)). julia> V = AveragedField(v, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:6448,Availability,ERROR,ERROR,6448,"id{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center) via identity;    ├── 0.5;    └── + at (Face, Center, Center);       ├── ^ at (Face, Center, Center) via identity;       │   ├── - at (Face, Center, Center) via identity;       │   │   ├── Field located at (Face, Center, Center);       │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);       │   └── 2;       ├── ^ at (Center, Face, Center) via identity;       │   ├── - at (Center, Face, Center) via identity;       │   │   ├── Field located at (Center, Face, Center);       │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center);       │   └── 2;       └── ^ at (Center, Center, Face) via identity;          ├── Field located at (Center, Center, Face);          └── 2. julia> compute!(ComputedField(tke)); ERROR: InvalidIRError: compiling kernel gpu__compute!; ```. Interestingly, this works:. ```julia; julia> tke = ((u - U)^2 + (v - V)^2 + w^2) / 2; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Face, Center, Center) via identity;    ├── + at (Face, Center, Center);    │   ├── ^ at (Face, Center, Center) via identity;    │   │   ├── - at (Face, Center, Center) via identity;    │   │   │   ├── Field located at (Face, Center, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    │   │   └── 2;    │   ├── ^ at (Center, Face, Center) via identity;    │   │   ├── - at (Center, Face, Center) via identity;    │   │   │   ├── Field located at (Center, Face, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Cent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:7864,Deployability,update,update,7864,"── Field located at (Center, Face, Center);       │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center);       │   └── 2;       └── ^ at (Center, Center, Face) via identity;          ├── Field located at (Center, Center, Face);          └── 2. julia> compute!(ComputedField(tke)); ERROR: InvalidIRError: compiling kernel gpu__compute!; ```. Interestingly, this works:. ```julia; julia> tke = ((u - U)^2 + (v - V)^2 + w^2) / 2; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Face, Center, Center) via identity;    ├── + at (Face, Center, Center);    │   ├── ^ at (Face, Center, Center) via identity;    │   │   ├── - at (Face, Center, Center) via identity;    │   │   │   ├── Field located at (Face, Center, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    │   │   └── 2;    │   ├── ^ at (Center, Face, Center) via identity;    │   │   ├── - at (Center, Face, Center) via identity;    │   │   │   ├── Field located at (Center, Face, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center);    │   │   └── 2;    │   └── ^ at (Center, Center, Face) via identity;       │   ├── Field located at (Center, Center, Face);       │   └── 2;    └── 2. julia> compute!(ComputedField(tke)); ```. So I guess we are almost there with `AveragedField`. I think the order or arguments could actually matter for compilation due to heuristics that are invoked during compilation... ?. We might update the test for computations with `AveragedField` because they might pass with a different ordering. We could also change how `AbstractOperations` are built and put `Number` as the second argument regardless of how the expression is written.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:4135,Safety,abort,aborted,4135,"9_Li3ES10_IS9_Li3ELi1EEE10_identity1S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S25_S26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES27_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S29_S18_S25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S27_S29_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S28_S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S26_S27_S29_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S25_S26_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. We haven't discussed the problem with `AveragedField` on this thread. I think we need a new issue for that (can't remember if there already is one). It actually looks like some, but not all of the issue there have been solved. A minimal example is:. ```julia; julia> U = AveragedField(u, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (1, 1, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── dims: (1, 2); ├── operand: Field located at (Face, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(u - U)). julia> compute!(ComputedField((u - U)^2)). julia> V = AveragedField(v, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:7875,Testability,test,test,7875,"── Field located at (Center, Face, Center);       │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center);       │   └── 2;       └── ^ at (Center, Center, Face) via identity;          ├── Field located at (Center, Center, Face);          └── 2. julia> compute!(ComputedField(tke)); ERROR: InvalidIRError: compiling kernel gpu__compute!; ```. Interestingly, this works:. ```julia; julia> tke = ((u - U)^2 + (v - V)^2 + w^2) / 2; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Face, Center, Center) via identity;    ├── + at (Face, Center, Center);    │   ├── ^ at (Face, Center, Center) via identity;    │   │   ├── - at (Face, Center, Center) via identity;    │   │   │   ├── Field located at (Face, Center, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    │   │   └── 2;    │   ├── ^ at (Center, Face, Center) via identity;    │   │   ├── - at (Center, Face, Center) via identity;    │   │   │   ├── Field located at (Center, Face, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center);    │   │   └── 2;    │   └── ^ at (Center, Center, Face) via identity;       │   ├── Field located at (Center, Center, Face);       │   └── 2;    └── 2. julia> compute!(ComputedField(tke)); ```. So I guess we are almost there with `AveragedField`. I think the order or arguments could actually matter for compilation due to heuristics that are invoked during compilation... ?. We might update the test for computations with `AveragedField` because they might pass with a different ordering. We could also change how `AbstractOperations` are built and put `Number` as the second argument regardless of how the expression is written.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872698:1200,Availability,ERROR,ERROR,1200,"This doesn't work sadly:. ```julia; julia> tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Center, Center, Center) via identity;    ├── + at (Center, Center, Center);    │   ├── ^ at (Center, Center, Center) via identity;    │   │   ├── - at (Center, Center, Center) via identity;    │   │   │   ├── Field located at (Face, Center, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    │   │   └── 2;    │   ├── ^ at (Center, Center, Center) via identity;    │   │   ├── - at (Center, Center, Center) via identity;    │   │   │   ├── Field located at (Center, Face, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center);    │   │   └── 2;    │   └── ^ at (Center, Center, Center) via ℑzᵃᵃᶜ;       │   ├── Field located at (Center, Center, Face);       │   └── 2;    └── 2. julia> compute!(ComputedField(tke)); ERROR: InvalidIRError: compiling kernel gpu__compute!; ```. There's something fishy there, worth looking into. We can change the topic of this issue to focus on `AveragedField` or open a new one. Happy to do either. EDIT: I see the issue. While we ensure that binary operations always occur at the common location for fields, we haven't ensured that operations between fields and _ReducedFields_ occur at the location of the 3D field. We can fix this by defining a few more functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872698
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821882911:599,Energy Efficiency,Reduce,ReducedFields,599,"> There's something fishy there, worth looking into. We can change the topic of this issue to focus on AveragedField or open a new one. Happy to do either. Thanks for all the work! I think I'll reopen this thread then since the issue is not resolved and we may still be able to make progress. Also there's a chance that someone will see this thread and have some good ideas now that we specifically link this thread in the GPU docs. > EDIT: I see the issue. While we ensure that binary operations always occur at the common location for fields, we haven't ensured that operations between fields and ReducedFields occur at the location of the 3D field. We can fix this by defining a few more functions. That's awesome! I vote for another separate issue for the averaged fields in the name of organization. But I'll let you decide that one since you already have insights into how to solve it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821882911
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-822887354:1306,Integrability,depend,dependent,1306,"@glwagner Just FYI, some of the things that did not work for you, actually worked for me. Most notably:. ```julia; julia> tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Center, Center, Center) via identity;    ├── + at (Center, Center, Center);    │   ├── ^ at (Center, Center, Center) via identity;    │   │   ├── - at (Center, Center, Center) via identity;    │   │   │   ├── Field located at (Face, Center, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    │   │   └── 2;    │   ├── ^ at (Center, Center, Center) via identity;    │   │   ├── - at (Center, Center, Center) via identity;    │   │   │   ├── Field located at (Center, Face, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center);    │   │   └── 2;    │   └── ^ at (Center, Center, Center) via ℑzᵃᵃᶜ;       │   ├── Field located at (Center, Center, Face);       │   └── 2;    └── 2. julia> compute!(tke). julia> ; ```. So it appears to be machine-dependent at least to some extent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-822887354
https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-884902923:183,Deployability,update,update,183,Interesting. I will open a new issue that's specific to the current issue with a concise summary. It's hard to parse the conversation in this long issue. I guess we will also have to update the docs for this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-884902923
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788:562,Availability,error,error,562,"> Should AMD use z_dot_g_b now?. The implementation of a ""buoyancy-aware"" AMD is not correct... But yes, if we wanted to have a working version of this feature, it would have to know the direction of gravity. We'd have to add terms that depend on the horizontal directions for it to be correct I think, which probably warrants re-deriving it for generalized gravity from scratch. Since it doesn't even work for vertical gravity we should probably just nuke it and address later. Simplest would be to implement a working version for vertical gravity and throw an error if gravity is tilted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788:237,Integrability,depend,depend,237,"> Should AMD use z_dot_g_b now?. The implementation of a ""buoyancy-aware"" AMD is not correct... But yes, if we wanted to have a working version of this feature, it would have to know the direction of gravity. We'd have to add terms that depend on the horizontal directions for it to be correct I think, which probably warrants re-deriving it for generalized gravity from scratch. Since it doesn't even work for vertical gravity we should probably just nuke it and address later. Simplest would be to implement a working version for vertical gravity and throw an error if gravity is tilted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788:479,Usability,Simpl,Simplest,479,"> Should AMD use z_dot_g_b now?. The implementation of a ""buoyancy-aware"" AMD is not correct... But yes, if we wanted to have a working version of this feature, it would have to know the direction of gravity. We'd have to add terms that depend on the horizontal directions for it to be correct I think, which probably warrants re-deriving it for generalized gravity from scratch. Since it doesn't even work for vertical gravity we should probably just nuke it and address later. Simplest would be to implement a working version for vertical gravity and throw an error if gravity is tilted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:3190,Deployability,Patch,Patch,3190," - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b574af8f9b259bd480acf1bdd913e8969bb440833342c0fba3f1150>; > (7); > - *M* src/Buoyancy/linear_equation_of_state.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-f3c384915af5bdd55a7a9cb929dee20fcca1682630706def515ed65b5a3cb490>; > (42); > - *M* src/Buoyancy/seawater_buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-17b154b6d4fa0d986ee4ef99715cced4bc7eac3c93690c52239d83745090c334>; > (56); > - *M* src/Models/IncompressibleModels/calculate_tendencies.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-d06aacb9cbc9584fb2a2b179fd21415b042b52b97b6ee8da84cf3db2f97c332c>; > (10); > - *M* src/Models/IncompressibleModels/update_hydrostatic_pressure.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-cac1602a95ce47ec833e4e03b0d684d4e95f4129b74770798b6cad304491fb9d>; > (4); > - *M* src/Models/IncompressibleModels/velocity_and_tracer_tendencies.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-015b2369f27f408eb92ff3d3931082333604e2cf3fcb40ebd72ebbf970d4d144>; > (22); >; > Patch Links:; >; > - https://github.com/CliMA/Oceananigans.jl/pull/1242.patch; > - https://github.com/CliMA/Oceananigans.jl/pull/1242.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1242>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQWSWFTACIASZ2L2AETSS27BBANCNFSM4ULEPDEQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:3262,Deployability,patch,patch,3262," - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b574af8f9b259bd480acf1bdd913e8969bb440833342c0fba3f1150>; > (7); > - *M* src/Buoyancy/linear_equation_of_state.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-f3c384915af5bdd55a7a9cb929dee20fcca1682630706def515ed65b5a3cb490>; > (42); > - *M* src/Buoyancy/seawater_buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-17b154b6d4fa0d986ee4ef99715cced4bc7eac3c93690c52239d83745090c334>; > (56); > - *M* src/Models/IncompressibleModels/calculate_tendencies.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-d06aacb9cbc9584fb2a2b179fd21415b042b52b97b6ee8da84cf3db2f97c332c>; > (10); > - *M* src/Models/IncompressibleModels/update_hydrostatic_pressure.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-cac1602a95ce47ec833e4e03b0d684d4e95f4129b74770798b6cad304491fb9d>; > (4); > - *M* src/Models/IncompressibleModels/velocity_and_tracer_tendencies.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-015b2369f27f408eb92ff3d3931082333604e2cf3fcb40ebd72ebbf970d4d144>; > (22); >; > Patch Links:; >; > - https://github.com/CliMA/Oceananigans.jl/pull/1242.patch; > - https://github.com/CliMA/Oceananigans.jl/pull/1242.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1242>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQWSWFTACIASZ2L2AETSS27BBANCNFSM4ULEPDEQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:1089,Modifiability,refactor,refactor,1089," 2, 2020, 5:41 PM Ali Ramadhan <notifications@github.com> wrote:. > This PR adds experimental support for rotating/tilting the gravity vector.; >; > I'm not even sure if it works properly but I'm opening a draft PR as it; > might be ready to be experimented with? I don't think we can have a; > non-zero gravity component along a periodic direction as the fluid just; > free falls along that dimension and the model blows up.; >; > But here's a plume rising with gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b5",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:1604,Modifiability,sandbox,sandbox,1604,"th gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b574af8f9b259bd480acf1bdd913e8969bb440833342c0fba3f1150>; > (7); > - *M* src/Buoyancy/linear_equation_of_state.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-f3c384915af5bdd55a7a9cb929dee20fcca1682630706def515ed65b5a3cb490>; > (42); > - *M* src/Buoyancy/seawater_buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-17b154b6d4fa0d986ee4ef99715cced4bc7eac3c93690c52239d83745090c334>; > (56); > - *M* src/Models/Incom",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:1643,Modifiability,sandbox,sandbox,1643,"th gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b574af8f9b259bd480acf1bdd913e8969bb440833342c0fba3f1150>; > (7); > - *M* src/Buoyancy/linear_equation_of_state.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-f3c384915af5bdd55a7a9cb929dee20fcca1682630706def515ed65b5a3cb490>; > (42); > - *M* src/Buoyancy/seawater_buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-17b154b6d4fa0d986ee4ef99715cced4bc7eac3c93690c52239d83745090c334>; > (56); > - *M* src/Models/Incom",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:819,Testability,test,testing,819,"Ali, good progress. Does this keep a resting fluid stratified in the; direction of gravity at rest? John. On Wed, Dec 2, 2020, 5:41 PM Ali Ramadhan <notifications@github.com> wrote:. > This PR adds experimental support for rotating/tilting the gravity vector.; >; > I'm not even sure if it works properly but I'm opening a draft PR as it; > might be ready to be experimented with? I don't think we can have a; > non-zero gravity component along a periodic direction as the fluid just; > free falls along that dimension and the model blows up.; >; > But here's a plume rising with gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:1604,Testability,sandbox,sandbox,1604,"th gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b574af8f9b259bd480acf1bdd913e8969bb440833342c0fba3f1150>; > (7); > - *M* src/Buoyancy/linear_equation_of_state.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-f3c384915af5bdd55a7a9cb929dee20fcca1682630706def515ed65b5a3cb490>; > (42); > - *M* src/Buoyancy/seawater_buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-17b154b6d4fa0d986ee4ef99715cced4bc7eac3c93690c52239d83745090c334>; > (56); > - *M* src/Models/Incom",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:1643,Testability,sandbox,sandbox,1643,"th gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b574af8f9b259bd480acf1bdd913e8969bb440833342c0fba3f1150>; > (7); > - *M* src/Buoyancy/linear_equation_of_state.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-f3c384915af5bdd55a7a9cb929dee20fcca1682630706def515ed65b5a3cb490>; > (42); > - *M* src/Buoyancy/seawater_buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-17b154b6d4fa0d986ee4ef99715cced4bc7eac3c93690c52239d83745090c334>; > (56); > - *M* src/Models/Incom",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737551257:194,Integrability,message,message,194,"> How is this possible with a periodic solution?. Maybe I'm missing something, but I can't imagine how that would _not_ happen. Take the example animation that @ali-ramadhan posted in the first message. If you image the same IC but with a domain periodic in x and z the blob would accelerate towards the upper right and come back in the lower left endlessly, but constantly gaining speed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737551257
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737554035:144,Integrability,message,message,144,"> Maybe I'm missing something, but I can't imagine how that would not happen. Take the example animation that @ali-ramadhan posted in the first message. If you image the same IC but with a domain periodic in x and z the blob would accelerate towards the upper right and come back in the lower left endlessly, but constantly gaining speed. I think the problem is that we cannot impose a `b` that has a non-zero domain average. This is consistent with its definition (eg it is proportional to the density _perturbation_; we subtract out a reference density in Boussinesq). Consider the x-momentum equation:. ```; du/dt + ... = b sin(theta); ```. if `b` has no net average, then the average of this equation is just. ```; d <u> / dt = 0; ```. right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737554035
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737639915:1307,Energy Efficiency,schedul,schedule,1307,"ot a problem conceptually. But it might indeed lead to big velocities that they may require smaller dt to tame the CFL. That's not a problem of the code though... It's something the user should be aware. A similar issue comes up, e.g., if you set up a highly unstable stratification. In that case the code will blow up unless you choose your dt appropriately (see, e.g., #1190). Now, in an attempt to show that having `z` periodic is not an issue, I tried to simulate the rising bubble with periodic boundary conditions. I got this puzzling result. Did I do anything wrong?. ```Julia; using Oceananigans, Oceananigans.Grids, Plots. grid = RegularCartesianGrid(size = (1, 64, 64),; x = (0, 1), y = (-4, 4), z = (-4, 4),; topology = (Periodic, Periodic, Periodic)). model = IncompressibleModel(grid = grid,; architecture = CPU(),; advection = Oceananigans.Advection.WENO5(),; tracers = :b,; buoyancy = BuoyancyTracer(),; closure = IsotropicDiffusivity(ν=1e-3, κ=1e-3)). @info ""Simulating a rising buoyant bubble with"" model. set!(model, b = (x, y, z) -> exp(-y^2 - z^2)). simulation = Simulation(model, Δt=0.01, stop_iteration=1000). using Oceananigans.OutputWriters. simulation.output_writers[:fields] = JLD2OutputWriter(model, (model.tracers.b,),; schedule = TimeInterval(0.1),; prefix = ""bubble"",; force = true). run!(simulation). using JLD2. file = jldopen(simulation.output_writers[:fields].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). b = model.tracers.b. y, z = ynodes(b), znodes(b). # Analyze the data. anim = @animate for (i, iteration) in enumerate(iterations); b_snapshot = file[""timeseries/1/$iteration""][1, :, :]. plt = contourf(y, z, b_snapshot',; xlabel = ""y"", ylabel = ""z"", title = ""Buoyancy"",; xlim = (grid.yF[1], grid.yF[end]), ylim = (grid.zF[1], grid.zF[end]),; aspectratio = :equal, linewidth = 0); end. gif(anim, ""bubble.gif"", fps = 8) # hide; ```. ![bubble](https://user-images.githubusercontent.com/7112768/100959619-cd30bf80-3572-11eb-84a7-89f304ef7ccc.gif)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737639915
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-738007469:328,Testability,test,test,328,Thanks for the discussion @glwagner @tomchor @wenegrat I see that it was the initial condition that was unsuitable. Will read Wenegrat & Thomas (2020) to better understand how you set up your simulation there. > Does this keep a resting fluid stratified in the direction of gravity at rest? John. Ah that would indeed be a good test: set up an inviscid ocean stratified in the direction of g and ensure that the velocities remain (close to) zero. Ah interesting result @navidcy... Your setup looks good to me but not sure I can explain it either. Almost weirdly looks like the bubble is hitting an invisible boundary haha (I expected the bubble to keep rising and not spread out so suddently...),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-738007469
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-738030820:262,Testability,test,test,262,"> Did I do anything wrong?. @navidcy you may want to visualize the vertical velocity field. It looks possibly like the right solution in the case that you had used a buoyancy field with zero domain mean (despite that you did not specify this). @ali-ramadhan can test this by tweaking his ""sideways gravity"" example to have zero initial mean buoyancy. @navidcy you can also test this by subtracting the domain mean from your initial buoyancy condition and confirming that you obtain the same result. You can also confirm that, no matter what mean buoyancy you set, you get the same result. Finally, @navidcy I would check to see whether the hydrostatic pressure is vertically periodic in all of the cases you try.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-738030820
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-738030820:373,Testability,test,test,373,"> Did I do anything wrong?. @navidcy you may want to visualize the vertical velocity field. It looks possibly like the right solution in the case that you had used a buoyancy field with zero domain mean (despite that you did not specify this). @ali-ramadhan can test this by tweaking his ""sideways gravity"" example to have zero initial mean buoyancy. @navidcy you can also test this by subtracting the domain mean from your initial buoyancy condition and confirming that you obtain the same result. You can also confirm that, no matter what mean buoyancy you set, you get the same result. Finally, @navidcy I would check to see whether the hydrostatic pressure is vertically periodic in all of the cases you try.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-738030820
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312:1100,Modifiability,inherit,inherit,1100,"Sorry if I'm missing something obvious (still new with the working of Oceananigans/Julia), but I was trying to test this feature and expand it to `BuoyancyTracer` over the weekend and I wonder if this implementation can be made more general. . The way I understand @ali-ramadhan created some functions `g_x` to extract the gravity components in each direction and then used them in the `x_dot_g_b` functions to calculate each component of the gravity acceleration. The thing is that gravity can only be a vector using `SeawaterBuoyancy`. When trying to apply this to `BuoyancyTracer` I found that I'd need to replicate the same feature but with a different name (since, as @glwagner pointed out, `gravitational_acceleration` would be a confusing name when working directly with buoyancy). Also, if you also think issue https://github.com/CliMA/Oceananigans.jl/issues/1372 is relevant, it might be nice to have one unified word/approach for the tilting of the domain. So what do you guys think if this tilting is implement at the `AbstractBuoyancy` level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe `tilt`, `gravitational_direction` or `gravity_projection`) that would default to `(0, 0, 1)` and a similar option could be given to `FPlane`, avoiding confusion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312:1312,Safety,avoid,avoiding,1312,"Sorry if I'm missing something obvious (still new with the working of Oceananigans/Julia), but I was trying to test this feature and expand it to `BuoyancyTracer` over the weekend and I wonder if this implementation can be made more general. . The way I understand @ali-ramadhan created some functions `g_x` to extract the gravity components in each direction and then used them in the `x_dot_g_b` functions to calculate each component of the gravity acceleration. The thing is that gravity can only be a vector using `SeawaterBuoyancy`. When trying to apply this to `BuoyancyTracer` I found that I'd need to replicate the same feature but with a different name (since, as @glwagner pointed out, `gravitational_acceleration` would be a confusing name when working directly with buoyancy). Also, if you also think issue https://github.com/CliMA/Oceananigans.jl/issues/1372 is relevant, it might be nice to have one unified word/approach for the tilting of the domain. So what do you guys think if this tilting is implement at the `AbstractBuoyancy` level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe `tilt`, `gravitational_direction` or `gravity_projection`) that would default to `(0, 0, 1)` and a similar option could be given to `FPlane`, avoiding confusion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312:111,Testability,test,test,111,"Sorry if I'm missing something obvious (still new with the working of Oceananigans/Julia), but I was trying to test this feature and expand it to `BuoyancyTracer` over the weekend and I wonder if this implementation can be made more general. . The way I understand @ali-ramadhan created some functions `g_x` to extract the gravity components in each direction and then used them in the `x_dot_g_b` functions to calculate each component of the gravity acceleration. The thing is that gravity can only be a vector using `SeawaterBuoyancy`. When trying to apply this to `BuoyancyTracer` I found that I'd need to replicate the same feature but with a different name (since, as @glwagner pointed out, `gravitational_acceleration` would be a confusing name when working directly with buoyancy). Also, if you also think issue https://github.com/CliMA/Oceananigans.jl/issues/1372 is relevant, it might be nice to have one unified word/approach for the tilting of the domain. So what do you guys think if this tilting is implement at the `AbstractBuoyancy` level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe `tilt`, `gravitational_direction` or `gravity_projection`) that would default to `(0, 0, 1)` and a similar option could be given to `FPlane`, avoiding confusion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:704,Integrability,interface,interface,704,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:1625,Integrability,wrap,wrapper,1625,"ey can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact multiple model components at the same time. This has cropped up in `HydrostaticFreeSurfaceModel` where `gravitational_acceleration` can be specified separately in the buoyancy model and the free surface model. Dealing with global physical parameters is the purpose of the [`CLIMAParameters`](https://github.com/CliMA/CLIMAParameters.jl) package so we may need to brainstorm about how to use that package in this context...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:133,Modifiability,inherit,inherit,133,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:335,Safety,avoid,avoiding,335,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:545,Safety,avoid,avoiding,545,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:1285,Safety,avoid,avoid,1285," a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact multiple model components at the same time. This has cropped up in `HydrostaticFreeSurfaceModel` where `gravitational_acceleration` can be specified separately in the buoyancy model and the free surface model. Dealing with global physical parameters is the purpose of the [`CLIMAParameters`](",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:488,Testability,log,logic,488,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782997067:172,Usability,clear,clear,172,"> buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()). I actually really like this approach. It's a bit verbose, I agree, but it's extremely clear and intuitive. It seems like it would be a bit of work though, no? (I wouldn't know how to do it...). @ali-ramadhan since you coded this PR, anything to add?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782997067
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782997067:182,Usability,intuit,intuitive,182,"> buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()). I actually really like this approach. It's a bit verbose, I agree, but it's extremely clear and intuitive. It seems like it would be a bit of work though, no? (I wouldn't know how to do it...). @ali-ramadhan since you coded this PR, anything to add?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782997067
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783479651:311,Testability,test,test,311,"`gravitational_direction` for `Buoyancy` seems like a good name!. Is it a ""direction"" where g_x + g_y + g_z = 1 or is it a unit vector where |g| = g_x^2 + g_y^2 + g_z^2 = 1?. This PR has gotten a bit stale but should be easy to revive and add `gravitational_direction`. I guess we thought this PR was missing a test? I'm happy to merge it as long as the 45 degree slanted rising thermal bubble looks good and we can worry about adding a more rigorous test in a future PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783479651
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783479651:451,Testability,test,test,451,"`gravitational_direction` for `Buoyancy` seems like a good name!. Is it a ""direction"" where g_x + g_y + g_z = 1 or is it a unit vector where |g| = g_x^2 + g_y^2 + g_z^2 = 1?. This PR has gotten a bit stale but should be easy to revive and add `gravitational_direction`. I guess we thought this PR was missing a test? I'm happy to merge it as long as the 45 degree slanted rising thermal bubble looks good and we can worry about adding a more rigorous test in a future PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783479651
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746:1210,Availability,avail,available,1210,"I think it's more intuitive if `gravitational_direction` is a unit vector where `|g|=1`, no?. > I guess we thought this PR was missing a test? I'm happy to merge it as long as the 45 degree slanted rising thermal bubble looks good and we can worry about adding a more rigorous test in a future PR?. I ran the bubble case and it looked okay to me. I don't know if that's already good enough for merging this PR. I'd recomment merging once we get the more general tilt for buoyancy (if you agree that that's important.). My idea was to start a more rigorous test using a tilted BBL example from the literature this weekend. I was thinking this could eventually become a docs example to show. - Tilted gravity; - Monin-Obukhov similarity wall model; - Maybe stretched grid if it's done by then?; - NetCDF outputs (I think none of the current examples use NetCDF). I ended up not doing it because the papers I went through used both buoyancy as a tracer (not implement yet in this PR; hence my comment here) and tilt the domain in the `x` direction, so I'd need an `x` component of coriolis (hence my issue https://github.com/CliMA/Oceananigans.jl/issues/1372). I know these things are easy to circumvent with the available tools (i.e. using temperature to get the proper buoyancy and rotating the domain so that the tilt is in `y`, not `x`), but I thought it was best to make a thorough test once as these tools were in place already.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746:137,Testability,test,test,137,"I think it's more intuitive if `gravitational_direction` is a unit vector where `|g|=1`, no?. > I guess we thought this PR was missing a test? I'm happy to merge it as long as the 45 degree slanted rising thermal bubble looks good and we can worry about adding a more rigorous test in a future PR?. I ran the bubble case and it looked okay to me. I don't know if that's already good enough for merging this PR. I'd recomment merging once we get the more general tilt for buoyancy (if you agree that that's important.). My idea was to start a more rigorous test using a tilted BBL example from the literature this weekend. I was thinking this could eventually become a docs example to show. - Tilted gravity; - Monin-Obukhov similarity wall model; - Maybe stretched grid if it's done by then?; - NetCDF outputs (I think none of the current examples use NetCDF). I ended up not doing it because the papers I went through used both buoyancy as a tracer (not implement yet in this PR; hence my comment here) and tilt the domain in the `x` direction, so I'd need an `x` component of coriolis (hence my issue https://github.com/CliMA/Oceananigans.jl/issues/1372). I know these things are easy to circumvent with the available tools (i.e. using temperature to get the proper buoyancy and rotating the domain so that the tilt is in `y`, not `x`), but I thought it was best to make a thorough test once as these tools were in place already.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746:277,Testability,test,test,277,"I think it's more intuitive if `gravitational_direction` is a unit vector where `|g|=1`, no?. > I guess we thought this PR was missing a test? I'm happy to merge it as long as the 45 degree slanted rising thermal bubble looks good and we can worry about adding a more rigorous test in a future PR?. I ran the bubble case and it looked okay to me. I don't know if that's already good enough for merging this PR. I'd recomment merging once we get the more general tilt for buoyancy (if you agree that that's important.). My idea was to start a more rigorous test using a tilted BBL example from the literature this weekend. I was thinking this could eventually become a docs example to show. - Tilted gravity; - Monin-Obukhov similarity wall model; - Maybe stretched grid if it's done by then?; - NetCDF outputs (I think none of the current examples use NetCDF). I ended up not doing it because the papers I went through used both buoyancy as a tracer (not implement yet in this PR; hence my comment here) and tilt the domain in the `x` direction, so I'd need an `x` component of coriolis (hence my issue https://github.com/CliMA/Oceananigans.jl/issues/1372). I know these things are easy to circumvent with the available tools (i.e. using temperature to get the proper buoyancy and rotating the domain so that the tilt is in `y`, not `x`), but I thought it was best to make a thorough test once as these tools were in place already.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746:556,Testability,test,test,556,"I think it's more intuitive if `gravitational_direction` is a unit vector where `|g|=1`, no?. > I guess we thought this PR was missing a test? I'm happy to merge it as long as the 45 degree slanted rising thermal bubble looks good and we can worry about adding a more rigorous test in a future PR?. I ran the bubble case and it looked okay to me. I don't know if that's already good enough for merging this PR. I'd recomment merging once we get the more general tilt for buoyancy (if you agree that that's important.). My idea was to start a more rigorous test using a tilted BBL example from the literature this weekend. I was thinking this could eventually become a docs example to show. - Tilted gravity; - Monin-Obukhov similarity wall model; - Maybe stretched grid if it's done by then?; - NetCDF outputs (I think none of the current examples use NetCDF). I ended up not doing it because the papers I went through used both buoyancy as a tracer (not implement yet in this PR; hence my comment here) and tilt the domain in the `x` direction, so I'd need an `x` component of coriolis (hence my issue https://github.com/CliMA/Oceananigans.jl/issues/1372). I know these things are easy to circumvent with the available tools (i.e. using temperature to get the proper buoyancy and rotating the domain so that the tilt is in `y`, not `x`), but I thought it was best to make a thorough test once as these tools were in place already.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746:1384,Testability,test,test,1384,"I think it's more intuitive if `gravitational_direction` is a unit vector where `|g|=1`, no?. > I guess we thought this PR was missing a test? I'm happy to merge it as long as the 45 degree slanted rising thermal bubble looks good and we can worry about adding a more rigorous test in a future PR?. I ran the bubble case and it looked okay to me. I don't know if that's already good enough for merging this PR. I'd recomment merging once we get the more general tilt for buoyancy (if you agree that that's important.). My idea was to start a more rigorous test using a tilted BBL example from the literature this weekend. I was thinking this could eventually become a docs example to show. - Tilted gravity; - Monin-Obukhov similarity wall model; - Maybe stretched grid if it's done by then?; - NetCDF outputs (I think none of the current examples use NetCDF). I ended up not doing it because the papers I went through used both buoyancy as a tracer (not implement yet in this PR; hence my comment here) and tilt the domain in the `x` direction, so I'd need an `x` component of coriolis (hence my issue https://github.com/CliMA/Oceananigans.jl/issues/1372). I know these things are easy to circumvent with the available tools (i.e. using temperature to get the proper buoyancy and rotating the domain so that the tilt is in `y`, not `x`), but I thought it was best to make a thorough test once as these tools were in place already.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746:18,Usability,intuit,intuitive,18,"I think it's more intuitive if `gravitational_direction` is a unit vector where `|g|=1`, no?. > I guess we thought this PR was missing a test? I'm happy to merge it as long as the 45 degree slanted rising thermal bubble looks good and we can worry about adding a more rigorous test in a future PR?. I ran the bubble case and it looked okay to me. I don't know if that's already good enough for merging this PR. I'd recomment merging once we get the more general tilt for buoyancy (if you agree that that's important.). My idea was to start a more rigorous test using a tilted BBL example from the literature this weekend. I was thinking this could eventually become a docs example to show. - Tilted gravity; - Monin-Obukhov similarity wall model; - Maybe stretched grid if it's done by then?; - NetCDF outputs (I think none of the current examples use NetCDF). I ended up not doing it because the papers I went through used both buoyancy as a tracer (not implement yet in this PR; hence my comment here) and tilt the domain in the `x` direction, so I'd need an `x` component of coriolis (hence my issue https://github.com/CliMA/Oceananigans.jl/issues/1372). I know these things are easy to circumvent with the available tools (i.e. using temperature to get the proper buoyancy and rotating the domain so that the tilt is in `y`, not `x`), but I thought it was best to make a thorough test once as these tools were in place already.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783517290:156,Availability,toler,tolerance,156,Ah we should probably add @johncmarshall54's suggested test before merging: ensure an ocean stratified along the direction of g remains at rest (up to some tolerance? not sure if it'll be machine precision zero).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783517290
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783517290:55,Testability,test,test,55,Ah we should probably add @johncmarshall54's suggested test before merging: ensure an ocean stratified along the direction of g remains at rest (up to some tolerance? not sure if it'll be machine precision zero).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783517290
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-791775664:311,Integrability,interface,interface,311,"@tomchor and I added a `BuoyancyModel` type (can't call it `Buoyancy` since that would conflict with the module name, name is up for debate) to store the gravity unit vector and the buoyancy model. Seems to work with `BuoyancyTracer` from @tomchor's simulations!. I guess what we weren't sure about is the user interface. Right now tilting gravity is done via e.g. ```julia; θ = 45; g = (0, sind(θ), cosd(θ)); model = IncompressibleModel(...; buoyancy = BuoyancyModel(model=BuoyancyTracer(), gravitational_unit_vector=g); ); ```. so now `model.buoyancy` is a `BuoyancyModel`. ---. But what should the user interface look like for not tilting gravity?. We could enforce explicit construction of a `BuoyancyModel` in every script, which may be seen as adding boilerplate, e.g. ```julia; model = IncompressibleModel(...; buoyancy = BuoyancyModel(model=SeawaterBuoyancy()); ); ```. or we could continue allowing. ```julia; model = IncompressibleModel(...; buoyancy = SeawaterBuoyancy(); ); ```. and the model constructor can convert `SeawaterBuoyancy` to a `BuoyancyModel`. This is less boilerplate but maybe somewhat implicit. I'm leaning towards the more implicit second solution of allowing just `buoyancy = SeawaterBuoyancy()`, but might be good to decide on one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-791775664
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-791775664:606,Integrability,interface,interface,606,"@tomchor and I added a `BuoyancyModel` type (can't call it `Buoyancy` since that would conflict with the module name, name is up for debate) to store the gravity unit vector and the buoyancy model. Seems to work with `BuoyancyTracer` from @tomchor's simulations!. I guess what we weren't sure about is the user interface. Right now tilting gravity is done via e.g. ```julia; θ = 45; g = (0, sind(θ), cosd(θ)); model = IncompressibleModel(...; buoyancy = BuoyancyModel(model=BuoyancyTracer(), gravitational_unit_vector=g); ); ```. so now `model.buoyancy` is a `BuoyancyModel`. ---. But what should the user interface look like for not tilting gravity?. We could enforce explicit construction of a `BuoyancyModel` in every script, which may be seen as adding boilerplate, e.g. ```julia; model = IncompressibleModel(...; buoyancy = BuoyancyModel(model=SeawaterBuoyancy()); ); ```. or we could continue allowing. ```julia; model = IncompressibleModel(...; buoyancy = SeawaterBuoyancy(); ); ```. and the model constructor can convert `SeawaterBuoyancy` to a `BuoyancyModel`. This is less boilerplate but maybe somewhat implicit. I'm leaning towards the more implicit second solution of allowing just `buoyancy = SeawaterBuoyancy()`, but might be good to decide on one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-791775664
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154:651,Modifiability,sandbox,sandbox,651,"> I also suggest changing the module name to Buoyancies or BuoyancyModels and reserving Buoyancy for the user-facing object. The current names that @ali-ramadhan and I used were always meant to be a placeholder as we couldn't agree on good ones to use. I quite like this suggestion (and I suspect @ali-ramadhan does too) so I implemented it.; Just as a reference, here are the commands that I used (plus the same for the struct `Buoyancy`):. ```bash; find . -type f -name ""*.jl"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; find . -type f -name ""*.md"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; ```. I also added an example in the sandbox that runs a fully quiescent fluid with a tilted stratification for an hour and then makes sure that the vertical and horizontal derivatives stay the way we expect them. (This test is done both for `BuoyancyTracer` and for `SeawaterBuoyancy`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154:651,Testability,sandbox,sandbox,651,"> I also suggest changing the module name to Buoyancies or BuoyancyModels and reserving Buoyancy for the user-facing object. The current names that @ali-ramadhan and I used were always meant to be a placeholder as we couldn't agree on good ones to use. I quite like this suggestion (and I suspect @ali-ramadhan does too) so I implemented it.; Just as a reference, here are the commands that I used (plus the same for the struct `Buoyancy`):. ```bash; find . -type f -name ""*.jl"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; find . -type f -name ""*.md"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; ```. I also added an example in the sandbox that runs a fully quiescent fluid with a tilted stratification for an hour and then makes sure that the vertical and horizontal derivatives stay the way we expect them. (This test is done both for `BuoyancyTracer` and for `SeawaterBuoyancy`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154:834,Testability,test,test,834,"> I also suggest changing the module name to Buoyancies or BuoyancyModels and reserving Buoyancy for the user-facing object. The current names that @ali-ramadhan and I used were always meant to be a placeholder as we couldn't agree on good ones to use. I quite like this suggestion (and I suspect @ali-ramadhan does too) so I implemented it.; Just as a reference, here are the commands that I used (plus the same for the struct `Buoyancy`):. ```bash; find . -type f -name ""*.jl"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; find . -type f -name ""*.md"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; ```. I also added an example in the sandbox that runs a fully quiescent fluid with a tilted stratification for an hour and then makes sure that the vertical and horizontal derivatives stay the way we expect them. (This test is done both for `BuoyancyTracer` and for `SeawaterBuoyancy`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796443566:63,Testability,test,tests,63,"@tomchor Thanks for adding the tilted gravity stratified fluid tests! I put them in `test_dynamics.jl` and they seem to pass even with 90 and 180 degree tilts!. I noticed that the test starts failing after ~10 hours for some angles though (or at least the deviations start becoming larger than square root of machine epsilon). For example:. ```; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660254037844065e-6, Δ = 3.2187251995663413e-19 at t = 1 hour with θ=60; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.00000000000176e-6, Δ = -1.7592874314471818e-18 at t = 1 hour with θ=60; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660130013623816e-6, Δ = 1.2402422057088938e-10 at t = 10 hours with θ=60; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.000172734522595e-6, Δ = -1.7273452259476338e-10 at t = 10 hours with θ=60. ```. I guess the difference is still pretty small and this is a coarse 2D testing setup with low-order numerics, but it does grow quite a bit. Is this something to be worried about for turbulent simulations? I wonder if it's worth making a movie to see what happens after 10-100+ hours. I think all tests should pass now so we could probably start using tilted gravity more seriously! Still need to address some of @glwagner's comments but will revisit this PR another day to do this. cc @gianlisi @arnscheidt",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796443566
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796443566:180,Testability,test,test,180,"@tomchor Thanks for adding the tilted gravity stratified fluid tests! I put them in `test_dynamics.jl` and they seem to pass even with 90 and 180 degree tilts!. I noticed that the test starts failing after ~10 hours for some angles though (or at least the deviations start becoming larger than square root of machine epsilon). For example:. ```; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660254037844065e-6, Δ = 3.2187251995663413e-19 at t = 1 hour with θ=60; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.00000000000176e-6, Δ = -1.7592874314471818e-18 at t = 1 hour with θ=60; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660130013623816e-6, Δ = 1.2402422057088938e-10 at t = 10 hours with θ=60; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.000172734522595e-6, Δ = -1.7273452259476338e-10 at t = 10 hours with θ=60. ```. I guess the difference is still pretty small and this is a coarse 2D testing setup with low-order numerics, but it does grow quite a bit. Is this something to be worried about for turbulent simulations? I wonder if it's worth making a movie to see what happens after 10-100+ hours. I think all tests should pass now so we could probably start using tilted gravity more seriously! Still need to address some of @glwagner's comments but will revisit this PR another day to do this. cc @gianlisi @arnscheidt",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796443566
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796443566:885,Testability,test,testing,885,"@tomchor Thanks for adding the tilted gravity stratified fluid tests! I put them in `test_dynamics.jl` and they seem to pass even with 90 and 180 degree tilts!. I noticed that the test starts failing after ~10 hours for some angles though (or at least the deviations start becoming larger than square root of machine epsilon). For example:. ```; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660254037844065e-6, Δ = 3.2187251995663413e-19 at t = 1 hour with θ=60; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.00000000000176e-6, Δ = -1.7592874314471818e-18 at t = 1 hour with θ=60; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660130013623816e-6, Δ = 1.2402422057088938e-10 at t = 10 hours with θ=60; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.000172734522595e-6, Δ = -1.7273452259476338e-10 at t = 10 hours with θ=60. ```. I guess the difference is still pretty small and this is a coarse 2D testing setup with low-order numerics, but it does grow quite a bit. Is this something to be worried about for turbulent simulations? I wonder if it's worth making a movie to see what happens after 10-100+ hours. I think all tests should pass now so we could probably start using tilted gravity more seriously! Still need to address some of @glwagner's comments but will revisit this PR another day to do this. cc @gianlisi @arnscheidt",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796443566
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796443566:1110,Testability,test,tests,1110,"@tomchor Thanks for adding the tilted gravity stratified fluid tests! I put them in `test_dynamics.jl` and they seem to pass even with 90 and 180 degree tilts!. I noticed that the test starts failing after ~10 hours for some angles though (or at least the deviations start becoming larger than square root of machine epsilon). For example:. ```; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660254037844065e-6, Δ = 3.2187251995663413e-19 at t = 1 hour with θ=60; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.00000000000176e-6, Δ = -1.7592874314471818e-18 at t = 1 hour with θ=60; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660130013623816e-6, Δ = 1.2402422057088938e-10 at t = 10 hours with θ=60; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.000172734522595e-6, Δ = -1.7273452259476338e-10 at t = 10 hours with θ=60. ```. I guess the difference is still pretty small and this is a coarse 2D testing setup with low-order numerics, but it does grow quite a bit. Is this something to be worried about for turbulent simulations? I wonder if it's worth making a movie to see what happens after 10-100+ hours. I think all tests should pass now so we could probably start using tilted gravity more seriously! Still need to address some of @glwagner's comments but will revisit this PR another day to do this. cc @gianlisi @arnscheidt",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796443566
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828:38,Availability,error,error,38,"@tomchor suggested that the increased error might be due to errors from low-order numerics piling up over many iterations. Indeed, switching to WENO-5 + RK3 reduces the error by an order of magnitude!. ```; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660130013623816e-6, Δ = 1.2402422057088938e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.000172734522595e-6, Δ = -1.7273452259476338e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660230615917627e-6, Δ = 2.3421926760073770e-11 at t = 10 hours with θ=60 # WENO5 + RK3; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.00003008535181e-6, Δ = -3.0085351809812464e-11 at t = 10 hours with θ=60 # WENO5 + RK3; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828:60,Availability,error,errors,60,"@tomchor suggested that the increased error might be due to errors from low-order numerics piling up over many iterations. Indeed, switching to WENO-5 + RK3 reduces the error by an order of magnitude!. ```; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660130013623816e-6, Δ = 1.2402422057088938e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.000172734522595e-6, Δ = -1.7273452259476338e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660230615917627e-6, Δ = 2.3421926760073770e-11 at t = 10 hours with θ=60 # WENO5 + RK3; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.00003008535181e-6, Δ = -3.0085351809812464e-11 at t = 10 hours with θ=60 # WENO5 + RK3; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828:169,Availability,error,error,169,"@tomchor suggested that the increased error might be due to errors from low-order numerics piling up over many iterations. Indeed, switching to WENO-5 + RK3 reduces the error by an order of magnitude!. ```; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660130013623816e-6, Δ = 1.2402422057088938e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.000172734522595e-6, Δ = -1.7273452259476338e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660230615917627e-6, Δ = 2.3421926760073770e-11 at t = 10 hours with θ=60 # WENO5 + RK3; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.00003008535181e-6, Δ = -3.0085351809812464e-11 at t = 10 hours with θ=60 # WENO5 + RK3; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828:157,Energy Efficiency,reduce,reduces,157,"@tomchor suggested that the increased error might be due to errors from low-order numerics piling up over many iterations. Indeed, switching to WENO-5 + RK3 reduces the error by an order of magnitude!. ```; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660130013623816e-6, Δ = 1.2402422057088938e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.000172734522595e-6, Δ = -1.7273452259476338e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660230615917627e-6, Δ = 2.3421926760073770e-11 at t = 10 hours with θ=60 # WENO5 + RK3; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.00003008535181e-6, Δ = -3.0085351809812464e-11 at t = 10 hours with θ=60 # WENO5 + RK3; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800715748:105,Energy Efficiency,reduce,reduce,105,"> Does `regularize_buoyancy()` prevent old scripts using the old notation from failing?. Yes, also helps reduce boilerplate due to e.g. ```julia; model = IncompressibleModel(...,; buoyancy = Buoyancy(model=BuoyancyTracer()); ); ```. since you can just do. ```julia; model = IncompressibleModel(...,; buoyancy = BuoyancyTracer(); ); ```. But yeah also nice that there are no breaking changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800715748
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:200,Performance,perform,performed,200,"I think this PR is finally ready to be merged, provided that tests pass. To make sure that `VerticalDirection` is working, I ran the equation of state benchmarks and they seem to match the benchmarks performed in https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594. If anything, benchmarks seem a bit better (probably different machine) and `RoquetEquationOfState` is surprisingly faster on the CPU (but might be a fluke). ```; Equation of state benchmarks; ┌───────────────┬───────────────────────┬───────────┬───────────┬───────────┬───────────┬─────────────┬────────┐; │ Architectures │ EquationsOfState │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼───────────────────────┼───────────┼───────────┼───────────┼───────────┼─────────────┼────────┤; │ CPU │ LinearEquationOfState │ 2.037 s │ 2.040 s │ 2.039 s │ 2.041 s │ 372.66 KiB │ 2090 │; │ CPU │ RoquetEquationOfState │ 1.759 s │ 1.761 s │ 1.761 s │ 1.763 s │ 373.77 KiB │ 2090 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:1965,Performance,perform,performance,1965,0 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬───────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ EquationsOfState │ slowdown │ memory │ allocs │; ├───────────────┼───────────────────────┼──────────┼──────────┼────────┤; │ CPU │ LinearEquationOfState │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ RoquetEquationOfState │ 0.863549 │ 1.00298 │ 1.0 │; │ CPU │ TEOS10EquationOfState │ 1.17707 │ 0.999665 │ 1.0 │; └───────────────┴───────────────────────┴──────────┴──────────┴────────┘; ```. ```; Equation of state relative performance (GPU); ┌───────────────┬───────────────────────┬──────────┬──────────┬──────────┐; │ Architectures │ EquationsOfState │ slowdown │ memory │ allocs │; ├───────────────┼───────────────────────┼──────────┼──────────┼──────────┤; │ GPU │ LinearEquationOfState │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ RoquetEquationOfState │ 1.00569 │ 1.00208 │ 0.986022 │; │ GPU │ TEOS10EquationOfState │ 1.02292 │ 0.995491 │ 1.0 │; └───────────────┴───────────────────────┴──────────┴──────────┴──────────┘. ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:2481,Performance,perform,performance,2481,0 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬───────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ EquationsOfState │ slowdown │ memory │ allocs │; ├───────────────┼───────────────────────┼──────────┼──────────┼────────┤; │ CPU │ LinearEquationOfState │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ RoquetEquationOfState │ 0.863549 │ 1.00298 │ 1.0 │; │ CPU │ TEOS10EquationOfState │ 1.17707 │ 0.999665 │ 1.0 │; └───────────────┴───────────────────────┴──────────┴──────────┴────────┘; ```. ```; Equation of state relative performance (GPU); ┌───────────────┬───────────────────────┬──────────┬──────────┬──────────┐; │ Architectures │ EquationsOfState │ slowdown │ memory │ allocs │; ├───────────────┼───────────────────────┼──────────┼──────────┼──────────┤; │ GPU │ LinearEquationOfState │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ RoquetEquationOfState │ 1.00569 │ 1.00208 │ 0.986022 │; │ GPU │ TEOS10EquationOfState │ 1.02292 │ 0.995491 │ 1.0 │; └───────────────┴───────────────────────┴──────────┴──────────┴──────────┘. ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:61,Testability,test,tests,61,"I think this PR is finally ready to be merged, provided that tests pass. To make sure that `VerticalDirection` is working, I ran the equation of state benchmarks and they seem to match the benchmarks performed in https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594. If anything, benchmarks seem a bit better (probably different machine) and `RoquetEquationOfState` is surprisingly faster on the CPU (but might be a fluke). ```; Equation of state benchmarks; ┌───────────────┬───────────────────────┬───────────┬───────────┬───────────┬───────────┬─────────────┬────────┐; │ Architectures │ EquationsOfState │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼───────────────────────┼───────────┼───────────┼───────────┼───────────┼─────────────┼────────┤; │ CPU │ LinearEquationOfState │ 2.037 s │ 2.040 s │ 2.039 s │ 2.041 s │ 372.66 KiB │ 2090 │; │ CPU │ RoquetEquationOfState │ 1.759 s │ 1.761 s │ 1.761 s │ 1.763 s │ 373.77 KiB │ 2090 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:151,Testability,benchmark,benchmarks,151,"I think this PR is finally ready to be merged, provided that tests pass. To make sure that `VerticalDirection` is working, I ran the equation of state benchmarks and they seem to match the benchmarks performed in https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594. If anything, benchmarks seem a bit better (probably different machine) and `RoquetEquationOfState` is surprisingly faster on the CPU (but might be a fluke). ```; Equation of state benchmarks; ┌───────────────┬───────────────────────┬───────────┬───────────┬───────────┬───────────┬─────────────┬────────┐; │ Architectures │ EquationsOfState │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼───────────────────────┼───────────┼───────────┼───────────┼───────────┼─────────────┼────────┤; │ CPU │ LinearEquationOfState │ 2.037 s │ 2.040 s │ 2.039 s │ 2.041 s │ 372.66 KiB │ 2090 │; │ CPU │ RoquetEquationOfState │ 1.759 s │ 1.761 s │ 1.761 s │ 1.763 s │ 373.77 KiB │ 2090 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:189,Testability,benchmark,benchmarks,189,"I think this PR is finally ready to be merged, provided that tests pass. To make sure that `VerticalDirection` is working, I ran the equation of state benchmarks and they seem to match the benchmarks performed in https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594. If anything, benchmarks seem a bit better (probably different machine) and `RoquetEquationOfState` is surprisingly faster on the CPU (but might be a fluke). ```; Equation of state benchmarks; ┌───────────────┬───────────────────────┬───────────┬───────────┬───────────┬───────────┬─────────────┬────────┐; │ Architectures │ EquationsOfState │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼───────────────────────┼───────────┼───────────┼───────────┼───────────┼─────────────┼────────┤; │ CPU │ LinearEquationOfState │ 2.037 s │ 2.040 s │ 2.039 s │ 2.041 s │ 372.66 KiB │ 2090 │; │ CPU │ RoquetEquationOfState │ 1.759 s │ 1.761 s │ 1.761 s │ 1.763 s │ 373.77 KiB │ 2090 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:301,Testability,benchmark,benchmarks,301,"I think this PR is finally ready to be merged, provided that tests pass. To make sure that `VerticalDirection` is working, I ran the equation of state benchmarks and they seem to match the benchmarks performed in https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594. If anything, benchmarks seem a bit better (probably different machine) and `RoquetEquationOfState` is surprisingly faster on the CPU (but might be a fluke). ```; Equation of state benchmarks; ┌───────────────┬───────────────────────┬───────────┬───────────┬───────────┬───────────┬─────────────┬────────┐; │ Architectures │ EquationsOfState │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼───────────────────────┼───────────┼───────────┼───────────┼───────────┼─────────────┼────────┤; │ CPU │ LinearEquationOfState │ 2.037 s │ 2.040 s │ 2.039 s │ 2.041 s │ 372.66 KiB │ 2090 │; │ CPU │ RoquetEquationOfState │ 1.759 s │ 1.761 s │ 1.761 s │ 1.763 s │ 373.77 KiB │ 2090 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099
https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:468,Testability,benchmark,benchmarks,468,"I think this PR is finally ready to be merged, provided that tests pass. To make sure that `VerticalDirection` is working, I ran the equation of state benchmarks and they seem to match the benchmarks performed in https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594. If anything, benchmarks seem a bit better (probably different machine) and `RoquetEquationOfState` is surprisingly faster on the CPU (but might be a fluke). ```; Equation of state benchmarks; ┌───────────────┬───────────────────────┬───────────┬───────────┬───────────┬───────────┬─────────────┬────────┐; │ Architectures │ EquationsOfState │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼───────────────────────┼───────────┼───────────┼───────────┼───────────┼─────────────┼────────┤; │ CPU │ LinearEquationOfState │ 2.037 s │ 2.040 s │ 2.039 s │ 2.041 s │ 372.66 KiB │ 2090 │; │ CPU │ RoquetEquationOfState │ 1.759 s │ 1.761 s │ 1.761 s │ 1.763 s │ 373.77 KiB │ 2090 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099
https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413:13,Integrability,wrap,wrapper,13,"Can we use a wrapper that automagically loads data from file for the specified time index (and also perform spatial slicing), using the nice GeoData getindex syntax?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413
https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413:40,Performance,load,loads,40,"Can we use a wrapper that automagically loads data from file for the specified time index (and also perform spatial slicing), using the nice GeoData getindex syntax?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413
https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413:100,Performance,perform,perform,100,"Can we use a wrapper that automagically loads data from file for the specified time index (and also perform spatial slicing), using the nice GeoData getindex syntax?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413
https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-891817915:318,Deployability,update,update,318,"> Hi, is there a reason why this isn't in the official examples?. Is it ready? This comment suggests it's not:. > This PR in a work-in-progress and depends on #1091. I still need to make it Literate. Perhaps @ali-ramadhan wouldn't mind some help though. It's probably stale right now and would need a merge master and update.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-891817915
https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-891817915:148,Integrability,depend,depends,148,"> Hi, is there a reason why this isn't in the official examples?. Is it ready? This comment suggests it's not:. > This PR in a work-in-progress and depends on #1091. I still need to make it Literate. Perhaps @ali-ramadhan wouldn't mind some help though. It's probably stale right now and would need a merge master and update.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-891817915
https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883:596,Availability,down,downsides,596,"After discussing with @ali-ramadhan, it seems more clear that a simple solution is just to use a default halo size of 3. For most models that use the highest order advection scheme we offer this has no effect. For models that use a lower-order advection scheme but don't change the halo size, the memory foot print of the model is ever-so-slightly larger than it needs to be. But this slightly-larger footprint probably isn't noticeable for most problems. So in summary, minimal halo sizes are a minor optimization that has little effect on most problems. Auto-optimizing the halo size has major downsides for usability, so I think the trade-off leans towards big default halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883
https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883:502,Performance,optimiz,optimization,502,"After discussing with @ali-ramadhan, it seems more clear that a simple solution is just to use a default halo size of 3. For most models that use the highest order advection scheme we offer this has no effect. For models that use a lower-order advection scheme but don't change the halo size, the memory foot print of the model is ever-so-slightly larger than it needs to be. But this slightly-larger footprint probably isn't noticeable for most problems. So in summary, minimal halo sizes are a minor optimization that has little effect on most problems. Auto-optimizing the halo size has major downsides for usability, so I think the trade-off leans towards big default halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883
https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883:561,Performance,optimiz,optimizing,561,"After discussing with @ali-ramadhan, it seems more clear that a simple solution is just to use a default halo size of 3. For most models that use the highest order advection scheme we offer this has no effect. For models that use a lower-order advection scheme but don't change the halo size, the memory foot print of the model is ever-so-slightly larger than it needs to be. But this slightly-larger footprint probably isn't noticeable for most problems. So in summary, minimal halo sizes are a minor optimization that has little effect on most problems. Auto-optimizing the halo size has major downsides for usability, so I think the trade-off leans towards big default halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883
https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883:51,Usability,clear,clear,51,"After discussing with @ali-ramadhan, it seems more clear that a simple solution is just to use a default halo size of 3. For most models that use the highest order advection scheme we offer this has no effect. For models that use a lower-order advection scheme but don't change the halo size, the memory foot print of the model is ever-so-slightly larger than it needs to be. But this slightly-larger footprint probably isn't noticeable for most problems. So in summary, minimal halo sizes are a minor optimization that has little effect on most problems. Auto-optimizing the halo size has major downsides for usability, so I think the trade-off leans towards big default halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883
https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883:64,Usability,simpl,simple,64,"After discussing with @ali-ramadhan, it seems more clear that a simple solution is just to use a default halo size of 3. For most models that use the highest order advection scheme we offer this has no effect. For models that use a lower-order advection scheme but don't change the halo size, the memory foot print of the model is ever-so-slightly larger than it needs to be. But this slightly-larger footprint probably isn't noticeable for most problems. So in summary, minimal halo sizes are a minor optimization that has little effect on most problems. Auto-optimizing the halo size has major downsides for usability, so I think the trade-off leans towards big default halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883
https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883:610,Usability,usab,usability,610,"After discussing with @ali-ramadhan, it seems more clear that a simple solution is just to use a default halo size of 3. For most models that use the highest order advection scheme we offer this has no effect. For models that use a lower-order advection scheme but don't change the halo size, the memory foot print of the model is ever-so-slightly larger than it needs to be. But this slightly-larger footprint probably isn't noticeable for most problems. So in summary, minimal halo sizes are a minor optimization that has little effect on most problems. Auto-optimizing the halo size has major downsides for usability, so I think the trade-off leans towards big default halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883
https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-744385156:64,Availability,fault,faults,64,"@navidcy if halos are too small then the code often NaNs or seg faults. The issue here is that we auto adjust halos in the model constructor:. https://github.com/CliMA/Oceananigans.jl/blob/ebd7858000c78f7b1754112a68c587e6195e620b/src/Models/IncompressibleModels/incompressible_model.jl#L111-L112. this means that with a higher-order advection scheme, `model.grid` ends up being different from what the user passes into the constructor. This is a usability issue, because it means that `VelocityFields(arch, grid)` built before the `model` is wrong for the default grid in common scenarios with high-order advection. Thus if users want to build `VelocityFields(arch, grid)` before building a `model`, they need to know about halos. We think this is undesirable. Neatly summed the issue is mainly that we probably can't rely exclusively on the model constructor to infer halo sizes, because the grid is a crucial object that often needs to have correct halo sizes before the model is constructed. Thus we need another solution to this usability issue. I'm proposing that we make the default halos large enough to accommodate almost all use cases to solve this problem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-744385156
https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-744385156:446,Usability,usab,usability,446,"@navidcy if halos are too small then the code often NaNs or seg faults. The issue here is that we auto adjust halos in the model constructor:. https://github.com/CliMA/Oceananigans.jl/blob/ebd7858000c78f7b1754112a68c587e6195e620b/src/Models/IncompressibleModels/incompressible_model.jl#L111-L112. this means that with a higher-order advection scheme, `model.grid` ends up being different from what the user passes into the constructor. This is a usability issue, because it means that `VelocityFields(arch, grid)` built before the `model` is wrong for the default grid in common scenarios with high-order advection. Thus if users want to build `VelocityFields(arch, grid)` before building a `model`, they need to know about halos. We think this is undesirable. Neatly summed the issue is mainly that we probably can't rely exclusively on the model constructor to infer halo sizes, because the grid is a crucial object that often needs to have correct halo sizes before the model is constructed. Thus we need another solution to this usability issue. I'm proposing that we make the default halos large enough to accommodate almost all use cases to solve this problem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-744385156
https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-744385156:1033,Usability,usab,usability,1033,"@navidcy if halos are too small then the code often NaNs or seg faults. The issue here is that we auto adjust halos in the model constructor:. https://github.com/CliMA/Oceananigans.jl/blob/ebd7858000c78f7b1754112a68c587e6195e620b/src/Models/IncompressibleModels/incompressible_model.jl#L111-L112. this means that with a higher-order advection scheme, `model.grid` ends up being different from what the user passes into the constructor. This is a usability issue, because it means that `VelocityFields(arch, grid)` built before the `model` is wrong for the default grid in common scenarios with high-order advection. Thus if users want to build `VelocityFields(arch, grid)` before building a `model`, they need to know about halos. We think this is undesirable. Neatly summed the issue is mainly that we probably can't rely exclusively on the model constructor to infer halo sizes, because the grid is a crucial object that often needs to have correct halo sizes before the model is constructed. Thus we need another solution to this usability issue. I'm proposing that we make the default halos large enough to accommodate almost all use cases to solve this problem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-744385156
https://github.com/CliMA/Oceananigans.jl/issues/1246#issuecomment-759601574:286,Testability,test,tested,286,"@glwagner I modified the docstring with a small example that I think illustrates the patterns relatively in [this commit](https://github.com/CliMA/Oceananigans.jl/pull/1293/commits/3b11bb07ca8a1ff97976d2ce743a1cd8afe2a4f0). I'm assuming that's what you meant by ""example"", right?. I've tested it already in some simple examples and it produces correct results. Is there anything else left besides testing this with an actual complex calculation that can only be done via `KernelComputedField` on a GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1246#issuecomment-759601574
https://github.com/CliMA/Oceananigans.jl/issues/1246#issuecomment-759601574:397,Testability,test,testing,397,"@glwagner I modified the docstring with a small example that I think illustrates the patterns relatively in [this commit](https://github.com/CliMA/Oceananigans.jl/pull/1293/commits/3b11bb07ca8a1ff97976d2ce743a1cd8afe2a4f0). I'm assuming that's what you meant by ""example"", right?. I've tested it already in some simple examples and it produces correct results. Is there anything else left besides testing this with an actual complex calculation that can only be done via `KernelComputedField` on a GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1246#issuecomment-759601574
https://github.com/CliMA/Oceananigans.jl/issues/1246#issuecomment-759601574:312,Usability,simpl,simple,312,"@glwagner I modified the docstring with a small example that I think illustrates the patterns relatively in [this commit](https://github.com/CliMA/Oceananigans.jl/pull/1293/commits/3b11bb07ca8a1ff97976d2ce743a1cd8afe2a4f0). I'm assuming that's what you meant by ""example"", right?. I've tested it already in some simple examples and it produces correct results. Is there anything else left besides testing this with an actual complex calculation that can only be done via `KernelComputedField` on a GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1246#issuecomment-759601574
https://github.com/CliMA/Oceananigans.jl/issues/1247#issuecomment-739324370:97,Testability,test,tests,97,Same here... Examples are fine after reverting in PR #1248 but I also noticed that shallow water tests are passing in that PR but failing on master so that's pretty weird. I'm pretty confused as well.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1247#issuecomment-739324370
https://github.com/CliMA/Oceananigans.jl/issues/1247#issuecomment-739528543:99,Availability,error,errors,99,Hmmm I wonder if this issue is actually due to #1254 (but with a NaN checker added we actually get errors).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1247#issuecomment-739528543
https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538894:36,Availability,checkpoint,checkpoint,36,"That's a neat idea. We also need to checkpoint simulations rather than models, to handle cases where output is time-dependent (windowed time-averages and, in the future, time derivatives).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538894
https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538894:116,Integrability,depend,dependent,116,"That's a neat idea. We also need to checkpoint simulations rather than models, to handle cases where output is time-dependent (windowed time-averages and, in the future, time derivatives).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538894
https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538996:18,Availability,checkpoint,checkpoint,18,"Can we also have `checkpoint(simulation, prefix)` if a checkpointer has not already been created?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538996
https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538996:55,Availability,checkpoint,checkpointer,55,"Can we also have `checkpoint(simulation, prefix)` if a checkpointer has not already been created?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538996
https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131:582,Integrability,depend,depends,582,"Posted from a slack conversation... I’ll try to clarify what we found for @francispoulin and @tomchor, if I understand correctly what was happening. I think @tomchor was. 1. Initializing a velocity field using set!(model, …); 2. Constructing a computed field ∂z_u = ComputedField(∂z(model.velocities.u)); 3. Evaluating the computed field via compute!(∂z_u); 4. Plotting ∂z_u and noticing that it’s wrong on boundaries. The reason why ∂z_u is wrong on boundaries is because the vertical derivative of u is calcaluated with a second-order difference that spans the boundary, and thus depends on “halo points” that are outside the physical domain. In Oceananigans, we use halo points to enforce Periodic, Value and Gradient boundary conditions, and will eventually use them for parallelization. If ∂z_u were calculated during a simulation, the halo points of u would be filled. However, in this case ∂z_u was evaluated before invoking run!As a result, the halo points of u were not filled, and thus ∂z_u was wrong on boundaries.; One fix for this mentioned by @alir is to fill the halo points “manually” by calling fill_halo_regions(u, CPU()) after invoking `set!`. This will work provided that u does not have function boundary conditions. If the boundary conditions of u depend on other model fields or the simulation time, this will fail. The code that fills halo regions is here: https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Models/IncompressibleModels/update_incompressible_model_state.jl#L15-L16. The “real” fix for this (a more generic solution that doesn’t require magical incantations in user scripts), however, is to fill_halo_regions! within set!. In fact, an even better solution is to call update_state!(model) at the end of set!. This way nonlinear diffusivities and hydrostatic pressure are also correct. We have also discussed projecting the velocity field onto an incompressible field within set!. We could make all these changes in one PR p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131
https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131:1270,Integrability,depend,depend,1270,"rom a slack conversation... I’ll try to clarify what we found for @francispoulin and @tomchor, if I understand correctly what was happening. I think @tomchor was. 1. Initializing a velocity field using set!(model, …); 2. Constructing a computed field ∂z_u = ComputedField(∂z(model.velocities.u)); 3. Evaluating the computed field via compute!(∂z_u); 4. Plotting ∂z_u and noticing that it’s wrong on boundaries. The reason why ∂z_u is wrong on boundaries is because the vertical derivative of u is calcaluated with a second-order difference that spans the boundary, and thus depends on “halo points” that are outside the physical domain. In Oceananigans, we use halo points to enforce Periodic, Value and Gradient boundary conditions, and will eventually use them for parallelization. If ∂z_u were calculated during a simulation, the halo points of u would be filled. However, in this case ∂z_u was evaluated before invoking run!As a result, the halo points of u were not filled, and thus ∂z_u was wrong on boundaries.; One fix for this mentioned by @alir is to fill the halo points “manually” by calling fill_halo_regions(u, CPU()) after invoking `set!`. This will work provided that u does not have function boundary conditions. If the boundary conditions of u depend on other model fields or the simulation time, this will fail. The code that fills halo regions is here: https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Models/IncompressibleModels/update_incompressible_model_state.jl#L15-L16. The “real” fix for this (a more generic solution that doesn’t require magical incantations in user scripts), however, is to fill_halo_regions! within set!. In fact, an even better solution is to call update_state!(model) at the end of set!. This way nonlinear diffusivities and hydrostatic pressure are also correct. We have also discussed projecting the velocity field onto an incompressible field within set!. We could make all these changes in one PR perhaps…",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131
https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539551:296,Safety,avoid,avoid,296,"No, it was due to the alignment process but note that the time step is aligned with both output writing and the simulation stop time. The simulation reached `simulation.stop_time` but it was forced to do more iterations in this loop (see below) so so the aligned time step turned out to be 0 (to avoid overshooting `simulation.stop_time`). https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Simulations/run.jl#L158-L166. Now the simulation won't end up in this situation anymore since it stops time stepping early if `simulation.stop_time` is reached.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539551
https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539870:182,Safety,avoid,avoided,182,"Oh. I didn't realize that the time-step was aligned with `simulation.stop_time`. I see then that the problem is intractable with the current ""sub iterations"" design. This problem is avoided by the design proposed in #1138.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539870
https://github.com/CliMA/Oceananigans.jl/pull/1255#issuecomment-739537556:51,Availability,error,error,51,"Yes I pointed that out in #1254. Question is do we error, warn, or return early if `time_step!(model::IncompressibleModel, 0)` is called?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1255#issuecomment-739537556
https://github.com/CliMA/Oceananigans.jl/pull/1255#issuecomment-739537874:95,Testability,test,tests,95,"Examples build again and don't NaN out so this was indeed the issue. I'll merge. Shallow water tests are failing because NaN checker, by default, checks for NaNs in `model.velocities.u` which `ShallowWaterModel` doesn't have. Default should probably be `fields(model)[1]`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1255#issuecomment-739537874
https://github.com/CliMA/Oceananigans.jl/issues/1256#issuecomment-739544512:135,Usability,simpl,simple,135,"I like the second verbose form. This might be hard to solve because the location information is encoded in types, so it's not quite as simple as dispatching on something like. ```julia; const NamedFieldTuple = NamedTuple{S, NTuple{N, <:AbstractField}} where {S, N}; ```. We might some super-field-tuple type idealization like. ```julia; FieldTuple = Union{Tuple{<:AbstractField}, Tuple{<:AbstractField, <:AbstractField}, ...}; ```. and. ```julia; const NamedFieldTuple = NamedTuple{S, FieldTuple} where S; ```. but I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1256#issuecomment-739544512
https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-739937856:25,Testability,test,tests,25,Also shallow water model tests are failing with `type Nothing has no field f`: https://buildkite.com/clima/oceananigans/builds/842#ea16ffb3-252d-4d5a-b46a-a585cedd915e/38-257. I'm guessing the default for `ShallowWaterModel`s is `coriolis = nothing` but the tendency kernels use `coriolis.f`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-739937856
https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-739947818:1586,Deployability,Update,Update,1586,"Thanks @ali-ramadhan that is some great advice and will certainly make the changes you requested and try and not forget these lessons for the future. . For starters, here are Hovmoeller plots of h, uh, and vh from the 1D case. Note that I tried it in the x and y directions and I'm glad to say they produce the same results, except for uh and vh are switched. ![Hovmoller_vh](https://user-images.githubusercontent.com/8239041/101361249-b6d57d00-386c-11eb-90da-552784ea98b7.png); ![Hovmoller_uh](https://user-images.githubusercontent.com/8239041/101361250-b76e1380-386c-11eb-91cd-672bd56da677.png); ![Hovmoller_h](https://user-images.githubusercontent.com/8239041/101361251-b76e1380-386c-11eb-859a-218361e43d7f.png). Second, this is a plot of the solution for the 1D case that starts off with no motion and a Gaussian field for height. This is a nice example of geostrophic adjustment, and can certainly be compared to papers that do such things. ![one_dimensional_shallow_water_x](https://user-images.githubusercontent.com/8239041/101361665-45e29500-386d-11eb-82d8-f440f3b07d80.gif). Third, I have done a 2D case and everything looks qualitatively the same, but it is much more diffusive. This is a plot of a slide through the centre that should reproduce the same thing as above, but the amplitudes are much weaker. This is only 64x64 so it's not very high resolution but I should probably change the advection scheme to make it more accurate. ![one_dimensional_shallow_water_2D_x](https://user-images.githubusercontent.com/8239041/101361578-251a3f80-386d-11eb-8e59-8c02e271cfcc.gif). Update: D'Alembert's solution for the radially symmetric wave equation in 2D differs from that in 1D because of an extra factor of 1/r in front. That is why the waves decay in amplitude much faster in 2D compared to 1D.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-739947818
https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-739952376:124,Testability,test,test,124,"Sorry for not removing the comments before. That was sloppy of me. They are gone now. On a similar note, the comments in my test scripts can also remove. However, I don't think these should be merged as they are my way of testing it and aren't really cleaned up. They will be removed for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-739952376
https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-739952376:222,Testability,test,testing,222,"Sorry for not removing the comments before. That was sloppy of me. They are gone now. On a similar note, the comments in my test scripts can also remove. However, I don't think these should be merged as they are my way of testing it and aren't really cleaned up. They will be removed for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-739952376
https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-739968338:27,Testability,test,tests,27,"> Also shallow water model tests are failing with `type Nothing has no field f`: https://buildkite.com/clima/oceananigans/builds/842#ea16ffb3-252d-4d5a-b46a-a585cedd915e/38-257; > ; > I'm guessing the default for `ShallowWaterModel`s is `coriolis = nothing` but the tendency kernels use `coriolis.f`. You are correct, it is nothing. I copied what was in IncompressibleModel. If we changed the defautls to the following, would this resolve the issue?. ```coriolis = FPlane(f=0.0)```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-739968338
https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740072504:53,Testability,test,test,53,PS: @francispoulin I think it's okay to keep the two test scripts as long as they're not part of `runtests.jl`. . Might be especially helpful at this early development stage so other developers/users can easily run the same scripts/tests that you're using to test the shallow water model. Then once the shallow water model is a bit more mature they could be turned into nice examples!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740072504
https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740072504:232,Testability,test,tests,232,PS: @francispoulin I think it's okay to keep the two test scripts as long as they're not part of `runtests.jl`. . Might be especially helpful at this early development stage so other developers/users can easily run the same scripts/tests that you're using to test the shallow water model. Then once the shallow water model is a bit more mature they could be turned into nice examples!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740072504
https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740072504:259,Testability,test,test,259,PS: @francispoulin I think it's okay to keep the two test scripts as long as they're not part of `runtests.jl`. . Might be especially helpful at this early development stage so other developers/users can easily run the same scripts/tests that you're using to test the shallow water model. Then once the shallow water model is a bit more mature they could be turned into nice examples!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740072504
https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740212374:894,Safety,sanity check,sanity check,894,"> Second, this is a plot of the solution for the 1D case that starts off with no motion and a Gaussian field for height. This is a nice example of geostrophic adjustment, and can certainly be compared to papers that do such things.; > ; > ![one_dimensional_shallow_water_x](https://user-images.githubusercontent.com/8239041/101361665-45e29500-386d-11eb-82d8-f440f3b07d80.gif); > ; > Third, I have done a 2D case and everything looks qualitatively the same, but it is much more diffusive. This is a plot of a slide through the centre that should reproduce the same thing as above, but the amplitudes are much weaker. This is only 64x64 so it's not very high resolution but I should probably change the advection scheme to make it more accurate.; > ; > ![one_dimensional_shallow_water_2D_x](https://user-images.githubusercontent.com/8239041/101361578-251a3f80-386d-11eb-8e59-8c02e271cfcc.gif). A sanity check would be to check whether geostrophic balance is satisfied in the center of the domain, e.g., something like the last figure from [this example](https://fourierflows.github.io/FourierFlowsDocumentation/dev/generated/OneDShallowWaterGeostrophicAdjustment/#Geostrophic-balance).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740212374
https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740619873:896,Safety,sanity check,sanity check,896,"> > Second, this is a plot of the solution for the 1D case that starts off with no motion and a Gaussian field for height. This is a nice example of geostrophic adjustment, and can certainly be compared to papers that do such things.; > > ![one_dimensional_shallow_water_x](https://user-images.githubusercontent.com/8239041/101361665-45e29500-386d-11eb-82d8-f440f3b07d80.gif); > > Third, I have done a 2D case and everything looks qualitatively the same, but it is much more diffusive. This is a plot of a slide through the centre that should reproduce the same thing as above, but the amplitudes are much weaker. This is only 64x64 so it's not very high resolution but I should probably change the advection scheme to make it more accurate.; > > ![one_dimensional_shallow_water_2D_x](https://user-images.githubusercontent.com/8239041/101361578-251a3f80-386d-11eb-8e59-8c02e271cfcc.gif); > ; > A sanity check would be to check whether geostrophic balance is satisfied in the center of the domain, e.g., something like the last figure from [this example](https://fourierflows.github.io/FourierFlowsDocumentation/dev/generated/OneDShallowWaterGeostrophicAdjustment/#Geostrophic-balance). Thanks @navidcy for the suggestion. After takling with @glwagner I remembered that radiating waves in 2D decay like 1/r, compared to 1D. That's the reason for the large difference in amplitude. I might try and put together an example showing this in detail. As for geostrophic balance, I will work on computing that usin the center differencing operators since they are pretty straightforward to apply.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740619873
https://github.com/CliMA/Oceananigans.jl/issues/1261#issuecomment-740673873:40,Integrability,depend,dependencies,40,I am in the JLD2 camp since it has less dependencies and is easier to get working ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1261#issuecomment-740673873
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:1039,Modifiability,refactor,refactoring,1039,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:868,Performance,perform,performance,868,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:944,Performance,perform,performance-tips,944,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:966,Performance,perform,performance-value-type,966,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:862,Safety,avoid,avoid,862,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:1066,Testability,test,test,1066,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554:1085,Safety,avoid,avoid,1085,"I think it's a great idea to use types to control order of approximation. `struct CenteredDifference{N} end` is more cleanly generalizable. But note that the right concept might be ""interpolating the derivative from cell-centered locations to face-centered locations"", rather than the order of a finite difference approximation. This distinction will become relevant when we have arbitrarily stretched grids (arbitrary stretching is simple for shallow water models, so this could come sooner than we anticipated previously). One simple possibility that might involve minimal code modifications is to add an order of approximation annotation to `RegularCartesianGrid`. We can then define ""nth-order"" interpolation and differencing operators with special notation (something like `δⁿxᶠᵃᵃ`) that types can opt into, such as `IsotropicDiffusivity` or the pressure term for `ShallowWaterModel`. The primary application for incompressible models is diffusion operators, I think. I'm not sure about high-order interpolation for other physics, such as Coriolis forces, etc. Using `grid` might avoid the complexity associated with specifying an ""order of approximation"" for each aspect of the physics separately. I guess we already separate out advection (we could in principle come up with default advection schemes associated with grid's order of approximation...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554:433,Usability,simpl,simple,433,"I think it's a great idea to use types to control order of approximation. `struct CenteredDifference{N} end` is more cleanly generalizable. But note that the right concept might be ""interpolating the derivative from cell-centered locations to face-centered locations"", rather than the order of a finite difference approximation. This distinction will become relevant when we have arbitrarily stretched grids (arbitrary stretching is simple for shallow water models, so this could come sooner than we anticipated previously). One simple possibility that might involve minimal code modifications is to add an order of approximation annotation to `RegularCartesianGrid`. We can then define ""nth-order"" interpolation and differencing operators with special notation (something like `δⁿxᶠᵃᵃ`) that types can opt into, such as `IsotropicDiffusivity` or the pressure term for `ShallowWaterModel`. The primary application for incompressible models is diffusion operators, I think. I'm not sure about high-order interpolation for other physics, such as Coriolis forces, etc. Using `grid` might avoid the complexity associated with specifying an ""order of approximation"" for each aspect of the physics separately. I guess we already separate out advection (we could in principle come up with default advection schemes associated with grid's order of approximation...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554:529,Usability,simpl,simple,529,"I think it's a great idea to use types to control order of approximation. `struct CenteredDifference{N} end` is more cleanly generalizable. But note that the right concept might be ""interpolating the derivative from cell-centered locations to face-centered locations"", rather than the order of a finite difference approximation. This distinction will become relevant when we have arbitrarily stretched grids (arbitrary stretching is simple for shallow water models, so this could come sooner than we anticipated previously). One simple possibility that might involve minimal code modifications is to add an order of approximation annotation to `RegularCartesianGrid`. We can then define ""nth-order"" interpolation and differencing operators with special notation (something like `δⁿxᶠᵃᵃ`) that types can opt into, such as `IsotropicDiffusivity` or the pressure term for `ShallowWaterModel`. The primary application for incompressible models is diffusion operators, I think. I'm not sure about high-order interpolation for other physics, such as Coriolis forces, etc. Using `grid` might avoid the complexity associated with specifying an ""order of approximation"" for each aspect of the physics separately. I guess we already separate out advection (we could in principle come up with default advection schemes associated with grid's order of approximation...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744021493:2474,Energy Efficiency,power,powerful,2474,"Difference`. The ""biased"" operators would presumably only be used for interpolation, and by biased advection schemes. But we still want a unified implementation, since `Centered{N}` is used by both interpolation and differencing. The new syntax for operators would be. ```julia; δxᶠᵃᵃ(i, j, k, grid::AbstractGrid, order::AbstractOperatorOrder, c); ```. ### A global default stored in `grid` might make sense. We may want to add a type parameter to grid so we can write something like. ```julia; δxᶠᵃᵃ(i, j, k, grid::AbstractGrid, args...) = δxᶠᵃᵃ(i, j, k, grid, grid.order, args...); ```. We want to allow the operators to be controlled independent of the global `grid.order` for advection schemes and for differencing pressure. The above function, the default `grid.order == Centered{2}`, and specialization of the advection and pressure differencing operations will I think ensure that all existing code works as it did previously, I think. ### Boundary conditions need to know about `grid.order`. Our implementation of boundary conditions assumes second-order operators. We would need to dispatch on `grid.order` in `fill_halo_regions!` to support higher-order differentiation. This is eminently doable, just a fair amount of busy work / arithmetic. . A nice bonus is that we would be able to change how high-order advection schemes mutate close to the boundary. For example, if we are using both fourth-order advection and fourth-order diffusion, we don't need to limit to second-order advection at the boundary, since halos will be filled consistent with fourth-order operations. In the implementation I am outlining, this requires using `grid.order` in our ""topologically conditional interpolation"":. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Advection/topologically_conditional_interpolation.jl. For WENO5 with fourth-order diffusion, we just need to switch to fourth-order advection close the boundary. This is potentially a powerful increase in global accuracy of our methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744021493
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744468361:3298,Availability,down,down,3298,"an either 1) use a special type such as `OneField` that defines `getindex(::OneField{FT}, args..) = one(FT)` or 2) define functions `_symmetric_interpolate_*(i, j, k, grid, scheme, c::Number) = c`. The latter approach is probably preferable since it may be more broadly useful. > Doing 4th order Center Differencing in either model would be easy enough to do but it does mean that the method is not strictly Finite Volume, and therefore does not retain nice conservation properties, in case we have them. I think we would like Oceananigans.jl to use finite volume methods, not finite difference methods. Perhaps @ali-ramadhan and @christophernhill can comment as well. We can use a 4th order finite volume methods instead of a 4th order finite different method to obtain 4th order convergence without resorting to a finite difference method. We already have 4th-order interpolation of fields, so the only missing piece for a fully 4th-order method is 4th-order interpolation of field gradients... ? I believe we know how to do 4th order interpolation of gradients via comments in PR #1806. We probably cannot support a 4th-order treatment of pressure for `IncompressibleModel` in the near future. The reason is that the FFT-based method we use to solve the pressure Poisson equation for `IncompressibleModel` explicitly requires 2nd-order discretization of pressure. We do not have an alternative implementation of a pressure Poisson solver for arbitrary-order methods. When we have a hydrostatic pressure solver for the 3D equations, a high-order pressure discretization could be interesting to explore. Alternatively, we could add a more general method for solving the pressure Poisson equation. But this is a non-trivial amount of work. I think the principal challenge of a high-order implementation is code design. The finite volume stencils themselves are not so hard to write down. But I think we want a clean code design that minimizes bugs and maximizes the utility of the high-order stencil.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744468361
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924:1172,Modifiability,variab,variable,1172,"**Can we use advection for mass evolution equation?**. Let me try and convince you that using advection for continuity makes sense. If I don't succeed then clearly I need to put more thought into it. The governing equation can be written in two forms; $$; \partial_t = -\partial_x (h u) - \partial_y (h v) = - \partial_x U - \partial_y V ; $$; If we were to solve this in terms of the velocities (u,v), then using advection is clearly a good idea as we are advecting h by the velocity. In the case of upwinding, we pick the direction based on the sign of u (or v). We are using the transports instead of velocities but it is very similar to the advection of a tracer $\nabla \cdot (u c)$ except that we use c = 1. Given that the physics is the same in both cases, I think we should be using the advection scheme for this term. . The evolution equations for h and c have a lot in common, which is helpful here. The one major difference is that h is an active tracer in the sense that it feeds back on the momentum. Even though that's the case, I don't think this should affect how we discretize the advection of h, even though it is disguesed with our use of the transport variable. If you agree with my reasoning I don't think we need to do anything different for the evolution of height equation, we might just need to have some new functions that account for this, which are essentially equivalent to c = 0. Maybe what you suggest is the way to proceed?. **High Order Finite Volume**. I agree that keeping things finite volume is a good idea, and that is how I would like to proceed. Good to know that IncompressibleModel won't generalize to higher order. I agree that the 4th-order pieces are there and just need to be assembled. The paper you cited above is very helpful but needs to be modified slightly as they present the method for a non-staggered grid, but ours is staggered. That is not problem, I just need to work through the details. Unless they have been done already?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924:156,Usability,clear,clearly,156,"**Can we use advection for mass evolution equation?**. Let me try and convince you that using advection for continuity makes sense. If I don't succeed then clearly I need to put more thought into it. The governing equation can be written in two forms; $$; \partial_t = -\partial_x (h u) - \partial_y (h v) = - \partial_x U - \partial_y V ; $$; If we were to solve this in terms of the velocities (u,v), then using advection is clearly a good idea as we are advecting h by the velocity. In the case of upwinding, we pick the direction based on the sign of u (or v). We are using the transports instead of velocities but it is very similar to the advection of a tracer $\nabla \cdot (u c)$ except that we use c = 1. Given that the physics is the same in both cases, I think we should be using the advection scheme for this term. . The evolution equations for h and c have a lot in common, which is helpful here. The one major difference is that h is an active tracer in the sense that it feeds back on the momentum. Even though that's the case, I don't think this should affect how we discretize the advection of h, even though it is disguesed with our use of the transport variable. If you agree with my reasoning I don't think we need to do anything different for the evolution of height equation, we might just need to have some new functions that account for this, which are essentially equivalent to c = 0. Maybe what you suggest is the way to proceed?. **High Order Finite Volume**. I agree that keeping things finite volume is a good idea, and that is how I would like to proceed. Good to know that IncompressibleModel won't generalize to higher order. I agree that the 4th-order pieces are there and just need to be assembled. The paper you cited above is very helpful but needs to be modified slightly as they present the method for a non-staggered grid, but ours is staggered. That is not problem, I just need to work through the details. Unless they have been done already?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924:427,Usability,clear,clearly,427,"**Can we use advection for mass evolution equation?**. Let me try and convince you that using advection for continuity makes sense. If I don't succeed then clearly I need to put more thought into it. The governing equation can be written in two forms; $$; \partial_t = -\partial_x (h u) - \partial_y (h v) = - \partial_x U - \partial_y V ; $$; If we were to solve this in terms of the velocities (u,v), then using advection is clearly a good idea as we are advecting h by the velocity. In the case of upwinding, we pick the direction based on the sign of u (or v). We are using the transports instead of velocities but it is very similar to the advection of a tracer $\nabla \cdot (u c)$ except that we use c = 1. Given that the physics is the same in both cases, I think we should be using the advection scheme for this term. . The evolution equations for h and c have a lot in common, which is helpful here. The one major difference is that h is an active tracer in the sense that it feeds back on the momentum. Even though that's the case, I don't think this should affect how we discretize the advection of h, even though it is disguesed with our use of the transport variable. If you agree with my reasoning I don't think we need to do anything different for the evolution of height equation, we might just need to have some new functions that account for this, which are essentially equivalent to c = 0. Maybe what you suggest is the way to proceed?. **High Order Finite Volume**. I agree that keeping things finite volume is a good idea, and that is how I would like to proceed. Good to know that IncompressibleModel won't generalize to higher order. I agree that the 4th-order pieces are there and just need to be assembled. The paper you cited above is very helpful but needs to be modified slightly as they present the method for a non-staggered grid, but ours is staggered. That is not problem, I just need to work through the details. Unless they have been done already?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744544855:533,Energy Efficiency,energy,energy,533,"> There could be consistency requirements between the treatment of pressure / height gradients in the momentum equation, and transport gradients in the continuity equation. @francispoulin do you know of any requirements here or is this not a concern?. Hmm, I don't believe so. If whatever finite volume scheme we use for the evolution of height, we will ensure mass is conserved. This presumably variable height will drive the motion, and that parts seems very distinct to me. However, if you wanted to ensure global conservation of energy, or something, maybe one needs to be careful about this? I don't believe this is a concern though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744544855
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744544855:396,Modifiability,variab,variable,396,"> There could be consistency requirements between the treatment of pressure / height gradients in the momentum equation, and transport gradients in the continuity equation. @francispoulin do you know of any requirements here or is this not a concern?. Hmm, I don't believe so. If whatever finite volume scheme we use for the evolution of height, we will ensure mass is conserved. This presumably variable height will drive the motion, and that parts seems very distinct to me. However, if you wanted to ensure global conservation of energy, or something, maybe one needs to be careful about this? I don't believe this is a concern though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744544855
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744585065:58,Energy Efficiency,energy,energy,58,"> However, if you wanted to ensure global conservation of energy, or something, maybe one needs to be careful about this?. Yes this, or numerical pitfalls (for example, its not possible to use a biased stencil for the pressure term as @navidcy found, I think). If there's no _a priori_ reason to worry, we might as well test it and find out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744585065
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744585065:320,Testability,test,test,320,"> However, if you wanted to ensure global conservation of energy, or something, maybe one needs to be careful about this?. Yes this, or numerical pitfalls (for example, its not possible to use a biased stencil for the pressure term as @navidcy found, I think). If there's no _a priori_ reason to worry, we might as well test it and find out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744585065
https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-1479827324:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-1479827324
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741117661:11,Testability,test,tests,11,Ah I think tests are failing because of #1262 so you might have to `git rebase master` or `git merge master`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741117661
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741137374:154,Deployability,update,updated,154,"> Ah I think tests are failing because of #1262 so you might have to `git rebase master` or `git merge master`. Thanks @ali-ramadhan . Conversely, I just updated test_shallow_water_model.jl, the same way you and pushed that. I suspect the tests will pass, as they did for me but we will see shortly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741137374
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741137374:13,Testability,test,tests,13,"> Ah I think tests are failing because of #1262 so you might have to `git rebase master` or `git merge master`. Thanks @ali-ramadhan . Conversely, I just updated test_shallow_water_model.jl, the same way you and pushed that. I suspect the tests will pass, as they did for me but we will see shortly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741137374
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741137374:239,Testability,test,tests,239,"> Ah I think tests are failing because of #1262 so you might have to `git rebase master` or `git merge master`. Thanks @ali-ramadhan . Conversely, I just updated test_shallow_water_model.jl, the same way you and pushed that. I suspect the tests will pass, as they did for me but we will see shortly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741137374
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741810464:1023,Testability,test,testing,1023,"> Looks slightly different from 2.5 in; > ; > ![image](https://user-images.githubusercontent.com/15271942/101569197-010c4a80-39a2-11eb-8826-8702648d9ae8.png); > ; > from; > ; > https://crd.lbl.gov/assets/pubs_presos/AMCS/ANAG/O4AdvDiff.pdf; > ; > The distinction is that you're trying to approximate the _derivative_ of a cell-averaged quantity at the face-averaged location, rather than merely interpolating a cell-averaged quantity to face-averaged locations. I think. Thanks @glwagner that is a great resource. Unfortuantely, my formula was only appropriate for Finite Differences and not Finite Volume. I will read through this work right now to understand where the formula comes from. But it seems like the two formulas you quoted would be the right ones for computing the derivatives and averages in a FV context, to yield 4th order. . This PR doesn't necessarily need this but if it's only a few lines of code, then why not include it. I hope to be able to make the appropriate changes this morning and do a bit of testing, to convince myself that we do have 4th order accuracy on the pressure terms.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741810464
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741890419:0,Deployability,Update,Update,0,"Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. It then occurred to me that we are using centre differencing for the divergence of the transport in the evolution equation for the height. That suggests that we would probably want to use 4-th order approximations to those terms as well. Question: Since we are chaging from approximations at faces to approximations at centers, should the formuals change? I don't think they should but wanted to ask, just in case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741890419
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741890419:190,Safety,predict,predicted,190,"Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. It then occurred to me that we are using centre differencing for the divergence of the transport in the evolution equation for the height. That suggests that we would probably want to use 4-th order approximations to those terms as well. Question: Since we are chaging from approximations at faces to approximations at centers, should the formuals change? I don't think they should but wanted to ask, just in case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741890419
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741890419:87,Testability,test,test,87,"Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. It then occurred to me that we are using centre differencing for the divergence of the transport in the evolution equation for the height. That suggests that we would probably want to use 4-th order approximations to those terms as well. Question: Since we are chaging from approximations at faces to approximations at centers, should the formuals change? I don't think they should but wanted to ask, just in case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741890419
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741895041:155,Availability,down,down,155,"Referring to https://github.com/CliMA/Oceananigans.jl/blob/master/src/Operators/README I think the formula doesn't change but the indices are just shifted down by one? Not sure if this also applies to the 4th-order operators though... Relevant section:; ```; The geometry of the staggerd grid used by Oceananigans (sometimes called the C-grid); is (in one dimension) shown below. face cell face cell face. i-1 i; ↓ ↓; | × | × |; ↑ ↑ ↑; i-1 i i+1. Difference operators are denoted by a `δ` (`\delta`). Calculating the difference; of a cell-centered quantity c at cell i will return the difference at face i. δcᵢ = cᵢ - cᵢ₋₁. and so this operation, if applied along the x-dimension, is denoted by `δxᶠᵃᵃ`. The difference of a face-centered quantity u at face i will return the difference; at cell i. δuᵢ = uᵢ₊₁ - uᵢ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741895041
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741927886:155,Modifiability,extend,extend,155,"Thanks @ali-ramadhan. I agree and confirmed that where the derivative is computed on faces and centres, the following line and the line below. This should extend to higher orders of course. https://github.com/CliMA/Oceananigans.jl/blob/ebd7858000c78f7b1754112a68c587e6195e620b/src/Operators/derivative_operators.jl#L18",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741927886
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:576,Availability,error,error,576,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:1439,Availability,error,error,1439,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:1478,Availability,error,error,1478,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:2,Deployability,Update,Update,2,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:367,Energy Efficiency,reduce,reduced,367,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:959,Energy Efficiency,reduce,reduce,959,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:1431,Energy Efficiency,reduce,reduced,1431,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:192,Safety,predict,predicted,192,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:711,Safety,predict,prediction,711,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:89,Testability,test,test,89,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982:97,Security,validat,validation,97,"@francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:. https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests. and it could make sense to contribute your convergence tests there. The tests are used to generate figures for documentation:. https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/. @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite. Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982:169,Security,validat,validation,169,"@francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:. https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests. and it could make sense to contribute your convergence tests there. The tests are used to generate figures for documentation:. https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/. @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite. Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982:383,Security,validat,validation,383,"@francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:. https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests. and it could make sense to contribute your convergence tests there. The tests are used to generate figures for documentation:. https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/. @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite. Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982:52,Testability,test,tests,52,"@francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:. https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests. and it could make sense to contribute your convergence tests there. The tests are used to generate figures for documentation:. https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/. @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite. Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982:84,Testability,test,tests,84,"@francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:. https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests. and it could make sense to contribute your convergence tests there. The tests are used to generate figures for documentation:. https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/. @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite. Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982:254,Testability,test,tests,254,"@francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:. https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests. and it could make sense to contribute your convergence tests there. The tests are used to generate figures for documentation:. https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/. @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite. Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982:271,Testability,test,tests,271,"@francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:. https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests. and it could make sense to contribute your convergence tests there. The tests are used to generate figures for documentation:. https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/. @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite. Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982:459,Testability,test,tests,459,"@francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:. https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests. and it could make sense to contribute your convergence tests there. The tests are used to generate figures for documentation:. https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/. @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite. Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982:502,Testability,test,testing,502,"@francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:. https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests. and it could make sense to contribute your convergence tests there. The tests are used to generate figures for documentation:. https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/. @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite. Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:1252,Deployability,update,update,1252,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:99,Security,validat,validation,99,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:177,Security,validat,validation,177,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:410,Security,validat,validation,410,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:54,Testability,test,tests,54,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:86,Testability,test,tests,86,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:268,Testability,test,tests,268,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:292,Testability,test,tests,292,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:492,Testability,test,tests,492,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:535,Testability,test,testing,535,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:333,Deployability,integrat,integrated,333,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:333,Integrability,integrat,integrated,333,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:162,Security,validat,validation,162,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:414,Security,validat,validation,414,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:561,Security,validat,validate,561,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:704,Security,validat,validation,704,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:823,Security,validat,validation,823,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:173,Testability,test,tests,173,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:231,Testability,test,test,231,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:397,Testability,test,tests,397,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:715,Testability,test,tests,715,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:780,Testability,test,test,780,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:834,Testability,test,tests,834,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:348,Deployability,integrat,integrated,348,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:348,Integrability,integrat,integrated,348,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:177,Security,validat,validation,177,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:429,Security,validat,validation,429,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:582,Security,validat,validate,582,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:725,Security,validat,validation,725,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:844,Security,validat,validation,844,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:188,Testability,test,tests,188,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:246,Testability,test,test,246,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:412,Testability,test,tests,412,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:736,Testability,test,tests,736,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:801,Testability,test,test,801,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:855,Testability,test,tests,855,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:936,Testability,test,tests,936,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:985,Testability,test,tests,985,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:1055,Testability,test,tests,1055,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132
https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744387824:41,Safety,avoid,avoided,41,I think a doctest is a good idea... just avoided it here because they're often finnicky and I didn't feel like I had the time to debug.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744387824
https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744735239:151,Availability,error,error,151,"@ali-ramadhan, out of curiosity do you know why this fails?; https://buildkite.com/clima/oceananigans/builds/894#25866b57-d2c9-48ec-a969-c2f1a11d7f39. error says `ERROR: UndefVarError: CPU not defined`... weird...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744735239
https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744735239:163,Availability,ERROR,ERROR,163,"@ali-ramadhan, out of curiosity do you know why this fails?; https://buildkite.com/clima/oceananigans/builds/894#25866b57-d2c9-48ec-a969-c2f1a11d7f39. error says `ERROR: UndefVarError: CPU not defined`... weird...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744735239
https://github.com/CliMA/Oceananigans.jl/pull/1270#issuecomment-746364115:23,Testability,test,tests,23,Do we know why these 4 tests fail? From looking at the first one it seems gpu related but I'm no expert.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1270#issuecomment-746364115
https://github.com/CliMA/Oceananigans.jl/pull/1270#issuecomment-746490238:25,Testability,test,tests,25,> Do we know why these 4 tests fail? From looking at the first one it seems gpu related but I'm no expert. One test failed because `AbstractGrid` was not imported. I'm not sure about the GPU issue since I didn't get to look at that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1270#issuecomment-746490238
https://github.com/CliMA/Oceananigans.jl/pull/1270#issuecomment-746490238:111,Testability,test,test,111,> Do we know why these 4 tests fail? From looking at the first one it seems gpu related but I'm no expert. One test failed because `AbstractGrid` was not imported. I'm not sure about the GPU issue since I didn't get to look at that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1270#issuecomment-746490238
https://github.com/CliMA/Oceananigans.jl/pull/1270#issuecomment-754008736:65,Testability,test,test,65,"Thanks for noticing @francispoulin ! The GPU issue was a failing test, so if tests are passing, there's no issue! Perhaps a gift from St. Nick.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1270#issuecomment-754008736
https://github.com/CliMA/Oceananigans.jl/pull/1270#issuecomment-754008736:77,Testability,test,tests,77,"Thanks for noticing @francispoulin ! The GPU issue was a failing test, so if tests are passing, there's no issue! Perhaps a gift from St. Nick.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1270#issuecomment-754008736
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444:613,Availability,error,error,613,"I figured out that the figures are all saved to a file and am including a couple of examples. I have a few thougths to share. - Updating plots shouldn't be difficult but don't know anything about the xticks mentioned above. - I think we have too many items in the legend. I think there should just be two sets of markers and the best fit. - Probably don't want to start at such a coarse grid as clearly we are far from convergence. - I think that UpwindBiasedFifthOrder just needs a little more effort to get the order. The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. . ![one_dimensional_convergence_WENO5](https://user-images.githubusercontent.com/8239041/102221597-51a70a80-3eb0-11eb-8421-4a519d5bbfc9.png); ![one_dimensional_convergence_UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102221609-54096480-3eb0-11eb-92bf-ef35bb069c96.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444:644,Energy Efficiency,reduce,reduce,644,"I figured out that the figures are all saved to a file and am including a couple of examples. I have a few thougths to share. - Updating plots shouldn't be difficult but don't know anything about the xticks mentioned above. - I think we have too many items in the legend. I think there should just be two sets of markers and the best fit. - Probably don't want to start at such a coarse grid as clearly we are far from convergence. - I think that UpwindBiasedFifthOrder just needs a little more effort to get the order. The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. . ![one_dimensional_convergence_WENO5](https://user-images.githubusercontent.com/8239041/102221597-51a70a80-3eb0-11eb-8421-4a519d5bbfc9.png); ![one_dimensional_convergence_UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102221609-54096480-3eb0-11eb-92bf-ef35bb069c96.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444:704,Security,validat,validations,704,"I figured out that the figures are all saved to a file and am including a couple of examples. I have a few thougths to share. - Updating plots shouldn't be difficult but don't know anything about the xticks mentioned above. - I think we have too many items in the legend. I think there should just be two sets of markers and the best fit. - Probably don't want to start at such a coarse grid as clearly we are far from convergence. - I think that UpwindBiasedFifthOrder just needs a little more effort to get the order. The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. . ![one_dimensional_convergence_WENO5](https://user-images.githubusercontent.com/8239041/102221597-51a70a80-3eb0-11eb-8421-4a519d5bbfc9.png); ![one_dimensional_convergence_UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102221609-54096480-3eb0-11eb-92bf-ef35bb069c96.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444:395,Usability,clear,clearly,395,"I figured out that the figures are all saved to a file and am including a couple of examples. I have a few thougths to share. - Updating plots shouldn't be difficult but don't know anything about the xticks mentioned above. - I think we have too many items in the legend. I think there should just be two sets of markers and the best fit. - Probably don't want to start at such a coarse grid as clearly we are far from convergence. - I think that UpwindBiasedFifthOrder just needs a little more effort to get the order. The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. . ![one_dimensional_convergence_WENO5](https://user-images.githubusercontent.com/8239041/102221597-51a70a80-3eb0-11eb-8421-4a519d5bbfc9.png); ![one_dimensional_convergence_UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102221609-54096480-3eb0-11eb-92bf-ef35bb069c96.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300622:95,Availability,error,error,95,"> The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. That seems like a likely culprit. I can't remember if I looked into that. Whatever it is I agree its a flaw in the test design that some other source of error dominates before asymptotic convergence is reached...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300622
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300622:297,Availability,error,error,297,"> The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. That seems like a likely culprit. I can't remember if I looked into that. Whatever it is I agree its a flaw in the test design that some other source of error dominates before asymptotic convergence is reached...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300622
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300622:126,Energy Efficiency,reduce,reduce,126,"> The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. That seems like a likely culprit. I can't remember if I looked into that. Whatever it is I agree its a flaw in the test design that some other source of error dominates before asymptotic convergence is reached...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300622
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300622:259,Testability,test,test,259,"> The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. That seems like a likely culprit. I can't remember if I looked into that. Whatever it is I agree its a flaw in the test design that some other source of error dominates before asymptotic convergence is reached...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300622
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300875:44,Security,validat,validations,44,> I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. It'd be great to clean this up and I can help; we can zoom or you can ask questions here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300875
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745301343:159,Testability,test,test,159,> I have a few thougths to share. I agree with the beautification you've suggested. Also formatting the xticks is far lower priority than readable convergence test plots.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745301343
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363:35,Modifiability,variab,variable,35,"A general question. In the tests a variable `results` is created, which is a mutable struct Dict. I see that map is a way to pick out elements of this object. When I ask for information on resutls I get something like this. ```julia> results; Dict{Any,Any} with 1 entry:; CenteredSecondOrder => fill((cx = (simulation = [-8.07688e-137, -2.28227e-125, -1.9026e-114, -4.67931e-104, -3.39525e-94, -7.26804e-…; ```. How do I get values from this object? . From looking in the scripts I gather that we need to use `map` but not sure what fields to get or how to get them. I found out that I can get a bit more inside using `results[CenteredSecondOrder]` but still not sure how to access the arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363:675,Security,access,access,675,"A general question. In the tests a variable `results` is created, which is a mutable struct Dict. I see that map is a way to pick out elements of this object. When I ask for information on resutls I get something like this. ```julia> results; Dict{Any,Any} with 1 entry:; CenteredSecondOrder => fill((cx = (simulation = [-8.07688e-137, -2.28227e-125, -1.9026e-114, -4.67931e-104, -3.39525e-94, -7.26804e-…; ```. How do I get values from this object? . From looking in the scripts I gather that we need to use `map` but not sure what fields to get or how to get them. I found out that I can get a bit more inside using `results[CenteredSecondOrder]` but still not sure how to access the arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363:27,Testability,test,tests,27,"A general question. In the tests a variable `results` is created, which is a mutable struct Dict. I see that map is a way to pick out elements of this object. When I ask for information on resutls I get something like this. ```julia> results; Dict{Any,Any} with 1 entry:; CenteredSecondOrder => fill((cx = (simulation = [-8.07688e-137, -2.28227e-125, -1.9026e-114, -4.67931e-104, -3.39525e-94, -7.26804e-…; ```. How do I get values from this object? . From looking in the scripts I gather that we need to use `map` but not sure what fields to get or how to get them. I found out that I can get a bit more inside using `results[CenteredSecondOrder]` but still not sure how to access the arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745422185:1126,Security,access,access,1126,"I am still learning how to parse the output but this is what I get. ```julia> typeof(results[CenteredSecondOrder]); Array{NamedTuple{(:cx, :grid),Tuple{NamedTuple{(:simulation, :analytical, :L₁, :L∞),Tuple{Array{Float64,1},Array{Float64,1},Float64,Float64}},Oceananigans.Grids.RegularCartesianGrid{Float64,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}},0}; ```. Also, I found that I can use map in the following way. ```; julia> c_ana = map(r -> r.cx.analytical[:], results[CenteredSecondOrder]); 0-dimensional Array{Array{Float64,1},0}:; [8.339763449228298e-167, 9.289942488656767e-154, 3.0530062298945994e-141, 2.960041007581741e-129, 8.466874781928682e-118, 7.14502772471784e-107, 1.7788530458865225e-96, 1.3065667360543323e-86, 2.831251796148466e-77, 1.8100091259558352e-68 … 6.525187676003588e-221, 1.7125465800091643e-236, 1.3260110721966124e-252, 3.0290558443461884e-269, 2.0413749536348825e-286, 4.058762655833247e-304, 2.2e-322, 0.0, 0.0, 0.0]; ```. Then I can access the array using `c_ana[1]'. This seems strange to me but I guess this is what I need to be doing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745422185
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745422185:11,Usability,learn,learning,11,"I am still learning how to parse the output but this is what I get. ```julia> typeof(results[CenteredSecondOrder]); Array{NamedTuple{(:cx, :grid),Tuple{NamedTuple{(:simulation, :analytical, :L₁, :L∞),Tuple{Array{Float64,1},Array{Float64,1},Float64,Float64}},Oceananigans.Grids.RegularCartesianGrid{Float64,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}},0}; ```. Also, I found that I can use map in the following way. ```; julia> c_ana = map(r -> r.cx.analytical[:], results[CenteredSecondOrder]); 0-dimensional Array{Array{Float64,1},0}:; [8.339763449228298e-167, 9.289942488656767e-154, 3.0530062298945994e-141, 2.960041007581741e-129, 8.466874781928682e-118, 7.14502772471784e-107, 1.7788530458865225e-96, 1.3065667360543323e-86, 2.831251796148466e-77, 1.8100091259558352e-68 … 6.525187676003588e-221, 1.7125465800091643e-236, 1.3260110721966124e-252, 3.0290558443461884e-269, 2.0413749536348825e-286, 4.058762655833247e-304, 2.2e-322, 0.0, 0.0, 0.0]; ```. Then I can access the array using `c_ana[1]'. This seems strange to me but I guess this is what I need to be doing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745422185
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745469217:533,Security,validat,validation,533,"I have created a branch and started to make changes to use Plots.jl. Attached are some not so excting plots that are the first of many to come. . ![test1](https://user-images.githubusercontent.com/8239041/102254504-ae1d2080-3ed6-11eb-855d-b79131a5a267.png). ![test2](https://user-images.githubusercontent.com/8239041/102254484-a52c4f00-3ed6-11eb-8354-1e0cdb835a30.png). I do have a question on how to do something. If you look in the code [here](https://github.com/CliMA/Oceananigans.jl/blob/1456cc68b0dd559f91d5ca3770bd123ff2f5eb3a/validation/convergence_tests/ConvergenceTests/OneDimensionalUtils.jl#L65) you will see that I need to put in the advection scheme for this to work. . My next step is to try looking over a couple of schemes, but can't do that using the current syntax. Any advice on what I need to change? The old code just had results, which I would like to have as well, but not sure why it's not working.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745469217
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745477192:161,Security,validat,validation,161,"On master there is an object called `all_results`, which is looped over:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/validation/convergence_tests/ConvergenceTests/OneDimensionalUtils.jl#L56-L58. It looks like you've omitted the loop over the contents of `all_results`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745477192
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745482196:257,Security,validat,validation,257,"I removed that because in master the length of results is just 1, so there is nothing to look over. . In `one_dimensional_gaussian_advection_diffusion.jl` at this [line](https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/validation/convergence_tests/one_dimensional_gaussian_advection_diffusion.jl#L46) it forms all_results by combining different results and I don't believe that I do that in this code. I just have their version of advection_results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745482196
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483637:142,Security,validat,validation,142,"Even if the length is 1, you are missing these lines:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/validation/convergence_tests/ConvergenceTests/OneDimensionalUtils.jl#L60-L63",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483637
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729:388,Availability,down,down,388,"When I try your suggestion I get that it is an Array, which is good to know. ; ```; julia> typeof(results[CenteredSecondOrder][1].cx.analytical); Array{Float64,1}; ```. I wonder if a simpler idea is to call the plotting for each advection_scheme, that way the scheme is fixed. . Clearly `results` is a very powerful and almost all knowing variable, but I am struggling with how to pin it down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729:307,Energy Efficiency,power,powerful,307,"When I try your suggestion I get that it is an Array, which is good to know. ; ```; julia> typeof(results[CenteredSecondOrder][1].cx.analytical); Array{Float64,1}; ```. I wonder if a simpler idea is to call the plotting for each advection_scheme, that way the scheme is fixed. . Clearly `results` is a very powerful and almost all knowing variable, but I am struggling with how to pin it down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729:339,Modifiability,variab,variable,339,"When I try your suggestion I get that it is an Array, which is good to know. ; ```; julia> typeof(results[CenteredSecondOrder][1].cx.analytical); Array{Float64,1}; ```. I wonder if a simpler idea is to call the plotting for each advection_scheme, that way the scheme is fixed. . Clearly `results` is a very powerful and almost all knowing variable, but I am struggling with how to pin it down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729:183,Usability,simpl,simpler,183,"When I try your suggestion I get that it is an Array, which is good to know. ; ```; julia> typeof(results[CenteredSecondOrder][1].cx.analytical); Array{Float64,1}; ```. I wonder if a simpler idea is to call the plotting for each advection_scheme, that way the scheme is fixed. . Clearly `results` is a very powerful and almost all knowing variable, but I am struggling with how to pin it down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729:279,Usability,Clear,Clearly,279,"When I try your suggestion I get that it is an Array, which is good to know. ; ```; julia> typeof(results[CenteredSecondOrder][1].cx.analytical); Array{Float64,1}; ```. I wonder if a simpler idea is to call the plotting for each advection_scheme, that way the scheme is fixed. . Clearly `results` is a very powerful and almost all knowing variable, but I am struggling with how to pin it down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745484536:128,Usability,simpl,simply,128,"I have removed names and linestyle for now, but will get back to this when things are working.; I changed the input argument to simply be results, instead of all_results, but maybe that was a bad idea. I can try it now and see how it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745484536
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542:71,Availability,error,errors,71,"I am happy to say that I am now able to get plots of the solutions and errors for a range of resolutions and advections_schemes. I have also learned a lot about `Plots.jl` in the process. . Tomorrow I will work on modifying `plot_error_convergence!`, since that actually gives us the plots that we want. Here are a couple of samples. They can and will be improved up. The first is the error for WENO5 and the scaling matches the theory very well, as I will confirm tomorrow. . ![test2WENO5](https://user-images.githubusercontent.com/8239041/102304453-78565700-3f2b-11eb-8219-dc377571c0e8.png). The second is the error from the UpwindBiasedFifthOrder, that shows that the error in the centre does not converge. I would guess this is either a time stepping problem or perhaps a but somewhere. ![test2UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102304487-8c9a5400-3f2b-11eb-88dc-e5c15e172edd.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542:385,Availability,error,error,385,"I am happy to say that I am now able to get plots of the solutions and errors for a range of resolutions and advections_schemes. I have also learned a lot about `Plots.jl` in the process. . Tomorrow I will work on modifying `plot_error_convergence!`, since that actually gives us the plots that we want. Here are a couple of samples. They can and will be improved up. The first is the error for WENO5 and the scaling matches the theory very well, as I will confirm tomorrow. . ![test2WENO5](https://user-images.githubusercontent.com/8239041/102304453-78565700-3f2b-11eb-8219-dc377571c0e8.png). The second is the error from the UpwindBiasedFifthOrder, that shows that the error in the centre does not converge. I would guess this is either a time stepping problem or perhaps a but somewhere. ![test2UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102304487-8c9a5400-3f2b-11eb-88dc-e5c15e172edd.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542:612,Availability,error,error,612,"I am happy to say that I am now able to get plots of the solutions and errors for a range of resolutions and advections_schemes. I have also learned a lot about `Plots.jl` in the process. . Tomorrow I will work on modifying `plot_error_convergence!`, since that actually gives us the plots that we want. Here are a couple of samples. They can and will be improved up. The first is the error for WENO5 and the scaling matches the theory very well, as I will confirm tomorrow. . ![test2WENO5](https://user-images.githubusercontent.com/8239041/102304453-78565700-3f2b-11eb-8219-dc377571c0e8.png). The second is the error from the UpwindBiasedFifthOrder, that shows that the error in the centre does not converge. I would guess this is either a time stepping problem or perhaps a but somewhere. ![test2UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102304487-8c9a5400-3f2b-11eb-88dc-e5c15e172edd.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542:671,Availability,error,error,671,"I am happy to say that I am now able to get plots of the solutions and errors for a range of resolutions and advections_schemes. I have also learned a lot about `Plots.jl` in the process. . Tomorrow I will work on modifying `plot_error_convergence!`, since that actually gives us the plots that we want. Here are a couple of samples. They can and will be improved up. The first is the error for WENO5 and the scaling matches the theory very well, as I will confirm tomorrow. . ![test2WENO5](https://user-images.githubusercontent.com/8239041/102304453-78565700-3f2b-11eb-8219-dc377571c0e8.png). The second is the error from the UpwindBiasedFifthOrder, that shows that the error in the centre does not converge. I would guess this is either a time stepping problem or perhaps a but somewhere. ![test2UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102304487-8c9a5400-3f2b-11eb-88dc-e5c15e172edd.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542:141,Usability,learn,learned,141,"I am happy to say that I am now able to get plots of the solutions and errors for a range of resolutions and advections_schemes. I have also learned a lot about `Plots.jl` in the process. . Tomorrow I will work on modifying `plot_error_convergence!`, since that actually gives us the plots that we want. Here are a couple of samples. They can and will be improved up. The first is the error for WENO5 and the scaling matches the theory very well, as I will confirm tomorrow. . ![test2WENO5](https://user-images.githubusercontent.com/8239041/102304453-78565700-3f2b-11eb-8219-dc377571c0e8.png). The second is the error from the UpwindBiasedFifthOrder, that shows that the error in the centre does not converge. I would guess this is either a time stepping problem or perhaps a but somewhere. ![test2UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102304487-8c9a5400-3f2b-11eb-88dc-e5c15e172edd.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704:233,Deployability,integrat,integrated,233,"Sure. I'm now working on making plots of convergence and should be able to get that done today. One issue is that I have commented out a lot of stuff, which was there before. I've focused on making the one advection test and haven't integrated it into the other tests, yet. Not sure if this is a problem?. I will create a PR later today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704:233,Integrability,integrat,integrated,233,"Sure. I'm now working on making plots of convergence and should be able to get that done today. One issue is that I have commented out a lot of stuff, which was there before. I've focused on making the one advection test and haven't integrated it into the other tests, yet. Not sure if this is a problem?. I will create a PR later today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704:216,Testability,test,test,216,"Sure. I'm now working on making plots of convergence and should be able to get that done today. One issue is that I have commented out a lot of stuff, which was there before. I've focused on making the one advection test and haven't integrated it into the other tests, yet. Not sure if this is a problem?. I will create a PR later today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704
https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704:262,Testability,test,tests,262,"Sure. I'm now working on making plots of convergence and should be able to get that done today. One issue is that I have commented out a lot of stuff, which was there before. I've focused on making the one advection test and haven't integrated it into the other tests, yet. Not sure if this is a problem?. I will create a PR later today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535:521,Energy Efficiency,schedul,schedules,521,"@tomchor does this result occur with just one OutputWriter, or do you have more than one OutputWriter being used at the same time?. Averaging collection is finalized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L179-L187. when `run_diagnostic!(wta::WindowedTimeAverage, model)` is called. But the criterion that triggers output is. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L38-L52. I have to say I don't understand why we special case `time == schedule.previous_actuation_time + schedule.interval`, since `rem(time, schedule.interval)` should be 0 and the algorithm should still work. Or am I missing something? It does seem to assume that `0` is the initial time (we could avoid that maybe by saving the initial `model.clock.time`...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535:605,Energy Efficiency,schedul,schedule,605,"@tomchor does this result occur with just one OutputWriter, or do you have more than one OutputWriter being used at the same time?. Averaging collection is finalized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L179-L187. when `run_diagnostic!(wta::WindowedTimeAverage, model)` is called. But the criterion that triggers output is. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L38-L52. I have to say I don't understand why we special case `time == schedule.previous_actuation_time + schedule.interval`, since `rem(time, schedule.interval)` should be 0 and the algorithm should still work. Or am I missing something? It does seem to assume that `0` is the initial time (we could avoid that maybe by saving the initial `model.clock.time`...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535:640,Energy Efficiency,schedul,schedule,640,"@tomchor does this result occur with just one OutputWriter, or do you have more than one OutputWriter being used at the same time?. Averaging collection is finalized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L179-L187. when `run_diagnostic!(wta::WindowedTimeAverage, model)` is called. But the criterion that triggers output is. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L38-L52. I have to say I don't understand why we special case `time == schedule.previous_actuation_time + schedule.interval`, since `rem(time, schedule.interval)` should be 0 and the algorithm should still work. Or am I missing something? It does seem to assume that `0` is the initial time (we could avoid that maybe by saving the initial `model.clock.time`...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535:677,Energy Efficiency,schedul,schedule,677,"@tomchor does this result occur with just one OutputWriter, or do you have more than one OutputWriter being used at the same time?. Averaging collection is finalized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L179-L187. when `run_diagnostic!(wta::WindowedTimeAverage, model)` is called. But the criterion that triggers output is. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L38-L52. I have to say I don't understand why we special case `time == schedule.previous_actuation_time + schedule.interval`, since `rem(time, schedule.interval)` should be 0 and the algorithm should still work. Or am I missing something? It does seem to assume that `0` is the initial time (we could avoid that maybe by saving the initial `model.clock.time`...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535:835,Safety,avoid,avoid,835,"@tomchor does this result occur with just one OutputWriter, or do you have more than one OutputWriter being used at the same time?. Averaging collection is finalized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L179-L187. when `run_diagnostic!(wta::WindowedTimeAverage, model)` is called. But the criterion that triggers output is. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L38-L52. I have to say I don't understand why we special case `time == schedule.previous_actuation_time + schedule.interval`, since `rem(time, schedule.interval)` should be 0 and the algorithm should still work. Or am I missing something? It does seem to assume that `0` is the initial time (we could avoid that maybe by saving the initial `model.clock.time`...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904:1100,Availability,down,downside,1100,"Anyways, I don't quite see it but that could be the issue. So we can try replacing. ```julia; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval) ; ```. with. ```julia; if model.clock.time == wta.schedule.previous_interval_stop_time + wta.schedule.interval; wta.schedule.previous_interval_stop_time = model.clock.time; else; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval); end; ```. Another possible solution is to have a different algorithm in which time-averaging is ""finalized"" when output is retrieved. Retrieval occurs here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L197-L205. And we could set `collecting=false` and reset `wta_schedule.previous_interval_stop_time` there. The only downside is that bad things might happen if for some reason the `WindowedTimeAverage` is called in a callback (for logging or something) apart from when output is being asked for (since that would restart time averaging when not desired...). These issues do seem to motivate figuring out how to record the averaging window / iterations somehow when saving `WindowedTimeAverage` to disk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904:202,Energy Efficiency,schedul,schedule,202,"Anyways, I don't quite see it but that could be the issue. So we can try replacing. ```julia; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval) ; ```. with. ```julia; if model.clock.time == wta.schedule.previous_interval_stop_time + wta.schedule.interval; wta.schedule.previous_interval_stop_time = model.clock.time; else; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval); end; ```. Another possible solution is to have a different algorithm in which time-averaging is ""finalized"" when output is retrieved. Retrieval occurs here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L197-L205. And we could set `collecting=false` and reset `wta_schedule.previous_interval_stop_time` there. The only downside is that bad things might happen if for some reason the `WindowedTimeAverage` is called in a callback (for logging or something) apart from when output is being asked for (since that would restart time averaging when not desired...). These issues do seem to motivate figuring out how to record the averaging window / iterations somehow when saving `WindowedTimeAverage` to disk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904:286,Energy Efficiency,schedul,schedule,286,"Anyways, I don't quite see it but that could be the issue. So we can try replacing. ```julia; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval) ; ```. with. ```julia; if model.clock.time == wta.schedule.previous_interval_stop_time + wta.schedule.interval; wta.schedule.previous_interval_stop_time = model.clock.time; else; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval); end; ```. Another possible solution is to have a different algorithm in which time-averaging is ""finalized"" when output is retrieved. Retrieval occurs here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L197-L205. And we could set `collecting=false` and reset `wta_schedule.previous_interval_stop_time` there. The only downside is that bad things might happen if for some reason the `WindowedTimeAverage` is called in a callback (for logging or something) apart from when output is being asked for (since that would restart time averaging when not desired...). These issues do seem to motivate figuring out how to record the averaging window / iterations somehow when saving `WindowedTimeAverage` to disk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904:355,Energy Efficiency,schedul,schedule,355,"Anyways, I don't quite see it but that could be the issue. So we can try replacing. ```julia; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval) ; ```. with. ```julia; if model.clock.time == wta.schedule.previous_interval_stop_time + wta.schedule.interval; wta.schedule.previous_interval_stop_time = model.clock.time; else; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval); end; ```. Another possible solution is to have a different algorithm in which time-averaging is ""finalized"" when output is retrieved. Retrieval occurs here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L197-L205. And we could set `collecting=false` and reset `wta_schedule.previous_interval_stop_time` there. The only downside is that bad things might happen if for some reason the `WindowedTimeAverage` is called in a callback (for logging or something) apart from when output is being asked for (since that would restart time averaging when not desired...). These issues do seem to motivate figuring out how to record the averaging window / iterations somehow when saving `WindowedTimeAverage` to disk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904:398,Energy Efficiency,schedul,schedule,398,"Anyways, I don't quite see it but that could be the issue. So we can try replacing. ```julia; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval) ; ```. with. ```julia; if model.clock.time == wta.schedule.previous_interval_stop_time + wta.schedule.interval; wta.schedule.previous_interval_stop_time = model.clock.time; else; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval); end; ```. Another possible solution is to have a different algorithm in which time-averaging is ""finalized"" when output is retrieved. Retrieval occurs here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L197-L205. And we could set `collecting=false` and reset `wta_schedule.previous_interval_stop_time` there. The only downside is that bad things might happen if for some reason the `WindowedTimeAverage` is called in a callback (for logging or something) apart from when output is being asked for (since that would restart time averaging when not desired...). These issues do seem to motivate figuring out how to record the averaging window / iterations somehow when saving `WindowedTimeAverage` to disk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904:421,Energy Efficiency,schedul,schedule,421,"Anyways, I don't quite see it but that could be the issue. So we can try replacing. ```julia; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval) ; ```. with. ```julia; if model.clock.time == wta.schedule.previous_interval_stop_time + wta.schedule.interval; wta.schedule.previous_interval_stop_time = model.clock.time; else; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval); end; ```. Another possible solution is to have a different algorithm in which time-averaging is ""finalized"" when output is retrieved. Retrieval occurs here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L197-L205. And we could set `collecting=false` and reset `wta_schedule.previous_interval_stop_time` there. The only downside is that bad things might happen if for some reason the `WindowedTimeAverage` is called in a callback (for logging or something) apart from when output is being asked for (since that would restart time averaging when not desired...). These issues do seem to motivate figuring out how to record the averaging window / iterations somehow when saving `WindowedTimeAverage` to disk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904:592,Energy Efficiency,schedul,schedule,592,"Anyways, I don't quite see it but that could be the issue. So we can try replacing. ```julia; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval) ; ```. with. ```julia; if model.clock.time == wta.schedule.previous_interval_stop_time + wta.schedule.interval; wta.schedule.previous_interval_stop_time = model.clock.time; else; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval); end; ```. Another possible solution is to have a different algorithm in which time-averaging is ""finalized"" when output is retrieved. Retrieval occurs here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L197-L205. And we could set `collecting=false` and reset `wta_schedule.previous_interval_stop_time` there. The only downside is that bad things might happen if for some reason the `WindowedTimeAverage` is called in a callback (for logging or something) apart from when output is being asked for (since that would restart time averaging when not desired...). These issues do seem to motivate figuring out how to record the averaging window / iterations somehow when saving `WindowedTimeAverage` to disk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904:676,Energy Efficiency,schedul,schedule,676,"Anyways, I don't quite see it but that could be the issue. So we can try replacing. ```julia; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval) ; ```. with. ```julia; if model.clock.time == wta.schedule.previous_interval_stop_time + wta.schedule.interval; wta.schedule.previous_interval_stop_time = model.clock.time; else; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval); end; ```. Another possible solution is to have a different algorithm in which time-averaging is ""finalized"" when output is retrieved. Retrieval occurs here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L197-L205. And we could set `collecting=false` and reset `wta_schedule.previous_interval_stop_time` there. The only downside is that bad things might happen if for some reason the `WindowedTimeAverage` is called in a callback (for logging or something) apart from when output is being asked for (since that would restart time averaging when not desired...). These issues do seem to motivate figuring out how to record the averaging window / iterations somehow when saving `WindowedTimeAverage` to disk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904:1215,Testability,log,logging,1215,"Anyways, I don't quite see it but that could be the issue. So we can try replacing. ```julia; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval) ; ```. with. ```julia; if model.clock.time == wta.schedule.previous_interval_stop_time + wta.schedule.interval; wta.schedule.previous_interval_stop_time = model.clock.time; else; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval); end; ```. Another possible solution is to have a different algorithm in which time-averaging is ""finalized"" when output is retrieved. Retrieval occurs here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L197-L205. And we could set `collecting=false` and reset `wta_schedule.previous_interval_stop_time` there. The only downside is that bad things might happen if for some reason the `WindowedTimeAverage` is called in a callback (for logging or something) apart from when output is being asked for (since that would restart time averaging when not desired...). These issues do seem to motivate figuring out how to record the averaging window / iterations somehow when saving `WindowedTimeAverage` to disk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873328230:50,Testability,test,test,50,I don't think so but I'm not 100% sure. We should test that the warning isn't generated --- it really shouldn't be (`window=interval` is the default after all...),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873328230
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873421141:2043,Energy Efficiency,schedul,schedule,2043,"0.0). julia> model = IncompressibleModel(; architecture = CPU(),; grid = grid,; ); IncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=4, Nz=4); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing. julia> Δt = 20minutes; 1200.0. julia> simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days); Simulation{typename(IncompressibleModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Float64): 20 minutes ; ├── Iteration interval: 20; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 3 days, stop iteration: Inf; ├── Diagnostics: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── nan_checker => typename(NaNChecker); └── Output writers: typename(OrderedCollections.OrderedDict) with no entries. julia> u, v, w = model.velocities; # unpack velocity `Field`s. julia> outputs = (u=u, v=v, w=w);. julia> using Oceananigans.OutputWriters: NetCDFOutputWriter, AveragedTimeInterval. julia> simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(10Δt; window=11Δt),; filepath = ""avg.nc"",; mode = ""c""); NetCDFOutputWriter scheduled on TimeInterval(3.333 hours):; ├── filepath: avg.nc; ├── dimensions: zC(4), zF(5), xC(4), yF(4), xF(4), yC(4), time(0); ├── 3 outputs: [""v"", ""w"", ""u""] averaged on AveragedTimeInterval(window=3.667 hours, stride=1, interval=3.333 hours); ├── field slicer: FieldSlicer(:, :, :, with_halos=false); └── array type: Array{Float32}. julia> run!(simulation); [ Info: Simulation is stopping. Model time 3 days has hit or exceeded simulation stop time 3 days.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873421141
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873421141:2150,Energy Efficiency,schedul,scheduled,2150,"0.0). julia> model = IncompressibleModel(; architecture = CPU(),; grid = grid,; ); IncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=4, Nz=4); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing. julia> Δt = 20minutes; 1200.0. julia> simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days); Simulation{typename(IncompressibleModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Float64): 20 minutes ; ├── Iteration interval: 20; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 3 days, stop iteration: Inf; ├── Diagnostics: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── nan_checker => typename(NaNChecker); └── Output writers: typename(OrderedCollections.OrderedDict) with no entries. julia> u, v, w = model.velocities; # unpack velocity `Field`s. julia> outputs = (u=u, v=v, w=w);. julia> using Oceananigans.OutputWriters: NetCDFOutputWriter, AveragedTimeInterval. julia> simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(10Δt; window=11Δt),; filepath = ""avg.nc"",; mode = ""c""); NetCDFOutputWriter scheduled on TimeInterval(3.333 hours):; ├── filepath: avg.nc; ├── dimensions: zC(4), zF(5), xC(4), yF(4), xF(4), yC(4), time(0); ├── 3 outputs: [""v"", ""w"", ""u""] averaged on AveragedTimeInterval(window=3.667 hours, stride=1, interval=3.333 hours); ├── field slicer: FieldSlicer(:, :, :, with_halos=false); └── array type: Array{Float32}. julia> run!(simulation); [ Info: Simulation is stopping. Model time 3 days has hit or exceeded simulation stop time 3 days.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873421141
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873421141:5,Testability,test,tested,5,"Just tested this and apparently the warning isn't issued anymore. However, no warning is issued now even when `window > inertval`:. ```julia; julia> using Oceananigans. julia> using Oceananigans.Utils. julia> using Oceananigans.Units. julia> grid = RegularRectilinearGrid(size=(4, 4, 4), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0)); RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0e6], y ∈ [0.0, 1.0e6], z ∈ [-4000.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (4, 4, 4); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (250000.0, 250000.0, 1000.0). julia> model = IncompressibleModel(; architecture = CPU(),; grid = grid,; ); IncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=4, Nz=4); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing. julia> Δt = 20minutes; 1200.0. julia> simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days); Simulation{typename(IncompressibleModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Float64): 20 minutes ; ├── Iteration interval: 20; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 3 days, stop iteration: Inf; ├── Diagnostics: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── nan_checker => typename(NaNChecker); └── Output writers: typename(OrderedCollections.OrderedDict) with no entries. julia> u, v, w = model.velocities; # unpack velocity `Field`s. julia> outputs = (u=u, v=v, w=w);. julia> using Oceananigans.OutputWriters: NetCDFOutputWriter, AveragedTimeInterval. julia> simulation.output_writers[:a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873421141
https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873447709:319,Availability,error,error,319,I think when the window is bigger than the interval the result is identical to the case that window=interval. Basically the algorithm starts averaging whenever the model time is greater than `end_of_next_interval - window`. I think we should regard windows larger than intervals as invalid specification; #1816 adds an error for this case.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873447709
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747100424:191,Availability,down,download,191,I think you might be able to derive the fifth order scheme from Wicker and Skamarock (2002):. https://palm.muk.uni-hannover.de/trac/wiki/doc/tec/discret. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.119.8289&rep=rep1&type=pdf. But I'm not 100% sure...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747100424
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747127872:205,Availability,down,download,205,> I think you might be able to derive the fifth order scheme from Wicker and Skamarock (2002):; > ; > https://palm.muk.uni-hannover.de/trac/wiki/doc/tec/discret; > ; > http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.119.8289&rep=rep1&type=pdf; > ; > But I'm not 100% sure... Very helpful.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747127872
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747576282:624,Availability,error,error,624,"I decided to program the different advection schemes in Julia, without using Oceananigans. I can share the code if anyone is interested but it's nothing fancy, and needs some cleaning up. I found that the 5th order upwinding stencil, as used in Oceananigans, should have fifth order convergence. See the results below. So the good news is the stencil formula is correct. The bad news is that I don't know why we are not getting the correct values in Oceananigans, even though I am using the exact same tests. I admit that I don't understand the symmetric interpolant stuff that is done, which is perhaps why I can't see the error. Also, doing 6th order would be easy enough to do if there was interest. ```; For UpwindingFirstOrder: Rate of convergence = -0.9661593569685473 expected = 1. For CenterSecondOrder: Rate of convergence = -1.9640228832659088 expected = 1. For UpwindingThirdOrder: Rate of convergence = -2.9708218645270197 expected = 3. For CenterFourthOrder: Rate of convergence = -3.7210792193087565 expected = 4. For UpwindingFifthOrder: Rate of convergence = -4.847601153924809 expected = 5. For CenterSixthOrder: Rate of convergence = -5.784776184328756 expected = 6. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747576282
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747576282:502,Testability,test,tests,502,"I decided to program the different advection schemes in Julia, without using Oceananigans. I can share the code if anyone is interested but it's nothing fancy, and needs some cleaning up. I found that the 5th order upwinding stencil, as used in Oceananigans, should have fifth order convergence. See the results below. So the good news is the stencil formula is correct. The bad news is that I don't know why we are not getting the correct values in Oceananigans, even though I am using the exact same tests. I admit that I don't understand the symmetric interpolant stuff that is done, which is perhaps why I can't see the error. Also, doing 6th order would be easy enough to do if there was interest. ```; For UpwindingFirstOrder: Rate of convergence = -0.9661593569685473 expected = 1. For CenterSecondOrder: Rate of convergence = -1.9640228832659088 expected = 1. For UpwindingThirdOrder: Rate of convergence = -2.9708218645270197 expected = 3. For CenterFourthOrder: Rate of convergence = -3.7210792193087565 expected = 4. For UpwindingFifthOrder: Rate of convergence = -4.847601153924809 expected = 5. For CenterSixthOrder: Rate of convergence = -5.784776184328756 expected = 6. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747576282
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747710521:269,Testability,test,tests,269,"Heh I think if you can produce a convergence plot then its worthy to be included in the code! Someone might want 6th order advection... > The bad news is that I don't know why we are not getting the correct values in Oceananigans, even though I am using the exact same tests. That sounds like you've isolated a bug...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747710521
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747713133:117,Availability,error,error,117,"> I admit that I don't understand the symmetric interpolant stuff that is done, which is perhaps why I can't see the error. This distinction only matters for momentum advection. For tracer advection, the velocity field does not have to be interpolated to the location of the tracer fluxes, since it's already located there due to the staggered arrangement of velocity fields and tracer fields. For tracer advection, all that matters are the definition of the left-biased and right-biased functions for interpolating cell-averaged tracer values to cell faces. These are the functions `left_biased_interpolate_xᶠᵃᵃ`, etc. This might be made clear by the operators for `advective_tracer_flux_*` when using an upwind-biased scheme:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Advection/upwind_biased_advective_fluxes.jl#L103-L110",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747713133
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747713133:639,Usability,clear,clear,639,"> I admit that I don't understand the symmetric interpolant stuff that is done, which is perhaps why I can't see the error. This distinction only matters for momentum advection. For tracer advection, the velocity field does not have to be interpolated to the location of the tracer fluxes, since it's already located there due to the staggered arrangement of velocity fields and tracer fields. For tracer advection, all that matters are the definition of the left-biased and right-biased functions for interpolating cell-averaged tracer values to cell faces. These are the functions `left_biased_interpolate_xᶠᵃᵃ`, etc. This might be made clear by the operators for `advective_tracer_flux_*` when using an upwind-biased scheme:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Advection/upwind_biased_advective_fluxes.jl#L103-L110",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747713133
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029:653,Availability,error,error,653,"I have written a script, with much help from @ali-ramadhan and @glwagner , that computes the rates of convergence for the one dimensinal constant advection case using two approaches: the 1st to 6th order schemes that I mentioned before, and the 2nd to 5th order schemes that are in Oceananigans. The results are shown below. ![convergence_rates_all](https://user-images.githubusercontent.com/8239041/102648898-511fa580-4136-11eb-99c9-a02b85465c96.png). ![convergence_rates_Oceananigans](https://user-images.githubusercontent.com/8239041/102648908-5381ff80-4136-11eb-8feb-de736ec30438.png). **Good news:** Oceananigams produces the correct slopes within error for all the cases. **Next problem:** Figure out why we didn't get the right slope in the other calculation from before and fix whatever the bug might be. You can find the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/validation/new_framework/rates_of_convergence.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029:892,Deployability,update,update-convergence-tests,892,"I have written a script, with much help from @ali-ramadhan and @glwagner , that computes the rates of convergence for the one dimensinal constant advection case using two approaches: the 1st to 6th order schemes that I mentioned before, and the 2nd to 5th order schemes that are in Oceananigans. The results are shown below. ![convergence_rates_all](https://user-images.githubusercontent.com/8239041/102648898-511fa580-4136-11eb-99c9-a02b85465c96.png). ![convergence_rates_Oceananigans](https://user-images.githubusercontent.com/8239041/102648908-5381ff80-4136-11eb-8feb-de736ec30438.png). **Good news:** Oceananigams produces the correct slopes within error for all the cases. **Next problem:** Figure out why we didn't get the right slope in the other calculation from before and fix whatever the bug might be. You can find the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/validation/new_framework/rates_of_convergence.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029:917,Security,validat,validation,917,"I have written a script, with much help from @ali-ramadhan and @glwagner , that computes the rates of convergence for the one dimensinal constant advection case using two approaches: the 1st to 6th order schemes that I mentioned before, and the 2nd to 5th order schemes that are in Oceananigans. The results are shown below. ![convergence_rates_all](https://user-images.githubusercontent.com/8239041/102648898-511fa580-4136-11eb-99c9-a02b85465c96.png). ![convergence_rates_Oceananigans](https://user-images.githubusercontent.com/8239041/102648908-5381ff80-4136-11eb-8feb-de736ec30438.png). **Good news:** Oceananigams produces the correct slopes within error for all the cases. **Next problem:** Figure out why we didn't get the right slope in the other calculation from before and fix whatever the bug might be. You can find the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/validation/new_framework/rates_of_convergence.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029:911,Testability,test,tests,911,"I have written a script, with much help from @ali-ramadhan and @glwagner , that computes the rates of convergence for the one dimensinal constant advection case using two approaches: the 1st to 6th order schemes that I mentioned before, and the 2nd to 5th order schemes that are in Oceananigans. The results are shown below. ![convergence_rates_all](https://user-images.githubusercontent.com/8239041/102648898-511fa580-4136-11eb-99c9-a02b85465c96.png). ![convergence_rates_Oceananigans](https://user-images.githubusercontent.com/8239041/102648908-5381ff80-4136-11eb-8feb-de736ec30438.png). **Good news:** Oceananigams produces the correct slopes within error for all the cases. **Next problem:** Figure out why we didn't get the right slope in the other calculation from before and fix whatever the bug might be. You can find the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/validation/new_framework/rates_of_convergence.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595:279,Availability,error,error,279,"Below you will see two plots of the rates of convergence rusing schemes that exist in Oceananigans. . This plot uses the solution obtained from Oceananigans directly. The lower order methods produce the correct slopes but the high order methods flatten out because of truncation error. The error I is consistent with single precision accuracy. ; (The slopes in the legend are taken from the plot shown below and are not the slopes of the curves from Oceananigans.) . ![convergence_rates_oceananigans](https://user-images.githubusercontent.com/8239041/103024246-79841700-451d-11eb-8321-454171fa2381.png). This plot is similar but computed using my own time-stepping code but it does use `advective_tracer_flux_x`. In developing this code I was able to ensure that everything is double precision and they give the correct slopes. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103024241-7721bd00-451d-11eb-8717-6437c7c2c577.png). **Good news:** The advection schemes in Oceananigans can produce the correct slopes, as predicted by theory. **Bad news:** Some part of Oceananigans (maybe times-stepping?) must use single precision accuracy, and that truncates the error of the method as a whole. Question: where is the bottleneck that reduces the global spatial accuracy from double to single precision?. This third figure shows the result for increased spatial resolution and we observe that the higher order methods saturate near `1e-16`, as you would expect from double precision. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103028959-c7514d00-4526-11eb-94c6-81fb3d429882.png). In case you are interested, these are the calculations of the rates of convergence for the two sets of calculations. ```; Method = Center2ⁿᵈ, Rate of Convergence = 1.99, Expected = 2; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = Upwind3ʳᵈ, Rate of Convergence = 2.99, Expected = 3; Method = UpwindBiasedThirdOrder(), Rate of Convergenc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595:290,Availability,error,error,290,"Below you will see two plots of the rates of convergence rusing schemes that exist in Oceananigans. . This plot uses the solution obtained from Oceananigans directly. The lower order methods produce the correct slopes but the high order methods flatten out because of truncation error. The error I is consistent with single precision accuracy. ; (The slopes in the legend are taken from the plot shown below and are not the slopes of the curves from Oceananigans.) . ![convergence_rates_oceananigans](https://user-images.githubusercontent.com/8239041/103024246-79841700-451d-11eb-8321-454171fa2381.png). This plot is similar but computed using my own time-stepping code but it does use `advective_tracer_flux_x`. In developing this code I was able to ensure that everything is double precision and they give the correct slopes. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103024241-7721bd00-451d-11eb-8717-6437c7c2c577.png). **Good news:** The advection schemes in Oceananigans can produce the correct slopes, as predicted by theory. **Bad news:** Some part of Oceananigans (maybe times-stepping?) must use single precision accuracy, and that truncates the error of the method as a whole. Question: where is the bottleneck that reduces the global spatial accuracy from double to single precision?. This third figure shows the result for increased spatial resolution and we observe that the higher order methods saturate near `1e-16`, as you would expect from double precision. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103028959-c7514d00-4526-11eb-94c6-81fb3d429882.png). In case you are interested, these are the calculations of the rates of convergence for the two sets of calculations. ```; Method = Center2ⁿᵈ, Rate of Convergence = 1.99, Expected = 2; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = Upwind3ʳᵈ, Rate of Convergence = 2.99, Expected = 3; Method = UpwindBiasedThirdOrder(), Rate of Convergenc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595:1184,Availability,error,error,1184,"d from Oceananigans directly. The lower order methods produce the correct slopes but the high order methods flatten out because of truncation error. The error I is consistent with single precision accuracy. ; (The slopes in the legend are taken from the plot shown below and are not the slopes of the curves from Oceananigans.) . ![convergence_rates_oceananigans](https://user-images.githubusercontent.com/8239041/103024246-79841700-451d-11eb-8321-454171fa2381.png). This plot is similar but computed using my own time-stepping code but it does use `advective_tracer_flux_x`. In developing this code I was able to ensure that everything is double precision and they give the correct slopes. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103024241-7721bd00-451d-11eb-8717-6437c7c2c577.png). **Good news:** The advection schemes in Oceananigans can produce the correct slopes, as predicted by theory. **Bad news:** Some part of Oceananigans (maybe times-stepping?) must use single precision accuracy, and that truncates the error of the method as a whole. Question: where is the bottleneck that reduces the global spatial accuracy from double to single precision?. This third figure shows the result for increased spatial resolution and we observe that the higher order methods saturate near `1e-16`, as you would expect from double precision. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103028959-c7514d00-4526-11eb-94c6-81fb3d429882.png). In case you are interested, these are the calculations of the rates of convergence for the two sets of calculations. ```; Method = Center2ⁿᵈ, Rate of Convergence = 1.99, Expected = 2; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = Upwind3ʳᵈ, Rate of Convergence = 2.99, Expected = 3; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 3.20, Expected = 3; Method = Center4ᵗʰ, Rate of Convergence = 3.98, Expected = 4; Method = CenteredFourthOrder(), Rate of Convergence",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595:1255,Energy Efficiency,reduce,reduces,1255,"runcation error. The error I is consistent with single precision accuracy. ; (The slopes in the legend are taken from the plot shown below and are not the slopes of the curves from Oceananigans.) . ![convergence_rates_oceananigans](https://user-images.githubusercontent.com/8239041/103024246-79841700-451d-11eb-8321-454171fa2381.png). This plot is similar but computed using my own time-stepping code but it does use `advective_tracer_flux_x`. In developing this code I was able to ensure that everything is double precision and they give the correct slopes. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103024241-7721bd00-451d-11eb-8717-6437c7c2c577.png). **Good news:** The advection schemes in Oceananigans can produce the correct slopes, as predicted by theory. **Bad news:** Some part of Oceananigans (maybe times-stepping?) must use single precision accuracy, and that truncates the error of the method as a whole. Question: where is the bottleneck that reduces the global spatial accuracy from double to single precision?. This third figure shows the result for increased spatial resolution and we observe that the higher order methods saturate near `1e-16`, as you would expect from double precision. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103028959-c7514d00-4526-11eb-94c6-81fb3d429882.png). In case you are interested, these are the calculations of the rates of convergence for the two sets of calculations. ```; Method = Center2ⁿᵈ, Rate of Convergence = 1.99, Expected = 2; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = Upwind3ʳᵈ, Rate of Convergence = 2.99, Expected = 3; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 3.20, Expected = 3; Method = Center4ᵗʰ, Rate of Convergence = 3.98, Expected = 4; Method = CenteredFourthOrder(), Rate of Convergence = 2.45, Expected = 4; Method = Upwind5ᵗʰ, Rate of Convergence = 4.97, Expected = 5; Method = UpwindBiasedFifthOrder(), Rate of Conv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595:1239,Performance,bottleneck,bottleneck,1239,"runcation error. The error I is consistent with single precision accuracy. ; (The slopes in the legend are taken from the plot shown below and are not the slopes of the curves from Oceananigans.) . ![convergence_rates_oceananigans](https://user-images.githubusercontent.com/8239041/103024246-79841700-451d-11eb-8321-454171fa2381.png). This plot is similar but computed using my own time-stepping code but it does use `advective_tracer_flux_x`. In developing this code I was able to ensure that everything is double precision and they give the correct slopes. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103024241-7721bd00-451d-11eb-8717-6437c7c2c577.png). **Good news:** The advection schemes in Oceananigans can produce the correct slopes, as predicted by theory. **Bad news:** Some part of Oceananigans (maybe times-stepping?) must use single precision accuracy, and that truncates the error of the method as a whole. Question: where is the bottleneck that reduces the global spatial accuracy from double to single precision?. This third figure shows the result for increased spatial resolution and we observe that the higher order methods saturate near `1e-16`, as you would expect from double precision. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103028959-c7514d00-4526-11eb-94c6-81fb3d429882.png). In case you are interested, these are the calculations of the rates of convergence for the two sets of calculations. ```; Method = Center2ⁿᵈ, Rate of Convergence = 1.99, Expected = 2; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = Upwind3ʳᵈ, Rate of Convergence = 2.99, Expected = 3; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 3.20, Expected = 3; Method = Center4ᵗʰ, Rate of Convergence = 3.98, Expected = 4; Method = CenteredFourthOrder(), Rate of Convergence = 2.45, Expected = 4; Method = Upwind5ᵗʰ, Rate of Convergence = 4.97, Expected = 5; Method = UpwindBiasedFifthOrder(), Rate of Conv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595:1040,Safety,predict,predicted,1040," you will see two plots of the rates of convergence rusing schemes that exist in Oceananigans. . This plot uses the solution obtained from Oceananigans directly. The lower order methods produce the correct slopes but the high order methods flatten out because of truncation error. The error I is consistent with single precision accuracy. ; (The slopes in the legend are taken from the plot shown below and are not the slopes of the curves from Oceananigans.) . ![convergence_rates_oceananigans](https://user-images.githubusercontent.com/8239041/103024246-79841700-451d-11eb-8321-454171fa2381.png). This plot is similar but computed using my own time-stepping code but it does use `advective_tracer_flux_x`. In developing this code I was able to ensure that everything is double precision and they give the correct slopes. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103024241-7721bd00-451d-11eb-8717-6437c7c2c577.png). **Good news:** The advection schemes in Oceananigans can produce the correct slopes, as predicted by theory. **Bad news:** Some part of Oceananigans (maybe times-stepping?) must use single precision accuracy, and that truncates the error of the method as a whole. Question: where is the bottleneck that reduces the global spatial accuracy from double to single precision?. This third figure shows the result for increased spatial resolution and we observe that the higher order methods saturate near `1e-16`, as you would expect from double precision. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103028959-c7514d00-4526-11eb-94c6-81fb3d429882.png). In case you are interested, these are the calculations of the rates of convergence for the two sets of calculations. ```; Method = Center2ⁿᵈ, Rate of Convergence = 1.99, Expected = 2; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = Upwind3ʳᵈ, Rate of Convergence = 2.99, Expected = 3; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313:281,Energy Efficiency,Adapt,Adapt,281,I would like to suggest the following checklist moving forward. - [ ] Decide whether we like the structure of the script `new_rates_of_convergence.jl`. How can we might improve it?; - [ ] Find where the bottleneck is in Oceanangans to make things globally single precision.; - [ ] Adapt this approach to the other validation cases that currently exist.; - [ ] Make `UpwindFirstOrderBiased()` advection scheme.; - [ ] Make `CenteredSixthOrder()` advection scheme.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313:281,Modifiability,Adapt,Adapt,281,I would like to suggest the following checklist moving forward. - [ ] Decide whether we like the structure of the script `new_rates_of_convergence.jl`. How can we might improve it?; - [ ] Find where the bottleneck is in Oceanangans to make things globally single precision.; - [ ] Adapt this approach to the other validation cases that currently exist.; - [ ] Make `UpwindFirstOrderBiased()` advection scheme.; - [ ] Make `CenteredSixthOrder()` advection scheme.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313:203,Performance,bottleneck,bottleneck,203,I would like to suggest the following checklist moving forward. - [ ] Decide whether we like the structure of the script `new_rates_of_convergence.jl`. How can we might improve it?; - [ ] Find where the bottleneck is in Oceanangans to make things globally single precision.; - [ ] Adapt this approach to the other validation cases that currently exist.; - [ ] Make `UpwindFirstOrderBiased()` advection scheme.; - [ ] Make `CenteredSixthOrder()` advection scheme.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313:314,Security,validat,validation,314,I would like to suggest the following checklist moving forward. - [ ] Decide whether we like the structure of the script `new_rates_of_convergence.jl`. How can we might improve it?; - [ ] Find where the bottleneck is in Oceanangans to make things globally single precision.; - [ ] Adapt this approach to the other validation cases that currently exist.; - [ ] Make `UpwindFirstOrderBiased()` advection scheme.; - [ ] Make `CenteredSixthOrder()` advection scheme.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754024823:369,Testability,test,test,369,"Thanks @ali-ramadhan for the feedback. What I have so far is only redoing the `one_dimensional_advection_schemes.jl` but I thought this was a good place to start. When we are happy with this it should be easy to do other more interesting cases. I am happy to work with you to merge this with what you did in the other PR, when you have time. I agree that having some `@test` checks is a good idea. . I don't think it's as simple as everything being single as I tried running Oceananigans using single and reproduced the same plot. @glwagner suggested maybe something happens in the pressure solve. Could be but I don't know yet but I'm going to try and test this using ShallowWaterModel, which has no pressure solve. I have used a small enough time step that the scheme hasn't bee a problem, but I agree that RK3 would be better. I was only using QAB2 because I wanted to compare it with what I had programmed, AB2, to get similar results. From what I have seen both QAB2 and AB2 do pretty much the same thing, in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754024823
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754024823:653,Testability,test,test,653,"Thanks @ali-ramadhan for the feedback. What I have so far is only redoing the `one_dimensional_advection_schemes.jl` but I thought this was a good place to start. When we are happy with this it should be easy to do other more interesting cases. I am happy to work with you to merge this with what you did in the other PR, when you have time. I agree that having some `@test` checks is a good idea. . I don't think it's as simple as everything being single as I tried running Oceananigans using single and reproduced the same plot. @glwagner suggested maybe something happens in the pressure solve. Could be but I don't know yet but I'm going to try and test this using ShallowWaterModel, which has no pressure solve. I have used a small enough time step that the scheme hasn't bee a problem, but I agree that RK3 would be better. I was only using QAB2 because I wanted to compare it with what I had programmed, AB2, to get similar results. From what I have seen both QAB2 and AB2 do pretty much the same thing, in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754024823
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754024823:29,Usability,feedback,feedback,29,"Thanks @ali-ramadhan for the feedback. What I have so far is only redoing the `one_dimensional_advection_schemes.jl` but I thought this was a good place to start. When we are happy with this it should be easy to do other more interesting cases. I am happy to work with you to merge this with what you did in the other PR, when you have time. I agree that having some `@test` checks is a good idea. . I don't think it's as simple as everything being single as I tried running Oceananigans using single and reproduced the same plot. @glwagner suggested maybe something happens in the pressure solve. Could be but I don't know yet but I'm going to try and test this using ShallowWaterModel, which has no pressure solve. I have used a small enough time step that the scheme hasn't bee a problem, but I agree that RK3 would be better. I was only using QAB2 because I wanted to compare it with what I had programmed, AB2, to get similar results. From what I have seen both QAB2 and AB2 do pretty much the same thing, in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754024823
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754024823:422,Usability,simpl,simple,422,"Thanks @ali-ramadhan for the feedback. What I have so far is only redoing the `one_dimensional_advection_schemes.jl` but I thought this was a good place to start. When we are happy with this it should be easy to do other more interesting cases. I am happy to work with you to merge this with what you did in the other PR, when you have time. I agree that having some `@test` checks is a good idea. . I don't think it's as simple as everything being single as I tried running Oceananigans using single and reproduced the same plot. @glwagner suggested maybe something happens in the pressure solve. Could be but I don't know yet but I'm going to try and test this using ShallowWaterModel, which has no pressure solve. I have used a small enough time step that the scheme hasn't bee a problem, but I agree that RK3 would be better. I was only using QAB2 because I wanted to compare it with what I had programmed, AB2, to get similar results. From what I have seen both QAB2 and AB2 do pretty much the same thing, in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754024823
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754117823:136,Availability,down,down,136,"When I use the advection schemes from ShallowWaterModel I get that the solution computed from Oceananigans has the correct slopes going down to very fine accuracies. The two plots are identicial. I think this is further evidence that the lack of accuracy comes from the pressure solve. One possibility is to have these convergence tests done through ShallowWaterModel, at least for the mean time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754117823
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754117823:331,Testability,test,tests,331,"When I use the advection schemes from ShallowWaterModel I get that the solution computed from Oceananigans has the correct slopes going down to very fine accuracies. The two plots are identicial. I think this is further evidence that the lack of accuracy comes from the pressure solve. One possibility is to have these convergence tests done through ShallowWaterModel, at least for the mean time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754117823
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376:116,Availability,error,error,116,"I installed Julia and set up Oceananigans on my laptop and when I try running `test_shallow_water_mode.jl` I get an error. I suspect this is because of my laptop more than the PR but any ideas what's going on here? . ```[2021/01/07 11:52:45.500] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); TaskFailedException:; BoundsError; Stacktrace:; [1] getindex at ./number.jl:83 [inlined]; [2] advective_tracer_flux_x at /home/fpoulin/software/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:105 [inlined]; [3] h_solution_tendency at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl:71 [inlined]; [4] cpu_calculate_Gh! at /home/fpoulin/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:230 [inlined]; [5] __thread_run(::Int64, ::Int64, ::Int64, ::KernelAbstractions.Kernel{KernelAbstractions.CPU,KernelAbstractions.NDIterat```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376:408,Availability,Error,Error,408,"I installed Julia and set up Oceananigans on my laptop and when I try running `test_shallow_water_mode.jl` I get an error. I suspect this is because of my laptop more than the PR but any ideas what's going on here? . ```[2021/01/07 11:52:45.500] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); TaskFailedException:; BoundsError; Stacktrace:; [1] getindex at ./number.jl:83 [inlined]; [2] advective_tracer_flux_x at /home/fpoulin/software/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:105 [inlined]; [3] h_solution_tendency at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl:71 [inlined]; [4] cpu_calculate_Gh! at /home/fpoulin/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:230 [inlined]; [5] __thread_run(::Int64, ::Int64, ::Int64, ::KernelAbstractions.Kernel{KernelAbstractions.CPU,KernelAbstractions.NDIterat```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376:2,Deployability,install,installed,2,"I installed Julia and set up Oceananigans on my laptop and when I try running `test_shallow_water_mode.jl` I get an error. I suspect this is because of my laptop more than the PR but any ideas what's going on here? . ```[2021/01/07 11:52:45.500] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); TaskFailedException:; BoundsError; Stacktrace:; [1] getindex at ./number.jl:83 [inlined]; [2] advective_tracer_flux_x at /home/fpoulin/software/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:105 [inlined]; [3] h_solution_tendency at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl:71 [inlined]; [4] cpu_calculate_Gh! at /home/fpoulin/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:230 [inlined]; [5] __thread_run(::Int64, ::Int64, ::Int64, ::KernelAbstractions.Kernel{KernelAbstractions.CPU,KernelAbstractions.NDIterat```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376:251,Testability,Test,Testing,251,"I installed Julia and set up Oceananigans on my laptop and when I try running `test_shallow_water_mode.jl` I get an error. I suspect this is because of my laptop more than the PR but any ideas what's going on here? . ```[2021/01/07 11:52:45.500] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); TaskFailedException:; BoundsError; Stacktrace:; [1] getindex at ./number.jl:83 [inlined]; [2] advective_tracer_flux_x at /home/fpoulin/software/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:105 [inlined]; [3] h_solution_tendency at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl:71 [inlined]; [4] cpu_calculate_Gh! at /home/fpoulin/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:230 [inlined]; [5] __thread_run(::Int64, ::Int64, ::Int64, ::KernelAbstractions.Kernel{KernelAbstractions.CPU,KernelAbstractions.NDIterat```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376:421,Testability,Test,Test,421,"I installed Julia and set up Oceananigans on my laptop and when I try running `test_shallow_water_mode.jl` I get an error. I suspect this is because of my laptop more than the PR but any ideas what's going on here? . ```[2021/01/07 11:52:45.500] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); TaskFailedException:; BoundsError; Stacktrace:; [1] getindex at ./number.jl:83 [inlined]; [2] advective_tracer_flux_x at /home/fpoulin/software/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:105 [inlined]; [3] h_solution_tendency at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl:71 [inlined]; [4] cpu_calculate_Gh! at /home/fpoulin/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:230 [inlined]; [5] __thread_run(::Int64, ::Int64, ::Int64, ::KernelAbstractions.Kernel{KernelAbstractions.CPU,KernelAbstractions.NDIterat```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376:468,Testability,test,test,468,"I installed Julia and set up Oceananigans on my laptop and when I try running `test_shallow_water_mode.jl` I get an error. I suspect this is because of my laptop more than the PR but any ideas what's going on here? . ```[2021/01/07 11:52:45.500] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); TaskFailedException:; BoundsError; Stacktrace:; [1] getindex at ./number.jl:83 [inlined]; [2] advective_tracer_flux_x at /home/fpoulin/software/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:105 [inlined]; [3] h_solution_tendency at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl:71 [inlined]; [4] cpu_calculate_Gh! at /home/fpoulin/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:230 [inlined]; [5] __thread_run(::Int64, ::Int64, ::Int64, ::KernelAbstractions.Kernel{KernelAbstractions.CPU,KernelAbstractions.NDIterat```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376:506,Testability,Test,Test,506,"I installed Julia and set up Oceananigans on my laptop and when I try running `test_shallow_water_mode.jl` I get an error. I suspect this is because of my laptop more than the PR but any ideas what's going on here? . ```[2021/01/07 11:52:45.500] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); TaskFailedException:; BoundsError; Stacktrace:; [1] getindex at ./number.jl:83 [inlined]; [2] advective_tracer_flux_x at /home/fpoulin/software/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:105 [inlined]; [3] h_solution_tendency at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl:71 [inlined]; [4] cpu_calculate_Gh! at /home/fpoulin/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:230 [inlined]; [5] __thread_run(::Int64, ::Int64, ::Int64, ::KernelAbstractions.Kernel{KernelAbstractions.CPU,KernelAbstractions.NDIterat```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:662,Availability,error,error,662,"A question for @glwagner . At the moment the tendencies in the evolution equation for height is computed here using essentailly a second-order finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:989,Availability,error,error,989,"A question for @glwagner . At the moment the tendencies in the evolution equation for height is computed here using essentailly a second-order finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:1117,Availability,ERROR,ERROR,1117,"finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:102 [inlined]; [6] cuStreamWaitEvent(::CuStream, ::CuEvent, ::Int64) at /home/fpoulin/.julia/pac",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:1299,Availability,Error,Error,1299,"ection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:102 [inlined]; [6] cuStreamWaitEvent(::CuStream, ::CuEvent, ::Int64) at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/utils/call.jl:93; [7] wait at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/events.jl:77 [inlined]; [8] wait(::KernelAb",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:1847,Availability,error,error,1847,"n be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:102 [inlined]; [6] cuStreamWaitEvent(::CuStream, ::CuEvent, ::Int64) at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/utils/call.jl:93; [7] wait at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/events.jl:77 [inlined]; [8] wait(::KernelAbstractions.CUDADevice, ::KernelAbstractions.MultiEvent{Tuple{KernelAbstractions.CudaEvent,KernelAbstractions.CudaEvent,KernelAbstractions.CudaEvent}}, ::Nothing, ::CuStream) at /home/fpoulin/.julia/packages/KernelAbstractions/jAutM/src/backends/cuda.jl:80; [9] wait(::KernelAbstractions.CUDADevice, ::KernelAbstractions.MultiEvent{Tuple{KernelAbstractions.CudaEvent,KernelAbstractions.CudaE```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:2038,Availability,error,error,2038,"n be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:102 [inlined]; [6] cuStreamWaitEvent(::CuStream, ::CuEvent, ::Int64) at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/utils/call.jl:93; [7] wait at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/events.jl:77 [inlined]; [8] wait(::KernelAbstractions.CUDADevice, ::KernelAbstractions.MultiEvent{Tuple{KernelAbstractions.CudaEvent,KernelAbstractions.CudaEvent,KernelAbstractions.CudaEvent}}, ::Nothing, ::CuStream) at /home/fpoulin/.julia/packages/KernelAbstractions/jAutM/src/backends/cuda.jl:80; [9] wait(::KernelAbstractions.CUDADevice, ::KernelAbstractions.MultiEvent{Tuple{KernelAbstractions.CudaEvent,KernelAbstractions.CudaE```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:375,Deployability,update,update-convergence-tests,375,"A question for @glwagner . At the moment the tendencies in the evolution equation for height is computed here using essentailly a second-order finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:630,Modifiability,variab,variables,630,"A question for @glwagner . At the moment the tendencies in the evolution equation for height is computed here using essentailly a second-order finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:394,Testability,test,tests,394,"A question for @glwagner . At the moment the tendencies in the evolution equation for height is computed here using essentailly a second-order finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:928,Testability,test,tests,928,"A question for @glwagner . At the moment the tendencies in the evolution equation for height is computed here using essentailly a second-order finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:1033,Testability,Test,Testing,1033,"tion equation for height is computed here using essentailly a second-order finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:102 [inlined]; [6] cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:1312,Testability,Test,Test,1312,"ection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:102 [inlined]; [6] cuStreamWaitEvent(::CuStream, ::CuEvent, ::Int64) at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/utils/call.jl:93; [7] wait at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/events.jl:77 [inlined]; [8] wait(::KernelAb",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:1359,Testability,test,test,1359,"p/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:102 [inlined]; [6] cuStreamWaitEvent(::CuStream, ::CuEvent, ::Int64) at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/utils/call.jl:93; [7] wait at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/events.jl:77 [inlined]; [8] wait(::KernelAbstractions.CUDADevice, ::KernelAbstractions.MultiEvent{Tuple{KernelAbstractions.Cud",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:1397,Testability,Test,Test,1397,"ed doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:102 [inlined]; [6] cuStreamWaitEvent(::CuStream, ::CuEvent, ::Int64) at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/utils/call.jl:93; [7] wait at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/events.jl:77 [inlined]; [8] wait(::KernelAbstractions.CUDADevice, ::KernelAbstractions.MultiEvent{Tuple{KernelAbstractions.CudaEvent,KernelAbstractions.CudaEvent,KernelAbstractions.CudaEvent}}, ::Nothing, ::CuStream) at /home/fpoulin/.julia/packages/KernelAbstra",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747153244:565,Availability,down,downside,565,"> This seems like a matter of preference, but I kinda like that the default is a reasonable value. Ok, let's think about it. It also doesn't make sense if what you're doing is non-dimensional... I've found that AMD doesn't actually work that well when turbulence is weak and the subfilter diffusivity is ""close"" to the molecular value. It might be more symbolic than anything to have a non-zero molecular diffusivity, since setting it to zero might not have an observable effect on results ... ? What do you think? Have you found that it changes your results?. One downside of specifying a non-zero yet negligible number (in other words, the difference between this number and zero cannot be observed) is that it _implies_ that non-zeroness is important when it isn't. So if it really doesn't matter, I'm worried that it distracts from the communication of scientific results... The default for `IsotropicDiffusivity` is also this ""20 degree water"" number. Maybe that's more important to change, since simulations with `IsotropicDiffusivity` in `Oceananigans` are probably idealized rather than DNS of a miniscule box.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747153244
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747154361:452,Usability,clear,clear,452,"> Although I prefer to keep calling ν_e the eddy diffusivity, since that's what everyone calls it and it's supposed to model the action of eddies. The caveat here is that this doesn't match the convention that the code uses, right? Which I think can be pretty confusing. You've pointed out here that the docs are inconsistent, so they must be changed. But we could change notation in both the code and the docs if we think it will make either one more clear. . We could also change the closure implementation so that the contribution of the molecular diffusivity to flux divergences is added separately, rather than adding the molecular diffusivity to `νₑ` in `calculate_diffusivities!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747154361
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747485363:183,Usability,clear,clear,183,"> You've pointed out here that the docs are inconsistent, so they must be changed. But we could change notation in both the code and the docs if we think it will make either one more clear. I'm not sure what the best approach is for the code. Also, I'm happy to change the docs to be consistent after we agree on what to do, but I'd rather not be the one changing the code right now (if we do decide to change it). That would require me to spend a considerable amount of time learning how to contribute to Oceananigans given that I've never started a project in Julia or contributed to a repo that wasn't my own).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747485363
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747485363:476,Usability,learn,learning,476,"> You've pointed out here that the docs are inconsistent, so they must be changed. But we could change notation in both the code and the docs if we think it will make either one more clear. I'm not sure what the best approach is for the code. Also, I'm happy to change the docs to be consistent after we agree on what to do, but I'd rather not be the one changing the code right now (if we do decide to change it). That would require me to spend a considerable amount of time learning how to contribute to Oceananigans given that I've never started a project in Julia or contributed to a repo that wasn't my own).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747485363
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-774500558:183,Usability,clear,clear,183,"> You've pointed out here that the docs are inconsistent, so they must be changed. But we could change notation in both the code and the docs if we think it will make either one more clear. So, I thought about this a little more, and I do think that the notation used in the code and the docs could change to something more accurate and consistent. Right now, if I understand correctly, the code considers `ν_sgs` to model the action of eddies, `v` to be molecular diffusion, and `v_e` to be the sum of both:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L135. However, a better way of naming thing (which both the docs and code could follow) would be . - take `ν_e` (or `ν_eddy` if you prefer) to be the turbulent closure alone. Because that is meant to model _exclusively_ the action of eddies, so the name makes sense.; - `ν` could continue being the molecular diffusivity (we could even change it to `ν_m` or `ν_molec` to be more explicit); - `ν_sgs` is then `ν_eddy` + `ν_molec`, since this is generally what turbulence literature uses. And it makes sense, since both unresolved eddies and molecular diffusion are processes that happen at the sub-grid scales. This would require changing nomenclature in both the code and the docs, unfortunately, but the upside is that is doesn't require any change in the programming itself (it would have to change if we separated eddy and molecular viscosities). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-774500558
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775231776:244,Energy Efficiency,meter,meter,244,"> Having said that, I don't imagine that for large scale flows people will ever need to use the total as the eddy viscosities would dominate. Eddy viscosities dominate in almost all ocean problems, including large eddy simulation with grids on meter scales --- the exceptions being ""resolved LES"" of the bottom boundary layer, where in some circumstances (very small problems) the molecular contribution can be significant. For typical ocean conditions we have found that the molecular contribution is less than a percent in most cases (which may be less than numerical diffusion...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775231776
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775252780:691,Availability,down,down-gradient,691,"> I think the e could be ""effective"" rather than ""eddy"". I'm not sure it makes sense to refer to the molecular diffusivity as ""sub-grid scale"". Shouldn't we refer to the molecular contribution to the flux as ""resolved"" physics?. I come from an engineering background, so my views might be different, but I don't remember ever seeing something called ""effective"" diffusivity. Also, to me at least it's kind of ambiguous what process go into some ""effective"" diffusivity, which I think can confuse users (I certainly would be confused). . Plus, one could argue that molecular diffusivity itself isn't technically ""resolved physics"", since we're not resolving the molecules! It's just the same down-gradient closure as the eddy diffusivity. It works really well in this case because there's a huge scale separation between the molecule size and the smallest motion size, which is the Kolmogorov scale. While this scale separation is natural for molecular diffusivity, it's completely artificial (non-existent really) for the eddies, which is why it doesn't work nearly as well. (Corrsin published a really nice paper about this in 1976.). So I still think that `ν_sgs = ν_eddy + ν_molec` makes sense and is unambiguous. I think being unambiguous is the most important part here, though, since we want people to understand the code easy to be able to contribute, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775252780
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775312009:591,Usability,simpl,simple,591,"I agree that ""eddy viscosity"" is common and ""effective viscosity"" is not, and abusing the letter ""e"" could lead to confusion. However, I also think that ν_sgs is synonymous with ""eddy viscosity"" and that the molecular fluxes are not ""sub grid"" or ""sub filter"". The most important question is whether or not constant isotropic component of viscosity / diffusivity should be included in the arrays saved as `model.diffusivities`. What are people's opinions about that?. If would like to save the total viscosity there then I think we should call it just that (`ν_total`), or find a comparably simple name. If we would like to include just the ""eddy"" or nonlinear viscosity in `model.diffusivities`, then we can keep the current name in the code `νₑ`, and change the physics docs so that they are consistent with the code. The [physics docs](https://clima.github.io/OceananigansDocumentation/stable/physics/turbulence_closures/) are currently consistent with the code -- its just that we don't want to call ""sgs + molecular"" as `νₑ` or ""eddy"". As pointed out in the original post, the [numerical implementation docs](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/turbulence_closures/) are out of sync with both the physics docs and the code. I think this is because they were essentially written as a stand-alone tutorial to large eddy simulation rather than something that pertains specifically to Oceananigans. I think a lot of the numerical implementation docs are a bit dated. It might be better to nuke this section than confuse future users. But an alternative is to spend some time sprucing it up. More than just the large eddy simulation section needs to be improved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775312009
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775339859:1268,Modifiability,parameteriz,parameterization,1268,"Lots of interesting discussion here. Nomenclature can be a pain as people use a lot of different words for the same things and sometimes use the same word for different things. I wonder whether finding a good review article and citing that would be a good way to establish our foundation? I imagine there is a lot to choose from out there but don't have a specific one in mind. Below are a few thoughts. 1) I would argue that molecular viscosity is real (resolved) physics, in these continuum models, is derived from physical principles and you should not change the coefficients based on the grid you are using. These are measured in experiments and are what the community to believe as true when doing lab experiments. 2) For large-scale flows, as many of us consider, molecular viscosity is insignificant and should probably be ignored as it has no real meaning on the large scales. That is why summing molecular and eddy viscosities does not seem like such a good idea to me. However, adding a very small number to a large number will nto make much of a difference for all intensive purposes. I would think that the user has the onous of responsibility of picking the viscosity that is appropriate for their problem. . 3) For large-scale flows where you need some parameterization, I think that using `eddy` or `sgs` are accepted by large groups in the community. Effective seems a little less desirable for me as it does not say where it comes from.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775339859
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:959,Energy Efficiency,energy,energy,959,"The discussion about molecular viscosity being resolved/modeled physics is a deep one. Probably too deep for a github issue. After many discussions with Jim McWilliams he managed to convince me that the only difference between the modeling of eddy versus molecular diffusion is scale separation between processes. The issue about always keeping a more rigorous set of equations and including the molecular diffusivity by default (even though it's probably not important in the vast majority of cases) is one of many modeling philosophies. I highly recommend the paper by [Kerry Emanuel](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2019AV000129). It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:1063,Energy Efficiency,energy,energy,1063,"ably too deep for a github issue. After many discussions with Jim McWilliams he managed to convince me that the only difference between the modeling of eddy versus molecular diffusion is scale separation between processes. The issue about always keeping a more rigorous set of equations and including the molecular diffusivity by default (even though it's probably not important in the vast majority of cases) is one of many modeling philosophies. I highly recommend the paper by [Kerry Emanuel](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2019AV000129). It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's mo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:1123,Energy Efficiency,energy,energy,1123,"ably too deep for a github issue. After many discussions with Jim McWilliams he managed to convince me that the only difference between the modeling of eddy versus molecular diffusion is scale separation between processes. The issue about always keeping a more rigorous set of equations and including the molecular diffusivity by default (even though it's probably not important in the vast majority of cases) is one of many modeling philosophies. I highly recommend the paper by [Kerry Emanuel](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2019AV000129). It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's mo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:1618,Energy Efficiency,energy,energy,1618," It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's more inline with the physics, which are additive, and we don't gain significant computational efficiency from neglecting it. But that's just my vote. (I also like calling it `ν_total`, as it is unambiguous.); - 2 - What should we do about the numerical implementation docs being out of sync with both the physics docs and the code? I'm happy to change the docs myself, but I think we haven't converged on how to do that yet. I'm okay with nuking one of the docs sections. I don't see why two separate sections are needed and the [physics / turbulence closures](https://",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:1733,Safety,predict,prediction,1733," It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's more inline with the physics, which are additive, and we don't gain significant computational efficiency from neglecting it. But that's just my vote. (I also like calling it `ν_total`, as it is unambiguous.); - 2 - What should we do about the numerical implementation docs being out of sync with both the physics docs and the code? I'm happy to change the docs myself, but I think we haven't converged on how to do that yet. I'm okay with nuking one of the docs sections. I don't see why two separate sections are needed and the [physics / turbulence closures](https://",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:844,Usability,simpl,simple,844,"The discussion about molecular viscosity being resolved/modeled physics is a deep one. Probably too deep for a github issue. After many discussions with Jim McWilliams he managed to convince me that the only difference between the modeling of eddy versus molecular diffusion is scale separation between processes. The issue about always keeping a more rigorous set of equations and including the molecular diffusivity by default (even though it's probably not important in the vast majority of cases) is one of many modeling philosophies. I highly recommend the paper by [Kerry Emanuel](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2019AV000129). It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-776178051:982,Integrability,interface,interface,982,"> Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's more inline with the physics, which are additive, and we don't gain significant computational efficiency from neglecting it. I think my suggestion is being misinterpreted --- I was referring only to changes to software and data structures; not changes to the partial differential equations being solved. . If we do not ""add"" the constant background viscosity component to `model.diffusivities.νₑ`, we would instead add the contribution of the constant background viscosity to the total diffusive flux divergence separately from the contribution associated with the nonlinear eddy viscosity (similar to how the diffusive flux divergence for constant background viscosity is currently calculated without the auxiliary field `model.diffusivities.νₑ`). Thus my suggestion only changes the content of `model.diffusivities.νₑ` and otherwise preserves both the user interface and the default behavior for `Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation`. We could also completely remove ""constant background"" parameter from `AnisotropicMinimumDissipation` and preserve existing behavior, since users can use multiple turbulence closures to achieve the same effect, as in. ```julia; closure = (AnisotropicMinimumDissipation(), IsotropicViscosity(ν=1.05e-6)); ```. for example. This might be a better user interface than what we have now. As a side note, since there's no constant background viscosity that's appropriate for all scenarios, it should probably be zero by default if we continue to allow users to set it as a parameter in `AnisotropicMinimumDissipation` (eg #1278).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-776178051
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-776178051:1435,Integrability,interface,interface,1435,"> Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's more inline with the physics, which are additive, and we don't gain significant computational efficiency from neglecting it. I think my suggestion is being misinterpreted --- I was referring only to changes to software and data structures; not changes to the partial differential equations being solved. . If we do not ""add"" the constant background viscosity component to `model.diffusivities.νₑ`, we would instead add the contribution of the constant background viscosity to the total diffusive flux divergence separately from the contribution associated with the nonlinear eddy viscosity (similar to how the diffusive flux divergence for constant background viscosity is currently calculated without the auxiliary field `model.diffusivities.νₑ`). Thus my suggestion only changes the content of `model.diffusivities.νₑ` and otherwise preserves both the user interface and the default behavior for `Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation`. We could also completely remove ""constant background"" parameter from `AnisotropicMinimumDissipation` and preserve existing behavior, since users can use multiple turbulence closures to achieve the same effect, as in. ```julia; closure = (AnisotropicMinimumDissipation(), IsotropicViscosity(ν=1.05e-6)); ```. for example. This might be a better user interface than what we have now. As a side note, since there's no constant background viscosity that's appropriate for all scenarios, it should probably be zero by default if we continue to allow users to set it as a parameter in `AnisotropicMinimumDissipation` (eg #1278).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-776178051
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-837110791:395,Usability,simpl,simplified,395,"I'm thinking about introducing a new container for ""auxiliary fields"" called `model.auxiliaries`, getting rid of `model.diffusivities`, and putting references to the ""eddy diffusivity"" in the LES closure parameter structs. Are we okay with removing the constant background viscosities and diffusivities from the LES closures, and using closure tuples instead to implement this behavior? Much is simplified this way I think, because we can now have `closure.νₑ` straightforwardly. I think scripts are also clearer because users would write:. ```julia; closure = (AnisotropicMinimumDissipation(), IsotropicDiffusivity(ν=1.05e-6)); ```. To implement an LES closure in addition to a constant background isotropic viscosity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-837110791
https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-837110791:505,Usability,clear,clearer,505,"I'm thinking about introducing a new container for ""auxiliary fields"" called `model.auxiliaries`, getting rid of `model.diffusivities`, and putting references to the ""eddy diffusivity"" in the LES closure parameter structs. Are we okay with removing the constant background viscosities and diffusivities from the LES closures, and using closure tuples instead to implement this behavior? Much is simplified this way I think, because we can now have `closure.νₑ` straightforwardly. I think scripts are also clearer because users would write:. ```julia; closure = (AnisotropicMinimumDissipation(), IsotropicDiffusivity(ν=1.05e-6)); ```. To implement an LES closure in addition to a constant background isotropic viscosity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-837110791
https://github.com/CliMA/Oceananigans.jl/issues/1278#issuecomment-747170506:1289,Testability,test,testing,1289,"I agree with your arguments. However, if I understood correctly, my only; concern (as a user) is that if you set them to zero by default,; setting `closure=IsotropicDiffusivity()` in a model will create a; simulation that will have no diffusivities and most likely will crash. From; a user perspective that's not the expected behavior I think, right?. On Wed, Dec 16, 2020, 18:17 Gregory L. Wagner <notifications@github.com>; wrote:. > IsotropicDiffusivity currently uses a viscosity and thermal diffusivity; > appropriate for water at 20 degrees Celsius and 35 psu:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L11-L28; >; > When I put this in I originally thought it was positive because it; > provided a reference. It's also cute because its ""oceanic"".; >; > But as time has gone on I now fear its actually surprising and also not; > very useful, since it's not actually a common to use Oceananigans for; > direct numerical simulations of miniscule boxes with molecular transport; > coefficients. Instead, IsotropicDiffusivity is useful for 1) idealized; > problems and education and 2) as a simple turbulence closure when setting; > up a simulation / testing ideas, possibly prior to implementing a more; > complicated closure. This ""ocean-realistic"" default is inconvenient for; > either case.; >; > So, I propose changing the default for both the viscosity and diffusivity; > to 0.; >; > cc @tomchor <https://github.com/tomchor> @xiaozhour; > <https://github.com/xiaozhour>; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1278>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KU2HG7BRG62RUDLKJTSVFS5JANCNFSM4U64DLDA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1278#issuecomment-747170506
https://github.com/CliMA/Oceananigans.jl/issues/1278#issuecomment-747170506:1229,Usability,simpl,simple,1229,"I agree with your arguments. However, if I understood correctly, my only; concern (as a user) is that if you set them to zero by default,; setting `closure=IsotropicDiffusivity()` in a model will create a; simulation that will have no diffusivities and most likely will crash. From; a user perspective that's not the expected behavior I think, right?. On Wed, Dec 16, 2020, 18:17 Gregory L. Wagner <notifications@github.com>; wrote:. > IsotropicDiffusivity currently uses a viscosity and thermal diffusivity; > appropriate for water at 20 degrees Celsius and 35 psu:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L11-L28; >; > When I put this in I originally thought it was positive because it; > provided a reference. It's also cute because its ""oceanic"".; >; > But as time has gone on I now fear its actually surprising and also not; > very useful, since it's not actually a common to use Oceananigans for; > direct numerical simulations of miniscule boxes with molecular transport; > coefficients. Instead, IsotropicDiffusivity is useful for 1) idealized; > problems and education and 2) as a simple turbulence closure when setting; > up a simulation / testing ideas, possibly prior to implementing a more; > complicated closure. This ""ocean-realistic"" default is inconvenient for; > either case.; >; > So, I propose changing the default for both the viscosity and diffusivity; > to 0.; >; > cc @tomchor <https://github.com/tomchor> @xiaozhour; > <https://github.com/xiaozhour>; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1278>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KU2HG7BRG62RUDLKJTSVFS5JANCNFSM4U64DLDA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1278#issuecomment-747170506
https://github.com/CliMA/Oceananigans.jl/issues/1278#issuecomment-747435585:932,Availability,error,error,932,"> my only; concern (as a user) is that if you set them to zero by default,; setting `closure=IsotropicDiffusivity()` in a model will create a; simulation that will have no diffusivities and most likely will crash. From; a user perspective that's not the expected behavior I think, right?. This is definitely the right way to think about it!. I guess with this default, `closure=IsotropicDiffusivity()` is equivalent to `closure = nothing`. Note we _can_ run ""inviscid"" simulations. They don't always blow up if the time-step is small enough (even when the advection scheme conserved variances...) For example some of the work over at https://github.com/CliMA/GeophysicalDissipation.jl. We could just use 0 default for kappa and require nu. This is convenient for simulations with no tracers that don't need kappa. Then the idea I guess is that if you're using `IsotropicDiffusivity`, you have to at least specify `nu` or you get an error (rather than being able to run a model in which you don't know what the explicit dissipation model is).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1278#issuecomment-747435585
https://github.com/CliMA/Oceananigans.jl/issues/1279#issuecomment-747484630:70,Usability,clear,clearer,70,"There are different thoughts as to what biharmonic means. Harmonic is clearer and we all agree that the harmonic operator is the Laplacian and looks like ; ```; \nabla^2 = \partial_xx + \partial_yy + \partial_zz. ; ```; Biharmonic is usually defined has the harmonic operator squared, which is ; ```; (\nabla^2)^2 = (\partial_xx + \partial_yy + \partial_zz)^2,; ```; which involves cross terms. What we mention in the docs is horizontal biharmonic plus vertical harmonic. Not something that rolls off the tongue. . The one that we currently used, is fourth-order hyperdiffusion, and makes a lot of sense in a lot of contexts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1279#issuecomment-747484630
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280:903,Availability,checkpoint,checkpoint,903,"A simple fix might write an `initialize_schedule!` method for `TimeInterval` that sets the `previous_actuation_time` to the current `model.clock.time`. The schedules are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Simulations/run.jl#L140. `initialize_schedule!` for `TimeInterval` goes to the fallback:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L10. I think you'll also want to change the syntax of `initialize_schedule` to take `model` as an input, so all the functions will look like `initialize_schedule!(schedule, model)`. This also affects the one non-trivial `initialize_schedule!` method here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L92. Ultimately I think @qwert2266 is right. We need to checkpoint both models and output writers, or, better yet, the entire `simulation`. This checkpointing issue also affects time-averages since they have to be checkpointed too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280:992,Availability,checkpoint,checkpointing,992,"A simple fix might write an `initialize_schedule!` method for `TimeInterval` that sets the `previous_actuation_time` to the current `model.clock.time`. The schedules are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Simulations/run.jl#L140. `initialize_schedule!` for `TimeInterval` goes to the fallback:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L10. I think you'll also want to change the syntax of `initialize_schedule` to take `model` as an input, so all the functions will look like `initialize_schedule!(schedule, model)`. This also affects the one non-trivial `initialize_schedule!` method here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L92. Ultimately I think @qwert2266 is right. We need to checkpoint both models and output writers, or, better yet, the entire `simulation`. This checkpointing issue also affects time-averages since they have to be checkpointed too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280:1061,Availability,checkpoint,checkpointed,1061,"A simple fix might write an `initialize_schedule!` method for `TimeInterval` that sets the `previous_actuation_time` to the current `model.clock.time`. The schedules are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Simulations/run.jl#L140. `initialize_schedule!` for `TimeInterval` goes to the fallback:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L10. I think you'll also want to change the syntax of `initialize_schedule` to take `model` as an input, so all the functions will look like `initialize_schedule!(schedule, model)`. This also affects the one non-trivial `initialize_schedule!` method here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L92. Ultimately I think @qwert2266 is right. We need to checkpoint both models and output writers, or, better yet, the entire `simulation`. This checkpointing issue also affects time-averages since they have to be checkpointed too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280:156,Energy Efficiency,schedul,schedules,156,"A simple fix might write an `initialize_schedule!` method for `TimeInterval` that sets the `previous_actuation_time` to the current `model.clock.time`. The schedules are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Simulations/run.jl#L140. `initialize_schedule!` for `TimeInterval` goes to the fallback:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L10. I think you'll also want to change the syntax of `initialize_schedule` to take `model` as an input, so all the functions will look like `initialize_schedule!(schedule, model)`. This also affects the one non-trivial `initialize_schedule!` method here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L92. Ultimately I think @qwert2266 is right. We need to checkpoint both models and output writers, or, better yet, the entire `simulation`. This checkpointing issue also affects time-averages since they have to be checkpointed too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280:467,Energy Efficiency,schedul,schedules,467,"A simple fix might write an `initialize_schedule!` method for `TimeInterval` that sets the `previous_actuation_time` to the current `model.clock.time`. The schedules are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Simulations/run.jl#L140. `initialize_schedule!` for `TimeInterval` goes to the fallback:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L10. I think you'll also want to change the syntax of `initialize_schedule` to take `model` as an input, so all the functions will look like `initialize_schedule!(schedule, model)`. This also affects the one non-trivial `initialize_schedule!` method here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L92. Ultimately I think @qwert2266 is right. We need to checkpoint both models and output writers, or, better yet, the entire `simulation`. This checkpointing issue also affects time-averages since they have to be checkpointed too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280:643,Energy Efficiency,schedul,schedule,643,"A simple fix might write an `initialize_schedule!` method for `TimeInterval` that sets the `previous_actuation_time` to the current `model.clock.time`. The schedules are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Simulations/run.jl#L140. `initialize_schedule!` for `TimeInterval` goes to the fallback:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L10. I think you'll also want to change the syntax of `initialize_schedule` to take `model` as an input, so all the functions will look like `initialize_schedule!(schedule, model)`. This also affects the one non-trivial `initialize_schedule!` method here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L92. Ultimately I think @qwert2266 is right. We need to checkpoint both models and output writers, or, better yet, the entire `simulation`. This checkpointing issue also affects time-averages since they have to be checkpointed too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280:834,Energy Efficiency,schedul,schedules,834,"A simple fix might write an `initialize_schedule!` method for `TimeInterval` that sets the `previous_actuation_time` to the current `model.clock.time`. The schedules are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Simulations/run.jl#L140. `initialize_schedule!` for `TimeInterval` goes to the fallback:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L10. I think you'll also want to change the syntax of `initialize_schedule` to take `model` as an input, so all the functions will look like `initialize_schedule!(schedule, model)`. This also affects the one non-trivial `initialize_schedule!` method here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L92. Ultimately I think @qwert2266 is right. We need to checkpoint both models and output writers, or, better yet, the entire `simulation`. This checkpointing issue also affects time-averages since they have to be checkpointed too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280:2,Usability,simpl,simple,2,"A simple fix might write an `initialize_schedule!` method for `TimeInterval` that sets the `previous_actuation_time` to the current `model.clock.time`. The schedules are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Simulations/run.jl#L140. `initialize_schedule!` for `TimeInterval` goes to the fallback:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L10. I think you'll also want to change the syntax of `initialize_schedule` to take `model` as an input, so all the functions will look like `initialize_schedule!(schedule, model)`. This also affects the one non-trivial `initialize_schedule!` method here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L92. Ultimately I think @qwert2266 is right. We need to checkpoint both models and output writers, or, better yet, the entire `simulation`. This checkpointing issue also affects time-averages since they have to be checkpointed too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749594498:75,Availability,checkpoint,checkpointing,75,"Yeah that would work but might be worth spending the extra work to support checkpointing and pickup for schedules (and time averages). I guess we will have to pass the `simulation` when constructing a `Checkpointer` but then we're stuck with the `write_output!(output_writer, model)` function signature. We could just fully switch to passing the simulation to output writers and diagnostics?. I think we also need to nuke `restore_from_checkpoint`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749594498
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749594498:202,Availability,Checkpoint,Checkpointer,202,"Yeah that would work but might be worth spending the extra work to support checkpointing and pickup for schedules (and time averages). I guess we will have to pass the `simulation` when constructing a `Checkpointer` but then we're stuck with the `write_output!(output_writer, model)` function signature. We could just fully switch to passing the simulation to output writers and diagnostics?. I think we also need to nuke `restore_from_checkpoint`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749594498
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749594498:104,Energy Efficiency,schedul,schedules,104,"Yeah that would work but might be worth spending the extra work to support checkpointing and pickup for schedules (and time averages). I guess we will have to pass the `simulation` when constructing a `Checkpointer` but then we're stuck with the `write_output!(output_writer, model)` function signature. We could just fully switch to passing the simulation to output writers and diagnostics?. I think we also need to nuke `restore_from_checkpoint`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749594498
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568:127,Availability,down,downside,127,"> We could just fully switch to passing the simulation to output writers and diagnostics?. Doesn't seem like there's much of a downside to that?. If `OutputWriters` are basically fancy functions of `model`, but checkpointing depends on the `Simulation`, then a `Checkpointer` might not be an output writer at all... We may want have a pow wow and rethink the whole concept of checkpointing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568:211,Availability,checkpoint,checkpointing,211,"> We could just fully switch to passing the simulation to output writers and diagnostics?. Doesn't seem like there's much of a downside to that?. If `OutputWriters` are basically fancy functions of `model`, but checkpointing depends on the `Simulation`, then a `Checkpointer` might not be an output writer at all... We may want have a pow wow and rethink the whole concept of checkpointing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568:262,Availability,Checkpoint,Checkpointer,262,"> We could just fully switch to passing the simulation to output writers and diagnostics?. Doesn't seem like there's much of a downside to that?. If `OutputWriters` are basically fancy functions of `model`, but checkpointing depends on the `Simulation`, then a `Checkpointer` might not be an output writer at all... We may want have a pow wow and rethink the whole concept of checkpointing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568:376,Availability,checkpoint,checkpointing,376,"> We could just fully switch to passing the simulation to output writers and diagnostics?. Doesn't seem like there's much of a downside to that?. If `OutputWriters` are basically fancy functions of `model`, but checkpointing depends on the `Simulation`, then a `Checkpointer` might not be an output writer at all... We may want have a pow wow and rethink the whole concept of checkpointing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568:225,Integrability,depend,depends,225,"> We could just fully switch to passing the simulation to output writers and diagnostics?. Doesn't seem like there's much of a downside to that?. If `OutputWriters` are basically fancy functions of `model`, but checkpointing depends on the `Simulation`, then a `Checkpointer` might not be an output writer at all... We may want have a pow wow and rethink the whole concept of checkpointing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568
https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-1480294818:140,Availability,checkpoint,checkpointing,140,I'm closing this because it's unclear if it's still a concern... please open if it is. There are likely quite a few outstanding issues with checkpointing...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-1480294818
https://github.com/CliMA/Oceananigans.jl/issues/1281#issuecomment-752068938:316,Availability,down,downloading,316,"As @navidcy hints I think the difficulties here are using `Plots.jl` on a headless system. To address this issue @navidcy is suggesting that you execute / write `ENV[""GKSwstype""] = ""100""` at the top of the tutorial. Alternatively, you can avoid remote plotting and attempt to run the `@animate` block locally, after downloading the data. I do think it is convenient to plot remotely however, so it'd be nice if you can make that work for you. Searching ""headless plotting julia Plots"" might turn up more information (I didn't find anything immediately, but I've seen useful threads before and it'd be nice to paste them here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281#issuecomment-752068938
https://github.com/CliMA/Oceananigans.jl/issues/1281#issuecomment-752068938:239,Safety,avoid,avoid,239,"As @navidcy hints I think the difficulties here are using `Plots.jl` on a headless system. To address this issue @navidcy is suggesting that you execute / write `ENV[""GKSwstype""] = ""100""` at the top of the tutorial. Alternatively, you can avoid remote plotting and attempt to run the `@animate` block locally, after downloading the data. I do think it is convenient to plot remotely however, so it'd be nice if you can make that work for you. Searching ""headless plotting julia Plots"" might turn up more information (I didn't find anything immediately, but I've seen useful threads before and it'd be nice to paste them here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281#issuecomment-752068938
https://github.com/CliMA/Oceananigans.jl/issues/1281#issuecomment-752285301:134,Availability,error,errors,134,"My bad, it was remote-ssh in vscode acting up. For some reason it just stopping plotting full-size graphs and started giving me these errors.; Doing things locally Oceananigans works perfectly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281#issuecomment-752285301
https://github.com/CliMA/Oceananigans.jl/issues/1285#issuecomment-755264366:195,Modifiability,extend,extending,195,"The Julia docs go into a lot of detail and have a useful summary (https://docs.julialang.org/en/v1.5/manual/modules/#Summary-of-module-usage-1) but I think `import` is used with the intention of extending a method via multiple dispatch. So you would `import Flux: σ` if you wanted to define a new method for `σ`, e.g. if you wanted to define a custom `σ(x::Complex)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1285#issuecomment-755264366
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:24,Deployability,update,updates,24,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:32,Energy Efficiency,Adapt,Adapt,32,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:227,Energy Efficiency,Adapt,Adapt,227,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:96,Integrability,depend,dependency,96,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:32,Modifiability,Adapt,Adapt,32,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:227,Modifiability,Adapt,Adapt,227,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:211,Testability,test,tests,211,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881:65,Deployability,update,updates,65,I think it must be blocked by some dependency since CompatHelper updates the Manifest. I guess merging #1295 caused some conflicts so I might try bumping to Adapt v3.0.0 in a different PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881:157,Energy Efficiency,Adapt,Adapt,157,I think it must be blocked by some dependency since CompatHelper updates the Manifest. I guess merging #1295 caused some conflicts so I might try bumping to Adapt v3.0.0 in a different PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881:35,Integrability,depend,dependency,35,I think it must be blocked by some dependency since CompatHelper updates the Manifest. I guess merging #1295 caused some conflicts so I might try bumping to Adapt v3.0.0 in a different PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881:157,Modifiability,Adapt,Adapt,157,I think it must be blocked by some dependency since CompatHelper updates the Manifest. I guess merging #1295 caused some conflicts so I might try bumping to Adapt v3.0.0 in a different PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971:146,Deployability,release,release,146,Yeah so Adapt v3.0.0 is blocked by CUDA.jl right now: https://github.com/JuliaGPU/CUDA.jl/pull/626. I think we just need to wait for a new tagged release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971:8,Energy Efficiency,Adapt,Adapt,8,Yeah so Adapt v3.0.0 is blocked by CUDA.jl right now: https://github.com/JuliaGPU/CUDA.jl/pull/626. I think we just need to wait for a new tagged release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971
https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971:8,Modifiability,Adapt,Adapt,8,Yeah so Adapt v3.0.0 is blocked by CUDA.jl right now: https://github.com/JuliaGPU/CUDA.jl/pull/626. I think we just need to wait for a new tagged release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971
https://github.com/CliMA/Oceananigans.jl/issues/1288#issuecomment-1479841532:52,Availability,ERROR,ERROR,52,"```julia; julia> AveragedTimeInterval(1, window=2); ERROR: ArgumentError: Averaging window 2 is greater than the output interval 1.; Stacktrace:; [1] #AveragedTimeInterval#19; @ ~/.julia/packages/Oceananigans/tqmFU/src/OutputWriters/windowed_time_average.jl:85 [inlined]; [2] top-level scope; @ REPL[6]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1288#issuecomment-1479841532
https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755274258:210,Availability,error,errors,210,"Hi @Sumanshekhar17, I couldn't immediately see the difference between your script and the ""ocean wind mixing and convection"" example but your script seems fine so I tried running it and it time-stepped with no errors with Julia 1.5 and Oceananigans v0.45.2. ![image](https://user-images.githubusercontent.com/20099589/103768518-a5f56400-4ff0-11eb-8cab-596d0b00e7a8.png). Can you post more details about your issue and the error you're encountering? Full stacktrace + error would be helpful. Would also be helpful to post the status of your Julia environment including your Julia version and the version of Julia you're using. You can do this with the `Pkg.status()` command: https://julialang.github.io/Pkg.jl/v1/repl/#repl-status. When posting code on GitHub it's always good to enclose the code in triple backticks (```) so it gets formatted as Julia code making it easier to read. I edited your post to do this. It would also be good to keep the title short and concise if you can. You can always include more details in the comment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755274258
https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755274258:422,Availability,error,error,422,"Hi @Sumanshekhar17, I couldn't immediately see the difference between your script and the ""ocean wind mixing and convection"" example but your script seems fine so I tried running it and it time-stepped with no errors with Julia 1.5 and Oceananigans v0.45.2. ![image](https://user-images.githubusercontent.com/20099589/103768518-a5f56400-4ff0-11eb-8cab-596d0b00e7a8.png). Can you post more details about your issue and the error you're encountering? Full stacktrace + error would be helpful. Would also be helpful to post the status of your Julia environment including your Julia version and the version of Julia you're using. You can do this with the `Pkg.status()` command: https://julialang.github.io/Pkg.jl/v1/repl/#repl-status. When posting code on GitHub it's always good to enclose the code in triple backticks (```) so it gets formatted as Julia code making it easier to read. I edited your post to do this. It would also be good to keep the title short and concise if you can. You can always include more details in the comment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755274258
https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755274258:467,Availability,error,error,467,"Hi @Sumanshekhar17, I couldn't immediately see the difference between your script and the ""ocean wind mixing and convection"" example but your script seems fine so I tried running it and it time-stepped with no errors with Julia 1.5 and Oceananigans v0.45.2. ![image](https://user-images.githubusercontent.com/20099589/103768518-a5f56400-4ff0-11eb-8cab-596d0b00e7a8.png). Can you post more details about your issue and the error you're encountering? Full stacktrace + error would be helpful. Would also be helpful to post the status of your Julia environment including your Julia version and the version of Julia you're using. You can do this with the `Pkg.status()` command: https://julialang.github.io/Pkg.jl/v1/repl/#repl-status. When posting code on GitHub it's always good to enclose the code in triple backticks (```) so it gets formatted as Julia code making it easier to read. I edited your post to do this. It would also be good to keep the title short and concise if you can. You can always include more details in the comment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755274258
https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755287455:523,Availability,error,error,523,"Thank you very much for your reply sir, I am new to this community pardon me, I will take care from next time. Sir this the status of Julia package-; ![julia package](https://user-images.githubusercontent.com/67187927/103770697-71af9100-504c-11eb-991e-f22d2239efeb.PNG). Sir I have Gaussian surface cooling function at the top of the surface and Beta plane approximation in my code with different grid size and spacing and rest initial and boundary conditions are same as ""ocean wind mixing and convection"" . The following error come after 720 iteration-. ![error1](https://user-images.githubusercontent.com/67187927/103771251-5ee98c00-504d-11eb-8a07-5395c6d1d74a.PNG); ; I have also checked my CFL number by changing but this error remains and appear after some iteration. . Thank you in advance!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755287455
https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755287455:727,Availability,error,error,727,"Thank you very much for your reply sir, I am new to this community pardon me, I will take care from next time. Sir this the status of Julia package-; ![julia package](https://user-images.githubusercontent.com/67187927/103770697-71af9100-504c-11eb-991e-f22d2239efeb.PNG). Sir I have Gaussian surface cooling function at the top of the surface and Beta plane approximation in my code with different grid size and spacing and rest initial and boundary conditions are same as ""ocean wind mixing and convection"" . The following error come after 720 iteration-. ![error1](https://user-images.githubusercontent.com/67187927/103771251-5ee98c00-504d-11eb-8a07-5395c6d1d74a.PNG); ; I have also checked my CFL number by changing but this error remains and appear after some iteration. . Thank you in advance!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755287455
https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755309800:274,Energy Efficiency,meter,meters,274,What are you trying to simulate?. It looks like you're trying to simulate a Gaussian surface cooling in a tiny 4 x 4 x 0.1 m box with a Coriolis parameter of f = 0.5 and beta = 3.75e-3?. Not sure if it makes sense to use a beta plane approximation on a domain that's only 4 meters long...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755309800
https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003:73,Performance,perform,performed,73,"I don't follow everything here but it looks like the simulation is being performed on a login node in the above screenshot. @Sumanshekhar17, your cluster may have a policy in place to stop (""kill"") jobs that run on a login node. To sort out script vs cluster issues I suggest running the script on a local machine (for example, your laptop) first. If it runs to completion, and also starts and runs on the cluster with `architecture=GPU()`, then we know the problem is due to cluster policy or some other cluster-specific setting, rather than a problem with your script or Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003
https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003:88,Testability,log,login,88,"I don't follow everything here but it looks like the simulation is being performed on a login node in the above screenshot. @Sumanshekhar17, your cluster may have a policy in place to stop (""kill"") jobs that run on a login node. To sort out script vs cluster issues I suggest running the script on a local machine (for example, your laptop) first. If it runs to completion, and also starts and runs on the cluster with `architecture=GPU()`, then we know the problem is due to cluster policy or some other cluster-specific setting, rather than a problem with your script or Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003
https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003:217,Testability,log,login,217,"I don't follow everything here but it looks like the simulation is being performed on a login node in the above screenshot. @Sumanshekhar17, your cluster may have a policy in place to stop (""kill"") jobs that run on a login node. To sort out script vs cluster issues I suggest running the script on a local machine (for example, your laptop) first. If it runs to completion, and also starts and runs on the cluster with `architecture=GPU()`, then we know the problem is due to cluster policy or some other cluster-specific setting, rather than a problem with your script or Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003
https://github.com/CliMA/Oceananigans.jl/issues/1290#issuecomment-756170764:105,Modifiability,extend,extends,105,"It's needed when your computation is located on `Face`s. By default, `work_layout` returns a layout that extends from ""1 to `N`"". This default is used for time-stepping kernels. But for diagnostics you usually want that last grid point at `N+1`. It might make sense to change the default value, since users / people writing new kernels probably want `include_right_boundaries=true`, and its only a minority of rarely-changed kernels (for time-stepping) that want `include_right_boundaries=false`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1290#issuecomment-756170764
https://github.com/CliMA/Oceananigans.jl/issues/1290#issuecomment-758701367:339,Energy Efficiency,reduce,reduced,339,"> Not within scope for this issue of course but as part of supporting Flat topologies/dimensions, would it make sense to add a Flat or Nothing location for locations along Flat dimensions?. If I understand the suggestion correctly, we currently do this, as `Nothing` is borrowed as a third location ""type"" along with `Face` and `Cell` for reduced fields. See, for example, the implementation of `getindex` for `AbstractReducedField`:. https://github.com/CliMA/Oceananigans.jl/blob/ab20c9cc97589842f71659dab18128491e6aa357/src/Fields/reduced_field.jl#L9-L28",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1290#issuecomment-758701367
https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756152081:45,Testability,test,tests,45,"Thanks @glwagner for the feedback. There are tests that were added for both the time-stepping and introducing tracers. https://github.com/CliMA/Oceananigans.jl/blob/swm-shenanigans/test/test_shallow_water_models.jl. I agree that testing shallow_water_model_forcing on the other code, is a good idea. @ali-ramadhan , did you want to try that in this PR or in a subsequent one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756152081
https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756152081:181,Testability,test,test,181,"Thanks @glwagner for the feedback. There are tests that were added for both the time-stepping and introducing tracers. https://github.com/CliMA/Oceananigans.jl/blob/swm-shenanigans/test/test_shallow_water_models.jl. I agree that testing shallow_water_model_forcing on the other code, is a good idea. @ali-ramadhan , did you want to try that in this PR or in a subsequent one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756152081
https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756152081:229,Testability,test,testing,229,"Thanks @glwagner for the feedback. There are tests that were added for both the time-stepping and introducing tracers. https://github.com/CliMA/Oceananigans.jl/blob/swm-shenanigans/test/test_shallow_water_models.jl. I agree that testing shallow_water_model_forcing on the other code, is a good idea. @ali-ramadhan , did you want to try that in this PR or in a subsequent one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756152081
https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756152081:25,Usability,feedback,feedback,25,"Thanks @glwagner for the feedback. There are tests that were added for both the time-stepping and introducing tracers. https://github.com/CliMA/Oceananigans.jl/blob/swm-shenanigans/test/test_shallow_water_models.jl. I agree that testing shallow_water_model_forcing on the other code, is a good idea. @ali-ramadhan , did you want to try that in this PR or in a subsequent one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756152081
https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133:223,Deployability,Continuous,ContinuousForcing,223,"Both `IncompressibleModel` and `ShallowWaterModel` use the more general `model_forcing` now, but I had to refactor `regularize_forcing` a bit as it needs the `model_field_names` when constructing `Relaxation` forcings and `ContinuousForcing`s with field dependencies. Tests passed on Tartarus but might be good if @glwagner had a quick look to make sure it's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133
https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133:254,Integrability,depend,dependencies,254,"Both `IncompressibleModel` and `ShallowWaterModel` use the more general `model_forcing` now, but I had to refactor `regularize_forcing` a bit as it needs the `model_field_names` when constructing `Relaxation` forcings and `ContinuousForcing`s with field dependencies. Tests passed on Tartarus but might be good if @glwagner had a quick look to make sure it's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133
https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133:106,Modifiability,refactor,refactor,106,"Both `IncompressibleModel` and `ShallowWaterModel` use the more general `model_forcing` now, but I had to refactor `regularize_forcing` a bit as it needs the `model_field_names` when constructing `Relaxation` forcings and `ContinuousForcing`s with field dependencies. Tests passed on Tartarus but might be good if @glwagner had a quick look to make sure it's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133
https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133:268,Testability,Test,Tests,268,"Both `IncompressibleModel` and `ShallowWaterModel` use the more general `model_forcing` now, but I had to refactor `regularize_forcing` a bit as it needs the `model_field_names` when constructing `Relaxation` forcings and `ContinuousForcing`s with field dependencies. Tests passed on Tartarus but might be good if @glwagner had a quick look to make sure it's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133
https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700:64,Integrability,message,message,64,"@glwagner Sorry for posting in the wrong place. Here's the same message again:. @glwagner I modified the docstring with a small example that I think illustrates the patterns relatively in this commit. I'm assuming that's what you meant by ""example"", right?. I've tested it already in some simple examples and it produces correct results. Is there anything else left besides testing this with an actual complex calculation that can only be done via KernelComputedField on a GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700
https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700:263,Testability,test,tested,263,"@glwagner Sorry for posting in the wrong place. Here's the same message again:. @glwagner I modified the docstring with a small example that I think illustrates the patterns relatively in this commit. I'm assuming that's what you meant by ""example"", right?. I've tested it already in some simple examples and it produces correct results. Is there anything else left besides testing this with an actual complex calculation that can only be done via KernelComputedField on a GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700
https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700:374,Testability,test,testing,374,"@glwagner Sorry for posting in the wrong place. Here's the same message again:. @glwagner I modified the docstring with a small example that I think illustrates the patterns relatively in this commit. I'm assuming that's what you meant by ""example"", right?. I've tested it already in some simple examples and it produces correct results. Is there anything else left besides testing this with an actual complex calculation that can only be done via KernelComputedField on a GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700
https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700:289,Usability,simpl,simple,289,"@glwagner Sorry for posting in the wrong place. Here's the same message again:. @glwagner I modified the docstring with a small example that I think illustrates the patterns relatively in this commit. I'm assuming that's what you meant by ""example"", right?. I've tested it already in some simple examples and it produces correct results. Is there anything else left besides testing this with an actual complex calculation that can only be done via KernelComputedField on a GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700
https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759837562:10,Testability,test,tested,10,"I already tested it for some complex calculations (TKE, Ri, Ro and Ertel PV) and the results are correct!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759837562
https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756967857:664,Availability,error,error,664,"Hi @qiangdeng!. I think the v boundary conditions weren't being applied due to an unfortunate typo: I think you need to pass `boundary_conditions = (v=v_bc,)` (a named tuple):. ```julia; julia> model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs); ). julia> model.velocities.v.boundary_conditions.north; BoundaryCondition: type=NormalFlow, condition=nothing; ```. ```julia; julia> model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs,); ). julia> model.velocities.v.boundary_conditions.north; BoundaryCondition: type=NormalFlow, condition=-0.5; ```. Oceananigans should have produced an error asking for a `NamedTuple`: https://github.com/CliMA/Oceananigans.jl/blob/f16989d69030b61ea1b1fdf7fe5659b5fa25aadd/src/Models/IncompressibleModels/incompressible_model.jl#L91. This might be a bug... PS: When posting code on GitHub it's nice to enclose the code in triple backticks (```) so it gets formatted as code making it easier to read. I edited your post to do this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756967857
https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930:909,Deployability,update,updates,909,"Ah ok I see why your original script didn't work now. When executing. ```julia; model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs); ); ```. this assigned `v_bcs` to the new variable `v` and passes it to the `IncompressibleModel` function. `v_bc` itself is a `NamedTuple` containing `x, y, z` properties so the `IncompressibleModel` constructor does not complain. Since the named tuple that is passed does not not have a `v` property, the velocities get the default boundary conditions (free slip and no normal flow). Then when you call `set!(model, v=-0.5)` it fills v to be -0.5 everywhere but then `update_state!(model)` is called to ensure that the velocity field is incompressible (divergence-free) by performing a pressure projection step. Since the default boundary condition enforces no-normal flow, the velocity cannot be -0.5 everywhere so the pressure field updates it to be zero to enforce incompressibility. This is a pretty subtle bug (related to #1204)... Since the proper named tuple can't be checked for in the constructor function signature, I wonder if it's worth adding a manual check to make sure a `NamedTuple{(:x,:y,:z)}` was not passed to the model constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930
https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930:214,Modifiability,variab,variable,214,"Ah ok I see why your original script didn't work now. When executing. ```julia; model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs); ); ```. this assigned `v_bcs` to the new variable `v` and passes it to the `IncompressibleModel` function. `v_bc` itself is a `NamedTuple` containing `x, y, z` properties so the `IncompressibleModel` constructor does not complain. Since the named tuple that is passed does not not have a `v` property, the velocities get the default boundary conditions (free slip and no normal flow). Then when you call `set!(model, v=-0.5)` it fills v to be -0.5 everywhere but then `update_state!(model)` is called to ensure that the velocity field is incompressible (divergence-free) by performing a pressure projection step. Since the default boundary condition enforces no-normal flow, the velocity cannot be -0.5 everywhere so the pressure field updates it to be zero to enforce incompressibility. This is a pretty subtle bug (related to #1204)... Since the proper named tuple can't be checked for in the constructor function signature, I wonder if it's worth adding a manual check to make sure a `NamedTuple{(:x,:y,:z)}` was not passed to the model constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930
https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930:747,Performance,perform,performing,747,"Ah ok I see why your original script didn't work now. When executing. ```julia; model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs); ); ```. this assigned `v_bcs` to the new variable `v` and passes it to the `IncompressibleModel` function. `v_bc` itself is a `NamedTuple` containing `x, y, z` properties so the `IncompressibleModel` constructor does not complain. Since the named tuple that is passed does not not have a `v` property, the velocities get the default boundary conditions (free slip and no normal flow). Then when you call `set!(model, v=-0.5)` it fills v to be -0.5 everywhere but then `update_state!(model)` is called to ensure that the velocity field is incompressible (divergence-free) by performing a pressure projection step. Since the default boundary condition enforces no-normal flow, the velocity cannot be -0.5 everywhere so the pressure field updates it to be zero to enforce incompressibility. This is a pretty subtle bug (related to #1204)... Since the proper named tuple can't be checked for in the constructor function signature, I wonder if it's worth adding a manual check to make sure a `NamedTuple{(:x,:y,:z)}` was not passed to the model constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930
https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:84,Energy Efficiency,Adapt,Adapt,84,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372
https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:226,Energy Efficiency,Adapt,Adapt,226,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372
https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:93,Integrability,depend,dependency,93,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372
https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:202,Integrability,depend,dependencies,202,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372
https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:84,Modifiability,Adapt,Adapt,84,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372
https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:226,Modifiability,Adapt,Adapt,226,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372
https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:243,Testability,test,tests,243,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-756955938:325,Availability,avail,available,325,Just pasting this definition (approximation?) of APE from Vallis' textbook (2nd edition):. ![image](https://user-images.githubusercontent.com/20099589/104056542-aa6f7780-51be-11eb-8924-22de37acfdbd.png). Should be possible to compute/diagnose with a `KernelComputedField` (#1293). Also found this paper on oceanic convective available potential energy (CAPE) but it looks pretty complicated and not sure if it's immediately useful: https://doi.org/10.1175/JPO-D-14-0155.1. cc @sandreza since APE might be a useful diagnostic for your mesoscale simulations?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-756955938
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-756955938:345,Energy Efficiency,energy,energy,345,Just pasting this definition (approximation?) of APE from Vallis' textbook (2nd edition):. ![image](https://user-images.githubusercontent.com/20099589/104056542-aa6f7780-51be-11eb-8924-22de37acfdbd.png). Should be possible to compute/diagnose with a `KernelComputedField` (#1293). Also found this paper on oceanic convective available potential energy (CAPE) but it looks pretty complicated and not sure if it's immediately useful: https://doi.org/10.1175/JPO-D-14-0155.1. cc @sandreza since APE might be a useful diagnostic for your mesoscale simulations?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-756955938
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758708719:853,Usability,simpl,simplest,853,"Thanks @jklymak . . I looked at this paper and the APE for the incompressible Boussinesq model is defined explicitly in section 2.4. The APE is defined in equation 3.6 as . APE = \int_V E_a dV ; = \int_V \rho g (z - z_R) dV, (1). where `E_a` is the APE density. This is exact and to compute this one needs to find the reference depth, `z_R`, which is I presume where the sorting comes in. . Then, it says that one can show that the APE density can be written as. E_a = - \int_0^\zeta g \tilde \zeta \rho_R' (z - \tilde \zeta) d \tilde \zeta (2); ; E_a \approx \rho_0 N_r^2 \zeta^2/2 (3). where `N_R^2 = - g/\rho_0 \rho_R'` is the Brunt-Vaisala frequency based on the reference density. Equations (1) and (2) are exact and (3) is approximate, but I believe (3) is exact in the case of constant stratifiation. . I wonder whether using equation (1) is the simplest? . (If anyone can tell me how to make equations in markdown I am happy to change this to make it prettier.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758708719
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758710250:460,Availability,mainten,maintenance,460,"I think it's probably a good idea to (cautiously) add diagnostics that are important yet difficult to write, such as this one. Note that this would be the first!. As a historical note, we have resisted adding diagnostics to the code base so far because we believed that a more generic solution would make it ""easy"" for users to define their own diagnostics (eg, as simple as writing the mathematical expression), and because long lists of diagnostics impose a maintenance burden. But I think there are some examples (such as APE) for which we probably can't define simply via abstractions like those provided by AbstractOperations. And as the code becomes more stable (and we have more contributors), maintaining a list of difficult-to-code but commonly-used diagnostics is more feasible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758710250
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758710250:365,Usability,simpl,simple,365,"I think it's probably a good idea to (cautiously) add diagnostics that are important yet difficult to write, such as this one. Note that this would be the first!. As a historical note, we have resisted adding diagnostics to the code base so far because we believed that a more generic solution would make it ""easy"" for users to define their own diagnostics (eg, as simple as writing the mathematical expression), and because long lists of diagnostics impose a maintenance burden. But I think there are some examples (such as APE) for which we probably can't define simply via abstractions like those provided by AbstractOperations. And as the code becomes more stable (and we have more contributors), maintaining a list of difficult-to-code but commonly-used diagnostics is more feasible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758710250
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758710250:565,Usability,simpl,simply,565,"I think it's probably a good idea to (cautiously) add diagnostics that are important yet difficult to write, such as this one. Note that this would be the first!. As a historical note, we have resisted adding diagnostics to the code base so far because we believed that a more generic solution would make it ""easy"" for users to define their own diagnostics (eg, as simple as writing the mathematical expression), and because long lists of diagnostics impose a maintenance burden. But I think there are some examples (such as APE) for which we probably can't define simply via abstractions like those provided by AbstractOperations. And as the code becomes more stable (and we have more contributors), maintaining a list of difficult-to-code but commonly-used diagnostics is more feasible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758710250
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758716153:66,Energy Efficiency,energy,energy,66,"I agree that most diagnostics like total tracer and total kinetic energy are pretty easy to compute and if it is a one liner, then we probably don't need to do anything special. . Computing the APE could be a oneliner as well, after we compute the reference depth and density. So maybe that's something we could add somewhere? . I have not done this before but I know it's pretty standard. I presume the MITgcm does and we could maybe borrow from their weather of knowledge?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758716153
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758899177:299,Availability,mainten,maintenance,299,"> As a historical note, we have resisted adding diagnostics to the code base so far because we believed that a more generic solution would make it ""easy"" for users to define their own diagnostics (eg, as simple as writing the mathematical expression), and because long lists of diagnostics impose a maintenance burden. I agree that some diagnostics would be important, but I also agree with the above philosophy of Oceananigans. In cases like this wouldn't it be good to consider adding a companion repo to oceananigas that has all these diagnostics rather than putting them in Oceananigans by default? Much like LESbrary.jl does, it would be someting that (hopefully) can use `KernelComputedFields`, but it wouldn't be dedicated only to LES (so I guess it can't be LESbrary.jl).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758899177
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758899177:204,Usability,simpl,simple,204,"> As a historical note, we have resisted adding diagnostics to the code base so far because we believed that a more generic solution would make it ""easy"" for users to define their own diagnostics (eg, as simple as writing the mathematical expression), and because long lists of diagnostics impose a maintenance burden. I agree that some diagnostics would be important, but I also agree with the above philosophy of Oceananigans. In cases like this wouldn't it be good to consider adding a companion repo to oceananigas that has all these diagnostics rather than putting them in Oceananigans by default? Much like LESbrary.jl does, it would be someting that (hopefully) can use `KernelComputedFields`, but it wouldn't be dedicated only to LES (so I guess it can't be LESbrary.jl).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758899177
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759473177:631,Availability,down,down,631,"From what I understand, we need to go through the entire domain and find out how much volume (or area in 2D) of each density we have. Then find the basic state where we have the different densities layed out flat, with the heaviest on the bottom. It sounds like the hard part is looking through the density profile to see how much of each density we have. . I have read, and believe, that it gets more complicated if you have geostrophic balance, which we typically would, but starting off with a 2D non-rotating example would be a reasonable first step. Is this what other people understand?. During non-covid times, I could walk down two doors and ask Kevin Lamb for help on how to do this. Even though I can't ask him in person I can email him questions, when they arise.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759473177
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759593794:393,Energy Efficiency,energy,energy,393,"> I have read, and believe, that it gets more complicated if you have geostrophic balance, which we typically would, but starting off with a 2D non-rotating example would be a reasonable first step. Is this what other people understand?. I think APE can still be unambiguously defined, even in the case of a geostrophic balance. If you want to decompose your flows in various ways to identify energy reservoirs associated with different classes of motion, that is even more specialized. I'm sure you can do it, but I expect the global sort is still necessary. . This all said, I think a reasonable approximation could be made to calculate the APE on a much coarser timestep to the full physics of the model. If you put such an expensive piece of code in, you would probably want a knob to twiddle to allow it to be coarsened, and then some tuning would be necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759593794
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759708449:211,Energy Efficiency,energy,energy,211,"I agree with you @jklymak , you can certainly compute APE in a rotating fluid, which will require a global sort. I wonder if the issue is how to pick the angle of the pycnoclines in the state of least potential energy? I am sure there are ways of doing these, and we can learn how when needed. It would be good to give the user an option as to whether they want to compute it and how often. Given what is set up in the time stepping wizard, I don't imagine this will be a concern, and would be nice to give the user the power to control this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759708449
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759708449:520,Energy Efficiency,power,power,520,"I agree with you @jklymak , you can certainly compute APE in a rotating fluid, which will require a global sort. I wonder if the issue is how to pick the angle of the pycnoclines in the state of least potential energy? I am sure there are ways of doing these, and we can learn how when needed. It would be good to give the user an option as to whether they want to compute it and how often. Given what is set up in the time stepping wizard, I don't imagine this will be a concern, and would be nice to give the user the power to control this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759708449
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759708449:271,Usability,learn,learn,271,"I agree with you @jklymak , you can certainly compute APE in a rotating fluid, which will require a global sort. I wonder if the issue is how to pick the angle of the pycnoclines in the state of least potential energy? I am sure there are ways of doing these, and we can learn how when needed. It would be good to give the user an option as to whether they want to compute it and how often. Given what is set up in the time stepping wizard, I don't imagine this will be a concern, and would be nice to give the user the power to control this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759708449
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759803618:451,Energy Efficiency,schedul,scheduled,451,"> This all said, I think a reasonable approximation could be made to calculate the APE on a much coarser timestep to the full physics of the model. If you put such an expensive piece of code in, you would probably want a knob to twiddle to allow it to be coarsened, and then some tuning would be necessary. Not sure I understand the comment but I believe what's being recommended is currently a feature of `Oceananigans`. Output / diagnostics can be ""scheduled"" in various ways, either on time intervals, iteration intervals, wall time intervals, or custom criteria designed by the user.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759803618
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-768786372:286,Energy Efficiency,energy,energy,286,"> I'm sure you can do it, but I expect the global sort is still necessary. Every source that I've read so far that mentions how to compute it says sorting needs to be done. Everything else seems to be an approximation. The hard part is, of course, to compute the ""unavailable potential energy"", which is the minimum PE of the system. The canonical way to do it apparently is to flatten the array, sort it, and then put it back into the original shape. In Python this can be easily done with (using `b` instead of `ρ`). ```; PE_min = np.sort(b.data.flatten()).reshape(*b.shape); ```. (disclaimer: I haven't tested if the result is exactly correct, but it should be along those lines.). I will have to program this diagnostic very soon and I'm thinking of doing it using `KernelComputedFields` (and then putting it up on a repo). My question is: what's the sorting/reshaping method that works for GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-768786372
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-768786372:606,Testability,test,tested,606,"> I'm sure you can do it, but I expect the global sort is still necessary. Every source that I've read so far that mentions how to compute it says sorting needs to be done. Everything else seems to be an approximation. The hard part is, of course, to compute the ""unavailable potential energy"", which is the minimum PE of the system. The canonical way to do it apparently is to flatten the array, sort it, and then put it back into the original shape. In Python this can be easily done with (using `b` instead of `ρ`). ```; PE_min = np.sort(b.data.flatten()).reshape(*b.shape); ```. (disclaimer: I haven't tested if the result is exactly correct, but it should be along those lines.). I will have to program this diagnostic very soon and I'm thinking of doing it using `KernelComputedFields` (and then putting it up on a repo). My question is: what's the sorting/reshaping method that works for GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-768786372
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-769013373:83,Usability,simpl,simple,83,Great to know that python can do this in one line! Maybe it will turn out to be as simple in Julia for both CPUs and GPUs.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-769013373
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839055923:85,Usability,simpl,simple,85,"> Great to know that python can do this in one line! Maybe it will turn out to be as simple in Julia for both CPUs and GPUs. Just wanted to point out that APE calculations are only this simple with simple for Cartesian grids with a flat bottom and a linear equation of state. Otherwise, the hard part is actually finding the depths/pressure associated with the sorted profile density profile (see [Huang 2005](https://www.ingentaconnect.com/content/jmr/jmr/2005/00000063/00000001/art00008?token=00611657770a742f3f3b3b6a332b257d7241255e4e7d63433b393f6a573d257025447023766c7a7338422c6b6337ede82)). I've been working on implementing this in an MITgcm simulation with a linear equation of state but complicated topography, and it has been a mess (and very slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839055923
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839055923:186,Usability,simpl,simple,186,"> Great to know that python can do this in one line! Maybe it will turn out to be as simple in Julia for both CPUs and GPUs. Just wanted to point out that APE calculations are only this simple with simple for Cartesian grids with a flat bottom and a linear equation of state. Otherwise, the hard part is actually finding the depths/pressure associated with the sorted profile density profile (see [Huang 2005](https://www.ingentaconnect.com/content/jmr/jmr/2005/00000063/00000001/art00008?token=00611657770a742f3f3b3b6a332b257d7241255e4e7d63433b393f6a573d257025447023766c7a7338422c6b6337ede82)). I've been working on implementing this in an MITgcm simulation with a linear equation of state but complicated topography, and it has been a mess (and very slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839055923
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839055923:198,Usability,simpl,simple,198,"> Great to know that python can do this in one line! Maybe it will turn out to be as simple in Julia for both CPUs and GPUs. Just wanted to point out that APE calculations are only this simple with simple for Cartesian grids with a flat bottom and a linear equation of state. Otherwise, the hard part is actually finding the depths/pressure associated with the sorted profile density profile (see [Huang 2005](https://www.ingentaconnect.com/content/jmr/jmr/2005/00000063/00000001/art00008?token=00611657770a742f3f3b3b6a332b257d7241255e4e7d63433b393f6a573d257025447023766c7a7338422c6b6337ede82)). I've been working on implementing this in an MITgcm simulation with a linear equation of state but complicated topography, and it has been a mess (and very slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839055923
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839078260:414,Integrability,interface,interface,414,"@hdrake can you clarify specifically what is difficult about the calculation? If we know the specific calculations we need to make we might be able to support / facilitate them with abstractions. For example, it may be possible to sort abstract operations --- like the product of a field and a grid metric like cell area or volume, or another multiplicative factor that represents the effect of bathymetry on cell interface area / volume.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839078260
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839372174:610,Availability,avail,available-potential-energy-and-mixing-in-densitystratified-fluids,610,"Thanks, @hdrake, for bringing up this important point. I guess we should also remember that the sorting procedure is only an approximation to the actual calculation of background potential energy. It's super useful and easy in most cases, so most people jump straight to that, but the more ""proper"" calculation of BPE involves calculating the quantity `z_*`:. ![Screenshot from 2021-05-11 18-44-11](https://user-images.githubusercontent.com/13205162/117906167-3edf0900-b289-11eb-9f0e-a4b7accab2a0.png). from [Winters et alia, (1995).](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/available-potential-energy-and-mixing-in-densitystratified-fluids/A45F1A40521FF0A0DC82BC705AD398DA). I think calculating BPE this way still has some complications, but at least I believe the calculation is unique. It might be the preferred for cases with topography, stretched grids, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839372174
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839372174:189,Energy Efficiency,energy,energy,189,"Thanks, @hdrake, for bringing up this important point. I guess we should also remember that the sorting procedure is only an approximation to the actual calculation of background potential energy. It's super useful and easy in most cases, so most people jump straight to that, but the more ""proper"" calculation of BPE involves calculating the quantity `z_*`:. ![Screenshot from 2021-05-11 18-44-11](https://user-images.githubusercontent.com/13205162/117906167-3edf0900-b289-11eb-9f0e-a4b7accab2a0.png). from [Winters et alia, (1995).](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/available-potential-energy-and-mixing-in-densitystratified-fluids/A45F1A40521FF0A0DC82BC705AD398DA). I think calculating BPE this way still has some complications, but at least I believe the calculation is unique. It might be the preferred for cases with topography, stretched grids, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839372174
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839372174:630,Energy Efficiency,energy,energy-and-mixing-in-densitystratified-fluids,630,"Thanks, @hdrake, for bringing up this important point. I guess we should also remember that the sorting procedure is only an approximation to the actual calculation of background potential energy. It's super useful and easy in most cases, so most people jump straight to that, but the more ""proper"" calculation of BPE involves calculating the quantity `z_*`:. ![Screenshot from 2021-05-11 18-44-11](https://user-images.githubusercontent.com/13205162/117906167-3edf0900-b289-11eb-9f0e-a4b7accab2a0.png). from [Winters et alia, (1995).](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/available-potential-energy-and-mixing-in-densitystratified-fluids/A45F1A40521FF0A0DC82BC705AD398DA). I think calculating BPE this way still has some complications, but at least I believe the calculation is unique. It might be the preferred for cases with topography, stretched grids, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839372174
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839373431:840,Deployability,upgrade,upgrade,840,"Also I'll post here my implementation of the sorting just in case it's useful for some people. . ```julia; function flattenedsort(A, dim_order::Union{Tuple, AbstractVector}); return reshape(sort(Array(permutedims(A, dim_order)[:])), (grid.Nx, grid.Ny, grid.Nz)); end. function sort_b(model; average=false); b = model.tracers.b; sorted_B = flattenedsort(interior(b), [3,2,1]); if !average; return sorted_B; else; return dropdims(mean(sorted_B, dims=(1,2)), dims=(1,2)); end; end; mean_sort_b = (mod)->sort_b(mod; average=true); ```. I bet this can be done more elegantly but here it is. Thanks to @glwagner for pointing me in the right direction for this. Note: Right now I have to explicitly transform `b` into an `Array` before sorting because the version of CUDA that Oceananigans currently uses doesn't have `sort` implemented. After we upgrade to Julia 1.6 we'll be able to use the most recent CUDA version and that transformation won't be necessary anymore (I think).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839373431
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661:214,Integrability,depend,depends,214,"@hdrake's point references Huang (2005), who point out that a reference state (associated with z* in Winters et al 1995) may not be easily or uniquely definable for seawater with a nonlinear equation of state that depends on salinity, temperature, and pressure:. ![image](https://user-images.githubusercontent.com/15271942/117912548-2d4b3080-b28c-11eb-8693-3805190dd52b.png). In practical terms I think the issue here is determine the ""adiabatic rearrangement"" mentioned by Winters et al. 2005. For a nonlinear equation of state like TEOS-10 where the buoyancy field `b` in the code _depends on depth / hydrostatic pressure_, the adiabatic rearrangement of the water column may not be obtained simply by sorting. However, @hdrake points out that an iterative procedure in which parcels are sorted, their buoyancy recalculated at the new depth, and then sorted again, may eventually converge to an adiabatic reference state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661:694,Usability,simpl,simply,694,"@hdrake's point references Huang (2005), who point out that a reference state (associated with z* in Winters et al 1995) may not be easily or uniquely definable for seawater with a nonlinear equation of state that depends on salinity, temperature, and pressure:. ![image](https://user-images.githubusercontent.com/15271942/117912548-2d4b3080-b28c-11eb-8693-3805190dd52b.png). In practical terms I think the issue here is determine the ""adiabatic rearrangement"" mentioned by Winters et al. 2005. For a nonlinear equation of state like TEOS-10 where the buoyancy field `b` in the code _depends on depth / hydrostatic pressure_, the adiabatic rearrangement of the water column may not be obtained simply by sorting. However, @hdrake points out that an iterative procedure in which parcels are sorted, their buoyancy recalculated at the new depth, and then sorted again, may eventually converge to an adiabatic reference state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841580109:238,Integrability,depend,depends,238,"@glwagner thanks for clarifying. Coming from an atmospheric sciences background, I'm a bit unclear on the details of TEOS-10 and the nuances associated with it. In particular it seems counter-intuitive to me how an equation of state that depends on depth fits in a Boussinesq fluid (where adiabatic rearrangement of parcels shouldn't change their buoyancy). But this probably isn't the best place to have a long discussion about it. Using the more fundamental definition of `z_*` does circumvent some of the issues mentioned by @hdrake, no? (Like topography.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841580109
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841580109:192,Usability,intuit,intuitive,192,"@glwagner thanks for clarifying. Coming from an atmospheric sciences background, I'm a bit unclear on the details of TEOS-10 and the nuances associated with it. In particular it seems counter-intuitive to me how an equation of state that depends on depth fits in a Boussinesq fluid (where adiabatic rearrangement of parcels shouldn't change their buoyancy). But this probably isn't the best place to have a long discussion about it. Using the more fundamental definition of `z_*` does circumvent some of the issues mentioned by @hdrake, no? (Like topography.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841580109
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841583340:322,Integrability,depend,dependence,322,"I think the difficult part is finding z*; this is what Huang 2005 seems to be discussing. I'm hazy on the details (maybe @hdrake can chime in) but I think the point is that while an adiabatic rearrangement into a stable density profile may exist, it may not be obtainable by a single sorting procedure due to the pressure dependence of the equation of state. Some of the subtleties of the Boussinesq approximation for seawater are discussed in http://pordlabs.ucsd.edu/wryoung/reprintPDFs/SeawaterBoussinesq.pdf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841583340
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-845144418:390,Deployability,continuous,continuous,390,"@tomchor ; > Using the more fundamental definition of `z_*` does circumvent some of the issues mentioned by @hdrake, no? (Like topography.). Somewhat, but even with the ""fundamental"" definition below there are some implicit assumptions. Winters et al. assume the area A is constant with depth. It's not clear to me that this formula still holds if A=A(z). Also not clear how to calculate a continuous A(z) from a discrete grid in a consistent way, especially with unstructured grids / or partial cells.; ![img](https://user-images.githubusercontent.com/13205162/117906167-3edf0900-b289-11eb-9f0e-a4b7accab2a0.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-845144418
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-845144418:303,Usability,clear,clear,303,"@tomchor ; > Using the more fundamental definition of `z_*` does circumvent some of the issues mentioned by @hdrake, no? (Like topography.). Somewhat, but even with the ""fundamental"" definition below there are some implicit assumptions. Winters et al. assume the area A is constant with depth. It's not clear to me that this formula still holds if A=A(z). Also not clear how to calculate a continuous A(z) from a discrete grid in a consistent way, especially with unstructured grids / or partial cells.; ![img](https://user-images.githubusercontent.com/13205162/117906167-3edf0900-b289-11eb-9f0e-a4b7accab2a0.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-845144418
https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-845144418:365,Usability,clear,clear,365,"@tomchor ; > Using the more fundamental definition of `z_*` does circumvent some of the issues mentioned by @hdrake, no? (Like topography.). Somewhat, but even with the ""fundamental"" definition below there are some implicit assumptions. Winters et al. assume the area A is constant with depth. It's not clear to me that this formula still holds if A=A(z). Also not clear how to calculate a continuous A(z) from a discrete grid in a consistent way, especially with unstructured grids / or partial cells.; ![img](https://user-images.githubusercontent.com/13205162/117906167-3edf0900-b289-11eb-9f0e-a4b7accab2a0.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-845144418
https://github.com/CliMA/Oceananigans.jl/pull/1298#issuecomment-759761482:60,Deployability,update,updated,60,@jklymak and/or @francispoulin could you have a look on the updated version and let me know how does it read?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1298#issuecomment-759761482
https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758112855:32,Testability,test,tests,32,"Just realized we don't have any tests checking that output attributes were correctly set, but this can addressed in a future PR I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758112855
https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758117471:34,Testability,test,tests,34,"> Just realized we don't have any tests checking that output attributes were correctly set, but this can addressed in a future PR I think. If it helps, at least with this one I tested on my laptop and it worked okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758117471
https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758117471:177,Testability,test,tested,177,"> Just realized we don't have any tests checking that output attributes were correctly set, but this can addressed in a future PR I think. If it helps, at least with this one I tested on my laptop and it worked okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758117471
https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758166414:156,Testability,test,tests,156,That's definitely good! It's not an issue that would crash a simulation but next time I'm editing `test_output_writers.jl` I'll remember to add some simple tests for this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758166414
https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758166414:149,Usability,simpl,simple,149,That's definitely good! It's not an issue that would crash a simulation but next time I'm editing `test_output_writers.jl` I'll remember to add some simple tests for this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758166414
https://github.com/CliMA/Oceananigans.jl/pull/1301#issuecomment-759606744:64,Usability,simpl,simply,64,"@ali-ramadhan here's an idea: rather than `FieldStatus`, we can simply re-use `Clock`. Then we can be paranoid and check the `time`, `iteration`, and `stage` for the purposes of recomputation. There's a bit less code which is nice too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301#issuecomment-759606744
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:911,Availability,checkpoint,checkpointing,911,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:1024,Availability,checkpoint,checkpointed,1024,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:1395,Availability,checkpoint,checkpoint,1395,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:1551,Availability,checkpoint,checkpointing,1551,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:1647,Availability,checkpoint,checkpointing,1647,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:197,Energy Efficiency,schedul,schedules,197,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:441,Energy Efficiency,schedul,schedules,441,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:981,Energy Efficiency,schedul,schedules,981,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:1006,Energy Efficiency,schedul,schedules,1006,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:1119,Energy Efficiency,schedul,schedules,1119,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:1169,Energy Efficiency,schedul,schedule,1169,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:1231,Energy Efficiency,schedul,schedules,1231,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:1346,Energy Efficiency,schedul,schedule,1346,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:1417,Energy Efficiency,schedul,schedules,1417,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:793,Safety,safe,safely,793,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:1639,Testability,test,testing,1639,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:24,Usability,feedback,feedback,24,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766893249:26,Availability,checkpoint,checkpoint,26,> The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent aligned_time_step from returning negative time steps. Should we use `initialize_schedule!` for `TimeInterval` to set `previous_actuation_time` to the `model.clock.time`? Or is this incorrect?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766893249
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766893249:48,Energy Efficiency,schedul,schedules,48,> The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent aligned_time_step from returning negative time steps. Should we use `initialize_schedule!` for `TimeInterval` to set `previous_actuation_time` to the `model.clock.time`? Or is this incorrect?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766893249
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-767748984:187,Energy Efficiency,schedul,schedule,187,> Should we use `initialize_schedule!` for `TimeInterval` to set `previous_actuation_time` to the `model.clock.time`? Or is this incorrect?. That might work. Setting it to a multiple of `schedule.time_interval` might be better but both could have unintended consequences that aren't tested for. I'll merge this PR since it's got an approval so it makes it into v0.46.0.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-767748984
https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-767748984:283,Testability,test,tested,283,> Should we use `initialize_schedule!` for `TimeInterval` to set `previous_actuation_time` to the `model.clock.time`? Or is this incorrect?. That might work. Setting it to a multiple of `schedule.time_interval` might be better but both could have unintended consequences that aren't tested for. I'll merge this PR since it's got an approval so it makes it into v0.46.0.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-767748984
https://github.com/CliMA/Oceananigans.jl/issues/1304#issuecomment-766901805:100,Usability,clear,clearly,100,"Thanks @ali-ramadhan and @glwagner . I agree with you completely. It is important to be focused and clearly Oceananigans should focus on the Ocean, and Ocean related activities. Now that I know I can import this repo into other repos, I am happy to piggy back on Oceananigans and have something else. Maybe Magnetonanigans? Still word smithing that. . Thanks again for making Oceananigans happen as I know it's a great resouce and so happy to be able to learn from it and use it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1304#issuecomment-766901805
https://github.com/CliMA/Oceananigans.jl/issues/1304#issuecomment-766901805:454,Usability,learn,learn,454,"Thanks @ali-ramadhan and @glwagner . I agree with you completely. It is important to be focused and clearly Oceananigans should focus on the Ocean, and Ocean related activities. Now that I know I can import this repo into other repos, I am happy to piggy back on Oceananigans and have something else. Maybe Magnetonanigans? Still word smithing that. . Thanks again for making Oceananigans happen as I know it's a great resouce and so happy to be able to learn from it and use it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1304#issuecomment-766901805
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760279876:284,Modifiability,variab,variable,284,"> Actually I think you want `u` at the same location as `uh`, so you should write; > ; > ```julia; > u = ComputedField(uh / h); > ```. Agreed. What I did was `u = ComputedField( @at (Face,Cell,Cell) uh/h )` but I guess you are telling me that it defaults to the position of the first variable?. Actually, I needed to use `model.solution.uh` instead of `uh` and it seems to be working better (but I'm not done). Does that make sense or am I missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760279876
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760280879:79,Modifiability,variab,variable,79,"> but I guess you are telling me that it defaults to the position of the first variable?. Correct. > Actually, I needed to use model.solution.uh instead of uh and it seems to be working better (but I'm not done). Does that make sense or am I missing something. My apologies for being unclear! I would write. ```julia; uh, vh, h = model.solution; u = ComputedField(uh / h); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760280879
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760282723:81,Modifiability,variab,variable,81,"> > but I guess you are telling me that it defaults to the position of the first variable?; > ; > Correct.; > ; > > Actually, I needed to use model.solution.uh instead of uh and it seems to be working better (but I'm not done). Does that make sense or am I missing something; > ; > My apologies for being unclear! I would write; > ; > ```julia; > uh, vh, h = model.solution; > u = ComputedField(uh / h); > ```. Great to know, thanks!. Actually, the fact that I have uh, vh and h already defined causes some problems. Rather than introducing more variables I will probably just use the long name. I will try and not forget this in the future though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760282723
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760282723:546,Modifiability,variab,variables,546,"> > but I guess you are telling me that it defaults to the position of the first variable?; > ; > Correct.; > ; > > Actually, I needed to use model.solution.uh instead of uh and it seems to be working better (but I'm not done). Does that make sense or am I missing something; > ; > My apologies for being unclear! I would write; > ; > ```julia; > uh, vh, h = model.solution; > u = ComputedField(uh / h); > ```. Great to know, thanks!. Actually, the fact that I have uh, vh and h already defined causes some problems. Rather than introducing more variables I will probably just use the long name. I will try and not forget this in the future though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760282723
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760950751:228,Availability,error,error,228,"I've modified the plotting to show both the total vorticity and the perturbation vorticity. I find this is useful for showing the most unstable mode. When I set the perturbation to zero, the perturbation vorticity is really the error in the numerical method. . I have increased the resolution and find that the error only increases linearly, and not quadratically. See below. Any idea why we are not getting quadratic convergence?. ```; Nx Error; --- -----; 64 0.092; 128 0.048; 256 0.024; 512 0.012; 1024 0.006. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760950751
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760950751:311,Availability,error,error,311,"I've modified the plotting to show both the total vorticity and the perturbation vorticity. I find this is useful for showing the most unstable mode. When I set the perturbation to zero, the perturbation vorticity is really the error in the numerical method. . I have increased the resolution and find that the error only increases linearly, and not quadratically. See below. Any idea why we are not getting quadratic convergence?. ```; Nx Error; --- -----; 64 0.092; 128 0.048; 256 0.024; 512 0.012; 1024 0.006. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760950751
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760950751:440,Availability,Error,Error,440,"I've modified the plotting to show both the total vorticity and the perturbation vorticity. I find this is useful for showing the most unstable mode. When I set the perturbation to zero, the perturbation vorticity is really the error in the numerical method. . I have increased the resolution and find that the error only increases linearly, and not quadratically. See below. Any idea why we are not getting quadratic convergence?. ```; Nx Error; --- -----; 64 0.092; 128 0.048; 256 0.024; 512 0.012; 1024 0.006. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760950751
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-761200938:253,Energy Efficiency,reduce,reduces,253,"> There might be something wrong with the initial condition. Here's a few snapshots for `IncompressibleModel`:; > ; > ... Thanks. I agree that's what we should be getting. I certainly don't have that yet, but getting there. The issue that I asked about reduces to the fact that when I compute the vorticity during the simulation, it is only computed with first order accuracy. We should have second order, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-761200938
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-762328386:369,Usability,simpl,simpler,369,"@glwagner I am trying to set things up exactly the way they are in the example you shared with me but there are some differences. For example, rotation is not specified in your problem but I need to in mine. Second, I believe this is a 2D problem with a rigid lid. Therefore, I think what you are solving is equivant to the barotropic quasi-geostrophic model, which is simpler than shallow water. I wanted to point out that in the code (link below), there might be a typo. In line 4, the streamfunction is defined. Then in line 5, the geostrophic velocity is then defined. If there is a `2 y /L ` in the first, theny you should have a ` - y/L`, in the second, not a positive as seems to appear. I should add that this term seems strange to me as I have never included it before, but I'm including it for the sake of comparison and I don't think it should cause any problems. https://github.com/CliMA/OceanModelComparison.jl/blob/master/unstable_bickley/periodic/Bickley.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-762328386
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-763703829:482,Usability,clear,clear,482,> https://github.com/CliMA/GeophysicalDissipation.jl/blob/main/bickley/ocean_machine_bickley.jl. I looked at the code and it seems to be using `HydrostaticBoussinesqSuperModel`. It seems to be defined [here](https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/SuperModels.jl). From what I can tell it's solvin the Hydrostatic Boussinesq model with a rigid lid. Is that correct @glwagner ? If so I can believe this Bickley jet is a solution for that model but still not clear it works for Shallow Water.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-763703829
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797013770:432,Energy Efficiency,reduce,reduce,432,"I have created a doc that goes with this example. This is my first attempt at this so feedback is greatly appreciated. Below are some questions that I have, 4 are mentioned explicitly in the docs and 1 I just thought of now. Of course these lines will be removed before merging. - <del>In the sidebar on the left I have that the title looks weird because of the underscores. How should I fix this?</del>; - <del>I should be able to reduce the number of lined with `using`. This may require modifying the model as well.</del>; - Should I change the parameters to be planetary or is this fine? ; - <del>The diagnostics that are produced are helped to compute the growth rates. Is there a cleaner way of doing this?</del>; - The final part should plot the figure and not save it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797013770
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797013770:86,Usability,feedback,feedback,86,"I have created a doc that goes with this example. This is my first attempt at this so feedback is greatly appreciated. Below are some questions that I have, 4 are mentioned explicitly in the docs and 1 I just thought of now. Of course these lines will be removed before merging. - <del>In the sidebar on the left I have that the title looks weird because of the underscores. How should I fix this?</del>; - <del>I should be able to reduce the number of lined with `using`. This may require modifying the model as well.</del>; - Should I change the parameters to be planetary or is this fine? ; - <del>The diagnostics that are produced are helped to compute the growth rates. Is there a cleaner way of doing this?</del>; - The final part should plot the figure and not save it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797013770
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797021290:61,Security,access,access,61,Great. I'll have a look after the docs are build (and I have access to the preview). :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797021290
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797817214:9,Testability,log,log,9,The docs log complaints about the Eady turbulence example giving NaNs... Did anything changed in the code?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797817214
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797845046:139,Energy Efficiency,reduce,reduce,139,"@glwagner or @ali-ramadhan, any idea why `eady_turbulence.jl` is giving NaNs? Running the example locally things look just fine!. I'll try reduce the maximum CFL a bit...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797845046
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798798794:47,Usability,clear,clearly,47,"A dubious honour to have the most comments but clearly there was a healthy discussion, and as a result we have a very nice example. I promise that my future examples will be more direct and will have shorter PR's. Thanks everyone for all the help and glad to put this to bed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798798794
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798925559:311,Deployability,update,updates,311,"I might have been a bit too quick to merge as it seems that some tests are failing on master, and I presume as a result, is why we are not getting the new example in the docs. . @navidcy do you happen to know what's gone wrong? . I see that `align` is still in the example so I wonder if we got confuses in our updates and don't have the latest and greatest version?. ```; # ```math; # \begin{align}; # \overline{\eta}(y) & = - Δη \tanh(y) ,; # \overline{u}(y) & = U \sech^2(y) .; # \end{align}; # ```; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798925559
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798925559:65,Testability,test,tests,65,"I might have been a bit too quick to merge as it seems that some tests are failing on master, and I presume as a result, is why we are not getting the new example in the docs. . @navidcy do you happen to know what's gone wrong? . I see that `align` is still in the example so I wonder if we got confuses in our updates and don't have the latest and greatest version?. ```; # ```math; # \begin{align}; # \overline{\eta}(y) & = - Δη \tanh(y) ,; # \overline{u}(y) & = U \sech^2(y) .; # \end{align}; # ```; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798925559
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798958905:670,Deployability,release,release,670,Hm... You didn't rush to merge. Tests on master look OK: https://buildkite.com/clima/oceananigans/builds/1587. Also the example seems to be in its latest and greatest version :); https://github.com/CliMA/Oceananigans.jl/blob/27b1324dca660ce8cb7f5e205dd7400bdd23cb3d/examples/Bickley_jet_shallow_water.jl#L83-L86. Also the `dev` version of the docs includes the example: https://clima.github.io/OceananigansDocumentation/dev/generated/Bickley_jet_shallow_water/; (without the `\begin{align}...`) You may need to refresh the browser to see it? Or make sure you select `dev` version from the dev; I think the default version of the docs you see is the latest stable tagged release. The buildkite icon status I think is confused...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798958905
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798958905:32,Testability,Test,Tests,32,Hm... You didn't rush to merge. Tests on master look OK: https://buildkite.com/clima/oceananigans/builds/1587. Also the example seems to be in its latest and greatest version :); https://github.com/CliMA/Oceananigans.jl/blob/27b1324dca660ce8cb7f5e205dd7400bdd23cb3d/examples/Bickley_jet_shallow_water.jl#L83-L86. Also the `dev` version of the docs includes the example: https://clima.github.io/OceananigansDocumentation/dev/generated/Bickley_jet_shallow_water/; (without the `\begin{align}...`) You may need to refresh the browser to see it? Or make sure you select `dev` version from the dev; I think the default version of the docs you see is the latest stable tagged release. The buildkite icon status I think is confused...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798958905
https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798968747:7,Safety,safe,safe,7,Better safe than sorry :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798968747
https://github.com/CliMA/Oceananigans.jl/pull/1306#issuecomment-759773107:184,Availability,ping,ping,184,"@ali-ramadhan I think the buildkite docs build cannot push the preview. It complains that ""there is no space on device"". Perhaps consider deleting all previous useless PR previews? Or ping somebody that can do that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1306#issuecomment-759773107
https://github.com/CliMA/Oceananigans.jl/pull/1306#issuecomment-762575210:18,Availability,error,error,18,"hm, seems it's an error `[libx264 @ 0x7f812080d600] width not divisible by 2`... will sort it out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1306#issuecomment-762575210
https://github.com/CliMA/Oceananigans.jl/pull/1306#issuecomment-762617819:8,Testability,test,tests,8,"ok, all tests pass!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1306#issuecomment-762617819
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404:12,Availability,error,error,12,"What is the error you are getting when you try to use it?. The only function you'd need to extend is `update_Δt!` I think, which is probably a small piece of work if we know what error we're getting. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Simulations/time_step_wizard.jl#L32",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404:179,Availability,error,error,179,"What is the error you are getting when you try to use it?. The only function you'd need to extend is `update_Δt!` I think, which is probably a small piece of work if we know what error we're getting. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Simulations/time_step_wizard.jl#L32",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404:91,Modifiability,extend,extend,91,"What is the error you are getting when you try to use it?. The only function you'd need to extend is `update_Δt!` I think, which is probably a small piece of work if we know what error we're getting. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Simulations/time_step_wizard.jl#L32",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761105597:57,Availability,error,error,57,"I had not tried it before but I just tried it now. . The error is that `ShallowWaterModel` has no field velocities. `cell_advection_timescale.jl` defined [here](https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Utils/cell_advection_timescale.jl) meeds to know the velocities, u,v,w. In `ShallowWaterModel` we know uh, vh, and h, from which we can compute the velocities. . Is this a time for dispatching?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761105597
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599:216,Energy Efficiency,Adapt,Adapt,216,"Hmm, I think then `cell_advection_timescale` and `cell_diffusion_timescale` need to be extended for `ShallowWaterModel`, after which the `TimeStepWizard` will probably work. Perhaps change the name of this issue to ""Adapt cell_advection_timescale for ShallowWaterModel""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599:87,Modifiability,extend,extended,87,"Hmm, I think then `cell_advection_timescale` and `cell_diffusion_timescale` need to be extended for `ShallowWaterModel`, after which the `TimeStepWizard` will probably work. Perhaps change the name of this issue to ""Adapt cell_advection_timescale for ShallowWaterModel""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599:216,Modifiability,Adapt,Adapt,216,"Hmm, I think then `cell_advection_timescale` and `cell_diffusion_timescale` need to be extended for `ShallowWaterModel`, after which the `TimeStepWizard` will probably work. Perhaps change the name of this issue to ""Adapt cell_advection_timescale for ShallowWaterModel""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761152934:33,Modifiability,extend,extend,33,"And just to clarify, when I say ""extend"" I'm referring to ""method extension"" --- in other words, defining new methods for a function that *dispatch* on the number or arguments and argument types.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761152934
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761165109:35,Modifiability,extend,extend,35,"> And just to clarify, when I say ""extend"" I'm referring to ""method extension"" --- in other words, defining new methods for a function that _dispatch_ on the number or arguments and argument types. That makes sense and it should be easy enough to define `ShallowWaterModel` versions of these. I will work on the advection case and let you know what I come up with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761165109
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052:326,Deployability,integrat,integrate,326,"This is my first attempt at making a version of `cell_advection_timescale` for `ShallowWaterModel`. Note that we are dividing elements of mass flux and height, which are not defined at the same cell points, but if we are looking for estimates I wonder if this will be sufficient. I have not tested this as I'm not sure how to integrate this into the rest of the code, but I thought we could try that after we agree on what the script should look like. ```; ""Returns the time-scale for advection on a regular grid across a single grid cell ; for ShallowWaterModel.""; function cell_advection_timescale(uh, vh, h, grid); umax = maximum(abs, uh / h); vmax = maximum(abs, vh / h). Δx = grid.Δx; Δy = grid.Δy. return min(Δx/umax, Δy/vmax); end. cell_advection_timescale(model) =; cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052:326,Integrability,integrat,integrate,326,"This is my first attempt at making a version of `cell_advection_timescale` for `ShallowWaterModel`. Note that we are dividing elements of mass flux and height, which are not defined at the same cell points, but if we are looking for estimates I wonder if this will be sufficient. I have not tested this as I'm not sure how to integrate this into the rest of the code, but I thought we could try that after we agree on what the script should look like. ```; ""Returns the time-scale for advection on a regular grid across a single grid cell ; for ShallowWaterModel.""; function cell_advection_timescale(uh, vh, h, grid); umax = maximum(abs, uh / h); vmax = maximum(abs, vh / h). Δx = grid.Δx; Δy = grid.Δy. return min(Δx/umax, Δy/vmax); end. cell_advection_timescale(model) =; cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052:291,Testability,test,tested,291,"This is my first attempt at making a version of `cell_advection_timescale` for `ShallowWaterModel`. Note that we are dividing elements of mass flux and height, which are not defined at the same cell points, but if we are looking for estimates I wonder if this will be sufficient. I have not tested this as I'm not sure how to integrate this into the rest of the code, but I thought we could try that after we agree on what the script should look like. ```; ""Returns the time-scale for advection on a regular grid across a single grid cell ; for ShallowWaterModel.""; function cell_advection_timescale(uh, vh, h, grid); umax = maximum(abs, uh / h); vmax = maximum(abs, vh / h). Δx = grid.Δx; Δy = grid.Δy. return min(Δx/umax, Δy/vmax); end. cell_advection_timescale(model) =; cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762898249:297,Energy Efficiency,allocate,allocate,297,"You could maybe form a conservative estimate using. ```; uhmax = maximum(abs, uh); vhmax = maximum(abs, vh); hmax = maximum(abs, h). umax = max(uhmax / hmax, vhmax / hmax); ```. but this would be overly conservative for very nonlinear problems, I suppose. One issue is that writing `uh ./ h` will allocate memory. Note that you need `./` (with the `.`), not just `/`. You'll also need to dispatch on `model::ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762898249
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762961317:40,Usability,clear,clear,40,"Agreed. Unfortunately, I'm not entirely clear how to dispatch. It will presumably require I also change something in `IncompressibleModel`, . If can give me high level descriptions of what needs to be done where, I can give it a try later today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762961317
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762963700:34,Usability,clear,clear,34,"> Unfortunately, I'm not entirely clear how to dispatch. Rather than. ```; cell_advection_timescale(model) =; cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid). ```. as posted abvove, you'll need to write. ```julia; cell_advection_timescale(model::ShallowWaterModel) =; cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762963700
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762968343:247,Integrability,depend,depending,247,thanks. And presumably a similar change needs to be done in the original script to include `IncompressibleModel`. That I think I can find and do. The last thing I can think of is where to define the function before there is a dispatch that occurs depending on the model.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762968343
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246:1775,Availability,error,error,1775,"You should write. ```julia; import Oceananigans.Utils: cell_advection_timescale; ```. at the top of the file `shallow_water_cell_advection_timescale.jl`. This ""imports"" the name `cell_advection_timescale` into your present scope such that the function can be extended with new methods. Next, you want to define a new method for `cell_advection_timescale` with the signature. ```julia; cell_advection_timescale(model::ShallowWaterModel) = # definition here; ```. Note that the function signature. ```julia; cell_advection_timescale(uh, vh, h, grid); ```. is already taken by one of the existing methods for `cell_advection_timescale`:. https://github.com/CliMA/Oceananigans.jl/blob/2016e730350e0b6b625a5cf85a68269a370686fd/src/Utils/cell_advection_timescale.jl#L2-L12. This means that you need to either use type annotations to distinguish the version that takes arguments `uh, vh, h, grid` from the method that takes `u, v, w, grid`, or (probably better) use a unique name. A good name for the method that takes the arguments `uh, vh, h, grid` could be. ```julia; shallow_water_cell_advection_timescale(uh, vh, h, grid) = # definition here; ```. Remember that with this new name, the function `cell_advection_timescale(model::ShallowWaterModel)` must call `shallow_water_cell_advection_timescale`; eg. ```; cell_advection_timescale(model::ShallowWaterModel) =; shallow_water_cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```. when this file is put together, you should include it in `ShallowWaterModels.jl`. This should allow you to `run!` a `Simulation` with `TimeStepWizard`. Perhaps it makes sense to add a test for this in this PR?. If this does not work, feel free to copy/paste the error here so that we can debug the issue. Note: I was confused earlier --- I definitely prefer `shallow_water_cell_advection_timescale.jl` for the filename. But anything will do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246:259,Modifiability,extend,extended,259,"You should write. ```julia; import Oceananigans.Utils: cell_advection_timescale; ```. at the top of the file `shallow_water_cell_advection_timescale.jl`. This ""imports"" the name `cell_advection_timescale` into your present scope such that the function can be extended with new methods. Next, you want to define a new method for `cell_advection_timescale` with the signature. ```julia; cell_advection_timescale(model::ShallowWaterModel) = # definition here; ```. Note that the function signature. ```julia; cell_advection_timescale(uh, vh, h, grid); ```. is already taken by one of the existing methods for `cell_advection_timescale`:. https://github.com/CliMA/Oceananigans.jl/blob/2016e730350e0b6b625a5cf85a68269a370686fd/src/Utils/cell_advection_timescale.jl#L2-L12. This means that you need to either use type annotations to distinguish the version that takes arguments `uh, vh, h, grid` from the method that takes `u, v, w, grid`, or (probably better) use a unique name. A good name for the method that takes the arguments `uh, vh, h, grid` could be. ```julia; shallow_water_cell_advection_timescale(uh, vh, h, grid) = # definition here; ```. Remember that with this new name, the function `cell_advection_timescale(model::ShallowWaterModel)` must call `shallow_water_cell_advection_timescale`; eg. ```; cell_advection_timescale(model::ShallowWaterModel) =; shallow_water_cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```. when this file is put together, you should include it in `ShallowWaterModels.jl`. This should allow you to `run!` a `Simulation` with `TimeStepWizard`. Perhaps it makes sense to add a test for this in this PR?. If this does not work, feel free to copy/paste the error here so that we can debug the issue. Note: I was confused earlier --- I definitely prefer `shallow_water_cell_advection_timescale.jl` for the filename. But anything will do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246:1697,Testability,test,test,1697,"You should write. ```julia; import Oceananigans.Utils: cell_advection_timescale; ```. at the top of the file `shallow_water_cell_advection_timescale.jl`. This ""imports"" the name `cell_advection_timescale` into your present scope such that the function can be extended with new methods. Next, you want to define a new method for `cell_advection_timescale` with the signature. ```julia; cell_advection_timescale(model::ShallowWaterModel) = # definition here; ```. Note that the function signature. ```julia; cell_advection_timescale(uh, vh, h, grid); ```. is already taken by one of the existing methods for `cell_advection_timescale`:. https://github.com/CliMA/Oceananigans.jl/blob/2016e730350e0b6b625a5cf85a68269a370686fd/src/Utils/cell_advection_timescale.jl#L2-L12. This means that you need to either use type annotations to distinguish the version that takes arguments `uh, vh, h, grid` from the method that takes `u, v, w, grid`, or (probably better) use a unique name. A good name for the method that takes the arguments `uh, vh, h, grid` could be. ```julia; shallow_water_cell_advection_timescale(uh, vh, h, grid) = # definition here; ```. Remember that with this new name, the function `cell_advection_timescale(model::ShallowWaterModel)` must call `shallow_water_cell_advection_timescale`; eg. ```; cell_advection_timescale(model::ShallowWaterModel) =; shallow_water_cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```. when this file is put together, you should include it in `ShallowWaterModels.jl`. This should allow you to `run!` a `Simulation` with `TimeStepWizard`. Perhaps it makes sense to add a test for this in this PR?. If this does not work, feel free to copy/paste the error here so that we can debug the issue. Note: I was confused earlier --- I definitely prefer `shallow_water_cell_advection_timescale.jl` for the filename. But anything will do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764674870:116,Testability,test,test,116,"Thanks @glwagner I'm happy to say this worked! Sorry that I was slow in putting the pieces together. I agree that a test would no be a bad idea. I glanced in `test_time_stepping.jl` and I did not see anything obvious that tested the time stepping. I modfiied `test_shallow_water.jl` to use the wizard but not it uses it for everything. Not necessarily bad, but not sure if this is what we want? Not sure if we want to have two of these functions. If there are not any tests for the wizard in `IncompresibleModel` maybe something should be done there and `ShallowWaterModel` can parallel that?. ```; function time_stepping_shallow_water_model_works(arch, topo, coriolis); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(2π, 2π, 2π), topology=topo); model = ShallowWaterModel(grid=grid, gravitational_acceleration=1, architecture=arch, coriolis=coriolis); set!(model, h=1). wizard = TimeStepWizard(cfl=1.0, Δt=1.0, max_change=1.1, max_Δt=10). simulation = Simulation(model, Δt=wizard, stop_iteration=1); run!(simulation). return model.clock.iteration == 1; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764674870
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764674870:222,Testability,test,tested,222,"Thanks @glwagner I'm happy to say this worked! Sorry that I was slow in putting the pieces together. I agree that a test would no be a bad idea. I glanced in `test_time_stepping.jl` and I did not see anything obvious that tested the time stepping. I modfiied `test_shallow_water.jl` to use the wizard but not it uses it for everything. Not necessarily bad, but not sure if this is what we want? Not sure if we want to have two of these functions. If there are not any tests for the wizard in `IncompresibleModel` maybe something should be done there and `ShallowWaterModel` can parallel that?. ```; function time_stepping_shallow_water_model_works(arch, topo, coriolis); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(2π, 2π, 2π), topology=topo); model = ShallowWaterModel(grid=grid, gravitational_acceleration=1, architecture=arch, coriolis=coriolis); set!(model, h=1). wizard = TimeStepWizard(cfl=1.0, Δt=1.0, max_change=1.1, max_Δt=10). simulation = Simulation(model, Δt=wizard, stop_iteration=1); run!(simulation). return model.clock.iteration == 1; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764674870
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764674870:468,Testability,test,tests,468,"Thanks @glwagner I'm happy to say this worked! Sorry that I was slow in putting the pieces together. I agree that a test would no be a bad idea. I glanced in `test_time_stepping.jl` and I did not see anything obvious that tested the time stepping. I modfiied `test_shallow_water.jl` to use the wizard but not it uses it for everything. Not necessarily bad, but not sure if this is what we want? Not sure if we want to have two of these functions. If there are not any tests for the wizard in `IncompresibleModel` maybe something should be done there and `ShallowWaterModel` can parallel that?. ```; function time_stepping_shallow_water_model_works(arch, topo, coriolis); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(2π, 2π, 2π), topology=topo); model = ShallowWaterModel(grid=grid, gravitational_acceleration=1, architecture=arch, coriolis=coriolis); set!(model, h=1). wizard = TimeStepWizard(cfl=1.0, Δt=1.0, max_change=1.1, max_Δt=10). simulation = Simulation(model, Δt=wizard, stop_iteration=1); run!(simulation). return model.clock.iteration == 1; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764674870
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764812698:31,Testability,test,test,31,This looks like a great simple test. Perhaps `time_step_wizard_shallow_water_model_works` is a good name for the function? You may want `stop_iteration=2` to ensure that the `update_dt` works as expected.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764812698
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764812698:24,Usability,simpl,simple,24,This looks like a great simple test. Perhaps `time_step_wizard_shallow_water_model_works` is a good name for the function? You may want `stop_iteration=2` to ensure that the `update_dt` works as expected.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764812698
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-765443511:17,Testability,test,test,17,"Done! There is a test for the time stepping wizard that loops over archs, but not topologies. I can certainly test those as well but didn't think that was necessary. Happy to fix it if there is any concern. If there aren't then I'm happy to close this issue and then focus on the accuracy of the solution, and comparing the results with the linear stability results that I posed yesterday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-765443511
https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-765443511:110,Testability,test,test,110,"Done! There is a test for the time stepping wizard that loops over archs, but not topologies. I can certainly test those as well but didn't think that was necessary. Happy to fix it if there is any concern. If there aren't then I'm happy to close this issue and then focus on the accuracy of the solution, and comparing the results with the linear stability results that I posed yesterday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-765443511
https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762926304:158,Availability,error,error,158,I've made this mistake many times haha. Seems like it might be good to add a warning telling users they probably meant to pass in a `ComputedField` since the error isn't super useful and only shows up when you call `run!`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762926304
https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762957312:158,Availability,error,error,158,> I've made this mistake many times haha. Seems like it might be good to add a warning telling users they probably meant to pass in a ComputedField since the error isn't super useful and only shows up when you call run!. We could limit the type of the elements of `values(outputs)` to callable objects and `AbstractField` ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762957312
https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229:172,Integrability,message,message,172,That sounds like a better check that would generalize!. The `ComputedField` vs. `AbstractOperation` distinction could be a common enough mistake to warrant a user-friendly message.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229
https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229:158,Usability,user-friendly,user-friendly,158,That sounds like a better check that would generalize!. The `ComputedField` vs. `AbstractOperation` distinction could be a common enough mistake to warrant a user-friendly message.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229
https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-763110066:58,Availability,error,error,58,"Something like. ```julia; validate_output(name, output) = error(""Output $name of type $(typeof(output)) is invalid!""); validate_output(name, ::Union(Base.Callable, AbstractField)) = nothing; validate_output(name, output::AbstractOperation) = error(""Output $name is an AbstractOperation, which is invalid. You may have meant to use ComputedField($name).""); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-763110066
https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-763110066:242,Availability,error,error,242,"Something like. ```julia; validate_output(name, output) = error(""Output $name of type $(typeof(output)) is invalid!""); validate_output(name, ::Union(Base.Callable, AbstractField)) = nothing; validate_output(name, output::AbstractOperation) = error(""Output $name is an AbstractOperation, which is invalid. You may have meant to use ComputedField($name).""); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-763110066
https://github.com/CliMA/Oceananigans.jl/issues/1309#issuecomment-763706226:164,Energy Efficiency,adapt,adaptive,164,"> Should also restructure the new `ShallowWaterModel` version in a similar way. Quite! In the context of `ShallowWaterModel`, this will only effect 1D models where adaptive time-stepping may not be that useful (because the vertical dimensions is `Flat` _a priori_). But we can add it there too if we think that's important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1309#issuecomment-763706226
https://github.com/CliMA/Oceananigans.jl/issues/1309#issuecomment-763706226:164,Modifiability,adapt,adaptive,164,"> Should also restructure the new `ShallowWaterModel` version in a similar way. Quite! In the context of `ShallowWaterModel`, this will only effect 1D models where adaptive time-stepping may not be that useful (because the vertical dimensions is `Flat` _a priori_). But we can add it there too if we think that's important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1309#issuecomment-763706226
https://github.com/CliMA/Oceananigans.jl/issues/1313#issuecomment-1479864497:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1313#issuecomment-1479864497
https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766164070:35,Testability,test,tests,35,Now begins the slog to fix all the tests haha. Looks like `show_fields.jl` is complaining that `Center` is not defined: https://buildkite.com/clima/oceananigans/builds/982#b79d3314-e323-4bce-a443-35926baf3803/40-133,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766164070
https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766179890:35,Testability,test,tests,35,"Apparently I don't know how to run tests locally, because they all passed here without problems. @ali-ramadhan Do you have any reference that I can check that shows how to run tests locally? In the meantime I'll do my best to fix this without local testing I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766179890
https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766179890:176,Testability,test,tests,176,"Apparently I don't know how to run tests locally, because they all passed here without problems. @ali-ramadhan Do you have any reference that I can check that shows how to run tests locally? In the meantime I'll do my best to fix this without local testing I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766179890
https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766179890:249,Testability,test,testing,249,"Apparently I don't know how to run tests locally, because they all passed here without problems. @ali-ramadhan Do you have any reference that I can check that shows how to run tests locally? In the meantime I'll do my best to fix this without local testing I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766179890
https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766309752:190,Testability,test,test,190,While in the repo's main directory I'd fire up Julia and then ; ```Julia; (@v1.5) pkg> activate .; Activating environment at `~/somefolder/Oceananigans.jl/Project.toml`. (Oceananigans) pkg> test; ```; That's what I'd do.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766309752
https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766390001:8,Deployability,release,release,8,And new release after?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766390001
https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766391028:10,Deployability,release,release,10,> And new release after?. Yes. I already tagged v0.46.0 in PR #1091 but not sure if it'll get merged soon. If either PR gets merged we should tag v0.46.0.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1314#issuecomment-766391028
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767021509:20,Performance,load,load,20,"I think you need to load cuda before you _build_ Oceananigans. You might need to do this from the login node, eg something like. ```; module load cuda; julia --project -e 'using Pkg; Pkg.build(""Oceananigans"")'; ```. Is that right @ali-ramadhan ?. The issue is that the functions `plan_forward_transforms` for `CuArray`s are not being loaded:. https://github.com/CliMA/Oceananigans.jl/blob/52bfeb09e3562f639deb32b8807f32a88e3a1cfa/src/Solvers/plan_transforms.jl#L30-L33. Note that your script is a julia file, so you should append it with `.jl` so that it's named `model_gpu_waves.jl`. As a side comment, you should take care when initializing a model with zero Eulerian-mean flow --- despite that this is common in the literature, it is unlikely to be a physically relevant initial condition (because it rarely occurs in nature, and because it will excite large inertial oscillations in your simulation). Some perspective on this issue is provided by [observations reported by Jerry Smith (2006)](https://journals.ametsoc.org/view/journals/phoc/36/7/jpo2910.1.xml?tab_body=abstract-display) and [a preprint that I'm first author on](https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767021509
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767021509:141,Performance,load,load,141,"I think you need to load cuda before you _build_ Oceananigans. You might need to do this from the login node, eg something like. ```; module load cuda; julia --project -e 'using Pkg; Pkg.build(""Oceananigans"")'; ```. Is that right @ali-ramadhan ?. The issue is that the functions `plan_forward_transforms` for `CuArray`s are not being loaded:. https://github.com/CliMA/Oceananigans.jl/blob/52bfeb09e3562f639deb32b8807f32a88e3a1cfa/src/Solvers/plan_transforms.jl#L30-L33. Note that your script is a julia file, so you should append it with `.jl` so that it's named `model_gpu_waves.jl`. As a side comment, you should take care when initializing a model with zero Eulerian-mean flow --- despite that this is common in the literature, it is unlikely to be a physically relevant initial condition (because it rarely occurs in nature, and because it will excite large inertial oscillations in your simulation). Some perspective on this issue is provided by [observations reported by Jerry Smith (2006)](https://journals.ametsoc.org/view/journals/phoc/36/7/jpo2910.1.xml?tab_body=abstract-display) and [a preprint that I'm first author on](https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767021509
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767021509:334,Performance,load,loaded,334,"I think you need to load cuda before you _build_ Oceananigans. You might need to do this from the login node, eg something like. ```; module load cuda; julia --project -e 'using Pkg; Pkg.build(""Oceananigans"")'; ```. Is that right @ali-ramadhan ?. The issue is that the functions `plan_forward_transforms` for `CuArray`s are not being loaded:. https://github.com/CliMA/Oceananigans.jl/blob/52bfeb09e3562f639deb32b8807f32a88e3a1cfa/src/Solvers/plan_transforms.jl#L30-L33. Note that your script is a julia file, so you should append it with `.jl` so that it's named `model_gpu_waves.jl`. As a side comment, you should take care when initializing a model with zero Eulerian-mean flow --- despite that this is common in the literature, it is unlikely to be a physically relevant initial condition (because it rarely occurs in nature, and because it will excite large inertial oscillations in your simulation). Some perspective on this issue is provided by [observations reported by Jerry Smith (2006)](https://journals.ametsoc.org/view/journals/phoc/36/7/jpo2910.1.xml?tab_body=abstract-display) and [a preprint that I'm first author on](https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767021509
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767021509:98,Testability,log,login,98,"I think you need to load cuda before you _build_ Oceananigans. You might need to do this from the login node, eg something like. ```; module load cuda; julia --project -e 'using Pkg; Pkg.build(""Oceananigans"")'; ```. Is that right @ali-ramadhan ?. The issue is that the functions `plan_forward_transforms` for `CuArray`s are not being loaded:. https://github.com/CliMA/Oceananigans.jl/blob/52bfeb09e3562f639deb32b8807f32a88e3a1cfa/src/Solvers/plan_transforms.jl#L30-L33. Note that your script is a julia file, so you should append it with `.jl` so that it's named `model_gpu_waves.jl`. As a side comment, you should take care when initializing a model with zero Eulerian-mean flow --- despite that this is common in the literature, it is unlikely to be a physically relevant initial condition (because it rarely occurs in nature, and because it will excite large inertial oscillations in your simulation). Some perspective on this issue is provided by [observations reported by Jerry Smith (2006)](https://journals.ametsoc.org/view/journals/phoc/36/7/jpo2910.1.xml?tab_body=abstract-display) and [a preprint that I'm first author on](https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767021509
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529:56,Availability,error,error,56,"It seems like adding the rebuilding step has fixed that error so thank you!; However, there is another error (see attached error log). Based on my print statements from my run script, the error is occurring when the `run!` command is called or during the run before the first output of progress.; [err_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873490/err_gpu.01.txt); [log_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873492/log_gpu.01.txt). I have run the same case using the CPU architecture and it made it through a couple timesteps so I know that it works. It just runs too slowly on the CPU to be practical to use. . To your note, I do use .jl extensions but github wouldn't allow me to attach a .jl so I changed it to .txt to post it. I don't anticipate the zero Eulerian-mean flow to be a huge issue because my forcing starts up very gradually over the first few hours so I would expect that to act as the spin-up you used in your paper. However, you know much more about this than I do. Even with a gradual climb in forcing at the beginning of the run, how would you recommend improving the settings? Can I initialize the Eulerian-mean flow with noise? Or just run a different, more formal spin up case and then initialize from that? . Thanks so much for your help, this is my first time working with an LES so I am very green.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529:103,Availability,error,error,103,"It seems like adding the rebuilding step has fixed that error so thank you!; However, there is another error (see attached error log). Based on my print statements from my run script, the error is occurring when the `run!` command is called or during the run before the first output of progress.; [err_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873490/err_gpu.01.txt); [log_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873492/log_gpu.01.txt). I have run the same case using the CPU architecture and it made it through a couple timesteps so I know that it works. It just runs too slowly on the CPU to be practical to use. . To your note, I do use .jl extensions but github wouldn't allow me to attach a .jl so I changed it to .txt to post it. I don't anticipate the zero Eulerian-mean flow to be a huge issue because my forcing starts up very gradually over the first few hours so I would expect that to act as the spin-up you used in your paper. However, you know much more about this than I do. Even with a gradual climb in forcing at the beginning of the run, how would you recommend improving the settings? Can I initialize the Eulerian-mean flow with noise? Or just run a different, more formal spin up case and then initialize from that? . Thanks so much for your help, this is my first time working with an LES so I am very green.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529:123,Availability,error,error,123,"It seems like adding the rebuilding step has fixed that error so thank you!; However, there is another error (see attached error log). Based on my print statements from my run script, the error is occurring when the `run!` command is called or during the run before the first output of progress.; [err_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873490/err_gpu.01.txt); [log_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873492/log_gpu.01.txt). I have run the same case using the CPU architecture and it made it through a couple timesteps so I know that it works. It just runs too slowly on the CPU to be practical to use. . To your note, I do use .jl extensions but github wouldn't allow me to attach a .jl so I changed it to .txt to post it. I don't anticipate the zero Eulerian-mean flow to be a huge issue because my forcing starts up very gradually over the first few hours so I would expect that to act as the spin-up you used in your paper. However, you know much more about this than I do. Even with a gradual climb in forcing at the beginning of the run, how would you recommend improving the settings? Can I initialize the Eulerian-mean flow with noise? Or just run a different, more formal spin up case and then initialize from that? . Thanks so much for your help, this is my first time working with an LES so I am very green.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529:188,Availability,error,error,188,"It seems like adding the rebuilding step has fixed that error so thank you!; However, there is another error (see attached error log). Based on my print statements from my run script, the error is occurring when the `run!` command is called or during the run before the first output of progress.; [err_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873490/err_gpu.01.txt); [log_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873492/log_gpu.01.txt). I have run the same case using the CPU architecture and it made it through a couple timesteps so I know that it works. It just runs too slowly on the CPU to be practical to use. . To your note, I do use .jl extensions but github wouldn't allow me to attach a .jl so I changed it to .txt to post it. I don't anticipate the zero Eulerian-mean flow to be a huge issue because my forcing starts up very gradually over the first few hours so I would expect that to act as the spin-up you used in your paper. However, you know much more about this than I do. Even with a gradual climb in forcing at the beginning of the run, how would you recommend improving the settings? Can I initialize the Eulerian-mean flow with noise? Or just run a different, more formal spin up case and then initialize from that? . Thanks so much for your help, this is my first time working with an LES so I am very green.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529:1362,Energy Efficiency,green,green,1362,"It seems like adding the rebuilding step has fixed that error so thank you!; However, there is another error (see attached error log). Based on my print statements from my run script, the error is occurring when the `run!` command is called or during the run before the first output of progress.; [err_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873490/err_gpu.01.txt); [log_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873492/log_gpu.01.txt). I have run the same case using the CPU architecture and it made it through a couple timesteps so I know that it works. It just runs too slowly on the CPU to be practical to use. . To your note, I do use .jl extensions but github wouldn't allow me to attach a .jl so I changed it to .txt to post it. I don't anticipate the zero Eulerian-mean flow to be a huge issue because my forcing starts up very gradually over the first few hours so I would expect that to act as the spin-up you used in your paper. However, you know much more about this than I do. Even with a gradual climb in forcing at the beginning of the run, how would you recommend improving the settings? Can I initialize the Eulerian-mean flow with noise? Or just run a different, more formal spin up case and then initialize from that? . Thanks so much for your help, this is my first time working with an LES so I am very green.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529:129,Testability,log,log,129,"It seems like adding the rebuilding step has fixed that error so thank you!; However, there is another error (see attached error log). Based on my print statements from my run script, the error is occurring when the `run!` command is called or during the run before the first output of progress.; [err_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873490/err_gpu.01.txt); [log_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873492/log_gpu.01.txt). I have run the same case using the CPU architecture and it made it through a couple timesteps so I know that it works. It just runs too slowly on the CPU to be practical to use. . To your note, I do use .jl extensions but github wouldn't allow me to attach a .jl so I changed it to .txt to post it. I don't anticipate the zero Eulerian-mean flow to be a huge issue because my forcing starts up very gradually over the first few hours so I would expect that to act as the spin-up you used in your paper. However, you know much more about this than I do. Even with a gradual climb in forcing at the beginning of the run, how would you recommend improving the settings? Can I initialize the Eulerian-mean flow with noise? Or just run a different, more formal spin up case and then initialize from that? . Thanks so much for your help, this is my first time working with an LES so I am very green.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:20,Availability,error,errors,20,"Sorry about the GPU errors, they're much scarier than they look! Looks like a pretty involved setup so I'll let @glwagner comment on the setup. In this case it looks like Julia is complaining about an `unsupported dynamic function invocation (call to overdub)` in `Fxn_scale` at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:571,Availability,avail,available,571,"Sorry about the GPU errors, they're much scarier than they look! Looks like a pretty involved setup so I'll let @glwagner comment on the setup. In this case it looks like Julia is complaining about an `unsupported dynamic function invocation (call to overdub)` in `Fxn_scale` at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:917,Energy Efficiency,Adapt,Adapt,917,"Sorry about the GPU errors, they're much scarier than they look! Looks like a pretty involved setup so I'll let @glwagner comment on the setup. In this case it looks like Julia is complaining about an `unsupported dynamic function invocation (call to overdub)` in `Fxn_scale` at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1610,Energy Efficiency,efficient,efficient,1610,"some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia -t n` where `n` is the number of threads to use) until a GPU version is up and running.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1742,Integrability,wrap,wrapper,1742,"some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia -t n` where `n` is the number of threads to use) until a GPU version is up and running.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:917,Modifiability,Adapt,Adapt,917,"Sorry about the GPU errors, they're much scarier than they look! Looks like a pretty involved setup so I'll let @glwagner comment on the setup. In this case it looks like Julia is complaining about an `unsupported dynamic function invocation (call to overdub)` in `Fxn_scale` at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:974,Modifiability,variab,variable,974,"Sorry about the GPU errors, they're much scarier than they look! Looks like a pretty involved setup so I'll let @glwagner comment on the setup. In this case it looks like Julia is complaining about an `unsupported dynamic function invocation (call to overdub)` in `Fxn_scale` at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1280,Modifiability,variab,variables,1280,"at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1343,Security,access,accessed,1343,"tself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia -t n` where `n` is the number of threads to use) until a GPU version i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660
https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:2154,Usability,simpl,simple,2154,"some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia -t n` where `n` is the number of threads to use) until a GPU version is up and running.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:119,Integrability,interface,interfaces,119,"I don't know a good reference for everything... To start with, our object is to calculate advective fluxes across cell interfaces. For this purpose we need to know the velocity field and the advected quantity (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedTh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:262,Integrability,interface,interfaces,262,"I don't know a good reference for everything... To start with, our object is to calculate advective fluxes across cell interfaces. For this purpose we need to know the velocity field and the advected quantity (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedTh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:367,Integrability,interface,interface,367,"I don't know a good reference for everything... To start with, our object is to calculate advective fluxes across cell interfaces. For this purpose we need to know the velocity field and the advected quantity (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedTh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:626,Integrability,interface,interfaces,626,"I don't know a good reference for everything... To start with, our object is to calculate advective fluxes across cell interfaces. For this purpose we need to know the velocity field and the advected quantity (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedTh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:971,Integrability,interface,interface,971,"I don't know a good reference for everything... To start with, our object is to calculate advective fluxes across cell interfaces. For this purpose we need to know the velocity field and the advected quantity (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedTh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:1215,Integrability,interface,interface,1215," (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedThirdOrder`, `UpwindBiasedFifthOrder`, `WENO5`), the symmetric interpolation for advecting velocities is a symmetric scheme of order `n-1`. So that's `CenteredSecondOrder`, `CenteredFourthOrder`, and `CenteredF",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:297,Usability,simpl,simple,297,"I don't know a good reference for everything... To start with, our object is to calculate advective fluxes across cell interfaces. For this purpose we need to know the velocity field and the advected quantity (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedTh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269:195,Deployability,integrat,integrate,195,"I am glad that we are talking about this and I'm also happy to help if I can. One thing that I noticed on the docs is that we say we are using the finite volume method but then we never actually integrate the PDEs to obtain the equations in terms of the cell averaged quantities. I think this would be helpful to the user as it would point out the differences between the value at a point and the cell average of that quantity. I don't think there needs to be a lot but integrating the tracer equation first, since that's easier, and the integrating the momentum equation would add someting which at that moment I don't think is present. What do you think @navidcy ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269:470,Deployability,integrat,integrating,470,"I am glad that we are talking about this and I'm also happy to help if I can. One thing that I noticed on the docs is that we say we are using the finite volume method but then we never actually integrate the PDEs to obtain the equations in terms of the cell averaged quantities. I think this would be helpful to the user as it would point out the differences between the value at a point and the cell average of that quantity. I don't think there needs to be a lot but integrating the tracer equation first, since that's easier, and the integrating the momentum equation would add someting which at that moment I don't think is present. What do you think @navidcy ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269:538,Deployability,integrat,integrating,538,"I am glad that we are talking about this and I'm also happy to help if I can. One thing that I noticed on the docs is that we say we are using the finite volume method but then we never actually integrate the PDEs to obtain the equations in terms of the cell averaged quantities. I think this would be helpful to the user as it would point out the differences between the value at a point and the cell average of that quantity. I don't think there needs to be a lot but integrating the tracer equation first, since that's easier, and the integrating the momentum equation would add someting which at that moment I don't think is present. What do you think @navidcy ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269:195,Integrability,integrat,integrate,195,"I am glad that we are talking about this and I'm also happy to help if I can. One thing that I noticed on the docs is that we say we are using the finite volume method but then we never actually integrate the PDEs to obtain the equations in terms of the cell averaged quantities. I think this would be helpful to the user as it would point out the differences between the value at a point and the cell average of that quantity. I don't think there needs to be a lot but integrating the tracer equation first, since that's easier, and the integrating the momentum equation would add someting which at that moment I don't think is present. What do you think @navidcy ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269:470,Integrability,integrat,integrating,470,"I am glad that we are talking about this and I'm also happy to help if I can. One thing that I noticed on the docs is that we say we are using the finite volume method but then we never actually integrate the PDEs to obtain the equations in terms of the cell averaged quantities. I think this would be helpful to the user as it would point out the differences between the value at a point and the cell average of that quantity. I don't think there needs to be a lot but integrating the tracer equation first, since that's easier, and the integrating the momentum equation would add someting which at that moment I don't think is present. What do you think @navidcy ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269:538,Integrability,integrat,integrating,538,"I am glad that we are talking about this and I'm also happy to help if I can. One thing that I noticed on the docs is that we say we are using the finite volume method but then we never actually integrate the PDEs to obtain the equations in terms of the cell averaged quantities. I think this would be helpful to the user as it would point out the differences between the value at a point and the cell average of that quantity. I don't think there needs to be a lot but integrating the tracer equation first, since that's easier, and the integrating the momentum equation would add someting which at that moment I don't think is present. What do you think @navidcy ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873779209:143,Integrability,interface,interfaces,143,"I think even 1D would be ok. On the question of interpolation of velocities: to compute fluxes we need to _reconstruct_ the fields at the cell interfaces. The velocity field is _staggered_ with respect to the tracer field, such that we can trivially reconstruct the velocity field by using the cell-averaged velocity component that's centered on the location it's needed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873779209
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874098416:81,Integrability,interface,interfaces,81,You are saying that you’d expect to have estimates of the velocity values at the interfaces rather than their cell-averaged values (centered around the interfaces)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874098416
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874098416:152,Integrability,interface,interfaces,152,You are saying that you’d expect to have estimates of the velocity values at the interfaces rather than their cell-averaged values (centered around the interfaces)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874098416
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874189245:94,Availability,down,downgrade,94,"I am including an update of my notes. Differences of note:. - Doing everything in 2D, but can downgrade to 1D if people feel this is confusing. I thought this would work well with the 2D picture we have already; - Using overline to denote a cell-averaged quantity. I know the code doesn't do this but this is the convention in the literature and seems good to have something to distintuish between cell-average and simply value; - The final answer is indeed in terms of quantities are the edges but the final equation is exact. The approximations come in when we approximate those fluxes using the cell-averaged quantities. We have a bunch of ways of doing this and I for one would like to discuss this more, but thought we should discuss what I have so far before going any further. ![Finite_Volume_Tracer_Equation](https://user-images.githubusercontent.com/8239041/124492299-4222dc80-dd82-11eb-9484-72f57f4f65ff.jpeg)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874189245
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874189245:18,Deployability,update,update,18,"I am including an update of my notes. Differences of note:. - Doing everything in 2D, but can downgrade to 1D if people feel this is confusing. I thought this would work well with the 2D picture we have already; - Using overline to denote a cell-averaged quantity. I know the code doesn't do this but this is the convention in the literature and seems good to have something to distintuish between cell-average and simply value; - The final answer is indeed in terms of quantities are the edges but the final equation is exact. The approximations come in when we approximate those fluxes using the cell-averaged quantities. We have a bunch of ways of doing this and I for one would like to discuss this more, but thought we should discuss what I have so far before going any further. ![Finite_Volume_Tracer_Equation](https://user-images.githubusercontent.com/8239041/124492299-4222dc80-dd82-11eb-9484-72f57f4f65ff.jpeg)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874189245
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874189245:415,Usability,simpl,simply,415,"I am including an update of my notes. Differences of note:. - Doing everything in 2D, but can downgrade to 1D if people feel this is confusing. I thought this would work well with the 2D picture we have already; - Using overline to denote a cell-averaged quantity. I know the code doesn't do this but this is the convention in the literature and seems good to have something to distintuish between cell-average and simply value; - The final answer is indeed in terms of quantities are the edges but the final equation is exact. The approximations come in when we approximate those fluxes using the cell-averaged quantities. We have a bunch of ways of doing this and I for one would like to discuss this more, but thought we should discuss what I have so far before going any further. ![Finite_Volume_Tracer_Equation](https://user-images.githubusercontent.com/8239041/124492299-4222dc80-dd82-11eb-9484-72f57f4f65ff.jpeg)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874189245
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874238564:98,Integrability,mediat,mediate,98,Might make sense to include a diffusive term too? The second-order fluxes are crucial and usually mediate how boundary conditions are prescribed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874238564
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874251284:59,Usability,simpl,simple,59,Good idea @glwagner. Below is a revised copy that includes simple diffusion. If we think this is a good start I can also create a PR with this in the docs. ![Finite_Volume_Tracer_Equation](https://user-images.githubusercontent.com/8239041/124504211-01808e80-dd95-11eb-8225-fe05612ca812.jpeg),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874251284
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874259919:120,Integrability,depend,depend,120,"Nice! We usually use \nu for viscosity and \kappa for diffusivity --- so should we use \kappa here? You can allow it to depend on x, y, z by writing \nabla \cdot (\kappa \nabla c) without loss of generality (it's also nice to see the divergence operator show up twice I think). Thanks for putting this together...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874259919
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874264766:272,Usability,feedback,feedback,272,"My bad, yes, \kappa is much better. Fixed. Also, I rewrote the Laplacian as the divergence of the product of \kappa and the gradient of c. That is also better I agree. Should I put together a PR for this part and then work on the momentum? I'm also happy to wait for more feedback. @navidcy , what do you think?. @glwagner : I will send you a link to the overleaf document.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874264766
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874266567:365,Integrability,interface,interfaces,365,"> Yes. Given the derivation I posted, and what @glwagner said, it seems like we want to be using the velocity at an edge not the cell-averaged values, which is what we are storing as fields. But I could be missing something here. I think we are making a particular choice: because we are using a staggered grid, we can reconstruct the velocity field at tracer cell interfaces simply be evaluating the cell-averaged velocity field there. Perhaps this reconstruction has a particular order of accuracy (eg second-order?) I'm not sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874266567
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874266567:376,Usability,simpl,simply,376,"> Yes. Given the derivation I posted, and what @glwagner said, it seems like we want to be using the velocity at an edge not the cell-averaged values, which is what we are storing as fields. But I could be missing something here. I think we are making a particular choice: because we are using a staggered grid, we can reconstruct the velocity field at tracer cell interfaces simply be evaluating the cell-averaged velocity field there. Perhaps this reconstruction has a particular order of accuracy (eg second-order?) I'm not sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874266567
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874268303:309,Deployability,update,updates,309,"> Should I put together a PR for this part and then work on the momentum? I'm also happy to wait for more feedback. @navidcy , what do you think?. My two cents is that it might be better to add as much content as possible in one PR. I thinks docs PRs can be a bit painful. It's not as crucial either for docs updates that the PRs are tight and focused. I think it's simpler to keep things general for curvilinear grids than to assume constant cell spacings by the way. We should discuss 2D versus 3D a bit more. While 2D is simpler, we will almost certainly need 3D as well at some point (when we resolve #1679). So we can have a ""tutorial"" 2D section, and then a ""fully descriptive"" 3D development --- or we can just do 3D from the start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874268303
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874268303:106,Usability,feedback,feedback,106,"> Should I put together a PR for this part and then work on the momentum? I'm also happy to wait for more feedback. @navidcy , what do you think?. My two cents is that it might be better to add as much content as possible in one PR. I thinks docs PRs can be a bit painful. It's not as crucial either for docs updates that the PRs are tight and focused. I think it's simpler to keep things general for curvilinear grids than to assume constant cell spacings by the way. We should discuss 2D versus 3D a bit more. While 2D is simpler, we will almost certainly need 3D as well at some point (when we resolve #1679). So we can have a ""tutorial"" 2D section, and then a ""fully descriptive"" 3D development --- or we can just do 3D from the start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874268303
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874268303:366,Usability,simpl,simpler,366,"> Should I put together a PR for this part and then work on the momentum? I'm also happy to wait for more feedback. @navidcy , what do you think?. My two cents is that it might be better to add as much content as possible in one PR. I thinks docs PRs can be a bit painful. It's not as crucial either for docs updates that the PRs are tight and focused. I think it's simpler to keep things general for curvilinear grids than to assume constant cell spacings by the way. We should discuss 2D versus 3D a bit more. While 2D is simpler, we will almost certainly need 3D as well at some point (when we resolve #1679). So we can have a ""tutorial"" 2D section, and then a ""fully descriptive"" 3D development --- or we can just do 3D from the start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874268303
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874268303:524,Usability,simpl,simpler,524,"> Should I put together a PR for this part and then work on the momentum? I'm also happy to wait for more feedback. @navidcy , what do you think?. My two cents is that it might be better to add as much content as possible in one PR. I thinks docs PRs can be a bit painful. It's not as crucial either for docs updates that the PRs are tight and focused. I think it's simpler to keep things general for curvilinear grids than to assume constant cell spacings by the way. We should discuss 2D versus 3D a bit more. While 2D is simpler, we will almost certainly need 3D as well at some point (when we resolve #1679). So we can have a ""tutorial"" 2D section, and then a ""fully descriptive"" 3D development --- or we can just do 3D from the start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874268303
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874270864:165,Deployability,integrat,integrate,165,"I'm still trying to figure out exactly how to go from cell value to cell-averaged value and back again. The forward approach is the quadrature scheme that we use to integrate on our cells. The backwards approach is the reconstructor. The standard choices that I've seen are to assume that the function is constant, linear and parabolic on each cell. If it's constant then the two coincide and there is nothing to worry about, but I presume this yields a lower order of accuracy. ; On top of what , we then have another choice on how to choose the flux based on the advection scheme. . Can you help me figure out what we are using as a reconstruction?. Everything else you suggest sounds good to me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874270864
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874270864:165,Integrability,integrat,integrate,165,"I'm still trying to figure out exactly how to go from cell value to cell-averaged value and back again. The forward approach is the quadrature scheme that we use to integrate on our cells. The backwards approach is the reconstructor. The standard choices that I've seen are to assume that the function is constant, linear and parabolic on each cell. If it's constant then the two coincide and there is nothing to worry about, but I presume this yields a lower order of accuracy. ; On top of what , we then have another choice on how to choose the flux based on the advection scheme. . Can you help me figure out what we are using as a reconstruction?. Everything else you suggest sounds good to me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874270864
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874283792:122,Integrability,depend,depends,122,"> Can you help me figure out what we are using as a reconstruction?. For the velocity field or tracer?. For the tracer it depends on the advection scheme. For the velocity field, I think our method is consistent with either a constant or linear reconstruction. I'm not sure about higher. Not that if we use a different reconstruction for computing tracer fluxes, we'd have to use the same reconstruction for calculating the divergence of the velocity field so that they are consistent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874283792
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874305803:177,Usability,feedback,feedback,177,"> My bad, yes, \kappa is much better. Fixed. omg, **definitely** κ :). > Should I put together a PR for this part and then work on the momentum? I'm also happy to wait for more feedback. @navidcy , what do you think?. Yeap, why not. Start a PR. > @glwagner : I will send you a link to the overleaf document. Add me to that. Or better just start the PR and we can all edit there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874305803
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290:184,Integrability,interface,interfaces,184,"OK. Sorry for not chiming in earlier @francispoulin, but indeed you are correct. The derivation you have for the advective terms of the tracer equation requires, e.g., u at the cell's interfaces. But we don't have those values, as you point out. In a finite volume formulation we only have the cell-averages of u around cells with centers the cell interfaces. But there is a way to reconstruct the value of u @ the interface from knowledge of the cell-averages of ū. This is usually referred as ""Reconstruction"" (section 2 of Shu 2009). I guess the best way to reconstruct u @ interface from all ū's is to take u as the cell average of ū at the particular cell? Have to think a bit on that (and wait for the coffee to kick in), but I guess this holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290:348,Integrability,interface,interfaces,348,"OK. Sorry for not chiming in earlier @francispoulin, but indeed you are correct. The derivation you have for the advective terms of the tracer equation requires, e.g., u at the cell's interfaces. But we don't have those values, as you point out. In a finite volume formulation we only have the cell-averages of u around cells with centers the cell interfaces. But there is a way to reconstruct the value of u @ the interface from knowledge of the cell-averages of ū. This is usually referred as ""Reconstruction"" (section 2 of Shu 2009). I guess the best way to reconstruct u @ interface from all ū's is to take u as the cell average of ū at the particular cell? Have to think a bit on that (and wait for the coffee to kick in), but I guess this holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290:415,Integrability,interface,interface,415,"OK. Sorry for not chiming in earlier @francispoulin, but indeed you are correct. The derivation you have for the advective terms of the tracer equation requires, e.g., u at the cell's interfaces. But we don't have those values, as you point out. In a finite volume formulation we only have the cell-averages of u around cells with centers the cell interfaces. But there is a way to reconstruct the value of u @ the interface from knowledge of the cell-averages of ū. This is usually referred as ""Reconstruction"" (section 2 of Shu 2009). I guess the best way to reconstruct u @ interface from all ū's is to take u as the cell average of ū at the particular cell? Have to think a bit on that (and wait for the coffee to kick in), but I guess this holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290:577,Integrability,interface,interface,577,"OK. Sorry for not chiming in earlier @francispoulin, but indeed you are correct. The derivation you have for the advective terms of the tracer equation requires, e.g., u at the cell's interfaces. But we don't have those values, as you point out. In a finite volume formulation we only have the cell-averages of u around cells with centers the cell interfaces. But there is a way to reconstruct the value of u @ the interface from knowledge of the cell-averages of ū. This is usually referred as ""Reconstruction"" (section 2 of Shu 2009). I guess the best way to reconstruct u @ interface from all ū's is to take u as the cell average of ū at the particular cell? Have to think a bit on that (and wait for the coffee to kick in), but I guess this holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290
https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874314460:165,Modifiability,flexible,flexible,165,"@navidcy . I just sent you an invite to the overleaf document. I thought maybe we want to have both the tracer and momentum equations before we create a PR, but I'm flexible. Thanks also for the reference. I remember seeing this paper before and liking it so I will look at it again. It seems that our advection schemes use the cell-averaged velocity to approximate the velocity at the edge. This is a perfectly valid choice and corresponds to a certain order of accuracy. I don't know what that is but I imagine using more cell averaged velocities would give a higher order accuracy. I'm not suggesting we do this, but I'm just trying to get a better understanding of the order of accuracy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874314460
https://github.com/CliMA/Oceananigans.jl/issues/1320#issuecomment-768400642:127,Testability,test,test,127,I'm not against a proliferation of advection schemes. We should probably not merge new advection schemes without a convergence test though?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1320#issuecomment-768400642
https://github.com/CliMA/Oceananigans.jl/issues/1320#issuecomment-768404599:71,Security,validat,validation,71,"Thanks @ali-ramadhan and I agree completely. When I was working on the validation schemes I did test these schemes outside of Oceananigans and they did produce the correct slopes of -1 and -6. Sixth order accuracy could actually be attractive for some applications. Getting first order from upwinding may not sound llike much but it does ensure positivity, which might also be helpful for some cases where you want to ensure tracer concentrations are non-negative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1320#issuecomment-768404599
https://github.com/CliMA/Oceananigans.jl/issues/1320#issuecomment-768404599:96,Testability,test,test,96,"Thanks @ali-ramadhan and I agree completely. When I was working on the validation schemes I did test these schemes outside of Oceananigans and they did produce the correct slopes of -1 and -6. Sixth order accuracy could actually be attractive for some applications. Getting first order from upwinding may not sound llike much but it does ensure positivity, which might also be helpful for some cases where you want to ensure tracer concentrations are non-negative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1320#issuecomment-768404599
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768625302:86,Testability,test,tested,86,"Hmmm, maybe more of a question for @glwagner but can you nest `ComputedField`s (is it tested?)? I think I always passed an abstract operation to a `ComputedField`. So I might try. ```julia; u_tot = u + U; b_tot = b + B. Ro_abs = ComputedField(-∂y(u_tot) / f0); Ri_abs = ComputedField(∂z(b_tot) / (∂z(u_tot)^2)); dbdz_abs = ComputedField(∂z(b_tot)); dudz_abs = ComputedField(∂z(u_tot)); Ri_abs2 = ComputedField(∂z(b_tot) / ∂z(u_tot)^2); ```. Otherwise might help to describe how `compute!(Ri_abs)` and `compute!(Ri_abs2)` are different from `Ri_cons`, e.g. is it completely wrong, factor of 2, only wrong at the boundary, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768625302
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768639056:330,Availability,error,error,330,"> Hmmm, maybe more of a question for @glwagner but can you nest ComputedFields (is it tested?)?. It appears you're right, that at least some of the problem comes from nested `ComputedField`s. (I need to run more tests later to be sure). If nesting `ComputedField`s isn't allowed and can't be made to work, I'd suggest throwing an error if possible. However, nesting `ComputedField`s seems like a pretty useful feature to have. My talks with @glwagner over `KernelComputedField` lead me to believe that it's possible to make that work, no?. > Otherwise might help to describe how compute!(Ri_abs) and compute!(Ri_abs2) are different from Ri_cons, e.g. is it completely wrong, factor of 2, only wrong at the boundary, etc. @ali-ramadhan I provided my full example in the last sentence of my question!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768639056
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768639056:86,Testability,test,tested,86,"> Hmmm, maybe more of a question for @glwagner but can you nest ComputedFields (is it tested?)?. It appears you're right, that at least some of the problem comes from nested `ComputedField`s. (I need to run more tests later to be sure). If nesting `ComputedField`s isn't allowed and can't be made to work, I'd suggest throwing an error if possible. However, nesting `ComputedField`s seems like a pretty useful feature to have. My talks with @glwagner over `KernelComputedField` lead me to believe that it's possible to make that work, no?. > Otherwise might help to describe how compute!(Ri_abs) and compute!(Ri_abs2) are different from Ri_cons, e.g. is it completely wrong, factor of 2, only wrong at the boundary, etc. @ali-ramadhan I provided my full example in the last sentence of my question!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768639056
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768639056:212,Testability,test,tests,212,"> Hmmm, maybe more of a question for @glwagner but can you nest ComputedFields (is it tested?)?. It appears you're right, that at least some of the problem comes from nested `ComputedField`s. (I need to run more tests later to be sure). If nesting `ComputedField`s isn't allowed and can't be made to work, I'd suggest throwing an error if possible. However, nesting `ComputedField`s seems like a pretty useful feature to have. My talks with @glwagner over `KernelComputedField` lead me to believe that it's possible to make that work, no?. > Otherwise might help to describe how compute!(Ri_abs) and compute!(Ri_abs2) are different from Ri_cons, e.g. is it completely wrong, factor of 2, only wrong at the boundary, etc. @ali-ramadhan I provided my full example in the last sentence of my question!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768639056
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768780674:459,Availability,error,error,459,"> @tomchor not sure this helps... Thanks for answer! I understand that apparently the issue is having a function in an `AbstractOperation`, right? I'm confused as to why this wasn't a problem in your example though (boundaries aside, of course). My main question is: if this is indeed a limitation, is there any interest in improving/changing this in any way? From the point of view of a naive user like myself, it's odd that I can add two things without any error/warning, they get calculated normally, and then in the end the result is wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768780674
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769240410:393,Usability,simpl,simplify,393,"Both `Function`s and `FunctionField`s are supposed to be supported in `AbstractOperation`s. In fact, supporting `Function`s in `AbstractOperations` is the original purpose of `FunctionField`. For example, see:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/AbstractOperations/binary_operations.jl#L80-L82. Though I appreciate you may have tried to simplify your code from some original example to produce an MWE, I think it's still a bit complicated to diagnose the issue. I've shown that you can construct a `ComputedField` using a `Derivative` acting on a `BinaryOperation` between a concrete `Field` and `FunctionField`. What ingredient(s) do we need to add to my example to break it? What specifically is going wrong?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769240410
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769359851:200,Usability,simpl,simplify,200,"> I think it's definitely possible you've run across some kind of bug, I'm just having trouble figuring out what the bug might be because there's a lot going on in these examples. Got it! I'll try to simplify it more whenever I have time. > I think your syntax is wrong for KernelComputedField, because u_tot is not an AbstractField, it is an AbstractOperation. I'm passing `u_tot` as a field_dependency when calculating `Ro` and `Ri`, and those work fine! The PV calculation is the only that fails. Are you saying that `Ri` and `Ro` (and possibly `u_tot`?) should be passed with the `parameters` keyword? Or are you saying that I can't nest `KernelComputedField`s in the first place?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769359851
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594:56,Integrability,interface,interface,56,"Well, this is interesting. I guess when we designed the interface for `KernelComputedField` I envisioned that `field_dependencies` would be a list of `AbstractField`s (hence the name). The point is that `compute!(element)` is called on every `element` of `field_dependencies`. `u_tot` is not a field, its an `AbstractOperation`. The interesting thing is that `compute!(u_tot)` can actually do something, because `compute!` is _also_ defined for `AbstractOperations` (if `u_tot` has any `ComputedField`s in its tree, they get computed). This is a use case I didn't think of. Other objects in `field_dependencies` (like integers, floating point numbers) are ok because there's a fallback `compute!(arbitrary_object) = nothing`. However, I don't like allowing this because it makes scripts confusing to read. An integer is an ""integer dependency"" (or just a ""dependency"") --- not a ""field dependency"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594:832,Integrability,depend,dependency,832,"Well, this is interesting. I guess when we designed the interface for `KernelComputedField` I envisioned that `field_dependencies` would be a list of `AbstractField`s (hence the name). The point is that `compute!(element)` is called on every `element` of `field_dependencies`. `u_tot` is not a field, its an `AbstractOperation`. The interesting thing is that `compute!(u_tot)` can actually do something, because `compute!` is _also_ defined for `AbstractOperations` (if `u_tot` has any `ComputedField`s in its tree, they get computed). This is a use case I didn't think of. Other objects in `field_dependencies` (like integers, floating point numbers) are ok because there's a fallback `compute!(arbitrary_object) = nothing`. However, I don't like allowing this because it makes scripts confusing to read. An integer is an ""integer dependency"" (or just a ""dependency"") --- not a ""field dependency"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594:856,Integrability,depend,dependency,856,"Well, this is interesting. I guess when we designed the interface for `KernelComputedField` I envisioned that `field_dependencies` would be a list of `AbstractField`s (hence the name). The point is that `compute!(element)` is called on every `element` of `field_dependencies`. `u_tot` is not a field, its an `AbstractOperation`. The interesting thing is that `compute!(u_tot)` can actually do something, because `compute!` is _also_ defined for `AbstractOperations` (if `u_tot` has any `ComputedField`s in its tree, they get computed). This is a use case I didn't think of. Other objects in `field_dependencies` (like integers, floating point numbers) are ok because there's a fallback `compute!(arbitrary_object) = nothing`. However, I don't like allowing this because it makes scripts confusing to read. An integer is an ""integer dependency"" (or just a ""dependency"") --- not a ""field dependency"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594:886,Integrability,depend,dependency,886,"Well, this is interesting. I guess when we designed the interface for `KernelComputedField` I envisioned that `field_dependencies` would be a list of `AbstractField`s (hence the name). The point is that `compute!(element)` is called on every `element` of `field_dependencies`. `u_tot` is not a field, its an `AbstractOperation`. The interesting thing is that `compute!(u_tot)` can actually do something, because `compute!` is _also_ defined for `AbstractOperations` (if `u_tot` has any `ComputedField`s in its tree, they get computed). This is a use case I didn't think of. Other objects in `field_dependencies` (like integers, floating point numbers) are ok because there's a fallback `compute!(arbitrary_object) = nothing`. However, I don't like allowing this because it makes scripts confusing to read. An integer is an ""integer dependency"" (or just a ""dependency"") --- not a ""field dependency"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426:43,Integrability,depend,dependency,43,"I think maybe you were interpreting ""field dependency"" as meaning ""a dependency of `KernelComputedField`"", rather than ""a dependency that _itself_ is a field""... ? It's the latter definition that I was thinking of; that's why we call `compute!` on its elements.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426:69,Integrability,depend,dependency,69,"I think maybe you were interpreting ""field dependency"" as meaning ""a dependency of `KernelComputedField`"", rather than ""a dependency that _itself_ is a field""... ? It's the latter definition that I was thinking of; that's why we call `compute!` on its elements.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426:122,Integrability,depend,dependency,122,"I think maybe you were interpreting ""field dependency"" as meaning ""a dependency of `KernelComputedField`"", rather than ""a dependency that _itself_ is a field""... ? It's the latter definition that I was thinking of; that's why we call `compute!` on its elements.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769389205:512,Integrability,depend,dependency,512,"There might be an issue with conditional computations but I'm not sure. For example, `ComputedField` has this `compute!` definition:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/computed_field.jl#L61-L62. I think we want something similar; eg we want the `time` argument in `KernelComputedField`:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/kernel_computed_field.jl#L76. and we want to use `compute_at!(dependency, time)` here:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/kernel_computed_field.jl#L78-L80",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769389205
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769546284:414,Usability,Simpl,Simple,414,"I appreciate the help, @glwagner. There's a lot to go through here so let's go little by little. @ali-ramadhan 's suggestion was right. Removing `ComputedField` from the definition of `u_tot` did the trick for my calculations. It seems that complexity is the limiting factor here. For example, this works. ```julia; u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). dbdz_abs = ComputedField(∂z(b_tot)) # Simple; dudz_abs = ComputedField(∂z(u_tot)) # Simple; Ri_abs2 = ComputedField(dbdz_abs/ dudz^2) # Try Ri again with but using other ComputedFields; compute!(Ri_abs2); ```. But trying to do all the calculations in one go fails for some reason:. ```julia; u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). Ri_abs = ComputedField(∂z(b_tot) / ∂z(u_tot)^2) # More complex; ```. The above code computes something, but it's the wrong result. (Curiously the result it computes is numerically the same as the calculation of the Rossby number in the same script, which may be a clue.). Here's my [Minimum Working Example](https://pastebin.com/v3hMpCWQ) made simpler. Hopefully it's easier to understand what's going on. There's a switch when defining `u_tot` to flip between an `AbstractOperation` definition and a `ComputedField` one. I think this is interesting behavior, and it's kinda dangerous since it fails silently. Can you guys confirm that you can reproduce the behavior?. I think I'll open another issue for the `KernelComputedField` stuff since I think it's something different.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769546284
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769546284:460,Usability,Simpl,Simple,460,"I appreciate the help, @glwagner. There's a lot to go through here so let's go little by little. @ali-ramadhan 's suggestion was right. Removing `ComputedField` from the definition of `u_tot` did the trick for my calculations. It seems that complexity is the limiting factor here. For example, this works. ```julia; u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). dbdz_abs = ComputedField(∂z(b_tot)) # Simple; dudz_abs = ComputedField(∂z(u_tot)) # Simple; Ri_abs2 = ComputedField(dbdz_abs/ dudz^2) # Try Ri again with but using other ComputedFields; compute!(Ri_abs2); ```. But trying to do all the calculations in one go fails for some reason:. ```julia; u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). Ri_abs = ComputedField(∂z(b_tot) / ∂z(u_tot)^2) # More complex; ```. The above code computes something, but it's the wrong result. (Curiously the result it computes is numerically the same as the calculation of the Rossby number in the same script, which may be a clue.). Here's my [Minimum Working Example](https://pastebin.com/v3hMpCWQ) made simpler. Hopefully it's easier to understand what's going on. There's a switch when defining `u_tot` to flip between an `AbstractOperation` definition and a `ComputedField` one. I think this is interesting behavior, and it's kinda dangerous since it fails silently. Can you guys confirm that you can reproduce the behavior?. I think I'll open another issue for the `KernelComputedField` stuff since I think it's something different.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769546284
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769546284:1072,Usability,simpl,simpler,1072,"I appreciate the help, @glwagner. There's a lot to go through here so let's go little by little. @ali-ramadhan 's suggestion was right. Removing `ComputedField` from the definition of `u_tot` did the trick for my calculations. It seems that complexity is the limiting factor here. For example, this works. ```julia; u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). dbdz_abs = ComputedField(∂z(b_tot)) # Simple; dudz_abs = ComputedField(∂z(u_tot)) # Simple; Ri_abs2 = ComputedField(dbdz_abs/ dudz^2) # Try Ri again with but using other ComputedFields; compute!(Ri_abs2); ```. But trying to do all the calculations in one go fails for some reason:. ```julia; u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). Ri_abs = ComputedField(∂z(b_tot) / ∂z(u_tot)^2) # More complex; ```. The above code computes something, but it's the wrong result. (Curiously the result it computes is numerically the same as the calculation of the Rossby number in the same script, which may be a clue.). Here's my [Minimum Working Example](https://pastebin.com/v3hMpCWQ) made simpler. Hopefully it's easier to understand what's going on. There's a switch when defining `u_tot` to flip between an `AbstractOperation` definition and a `ComputedField` one. I think this is interesting behavior, and it's kinda dangerous since it fails silently. Can you guys confirm that you can reproduce the behavior?. I think I'll open another issue for the `KernelComputedField` stuff since I think it's something different.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769546284
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445:32,Integrability,message,messages,32,"@glwagner Sorry, I missed these messages and just saw them now. I further inspected the code and it seems that the discrepancy comes from having one of the directions with `size=1`, simulating a `Flat` dimension. I'm not sure how worrisome this issue is given that you have PR https://github.com/CliMA/Oceananigans.jl/pull/1340, which may address this issue? . So, for example, consider the code block below (btw, I'm sorry that my examples are large, but I don't quite know how to create fields with BCs very well without creating a model behind it...):. ```julia; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Fields. # Get simulation parameters; f0 = 1e-4; dudy = -1.25e-4; dudz = -4e-3; dbdz = 1e-5. #++++ GRID; topology = (Periodic, Bounded, Bounded); grid = RegularCartesianGrid(size=(1, 4, 4), extent=(1000, 1000, 200),; topology=topology). # Define our model!; u_g(x, y, z, t) = dudy * y + dudz * z; b_g(x, y, z, t) = dbdz * z; model = IncompressibleModel(architecture = CPU(),; grid = grid,; tracers = (:b,),; buoyancy = BuoyancyTracer(),; background_fields = (u=u_g, b=b_g,),; ). # START DIAGNOSTICS; import Oceananigans.Fields: ComputedField; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z. u, v, w = model.velocities; b = model.tracers.b. U = model.background_fields.velocities.u; B = model.background_fields.tracers.b. u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). # Get correct constant values; Ri_true = dbdz / dudz^2. # Abstract operations tests; Ri_abs = ComputedField(∂z(b_tot) / ∂z(u_tot)^2) # More complex. dbdz_abs = ComputedField(∂z(b_tot)) # Simple; dudz_abs = ComputedField(∂z(u_tot)) # Simple; Ri_abs2 = ComputedField(dbdz_abs/ dudz^2) # Try Ri again with but using other ComputedFields; ; compute!(Ri_abs); compute!(Ri_abs2); ```. In the code above `Ri_abs2` gets calculated correctly, but `Ri_abs` does not:. ```julia; julia> Ri_true; 0.6250000000000001. julia> interior(Ri_abs2); 1×4×5 view(OffsetArray(::Array{Float64,3}, 0:2, 0:5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445:1497,Testability,test,tests,1497,"ut creating a model behind it...):. ```julia; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Fields. # Get simulation parameters; f0 = 1e-4; dudy = -1.25e-4; dudz = -4e-3; dbdz = 1e-5. #++++ GRID; topology = (Periodic, Bounded, Bounded); grid = RegularCartesianGrid(size=(1, 4, 4), extent=(1000, 1000, 200),; topology=topology). # Define our model!; u_g(x, y, z, t) = dudy * y + dudz * z; b_g(x, y, z, t) = dbdz * z; model = IncompressibleModel(architecture = CPU(),; grid = grid,; tracers = (:b,),; buoyancy = BuoyancyTracer(),; background_fields = (u=u_g, b=b_g,),; ). # START DIAGNOSTICS; import Oceananigans.Fields: ComputedField; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z. u, v, w = model.velocities; b = model.tracers.b. U = model.background_fields.velocities.u; B = model.background_fields.tracers.b. u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). # Get correct constant values; Ri_true = dbdz / dudz^2. # Abstract operations tests; Ri_abs = ComputedField(∂z(b_tot) / ∂z(u_tot)^2) # More complex. dbdz_abs = ComputedField(∂z(b_tot)) # Simple; dudz_abs = ComputedField(∂z(u_tot)) # Simple; Ri_abs2 = ComputedField(dbdz_abs/ dudz^2) # Try Ri again with but using other ComputedFields; ; compute!(Ri_abs); compute!(Ri_abs2); ```. In the code above `Ri_abs2` gets calculated correctly, but `Ri_abs` does not:. ```julia; julia> Ri_true; 0.6250000000000001. julia> interior(Ri_abs2); 1×4×5 view(OffsetArray(::Array{Float64,3}, 0:2, 0:5, 0:6), 1:1, 1:4, 1:5) with eltype Float64:; [:, :, 1] =; -2.1875 -2.1875 -2.1875 -2.1875. [:, :, 2] =; 0.625 0.625 0.625 0.625. [:, :, 3] =; 0.625 0.625 0.625 0.625. [:, :, 4] =; 0.625 0.625 0.625 0.625. [:, :, 5] =; 0.3125 0.3125 0.3125 0.3125. julia> interior(Ri_abs); 1×4×5 view(OffsetArray(::Array{Float64,3}, 0:2, 0:5, 0:6), 1:1, 1:4, 1:5) with eltype Float64:; [:, :, 1] =; -0.373637 -0.410247 -0.452514 -0.501666. [:, :, 2] =; 1.25 1.25 1.25 1.25. [:, :, 3] =; 1.25 1.25 1.25 1.25. [:, :, 4] =; 1.25 1.25 1.25 1.2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445:1606,Usability,Simpl,Simple,1606,"y = -1.25e-4; dudz = -4e-3; dbdz = 1e-5. #++++ GRID; topology = (Periodic, Bounded, Bounded); grid = RegularCartesianGrid(size=(1, 4, 4), extent=(1000, 1000, 200),; topology=topology). # Define our model!; u_g(x, y, z, t) = dudy * y + dudz * z; b_g(x, y, z, t) = dbdz * z; model = IncompressibleModel(architecture = CPU(),; grid = grid,; tracers = (:b,),; buoyancy = BuoyancyTracer(),; background_fields = (u=u_g, b=b_g,),; ). # START DIAGNOSTICS; import Oceananigans.Fields: ComputedField; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z. u, v, w = model.velocities; b = model.tracers.b. U = model.background_fields.velocities.u; B = model.background_fields.tracers.b. u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). # Get correct constant values; Ri_true = dbdz / dudz^2. # Abstract operations tests; Ri_abs = ComputedField(∂z(b_tot) / ∂z(u_tot)^2) # More complex. dbdz_abs = ComputedField(∂z(b_tot)) # Simple; dudz_abs = ComputedField(∂z(u_tot)) # Simple; Ri_abs2 = ComputedField(dbdz_abs/ dudz^2) # Try Ri again with but using other ComputedFields; ; compute!(Ri_abs); compute!(Ri_abs2); ```. In the code above `Ri_abs2` gets calculated correctly, but `Ri_abs` does not:. ```julia; julia> Ri_true; 0.6250000000000001. julia> interior(Ri_abs2); 1×4×5 view(OffsetArray(::Array{Float64,3}, 0:2, 0:5, 0:6), 1:1, 1:4, 1:5) with eltype Float64:; [:, :, 1] =; -2.1875 -2.1875 -2.1875 -2.1875. [:, :, 2] =; 0.625 0.625 0.625 0.625. [:, :, 3] =; 0.625 0.625 0.625 0.625. [:, :, 4] =; 0.625 0.625 0.625 0.625. [:, :, 5] =; 0.3125 0.3125 0.3125 0.3125. julia> interior(Ri_abs); 1×4×5 view(OffsetArray(::Array{Float64,3}, 0:2, 0:5, 0:6), 1:1, 1:4, 1:5) with eltype Float64:; [:, :, 1] =; -0.373637 -0.410247 -0.452514 -0.501666. [:, :, 2] =; 1.25 1.25 1.25 1.25. [:, :, 3] =; 1.25 1.25 1.25 1.25. [:, :, 4] =; 1.25 1.25 1.25 1.25. [:, :, 5] =; 3.51166 8.85813 52.2449 284.444; ```. This may be related to #1130, but then again there are no derivatives or interpolations at the boundary in ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445
https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445:1652,Usability,Simpl,Simple,1652,"y = -1.25e-4; dudz = -4e-3; dbdz = 1e-5. #++++ GRID; topology = (Periodic, Bounded, Bounded); grid = RegularCartesianGrid(size=(1, 4, 4), extent=(1000, 1000, 200),; topology=topology). # Define our model!; u_g(x, y, z, t) = dudy * y + dudz * z; b_g(x, y, z, t) = dbdz * z; model = IncompressibleModel(architecture = CPU(),; grid = grid,; tracers = (:b,),; buoyancy = BuoyancyTracer(),; background_fields = (u=u_g, b=b_g,),; ). # START DIAGNOSTICS; import Oceananigans.Fields: ComputedField; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z. u, v, w = model.velocities; b = model.tracers.b. U = model.background_fields.velocities.u; B = model.background_fields.tracers.b. u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). # Get correct constant values; Ri_true = dbdz / dudz^2. # Abstract operations tests; Ri_abs = ComputedField(∂z(b_tot) / ∂z(u_tot)^2) # More complex. dbdz_abs = ComputedField(∂z(b_tot)) # Simple; dudz_abs = ComputedField(∂z(u_tot)) # Simple; Ri_abs2 = ComputedField(dbdz_abs/ dudz^2) # Try Ri again with but using other ComputedFields; ; compute!(Ri_abs); compute!(Ri_abs2); ```. In the code above `Ri_abs2` gets calculated correctly, but `Ri_abs` does not:. ```julia; julia> Ri_true; 0.6250000000000001. julia> interior(Ri_abs2); 1×4×5 view(OffsetArray(::Array{Float64,3}, 0:2, 0:5, 0:6), 1:1, 1:4, 1:5) with eltype Float64:; [:, :, 1] =; -2.1875 -2.1875 -2.1875 -2.1875. [:, :, 2] =; 0.625 0.625 0.625 0.625. [:, :, 3] =; 0.625 0.625 0.625 0.625. [:, :, 4] =; 0.625 0.625 0.625 0.625. [:, :, 5] =; 0.3125 0.3125 0.3125 0.3125. julia> interior(Ri_abs); 1×4×5 view(OffsetArray(::Array{Float64,3}, 0:2, 0:5, 0:6), 1:1, 1:4, 1:5) with eltype Float64:; [:, :, 1] =; -0.373637 -0.410247 -0.452514 -0.501666. [:, :, 2] =; 1.25 1.25 1.25 1.25. [:, :, 3] =; 1.25 1.25 1.25 1.25. [:, :, 4] =; 1.25 1.25 1.25 1.25. [:, :, 5] =; 3.51166 8.85813 52.2449 284.444; ```. This may be related to #1130, but then again there are no derivatives or interpolations at the boundary in ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445
https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-769920640:2692,Availability,error,error,2692,"1 2.5e-11 2.5e-11 … 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11. ... [:, :, 15] =; 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 … 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11. [:, :, 16] =; 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 … 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11. [:, :, 17] =; -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 … -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10. julia> interior(PV_kern_notint); 1×64×17 view(OffsetArray(::Array{Float64,3}, 0:2, 0:65, 0:18), 1:1, 1:64, 1:17) with eltype Float64:; [:, :, 1] =; 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 … 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10. [:, :, 2] =; 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 … 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10. [:, :, 3] =; 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 … 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10. ... [:, :, 15] =; 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 … 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10. [:, :, 16] =; 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 … 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10. [:, :, 17] =; -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 … -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10. julia> PV_true; 6.500000000000004e-10; ```. So as you can see this doesn't look like a numerical error. I feel like I'm missing something kinda obvious here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-769920640
https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-770039548:162,Integrability,rout,routines,162,Thanks! You're right about the periodic condition and the halo region. Switching to a `8x8x8` did the trick! Although I would have thought that the interpolation routines appropriately calculated the fields at the periodic boundary. Is this expected behavior or a bug?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-770039548
https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769909121:17,Deployability,pipeline,pipeline,17,Sorry validation pipeline was accidently triggered so I canceled it. Fixed it so shouldn't happen in the future.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769909121
https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769909121:6,Security,validat,validation,6,Sorry validation pipeline was accidently triggered so I canceled it. Fixed it so shouldn't happen in the future.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769909121
https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769911007:19,Deployability,pipeline,pipeline,19,> Sorry validation pipeline was accidently triggered so I canceled it. Fixed it so shouldn't happen in the future. Does that mean it will retry the tests?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769911007
https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769911007:8,Security,validat,validation,8,> Sorry validation pipeline was accidently triggered so I canceled it. Fixed it so shouldn't happen in the future. Does that mean it will retry the tests?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769911007
https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769911007:148,Testability,test,tests,148,> Sorry validation pipeline was accidently triggered so I canceled it. Fixed it so shouldn't happen in the future. Does that mean it will retry the tests?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769911007
https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769956405:35,Testability,test,tests,35,> Does that mean it will retry the tests?. Ah no unfortunately it still says failed on some checks since they were canceled but all regular Oceananigans tests passed so should be good to merge! https://buildkite.com/clima/oceananigans/builds/1018,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769956405
https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769956405:153,Testability,test,tests,153,> Does that mean it will retry the tests?. Ah no unfortunately it still says failed on some checks since they were canceled but all regular Oceananigans tests passed so should be good to merge! https://buildkite.com/clima/oceananigans/builds/1018,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769956405
https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975:29,Availability,error,error,29,"Also, I noticed there was an error at the very beginning, copied below. ```; TEST_GROUP=shallow_water julia --project -e 'using Pkg; Pkg.test()'; Testing Oceananigans; ┌ Error: Pkg.Resolve.ResolverError(""Unsatisfiable requirements detected for package JLLWrappers [692b3bcd]:\n JLLWrappers [692b3bcd] log:\n ├─possible versions are: [1.0.0-1.0.2, 1.1.0-1.1.4, 1.2.0] or uninstalled\n ├─restricted to versions 1.1.3 by an explicit requirement, leaving only versions 1.1.3\n └─restricted by compatibility requirements with IntelOpenMP_jll [1d5cc7b8] to versions: 1.2.0 — no versions left\n └─IntelOpenMP_jll [1d5cc7b8] log:\n ├─possible versions are: 2018.0.3 or uninstalled\n └─restricted to versions 2018.0.3 by an explicit requirement, leaving only versions 2018.0.3"", nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975
https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975:170,Availability,Error,Error,170,"Also, I noticed there was an error at the very beginning, copied below. ```; TEST_GROUP=shallow_water julia --project -e 'using Pkg; Pkg.test()'; Testing Oceananigans; ┌ Error: Pkg.Resolve.ResolverError(""Unsatisfiable requirements detected for package JLLWrappers [692b3bcd]:\n JLLWrappers [692b3bcd] log:\n ├─possible versions are: [1.0.0-1.0.2, 1.1.0-1.1.4, 1.2.0] or uninstalled\n ├─restricted to versions 1.1.3 by an explicit requirement, leaving only versions 1.1.3\n └─restricted by compatibility requirements with IntelOpenMP_jll [1d5cc7b8] to versions: 1.2.0 — no versions left\n └─IntelOpenMP_jll [1d5cc7b8] log:\n ├─possible versions are: 2018.0.3 or uninstalled\n └─restricted to versions 2018.0.3 by an explicit requirement, leaving only versions 2018.0.3"", nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975
https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975:231,Safety,detect,detected,231,"Also, I noticed there was an error at the very beginning, copied below. ```; TEST_GROUP=shallow_water julia --project -e 'using Pkg; Pkg.test()'; Testing Oceananigans; ┌ Error: Pkg.Resolve.ResolverError(""Unsatisfiable requirements detected for package JLLWrappers [692b3bcd]:\n JLLWrappers [692b3bcd] log:\n ├─possible versions are: [1.0.0-1.0.2, 1.1.0-1.1.4, 1.2.0] or uninstalled\n ├─restricted to versions 1.1.3 by an explicit requirement, leaving only versions 1.1.3\n └─restricted by compatibility requirements with IntelOpenMP_jll [1d5cc7b8] to versions: 1.2.0 — no versions left\n └─IntelOpenMP_jll [1d5cc7b8] log:\n ├─possible versions are: 2018.0.3 or uninstalled\n └─restricted to versions 2018.0.3 by an explicit requirement, leaving only versions 2018.0.3"", nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975
https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975:137,Testability,test,test,137,"Also, I noticed there was an error at the very beginning, copied below. ```; TEST_GROUP=shallow_water julia --project -e 'using Pkg; Pkg.test()'; Testing Oceananigans; ┌ Error: Pkg.Resolve.ResolverError(""Unsatisfiable requirements detected for package JLLWrappers [692b3bcd]:\n JLLWrappers [692b3bcd] log:\n ├─possible versions are: [1.0.0-1.0.2, 1.1.0-1.1.4, 1.2.0] or uninstalled\n ├─restricted to versions 1.1.3 by an explicit requirement, leaving only versions 1.1.3\n └─restricted by compatibility requirements with IntelOpenMP_jll [1d5cc7b8] to versions: 1.2.0 — no versions left\n └─IntelOpenMP_jll [1d5cc7b8] log:\n ├─possible versions are: 2018.0.3 or uninstalled\n └─restricted to versions 2018.0.3 by an explicit requirement, leaving only versions 2018.0.3"", nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975
https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975:146,Testability,Test,Testing,146,"Also, I noticed there was an error at the very beginning, copied below. ```; TEST_GROUP=shallow_water julia --project -e 'using Pkg; Pkg.test()'; Testing Oceananigans; ┌ Error: Pkg.Resolve.ResolverError(""Unsatisfiable requirements detected for package JLLWrappers [692b3bcd]:\n JLLWrappers [692b3bcd] log:\n ├─possible versions are: [1.0.0-1.0.2, 1.1.0-1.1.4, 1.2.0] or uninstalled\n ├─restricted to versions 1.1.3 by an explicit requirement, leaving only versions 1.1.3\n └─restricted by compatibility requirements with IntelOpenMP_jll [1d5cc7b8] to versions: 1.2.0 — no versions left\n └─IntelOpenMP_jll [1d5cc7b8] log:\n ├─possible versions are: 2018.0.3 or uninstalled\n └─restricted to versions 2018.0.3 by an explicit requirement, leaving only versions 2018.0.3"", nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975
https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975:301,Testability,log,log,301,"Also, I noticed there was an error at the very beginning, copied below. ```; TEST_GROUP=shallow_water julia --project -e 'using Pkg; Pkg.test()'; Testing Oceananigans; ┌ Error: Pkg.Resolve.ResolverError(""Unsatisfiable requirements detected for package JLLWrappers [692b3bcd]:\n JLLWrappers [692b3bcd] log:\n ├─possible versions are: [1.0.0-1.0.2, 1.1.0-1.1.4, 1.2.0] or uninstalled\n ├─restricted to versions 1.1.3 by an explicit requirement, leaving only versions 1.1.3\n └─restricted by compatibility requirements with IntelOpenMP_jll [1d5cc7b8] to versions: 1.2.0 — no versions left\n └─IntelOpenMP_jll [1d5cc7b8] log:\n ├─possible versions are: 2018.0.3 or uninstalled\n └─restricted to versions 2018.0.3 by an explicit requirement, leaving only versions 2018.0.3"", nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975
https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975:617,Testability,log,log,617,"Also, I noticed there was an error at the very beginning, copied below. ```; TEST_GROUP=shallow_water julia --project -e 'using Pkg; Pkg.test()'; Testing Oceananigans; ┌ Error: Pkg.Resolve.ResolverError(""Unsatisfiable requirements detected for package JLLWrappers [692b3bcd]:\n JLLWrappers [692b3bcd] log:\n ├─possible versions are: [1.0.0-1.0.2, 1.1.0-1.1.4, 1.2.0] or uninstalled\n ├─restricted to versions 1.1.3 by an explicit requirement, leaving only versions 1.1.3\n └─restricted by compatibility requirements with IntelOpenMP_jll [1d5cc7b8] to versions: 1.2.0 — no versions left\n └─IntelOpenMP_jll [1d5cc7b8] log:\n ├─possible versions are: 2018.0.3 or uninstalled\n └─restricted to versions 2018.0.3 by an explicit requirement, leaving only versions 2018.0.3"", nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975
https://github.com/CliMA/Oceananigans.jl/issues/1327#issuecomment-1479847315:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1327#issuecomment-1479847315
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-772093692:332,Safety,avoid,avoids,332,"I'm not planning on running simulations with surface waves any time soon, so this doesn't directly affect me for now. That said, I think `stokes_drift` is the more correct term (regardless of the possibility of a free surface feature in the future). After all what is imposed is a Stokes drift, so I think calling it `stokes_drift` avoids confusion/ambiguity!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-772093692
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818:621,Integrability,rout,routinely,621,"Just for completeness, what do we think about `pseudomomentum`?. The issue with Stokes ""drift"" is that it implies a ""drifting"" which is not quite the right way to think about how surface waves affect the motion of fluid beneath them. In reality, average momentum (and thus any ""drifting"" that might occur) is imparted by external forces (such as the atmosphere); the averaged effect of surface waves is rather more subtle and is associated with changes to the relationship between mean momentum and vorticity (eg, vorticity feels the effect of pseudomomentum, despite that momentum does not). These concepts are confused routinely in the literature, so our community doesn't have a solid conceptual foundation on which standardized terminology is easily built. But suffice to say that in practice most people say ""Stokes drift"" but mean ""pseudomomentum"". In the context of Oceanagnians of course the prognostic variable _is_ the mean momentum (the Lagrangian-mean velocity field), thus this keyword really does control psuedomomentum with no impact on ""drifting""...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818:911,Modifiability,variab,variable,911,"Just for completeness, what do we think about `pseudomomentum`?. The issue with Stokes ""drift"" is that it implies a ""drifting"" which is not quite the right way to think about how surface waves affect the motion of fluid beneath them. In reality, average momentum (and thus any ""drifting"" that might occur) is imparted by external forces (such as the atmosphere); the averaged effect of surface waves is rather more subtle and is associated with changes to the relationship between mean momentum and vorticity (eg, vorticity feels the effect of pseudomomentum, despite that momentum does not). These concepts are confused routinely in the literature, so our community doesn't have a solid conceptual foundation on which standardized terminology is easily built. But suffice to say that in practice most people say ""Stokes drift"" but mean ""pseudomomentum"". In the context of Oceanagnians of course the prognostic variable _is_ the mean momentum (the Lagrangian-mean velocity field), thus this keyword really does control psuedomomentum with no impact on ""drifting""...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777567578:238,Usability,learn,learned,238,"Different perspectives are important and I admit that I have not thought about stokes drift from that perspective. Maybe mentioning this with a good reference might be appropriate? Not sure how much in depth one wants to get into this. I learned about pseudomomentum in the context of Hamiltoninan theory, but don't suspect we want to get into that level of detail, even though it is fun!. Also, if you mention pseudomomentum then do you need to also mention pseudoenergy?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777567578
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611:2076,Availability,error,error,2076,"aves. In other words, if particles and thus fluid undergo some net drift, then some external mean force must have imparted mean momentum to the fluid. So the first sentence of the Wikipedia article misleads. It's easy to get this wrong because in many systems the mean dynamics are ""trivial"" and do not evolve. But this is not always the case... The reason this subject is so tricky is because the physics of surface gravity waves _require_ a transfer of mean momentum from some external agent if they are excited (this is part of what it means for a wave field to have pseudomomentum). Thus the forced growth of waves is _also_ associated with a transfer of mean momentum (from the atmosphere to the ocean). But the mean momentum so transferred is not by any reasonable definition a ""wave property""; it undergoes an independent evolution and is easily divorced from wave fields that propagate rapidly away. In particular, if the system is rotating, the mean momentum excites a stationary inertial oscillation that has no net transport over long periods of time (while the wave field happily propagates ad infinitum)... Not that Wikipedia was always right before this on every topic --- but the view on Wikipedia is the same one that's taught in classrooms. I think users know _mathematically_ what is indicated by the keyword `stokes_drift`, especially if we well-document the fact that we solve for the Lagrangian-mean velocity. That's probably the most important thing. Buhler (2014) provides a good perspective on these issues, but doesn't really directly attack the primary conceptual error here (perhaps because such an attack is politically unpopular). I also am publishing a paper on this topic... https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf. I'm not sure this point matters much practically, but I think it might not be responsible to let it slide by without discussion. This was the original reason I avoided using the word `stokes_drift`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611:789,Modifiability,evolve,evolve,789,"It's hard because even [wikipedia](https://en.wikipedia.org/wiki/Stokes_drift) is misleading on this subject and says. > For a pure wave motion in fluid dynamics, the Stokes drift velocity is the average velocity when following a specific fluid parcel as it travels with the fluid flow. Yet if a mean velocity exists, the motion is not a ""pure wave"" motion; it has a mean component and a wave component, each of which have dynamics that are independent in the limit of small amplitude waves. In other words, if particles and thus fluid undergo some net drift, then some external mean force must have imparted mean momentum to the fluid. So the first sentence of the Wikipedia article misleads. It's easy to get this wrong because in many systems the mean dynamics are ""trivial"" and do not evolve. But this is not always the case... The reason this subject is so tricky is because the physics of surface gravity waves _require_ a transfer of mean momentum from some external agent if they are excited (this is part of what it means for a wave field to have pseudomomentum). Thus the forced growth of waves is _also_ associated with a transfer of mean momentum (from the atmosphere to the ocean). But the mean momentum so transferred is not by any reasonable definition a ""wave property""; it undergoes an independent evolution and is easily divorced from wave fields that propagate rapidly away. In particular, if the system is rotating, the mean momentum excites a stationary inertial oscillation that has no net transport over long periods of time (while the wave field happily propagates ad infinitum)... Not that Wikipedia was always right before this on every topic --- but the view on Wikipedia is the same one that's taught in classrooms. I think users know _mathematically_ what is indicated by the keyword `stokes_drift`, especially if we well-document the fact that we solve for the Lagrangian-mean velocity. That's probably the most important thing. Buhler (2014) provides a good perspective ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611:2448,Safety,avoid,avoided,2448,"aves. In other words, if particles and thus fluid undergo some net drift, then some external mean force must have imparted mean momentum to the fluid. So the first sentence of the Wikipedia article misleads. It's easy to get this wrong because in many systems the mean dynamics are ""trivial"" and do not evolve. But this is not always the case... The reason this subject is so tricky is because the physics of surface gravity waves _require_ a transfer of mean momentum from some external agent if they are excited (this is part of what it means for a wave field to have pseudomomentum). Thus the forced growth of waves is _also_ associated with a transfer of mean momentum (from the atmosphere to the ocean). But the mean momentum so transferred is not by any reasonable definition a ""wave property""; it undergoes an independent evolution and is easily divorced from wave fields that propagate rapidly away. In particular, if the system is rotating, the mean momentum excites a stationary inertial oscillation that has no net transport over long periods of time (while the wave field happily propagates ad infinitum)... Not that Wikipedia was always right before this on every topic --- but the view on Wikipedia is the same one that's taught in classrooms. I think users know _mathematically_ what is indicated by the keyword `stokes_drift`, especially if we well-document the fact that we solve for the Lagrangian-mean velocity. That's probably the most important thing. Buhler (2014) provides a good perspective on these issues, but doesn't really directly attack the primary conceptual error here (perhaps because such an attack is politically unpopular). I also am publishing a paper on this topic... https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf. I'm not sure this point matters much practically, but I think it might not be responsible to let it slide by without discussion. This was the original reason I avoided using the word `stokes_drift`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611:2046,Security,attack,attack,2046,"aves. In other words, if particles and thus fluid undergo some net drift, then some external mean force must have imparted mean momentum to the fluid. So the first sentence of the Wikipedia article misleads. It's easy to get this wrong because in many systems the mean dynamics are ""trivial"" and do not evolve. But this is not always the case... The reason this subject is so tricky is because the physics of surface gravity waves _require_ a transfer of mean momentum from some external agent if they are excited (this is part of what it means for a wave field to have pseudomomentum). Thus the forced growth of waves is _also_ associated with a transfer of mean momentum (from the atmosphere to the ocean). But the mean momentum so transferred is not by any reasonable definition a ""wave property""; it undergoes an independent evolution and is easily divorced from wave fields that propagate rapidly away. In particular, if the system is rotating, the mean momentum excites a stationary inertial oscillation that has no net transport over long periods of time (while the wave field happily propagates ad infinitum)... Not that Wikipedia was always right before this on every topic --- but the view on Wikipedia is the same one that's taught in classrooms. I think users know _mathematically_ what is indicated by the keyword `stokes_drift`, especially if we well-document the fact that we solve for the Lagrangian-mean velocity. That's probably the most important thing. Buhler (2014) provides a good perspective on these issues, but doesn't really directly attack the primary conceptual error here (perhaps because such an attack is politically unpopular). I also am publishing a paper on this topic... https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf. I'm not sure this point matters much practically, but I think it might not be responsible to let it slide by without discussion. This was the original reason I avoided using the word `stokes_drift`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611:2112,Security,attack,attack,2112,"aves. In other words, if particles and thus fluid undergo some net drift, then some external mean force must have imparted mean momentum to the fluid. So the first sentence of the Wikipedia article misleads. It's easy to get this wrong because in many systems the mean dynamics are ""trivial"" and do not evolve. But this is not always the case... The reason this subject is so tricky is because the physics of surface gravity waves _require_ a transfer of mean momentum from some external agent if they are excited (this is part of what it means for a wave field to have pseudomomentum). Thus the forced growth of waves is _also_ associated with a transfer of mean momentum (from the atmosphere to the ocean). But the mean momentum so transferred is not by any reasonable definition a ""wave property""; it undergoes an independent evolution and is easily divorced from wave fields that propagate rapidly away. In particular, if the system is rotating, the mean momentum excites a stationary inertial oscillation that has no net transport over long periods of time (while the wave field happily propagates ad infinitum)... Not that Wikipedia was always right before this on every topic --- but the view on Wikipedia is the same one that's taught in classrooms. I think users know _mathematically_ what is indicated by the keyword `stokes_drift`, especially if we well-document the fact that we solve for the Lagrangian-mean velocity. That's probably the most important thing. Buhler (2014) provides a good perspective on these issues, but doesn't really directly attack the primary conceptual error here (perhaps because such an attack is politically unpopular). I also am publishing a paper on this topic... https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf. I'm not sure this point matters much practically, but I think it might not be responsible to let it slide by without discussion. This was the original reason I avoided using the word `stokes_drift`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778188379:118,Usability,simpl,simplest,118,"Thanks @glwagner for more thoughts and the references. I agree that sticking to `stokes_drift` in this context is the simplest thing. . However, I wonder if we might want to have a nice example that tries and explain pseudomomentum? Since there is a lot of confusion in the literature (as you pointed out), I think it should be 1D to be as simple as possible. I found a reference for pseudomomentum in the [shallow water model](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-criterion-for-the-sign-of-the-pseudomomentum-of-modes-in-shallow-water-systems/8088FF1275BB78313627198546516FB2). I have not read this article yet but I wonder whether we might want to make an example that tries to explain this better? Maybe then people might go to Oceananigans for a reference on pseudomomentum? . Since this issue is closed if there is interest, this discussion should continue elsewhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778188379
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778188379:340,Usability,simpl,simple,340,"Thanks @glwagner for more thoughts and the references. I agree that sticking to `stokes_drift` in this context is the simplest thing. . However, I wonder if we might want to have a nice example that tries and explain pseudomomentum? Since there is a lot of confusion in the literature (as you pointed out), I think it should be 1D to be as simple as possible. I found a reference for pseudomomentum in the [shallow water model](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-criterion-for-the-sign-of-the-pseudomomentum-of-modes-in-shallow-water-systems/8088FF1275BB78313627198546516FB2). I have not read this article yet but I wonder whether we might want to make an example that tries to explain this better? Maybe then people might go to Oceananigans for a reference on pseudomomentum? . Since this issue is closed if there is interest, this discussion should continue elsewhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778188379
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778188379:507,Usability,simpl,simple-criterion-for-the-sign-of-the-pseudomomentum-of-modes-in-shallow-water-systems,507,"Thanks @glwagner for more thoughts and the references. I agree that sticking to `stokes_drift` in this context is the simplest thing. . However, I wonder if we might want to have a nice example that tries and explain pseudomomentum? Since there is a lot of confusion in the literature (as you pointed out), I think it should be 1D to be as simple as possible. I found a reference for pseudomomentum in the [shallow water model](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-criterion-for-the-sign-of-the-pseudomomentum-of-modes-in-shallow-water-systems/8088FF1275BB78313627198546516FB2). I have not read this article yet but I wonder whether we might want to make an example that tries to explain this better? Maybe then people might go to Oceananigans for a reference on pseudomomentum? . Since this issue is closed if there is interest, this discussion should continue elsewhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778188379
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778664270:58,Integrability,message,message,58,"Sorry if I jumped the gun on the merge, I thought I saw a message deciding against pseudomomentum but can't find it anymore. To be honest I don't know much about pseudomomentum, so I can't have an informed opinion. I know you can use it when talking about nonbreaking waves, but I, personally, find that nomenclature a little obscure in this context.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778664270
https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-779826789:457,Modifiability,variab,variable,457,"Ah, I think suffice to say that in the context of the Craik-Leibovich equations, whenever the word ""Stokes drift"" is used, it's ""pseudomomentum"" that is really meant. . In particular the original context of ""Stokes drift"" is the specific situation in which surface waves forced from rest are associated with a mean Lagrangian current that causes particles and fluid to ""drift"". In the Craik-Leibovich equations, the Lagrangian-mean momentum is a prognostic variable and is not determined or _explicitly_ modified by the ""Stokes drift"" (it is only _implicitly_ modified through changes to the fluid physics). Thus rather than causing fluid to ""drift"", specifying the ""Stokes drift"" in the Craik-Leibovich equations (and in Oceananigans) instead acts to modify the underlying fluid dynamics by changing the relationship between momentum and vorticity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-779826789
https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522:37,Testability,log,log,37,"From looking at the old Travis build log: https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/281310734. Looks like there's a pressure solver for vertically stretched grids that passes tests. And the regression tests were run on vertically stretched grids with constant grid spacings but they all fail since things blow up, e.g. ```; Testing vertically stretched grid with constant spacing [CPU] --- [29/01/2020 05:18:34] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:50; Δu: min=-3.8942e+65, max=3.88975e+65, mean=5.8421e+45, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δv: min=-3.8942e+65, max=3.88975e+65, mean=-7.77899e+46, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δw: min=-7.38289e+65, max=1.69765e+65, mean=4.87564e+46, absmean=7.48473e+62, std=1.3285e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔT: min=-4.52731e+63, max=1.7358e+64, mean=-1.98187e+45, absmean=2.06322e+61, std=3.64177e+62; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔS: min=-1.60869e+64, max=6.16781e+64, mean=2.97753e+44, absmean=7.33104e+61, std=1.29403e+63; ```. Seems like a good place to start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522
https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522:189,Testability,test,tests,189,"From looking at the old Travis build log: https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/281310734. Looks like there's a pressure solver for vertically stretched grids that passes tests. And the regression tests were run on vertically stretched grids with constant grid spacings but they all fail since things blow up, e.g. ```; Testing vertically stretched grid with constant spacing [CPU] --- [29/01/2020 05:18:34] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:50; Δu: min=-3.8942e+65, max=3.88975e+65, mean=5.8421e+45, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δv: min=-3.8942e+65, max=3.88975e+65, mean=-7.77899e+46, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δw: min=-7.38289e+65, max=1.69765e+65, mean=4.87564e+46, absmean=7.48473e+62, std=1.3285e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔT: min=-4.52731e+63, max=1.7358e+64, mean=-1.98187e+45, absmean=2.06322e+61, std=3.64177e+62; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔS: min=-1.60869e+64, max=6.16781e+64, mean=2.97753e+44, absmean=7.33104e+61, std=1.29403e+63; ```. Seems like a good place to start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522
https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522:215,Testability,test,tests,215,"From looking at the old Travis build log: https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/281310734. Looks like there's a pressure solver for vertically stretched grids that passes tests. And the regression tests were run on vertically stretched grids with constant grid spacings but they all fail since things blow up, e.g. ```; Testing vertically stretched grid with constant spacing [CPU] --- [29/01/2020 05:18:34] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:50; Δu: min=-3.8942e+65, max=3.88975e+65, mean=5.8421e+45, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δv: min=-3.8942e+65, max=3.88975e+65, mean=-7.77899e+46, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δw: min=-7.38289e+65, max=1.69765e+65, mean=4.87564e+46, absmean=7.48473e+62, std=1.3285e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔT: min=-4.52731e+63, max=1.7358e+64, mean=-1.98187e+45, absmean=2.06322e+61, std=3.64177e+62; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔS: min=-1.60869e+64, max=6.16781e+64, mean=2.97753e+44, absmean=7.33104e+61, std=1.29403e+63; ```. Seems like a good place to start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522
https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522:338,Testability,Test,Testing,338,"From looking at the old Travis build log: https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/281310734. Looks like there's a pressure solver for vertically stretched grids that passes tests. And the regression tests were run on vertically stretched grids with constant grid spacings but they all fail since things blow up, e.g. ```; Testing vertically stretched grid with constant spacing [CPU] --- [29/01/2020 05:18:34] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:50; Δu: min=-3.8942e+65, max=3.88975e+65, mean=5.8421e+45, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δv: min=-3.8942e+65, max=3.88975e+65, mean=-7.77899e+46, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δw: min=-7.38289e+65, max=1.69765e+65, mean=4.87564e+46, absmean=7.48473e+62, std=1.3285e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔT: min=-4.52731e+63, max=1.7358e+64, mean=-1.98187e+45, absmean=2.06322e+61, std=3.64177e+62; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔS: min=-1.60869e+64, max=6.16781e+64, mean=2.97753e+44, absmean=7.33104e+61, std=1.29403e+63; ```. Seems like a good place to start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522
https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522:482,Testability,test,test,482,"From looking at the old Travis build log: https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/281310734. Looks like there's a pressure solver for vertically stretched grids that passes tests. And the regression tests were run on vertically stretched grids with constant grid spacings but they all fail since things blow up, e.g. ```; Testing vertically stretched grid with constant spacing [CPU] --- [29/01/2020 05:18:34] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:50; Δu: min=-3.8942e+65, max=3.88975e+65, mean=5.8421e+45, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δv: min=-3.8942e+65, max=3.88975e+65, mean=-7.77899e+46, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δw: min=-7.38289e+65, max=1.69765e+65, mean=4.87564e+46, absmean=7.48473e+62, std=1.3285e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔT: min=-4.52731e+63, max=1.7358e+64, mean=-1.98187e+45, absmean=2.06322e+61, std=3.64177e+62; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔS: min=-1.60869e+64, max=6.16781e+64, mean=2.97753e+44, absmean=7.33104e+61, std=1.29403e+63; ```. Seems like a good place to start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522
https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522:702,Testability,test,test,702,"From looking at the old Travis build log: https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/281310734. Looks like there's a pressure solver for vertically stretched grids that passes tests. And the regression tests were run on vertically stretched grids with constant grid spacings but they all fail since things blow up, e.g. ```; Testing vertically stretched grid with constant spacing [CPU] --- [29/01/2020 05:18:34] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:50; Δu: min=-3.8942e+65, max=3.88975e+65, mean=5.8421e+45, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δv: min=-3.8942e+65, max=3.88975e+65, mean=-7.77899e+46, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δw: min=-7.38289e+65, max=1.69765e+65, mean=4.87564e+46, absmean=7.48473e+62, std=1.3285e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔT: min=-4.52731e+63, max=1.7358e+64, mean=-1.98187e+45, absmean=2.06322e+61, std=3.64177e+62; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔS: min=-1.60869e+64, max=6.16781e+64, mean=2.97753e+44, absmean=7.33104e+61, std=1.29403e+63; ```. Seems like a good place to start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522
https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522:924,Testability,test,test,924,"From looking at the old Travis build log: https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/281310734. Looks like there's a pressure solver for vertically stretched grids that passes tests. And the regression tests were run on vertically stretched grids with constant grid spacings but they all fail since things blow up, e.g. ```; Testing vertically stretched grid with constant spacing [CPU] --- [29/01/2020 05:18:34] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:50; Δu: min=-3.8942e+65, max=3.88975e+65, mean=5.8421e+45, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δv: min=-3.8942e+65, max=3.88975e+65, mean=-7.77899e+46, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δw: min=-7.38289e+65, max=1.69765e+65, mean=4.87564e+46, absmean=7.48473e+62, std=1.3285e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔT: min=-4.52731e+63, max=1.7358e+64, mean=-1.98187e+45, absmean=2.06322e+61, std=3.64177e+62; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔS: min=-1.60869e+64, max=6.16781e+64, mean=2.97753e+44, absmean=7.33104e+61, std=1.29403e+63; ```. Seems like a good place to start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522
https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522:1145,Testability,test,test,1145,"From looking at the old Travis build log: https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/281310734. Looks like there's a pressure solver for vertically stretched grids that passes tests. And the regression tests were run on vertically stretched grids with constant grid spacings but they all fail since things blow up, e.g. ```; Testing vertically stretched grid with constant spacing [CPU] --- [29/01/2020 05:18:34] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:50; Δu: min=-3.8942e+65, max=3.88975e+65, mean=5.8421e+45, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δv: min=-3.8942e+65, max=3.88975e+65, mean=-7.77899e+46, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δw: min=-7.38289e+65, max=1.69765e+65, mean=4.87564e+46, absmean=7.48473e+62, std=1.3285e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔT: min=-4.52731e+63, max=1.7358e+64, mean=-1.98187e+45, absmean=2.06322e+61, std=3.64177e+62; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔS: min=-1.60869e+64, max=6.16781e+64, mean=2.97753e+44, absmean=7.33104e+61, std=1.29403e+63; ```. Seems like a good place to start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522
https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522:1367,Testability,test,test,1367,"From looking at the old Travis build log: https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/281310734. Looks like there's a pressure solver for vertically stretched grids that passes tests. And the regression tests were run on vertically stretched grids with constant grid spacings but they all fail since things blow up, e.g. ```; Testing vertically stretched grid with constant spacing [CPU] --- [29/01/2020 05:18:34] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:50; Δu: min=-3.8942e+65, max=3.88975e+65, mean=5.8421e+45, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δv: min=-3.8942e+65, max=3.88975e+65, mean=-7.77899e+46, absmean=7.84018e+62, std=1.04702e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; Δw: min=-7.38289e+65, max=1.69765e+65, mean=4.87564e+46, absmean=7.48473e+62, std=1.3285e+64; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔT: min=-4.52731e+63, max=1.7358e+64, mean=-1.98187e+45, absmean=2.06322e+61, std=3.64177e+62; --- [29/01/2020 05:18:49] Info /home/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/test_regression.jl:11; ΔS: min=-1.60869e+64, max=6.16781e+64, mean=2.97753e+44, absmean=7.33104e+61, std=1.29403e+63; ```. Seems like a good place to start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332#issuecomment-771942522
https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772496240:110,Safety,avoid,avoid,110,PS @christophernhill: Buildkite tests did not run on this PR since we disable Buildkite on PRs from forks (to avoid random PRs executing potentially malicious code on Tartarus and Sverdrup). So we usually open and merge branches from the repo itself.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772496240
https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772496240:32,Testability,test,tests,32,PS @christophernhill: Buildkite tests did not run on this PR since we disable Buildkite on PRs from forks (to avoid random PRs executing potentially malicious code on Tartarus and Sverdrup). So we usually open and merge branches from the repo itself.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772496240
https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772577271:112,Safety,avoid,avoid,112,> PS @christophernhill: Buildkite tests did not run on this PR since we disable Buildkite on PRs from forks (to avoid random PRs executing potentially malicious code on Tartarus and Sverdrup).; > ; > So we usually open and merge branches from the repo itself. OK - I'll put it in a branch sometime today,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772577271
https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772577271:34,Testability,test,tests,34,> PS @christophernhill: Buildkite tests did not run on this PR since we disable Buildkite on PRs from forks (to avoid random PRs executing potentially malicious code on Tartarus and Sverdrup).; > ; > So we usually open and merge branches from the repo itself. OK - I'll put it in a branch sometime today,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772577271
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045:350,Deployability,integrat,integration,350,"> I've used xarray to analyze and plot Oceananigans NetCDF files quite a lot in the past with little difficulty (still really like xarray). Being on a regular Cartesian grid helps a lot obviously. You can use `xarray` on Oceananigans data blindly and be happy with it (I do it for the most part!), but their routines for interpolation and especially integration and differentiation don't match up with Oceananigans' finite volume scheme. So if you need to be precise with your calculations, you definitely shouldn't use the `xarray` default routines. And yes, this definitely overlaps with `AbstractOperations`, but I think that's okay, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045:308,Integrability,rout,routines,308,"> I've used xarray to analyze and plot Oceananigans NetCDF files quite a lot in the past with little difficulty (still really like xarray). Being on a regular Cartesian grid helps a lot obviously. You can use `xarray` on Oceananigans data blindly and be happy with it (I do it for the most part!), but their routines for interpolation and especially integration and differentiation don't match up with Oceananigans' finite volume scheme. So if you need to be precise with your calculations, you definitely shouldn't use the `xarray` default routines. And yes, this definitely overlaps with `AbstractOperations`, but I think that's okay, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045:350,Integrability,integrat,integration,350,"> I've used xarray to analyze and plot Oceananigans NetCDF files quite a lot in the past with little difficulty (still really like xarray). Being on a regular Cartesian grid helps a lot obviously. You can use `xarray` on Oceananigans data blindly and be happy with it (I do it for the most part!), but their routines for interpolation and especially integration and differentiation don't match up with Oceananigans' finite volume scheme. So if you need to be precise with your calculations, you definitely shouldn't use the `xarray` default routines. And yes, this definitely overlaps with `AbstractOperations`, but I think that's okay, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045:541,Integrability,rout,routines,541,"> I've used xarray to analyze and plot Oceananigans NetCDF files quite a lot in the past with little difficulty (still really like xarray). Being on a regular Cartesian grid helps a lot obviously. You can use `xarray` on Oceananigans data blindly and be happy with it (I do it for the most part!), but their routines for interpolation and especially integration and differentiation don't match up with Oceananigans' finite volume scheme. So if you need to be precise with your calculations, you definitely shouldn't use the `xarray` default routines. And yes, this definitely overlaps with `AbstractOperations`, but I think that's okay, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432:84,Energy Efficiency,power,powerful,84,You should be able to load any NetCDF file using xarray and it gives you a nice and powerful interface for analyzing and manipulating the data. Probably not the best example as it's a little old and messy (I've started using Makie more often) but here's one example: https://github.com/CliMA/LESbrary.jl/blob/3595ff2e1db6d5e6898b6ea84335fdb9dbd23b15/src/make_lesbrary_plots.py,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432:93,Integrability,interface,interface,93,You should be able to load any NetCDF file using xarray and it gives you a nice and powerful interface for analyzing and manipulating the data. Probably not the best example as it's a little old and messy (I've started using Makie more often) but here's one example: https://github.com/CliMA/LESbrary.jl/blob/3595ff2e1db6d5e6898b6ea84335fdb9dbd23b15/src/make_lesbrary_plots.py,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432:22,Performance,load,load,22,You should be able to load any NetCDF file using xarray and it gives you a nice and powerful interface for analyzing and manipulating the data. Probably not the best example as it's a little old and messy (I've started using Makie more often) but here's one example: https://github.com/CliMA/LESbrary.jl/blob/3595ff2e1db6d5e6898b6ea84335fdb9dbd23b15/src/make_lesbrary_plots.py,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134:1612,Availability,down,down,1612,"Hi folks. I just saw this issue. We are very glad that you're working to support interoperability btw oceananigans and xgcm! 🎉 We'd love to help however we can. Ideally you would not have to really do much here other than use CF conventions in your netCDF output and things would ""just work."" That's the beauty of standards. Unfortunately, CF conventions don't quite provide the right vocabulary to describe the curvilinear geometry of staggered grid models compactly (see https://github.com/cf-convention/discuss/issues/5). In the meantime, every modeling center seems to have their own preference for how to encode this (e.g. [comodo conventions](https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html) [now offline] used by ROMS and NEMO, [S-grid](https://github.com/sgrid/sgrid), [mosaics](https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf) from GFDL). . With xgcm, we decided to use the Comodo conventions (rather than invent yet another new convention). In retrospect, this was maybe the wrong choice, since the pycomodo project seems to have totally disappeared. 🤦 However, if you put the [right metadata](https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes) in your attributes, xgcm should be able to figure out your grid. Whatever you do, please try your best to squeeze your data into existing standard file formats and metadata conventions. ; Don't invent something new. MITgcm did this with the mds data format and it has been endless headaches for our community. I don't know what JLD2 is, but it sounds like you could be going down that route... If you have any questions, please ask! I'll try to respond.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134:81,Integrability,interoperab,interoperability,81,"Hi folks. I just saw this issue. We are very glad that you're working to support interoperability btw oceananigans and xgcm! 🎉 We'd love to help however we can. Ideally you would not have to really do much here other than use CF conventions in your netCDF output and things would ""just work."" That's the beauty of standards. Unfortunately, CF conventions don't quite provide the right vocabulary to describe the curvilinear geometry of staggered grid models compactly (see https://github.com/cf-convention/discuss/issues/5). In the meantime, every modeling center seems to have their own preference for how to encode this (e.g. [comodo conventions](https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html) [now offline] used by ROMS and NEMO, [S-grid](https://github.com/sgrid/sgrid), [mosaics](https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf) from GFDL). . With xgcm, we decided to use the Comodo conventions (rather than invent yet another new convention). In retrospect, this was maybe the wrong choice, since the pycomodo project seems to have totally disappeared. 🤦 However, if you put the [right metadata](https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes) in your attributes, xgcm should be able to figure out your grid. Whatever you do, please try your best to squeeze your data into existing standard file formats and metadata conventions. ; Don't invent something new. MITgcm did this with the mds data format and it has been endless headaches for our community. I don't know what JLD2 is, but it sounds like you could be going down that route... If you have any questions, please ask! I'll try to respond.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134:1622,Integrability,rout,route,1622,"Hi folks. I just saw this issue. We are very glad that you're working to support interoperability btw oceananigans and xgcm! 🎉 We'd love to help however we can. Ideally you would not have to really do much here other than use CF conventions in your netCDF output and things would ""just work."" That's the beauty of standards. Unfortunately, CF conventions don't quite provide the right vocabulary to describe the curvilinear geometry of staggered grid models compactly (see https://github.com/cf-convention/discuss/issues/5). In the meantime, every modeling center seems to have their own preference for how to encode this (e.g. [comodo conventions](https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html) [now offline] used by ROMS and NEMO, [S-grid](https://github.com/sgrid/sgrid), [mosaics](https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf) from GFDL). . With xgcm, we decided to use the Comodo conventions (rather than invent yet another new convention). In retrospect, this was maybe the wrong choice, since the pycomodo project seems to have totally disappeared. 🤦 However, if you put the [right metadata](https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes) in your attributes, xgcm should be able to figure out your grid. Whatever you do, please try your best to squeeze your data into existing standard file formats and metadata conventions. ; Don't invent something new. MITgcm did this with the mds data format and it has been endless headaches for our community. I don't know what JLD2 is, but it sounds like you could be going down that route... If you have any questions, please ask! I'll try to respond.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134:1197,Safety,detect,detecting-axes-from-dataset-attributes,1197,"Hi folks. I just saw this issue. We are very glad that you're working to support interoperability btw oceananigans and xgcm! 🎉 We'd love to help however we can. Ideally you would not have to really do much here other than use CF conventions in your netCDF output and things would ""just work."" That's the beauty of standards. Unfortunately, CF conventions don't quite provide the right vocabulary to describe the curvilinear geometry of staggered grid models compactly (see https://github.com/cf-convention/discuss/issues/5). In the meantime, every modeling center seems to have their own preference for how to encode this (e.g. [comodo conventions](https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html) [now offline] used by ROMS and NEMO, [S-grid](https://github.com/sgrid/sgrid), [mosaics](https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf) from GFDL). . With xgcm, we decided to use the Comodo conventions (rather than invent yet another new convention). In retrospect, this was maybe the wrong choice, since the pycomodo project seems to have totally disappeared. 🤦 However, if you put the [right metadata](https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes) in your attributes, xgcm should be able to figure out your grid. Whatever you do, please try your best to squeeze your data into existing standard file formats and metadata conventions. ; Don't invent something new. MITgcm did this with the mds data format and it has been endless headaches for our community. I don't know what JLD2 is, but it sounds like you could be going down that route... If you have any questions, please ask! I'll try to respond.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849:69,Availability,avail,available,69,"Ha, @rabernat beat me to it. I just wanted to mention that I am also available for questions and maybe clarify one more point of confusion that seems to stem from our current docs (working on improving that with @tomchor s input). . There are two parts in the NetCDF output that would make the integration with xgcm smooth: ; - Proper metadata for the dimensions (as mentioned by @rabernat above); - Output of grid metrics, which are distances, areas and cell volume of the grid. An important detail there is that each of the metrics should describe properties of the *surrounding cell*. So if you have a tracer value on the point `xT` and the cell bounds are given by a staggered coordinate `xC`, the distance (lets call it `dx`) for each `xT` point should describe the distance between the two surrounding `xC` points (and have `xC` as coordinate, so it can be matched correctly by xgcm). Currently the user has to input these manually but it might be convenient to add the [cf-attribute `cell_measures`](http://cfconventions.org/cf-conventions/cf-conventions.html#cell-measures), which we might support in the future with a more complete support for cf-metadata (see e.g. https://github.com/xgcm/xgcm/issues/127)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849:294,Deployability,integrat,integration,294,"Ha, @rabernat beat me to it. I just wanted to mention that I am also available for questions and maybe clarify one more point of confusion that seems to stem from our current docs (working on improving that with @tomchor s input). . There are two parts in the NetCDF output that would make the integration with xgcm smooth: ; - Proper metadata for the dimensions (as mentioned by @rabernat above); - Output of grid metrics, which are distances, areas and cell volume of the grid. An important detail there is that each of the metrics should describe properties of the *surrounding cell*. So if you have a tracer value on the point `xT` and the cell bounds are given by a staggered coordinate `xC`, the distance (lets call it `dx`) for each `xT` point should describe the distance between the two surrounding `xC` points (and have `xC` as coordinate, so it can be matched correctly by xgcm). Currently the user has to input these manually but it might be convenient to add the [cf-attribute `cell_measures`](http://cfconventions.org/cf-conventions/cf-conventions.html#cell-measures), which we might support in the future with a more complete support for cf-metadata (see e.g. https://github.com/xgcm/xgcm/issues/127)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849:294,Integrability,integrat,integration,294,"Ha, @rabernat beat me to it. I just wanted to mention that I am also available for questions and maybe clarify one more point of confusion that seems to stem from our current docs (working on improving that with @tomchor s input). . There are two parts in the NetCDF output that would make the integration with xgcm smooth: ; - Proper metadata for the dimensions (as mentioned by @rabernat above); - Output of grid metrics, which are distances, areas and cell volume of the grid. An important detail there is that each of the metrics should describe properties of the *surrounding cell*. So if you have a tracer value on the point `xT` and the cell bounds are given by a staggered coordinate `xC`, the distance (lets call it `dx`) for each `xT` point should describe the distance between the two surrounding `xC` points (and have `xC` as coordinate, so it can be matched correctly by xgcm). Currently the user has to input these manually but it might be convenient to add the [cf-attribute `cell_measures`](http://cfconventions.org/cf-conventions/cf-conventions.html#cell-measures), which we might support in the future with a more complete support for cf-metadata (see e.g. https://github.com/xgcm/xgcm/issues/127)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777135938:457,Availability,checkpoint,checkpointing,457,This is great. I hope we can replicate the grid metric naming conventions in the source code as well as in output. It might also be nice to come up with an `example/` that illustrates how to analyze Oceananigans output with xgcm (perhaps this can be done in a single julia script via `PyCall`?). Our current plan is to support output in NetCDF and JLD2 file formats. JLD2 is a native julia output format capable of serializing julia objects that we use for checkpointing but is unlikely to be widely used in the geosciences.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777135938
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:1972,Availability,down,down,1972,"tandards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If you have any questions, please ask! I'll try to respond.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXRYPNOI5TLPGVKV3DS6L7EJANCNFSM4XBBPGJA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:336,Integrability,interoperab,interoperability,336,"great Ryan - hope we can collaborate on this. There is a growing group of; people using and developing oceananigans and it would be good to link in; with xgcm. John. On Wed, Feb 10, 2021 at 5:03 PM Ryan Abernathey <notifications@github.com>; wrote:. > Hi folks. I just saw this issue. We are very glad that you're working to; > support interoperability btw oceananigans and xgcm! 🎉 We'd love to help; > however we can.; >; > Ideally you would not have to really do much here other than use CF; > conventions in your netCDF output and things would ""just work."" That's the; > beauty of standards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:1982,Integrability,rout,route,1982,"tandards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If you have any questions, please ask! I'll try to respond.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXRYPNOI5TLPGVKV3DS6L7EJANCNFSM4XBBPGJA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:1538,Safety,detect,detecting-axes-from-dataset-attributes,1538,"tandards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If you have any questions, please ask! I'll try to respond.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXRYPNOI5TLPGVKV3DS6L7EJANCNFSM4XBBPGJA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777162790:27,Deployability,continuous,continuous,27,I am very impressed by the continuous flow of amazing technical and scientific accomplishments from the CliMA group. But by far the most impressive feat is that you have managed to drag @johncmarshall54 onto GitHub. 🤣,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777162790
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480009990:100,Modifiability,variab,variable,100,The conversation around metrics is still unsettled. AFAICT there's no way to put those in the SGRID variable. There are [CF conventions](http://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#cell-measures) for `cell_measures`: specifically `area` and `volume` but we would also need length. There is a `cell_thickness` standard_name that could be used for this. cc @jbusecke,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480009990
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480392005:453,Modifiability,variab,variable,453,"Getting at least area and volume in there would be helpful, but kind of stopping short of 'doing this right'. . Each time I look at the SGRID specs I think ""Its right there"" when I see the specifications of 'edges=length', 'faces=area', and 'volume'; <img width=""804"" alt=""image"" src=""https://user-images.githubusercontent.com/14314623/227060884-d28ff5d1-9e0a-4874-b9eb-093afd4607f9.png"">; But AFAIK there is no way to actually assign a coordinate/data variable to each of these positions? If we could somehow add that into the spec I think that would be much better than abusing `cell_thickness`. . In my mind, all that is needed to correctly parse a metric into xgcm is a flag (e.g. this is a metric) and information on the 'kind' of metric and its 'orientation', both of which I believe can be encoded in SGRID already? So really all that is needed is some metadata that implements the flag. I hope this makes sense to folks. . Maybe we get some of the sgrid folks into this discussion? Just to see if I misinterpret what is already possible and whether we could add something to SGRID that indicates that a variable/coordinate represents some physical metric (length, area, volume). cc @hrajagers @rsignell-usgs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480392005
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480392005:1111,Modifiability,variab,variable,1111,"Getting at least area and volume in there would be helpful, but kind of stopping short of 'doing this right'. . Each time I look at the SGRID specs I think ""Its right there"" when I see the specifications of 'edges=length', 'faces=area', and 'volume'; <img width=""804"" alt=""image"" src=""https://user-images.githubusercontent.com/14314623/227060884-d28ff5d1-9e0a-4874-b9eb-093afd4607f9.png"">; But AFAIK there is no way to actually assign a coordinate/data variable to each of these positions? If we could somehow add that into the spec I think that would be much better than abusing `cell_thickness`. . In my mind, all that is needed to correctly parse a metric into xgcm is a flag (e.g. this is a metric) and information on the 'kind' of metric and its 'orientation', both of which I believe can be encoded in SGRID already? So really all that is needed is some metadata that implements the flag. I hope this makes sense to folks. . Maybe we get some of the sgrid folks into this discussion? Just to see if I misinterpret what is already possible and whether we could add something to SGRID that indicates that a variable/coordinate represents some physical metric (length, area, volume). cc @hrajagers @rsignell-usgs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480392005
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1507314745:376,Safety,detect,detect,376,"For those following this thread the [SGRID PR](https://github.com/xgcm/xgcm/pull/559#pullrequestreview-1383786186) mentioned above has now been merged to add SGRID functionalities into [xgcm](https://github.com/xgcm/xgcm). Please do try out if useful.; There are some docs for it [here](https://xgcm.readthedocs.io/en/latest/grids.html) describing to to have it automatically detect and extract an SGRID grid, and I'm happy for feedback/questions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1507314745
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1507314745:428,Usability,feedback,feedback,428,"For those following this thread the [SGRID PR](https://github.com/xgcm/xgcm/pull/559#pullrequestreview-1383786186) mentioned above has now been merged to add SGRID functionalities into [xgcm](https://github.com/xgcm/xgcm). Please do try out if useful.; There are some docs for it [here](https://xgcm.readthedocs.io/en/latest/grids.html) describing to to have it automatically detect and extract an SGRID grid, and I'm happy for feedback/questions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1507314745
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1516570220:103,Usability,clear,clear,103,"@jatkinson1000 thanks for your effort in https://github.com/xgcm/xgcm/pull/559. I'm glad there's now a clear standard way to proceed!. I'm gonna take a crack at adding those grid measures to Oceananigans NetCDF output in https://github.com/CliMA/Oceananigans.jl/pull/2652 now that it seems the pieces are all in place. However, I read the docs and I'm still a bit confused on how to implement them. Do you have an example NetCDF file (preferably 3D) that follows SGRID conventions that you can share? It would help me to use that as a basis of comparison. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1516570220
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1516623832:433,Safety,detect,detecting-axes-from-dataset-attributes,433,"Hi @tomchor There are a few examples of SGRID datasets listed on the original [xgcm sgrid issue](https://github.com/xgcm/xgcm/issues/109). I can also dig these out on my computer and share via email if you need - let me know. When you say documentation, is that the general [SGRID documentation](https://sgrid.github.io/sgrid/), or the [specific xgcm documentation relating to SGRID](https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1516623832
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1533516695:50,Availability,down,download,50,@jatkinson1000 sorry for the delay. I'm trying to download the datasets mentioned on the [original xgcm sgrid issue](https://github.com/xgcm/xgcm/issues/109) (namely the ones mentioned [here](https://github.com/xgcm/xgcm/issues/109#issuecomment-408855581) and [here](https://github.com/xgcm/xgcm/issues/109#issuecomment-408858235)) but I'm getting errors. Could you please dig some files out and either attach them here (I think you may need to zip them first) or email them to me? You can find my email through my personal website.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1533516695
https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1533516695:348,Availability,error,errors,348,@jatkinson1000 sorry for the delay. I'm trying to download the datasets mentioned on the [original xgcm sgrid issue](https://github.com/xgcm/xgcm/issues/109) (namely the ones mentioned [here](https://github.com/xgcm/xgcm/issues/109#issuecomment-408855581) and [here](https://github.com/xgcm/xgcm/issues/109#issuecomment-408858235)) but I'm getting errors. Could you please dig some files out and either attach them here (I think you may need to zip them first) or email them to me? You can find my email through my personal website.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1533516695
https://github.com/CliMA/Oceananigans.jl/pull/1337#issuecomment-772681103:73,Availability,error,error,73,Looks like some GPU tests didn't even start due to. ```; signal (7): Bus error; ```. so I restarted the build.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1337#issuecomment-772681103
https://github.com/CliMA/Oceananigans.jl/pull/1337#issuecomment-772681103:20,Testability,test,tests,20,Looks like some GPU tests didn't even start due to. ```; signal (7): Bus error; ```. so I restarted the build.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1337#issuecomment-772681103
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-772806561:15,Testability,benchmark,benchmarks,15,"> Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. I think this makes sense given my primitive understanding of how FFTW picks optimal plans for the particular problem its asked to solve.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-772806561
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:3722,Performance,perform,performance,3722,"───────────────────────────┬─────────┬─────────┬────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼────────────────────────────────┼─────────┼─────────┼────────┤; │ 192 │ (Bounded, Bounded, Bounded) │ 33.4393 │ 448.0 │ 226.0 │; │ 192 │ (Bounded, Bounded, Periodic) │ 32.0602 │ 368.0 │ 325.5 │; │ 192 │ (Bounded, Periodic, Bounded) │ 34.7631 │ 366.8 │ 322.5 │; │ 192 │ (Bounded, Periodic, Periodic) │ 17.1932 │ 178.2 │ 147.0 │; │ 192 │ (Periodic, Bounded, Bounded) │ 36.7915 │ 368.0 │ 325.5 │; │ 192 │ (Periodic, Bounded, Periodic) │ 35.3884 │ 196.0 │ 193.0 │; │ 192 │ (Periodic, Periodic, Bounded) │ 49.4769 │ 178.2 │ 147.0 │; │ 192 │ (Periodic, Periodic, Periodic) │ 58.4816 │ 5.83333 │ 7.75 │; └─────┴────────────────────────────────┴─────────┴─────────┴────────┘; ```. ## CPU slowdown (vs. triply-periodic). ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.76522 │ 1.0 │ 1.0 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 2.14077 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 2.32425 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.64349 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 2.44462 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.79278 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.72073 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:4731,Performance,perform,performance,4731," slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.76522 │ 1.0 │ 1.0 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 2.14077 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 2.32425 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.64349 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 2.44462 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.79278 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.72073 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 4.83605 │ 76.8 │ 29.1613 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 3.90501 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 3.91006 │ 52.4 │ 20.8065 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 5.59024 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 3.88581 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 2.96267 │ 28.0 │ 12.4516 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.03389 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # Static ocean benchmarks for all topologies. ## Raw numbers. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:8955,Performance,perform,performance,8955,"───┬─────────┬─────────┬─────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼────────────────────────────────┼─────────┼─────────┼─────────┤; │ 192 │ (Bounded, Bounded, Bounded) │ 107.967 │ 2.24983 │ 3.89024 │; │ 192 │ (Bounded, Bounded, Periodic) │ 122.789 │ 2.55222 │ 3.89223 │; │ 192 │ (Bounded, Periodic, Bounded) │ 103.133 │ 2.56202 │ 3.83395 │; │ 192 │ (Bounded, Periodic, Periodic) │ 84.934 │ 2.95066 │ 3.86268 │; │ 192 │ (Periodic, Bounded, Bounded) │ 102.06 │ 2.56254 │ 3.83673 │; │ 192 │ (Periodic, Bounded, Periodic) │ 108.457 │ 2.95943 │ 3.91362 │; │ 192 │ (Periodic, Periodic, Bounded) │ 161.616 │ 2.96456 │ 3.81949 │; │ 192 │ (Periodic, Periodic, Periodic) │ 178.682 │ 3.4072 │ 3.38448 │; └─────┴────────────────────────────────┴─────────┴─────────┴─────────┘; ```. ## CPU slowdown (vs. triply-periodic). ```; Topologies relative performance (CPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 1.34309 │ 1.46266 │ 1.48014 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.25281 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.05249 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.07645 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.0409 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 0.938853 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.17749 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; Topologies relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬──────────┬─────────┐; │ Architectu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:9976,Performance,perform,performance,9976," allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 1.34309 │ 1.46266 │ 1.48014 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.25281 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.05249 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.07645 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.0409 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 0.938853 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.17749 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; Topologies relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬──────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.22277 │ 0.965821 │ 1.70133 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.82308 │ 0.980729 │ 1.496 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.82349 │ 0.984497 │ 1.4736 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 2.26462 │ 0.989389 │ 1.24018 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.82237 │ 0.984695 │ 1.47467 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.54676 │ 0.992331 │ 1.25653 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.30183 │ 0.99405 │ 1.22631 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴─────────┘; ```. # Performance vs. main branch. ## Main branch. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬─",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:10941,Performance,Perform,Performance,10941,"c). ```; Topologies relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬──────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.22277 │ 0.965821 │ 1.70133 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.82308 │ 0.980729 │ 1.496 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.82349 │ 0.984497 │ 1.4736 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 2.26462 │ 0.989389 │ 1.24018 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.82237 │ 0.984695 │ 1.47467 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.54676 │ 0.992331 │ 1.25653 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.30183 │ 0.99405 │ 1.22631 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴─────────┘; ```. # Performance vs. main branch. ## Main branch. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┤; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.922 s │ 1.922 s │ 1.967 s │ 2.058 s │ 363.61 KiB │ 2163 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.143 s │ 2.144 s │ 2.145 s │ 2.146 s │ 317.33 KiB │ 1807 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.791 s │ 1.793 s │ 1.793 s │ 1.794 s │ 277.77 KiB │ 1661 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 32.188 ms │ 37.447 ms │ 36.936 ms │ 37.557 ms │ 985.94 KiB │ 13476 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 11.051 ms │ 11.114 ms │ 11.148 ms │ 11.533 ms │ 807.44 KiB │ 10746 │; │ GPU │ 192 │ (Periodic, Periodic, Periodi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:0,Testability,Test,Tests,0,"Tests all pass but code is a bit messy (especially `plan_transforms.jl`) due to lots of special cases that I'm not yet sure how to simplify so needs some work. Ran new FFT-based Poisson solver benchmarks on Tartarus (Titan V GPUs) and static ocean benchmarks for all topologies on Satori (Tesla V100 GPUs) + regression. Results are below. Will post a followup with some highlights/conclusions. # FFT-based Poisson solver benchmarks. ## Raw numbers. ```; FFT-based Poisson solver benchmarks; ┌───────────────┬─────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 560.466 ms │ 563.145 ms │ 563.074 ms │ 566.700 ms │ 192 bytes │ 4 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 434.408 ms │ 435.974 ms │ 437.003 ms │ 441.246 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 472.312 ms │ 473.340 ms │ 473.620 ms │ 475.649 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 333.460 ms │ 334.702 ms │ 334.998 ms │ 336.918 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 495.012 ms │ 497.853 ms │ 497.462 ms │ 500.181 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 363.169 ms │ 365.104 ms │ 365.891 ms │ 373.893 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 349.305 ms │ 350.431 ms │ 352.641 ms │ 371.861 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 203.109 ms │ 203.653 ms │ 204.025 ms │ 206.834 ms │ 192 bytes │ 4 │; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 7.765 ms │ 16.841 ms │ 15.934 ms │ 16.872 ms │ 84.00 KiB │ 904 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 6.492 ms │ 13.599 ms │ 12.878 ms │ 13.633 ms │ 57.50 KiB │ 651 │; │ GPU │ 192 │ (Bounded, Peri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:193,Testability,benchmark,benchmarks,193,"Tests all pass but code is a bit messy (especially `plan_transforms.jl`) due to lots of special cases that I'm not yet sure how to simplify so needs some work. Ran new FFT-based Poisson solver benchmarks on Tartarus (Titan V GPUs) and static ocean benchmarks for all topologies on Satori (Tesla V100 GPUs) + regression. Results are below. Will post a followup with some highlights/conclusions. # FFT-based Poisson solver benchmarks. ## Raw numbers. ```; FFT-based Poisson solver benchmarks; ┌───────────────┬─────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 560.466 ms │ 563.145 ms │ 563.074 ms │ 566.700 ms │ 192 bytes │ 4 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 434.408 ms │ 435.974 ms │ 437.003 ms │ 441.246 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 472.312 ms │ 473.340 ms │ 473.620 ms │ 475.649 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 333.460 ms │ 334.702 ms │ 334.998 ms │ 336.918 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 495.012 ms │ 497.853 ms │ 497.462 ms │ 500.181 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 363.169 ms │ 365.104 ms │ 365.891 ms │ 373.893 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 349.305 ms │ 350.431 ms │ 352.641 ms │ 371.861 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 203.109 ms │ 203.653 ms │ 204.025 ms │ 206.834 ms │ 192 bytes │ 4 │; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 7.765 ms │ 16.841 ms │ 15.934 ms │ 16.872 ms │ 84.00 KiB │ 904 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 6.492 ms │ 13.599 ms │ 12.878 ms │ 13.633 ms │ 57.50 KiB │ 651 │; │ GPU │ 192 │ (Bounded, Peri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:248,Testability,benchmark,benchmarks,248,"Tests all pass but code is a bit messy (especially `plan_transforms.jl`) due to lots of special cases that I'm not yet sure how to simplify so needs some work. Ran new FFT-based Poisson solver benchmarks on Tartarus (Titan V GPUs) and static ocean benchmarks for all topologies on Satori (Tesla V100 GPUs) + regression. Results are below. Will post a followup with some highlights/conclusions. # FFT-based Poisson solver benchmarks. ## Raw numbers. ```; FFT-based Poisson solver benchmarks; ┌───────────────┬─────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 560.466 ms │ 563.145 ms │ 563.074 ms │ 566.700 ms │ 192 bytes │ 4 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 434.408 ms │ 435.974 ms │ 437.003 ms │ 441.246 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 472.312 ms │ 473.340 ms │ 473.620 ms │ 475.649 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 333.460 ms │ 334.702 ms │ 334.998 ms │ 336.918 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 495.012 ms │ 497.853 ms │ 497.462 ms │ 500.181 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 363.169 ms │ 365.104 ms │ 365.891 ms │ 373.893 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 349.305 ms │ 350.431 ms │ 352.641 ms │ 371.861 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 203.109 ms │ 203.653 ms │ 204.025 ms │ 206.834 ms │ 192 bytes │ 4 │; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 7.765 ms │ 16.841 ms │ 15.934 ms │ 16.872 ms │ 84.00 KiB │ 904 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 6.492 ms │ 13.599 ms │ 12.878 ms │ 13.633 ms │ 57.50 KiB │ 651 │; │ GPU │ 192 │ (Bounded, Peri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:421,Testability,benchmark,benchmarks,421,"Tests all pass but code is a bit messy (especially `plan_transforms.jl`) due to lots of special cases that I'm not yet sure how to simplify so needs some work. Ran new FFT-based Poisson solver benchmarks on Tartarus (Titan V GPUs) and static ocean benchmarks for all topologies on Satori (Tesla V100 GPUs) + regression. Results are below. Will post a followup with some highlights/conclusions. # FFT-based Poisson solver benchmarks. ## Raw numbers. ```; FFT-based Poisson solver benchmarks; ┌───────────────┬─────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 560.466 ms │ 563.145 ms │ 563.074 ms │ 566.700 ms │ 192 bytes │ 4 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 434.408 ms │ 435.974 ms │ 437.003 ms │ 441.246 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 472.312 ms │ 473.340 ms │ 473.620 ms │ 475.649 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 333.460 ms │ 334.702 ms │ 334.998 ms │ 336.918 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 495.012 ms │ 497.853 ms │ 497.462 ms │ 500.181 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 363.169 ms │ 365.104 ms │ 365.891 ms │ 373.893 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 349.305 ms │ 350.431 ms │ 352.641 ms │ 371.861 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 203.109 ms │ 203.653 ms │ 204.025 ms │ 206.834 ms │ 192 bytes │ 4 │; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 7.765 ms │ 16.841 ms │ 15.934 ms │ 16.872 ms │ 84.00 KiB │ 904 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 6.492 ms │ 13.599 ms │ 12.878 ms │ 13.633 ms │ 57.50 KiB │ 651 │; │ GPU │ 192 │ (Bounded, Peri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:479,Testability,benchmark,benchmarks,479,"Tests all pass but code is a bit messy (especially `plan_transforms.jl`) due to lots of special cases that I'm not yet sure how to simplify so needs some work. Ran new FFT-based Poisson solver benchmarks on Tartarus (Titan V GPUs) and static ocean benchmarks for all topologies on Satori (Tesla V100 GPUs) + regression. Results are below. Will post a followup with some highlights/conclusions. # FFT-based Poisson solver benchmarks. ## Raw numbers. ```; FFT-based Poisson solver benchmarks; ┌───────────────┬─────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 560.466 ms │ 563.145 ms │ 563.074 ms │ 566.700 ms │ 192 bytes │ 4 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 434.408 ms │ 435.974 ms │ 437.003 ms │ 441.246 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 472.312 ms │ 473.340 ms │ 473.620 ms │ 475.649 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 333.460 ms │ 334.702 ms │ 334.998 ms │ 336.918 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 495.012 ms │ 497.853 ms │ 497.462 ms │ 500.181 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 363.169 ms │ 365.104 ms │ 365.891 ms │ 373.893 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 349.305 ms │ 350.431 ms │ 352.641 ms │ 371.861 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 203.109 ms │ 203.653 ms │ 204.025 ms │ 206.834 ms │ 192 bytes │ 4 │; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 7.765 ms │ 16.841 ms │ 15.934 ms │ 16.872 ms │ 84.00 KiB │ 904 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 6.492 ms │ 13.599 ms │ 12.878 ms │ 13.633 ms │ 57.50 KiB │ 651 │; │ GPU │ 192 │ (Bounded, Peri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:5688,Testability,benchmark,benchmarks,5688,"; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 4.83605 │ 76.8 │ 29.1613 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 3.90501 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 3.91006 │ 52.4 │ 20.8065 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 5.59024 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 3.88581 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 2.96267 │ 28.0 │ 12.4516 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.03389 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # Static ocean benchmarks for all topologies. ## Raw numbers. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.402 s │ 2.412 s │ 2.413 s │ 2.424 s │ 405.84 KiB │ 2460 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 2.247 s │ 2.250 s │ 2.252 s │ 2.259 s │ 363.28 KiB │ 2162 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.890 s │ 1.890 s │ 1.890 s │ 1.890 s │ 363.28 KiB │ 2162 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.923 s │ 1.933 s │ 1.931 s │ 1.936 s │ 317.00 KiB │ 1806 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.864 s │ 1.869 s │ 1.868 s │ 1.871 s │ 363.28 KiB │ 2162 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.685 s │ 1.686 s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:5751,Testability,benchmark,benchmarks,5751,"───────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 4.83605 │ 76.8 │ 29.1613 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 3.90501 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 3.91006 │ 52.4 │ 20.8065 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 5.59024 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 3.88581 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 2.96267 │ 28.0 │ 12.4516 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.03389 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # Static ocean benchmarks for all topologies. ## Raw numbers. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.402 s │ 2.412 s │ 2.413 s │ 2.424 s │ 405.84 KiB │ 2460 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 2.247 s │ 2.250 s │ 2.252 s │ 2.259 s │ 363.28 KiB │ 2162 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.890 s │ 1.890 s │ 1.890 s │ 1.890 s │ 363.28 KiB │ 2162 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.923 s │ 1.933 s │ 1.931 s │ 1.936 s │ 317.00 KiB │ 1806 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.864 s │ 1.869 s │ 1.868 s │ 1.871 s │ 363.28 KiB │ 2162 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.685 s │ 1.686 s │ 1.688 s │ 1.693 s │ 317.00 KiB │ 1806 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.092 s │ 2.114 s │ 2.109 s │ 2.121 s │ 317.00 KiB │ 1806 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.780 s │ 1.796 s │ 1.801 s │ 1.828 s │ 277.47 K",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:11002,Testability,benchmark,benchmarks,11002,"──────────────┼──────────┼──────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.22277 │ 0.965821 │ 1.70133 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.82308 │ 0.980729 │ 1.496 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.82349 │ 0.984497 │ 1.4736 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 2.26462 │ 0.989389 │ 1.24018 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.82237 │ 0.984695 │ 1.47467 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.54676 │ 0.992331 │ 1.25653 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.30183 │ 0.99405 │ 1.22631 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴─────────┘; ```. # Performance vs. main branch. ## Main branch. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┤; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.922 s │ 1.922 s │ 1.967 s │ 2.058 s │ 363.61 KiB │ 2163 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.143 s │ 2.144 s │ 2.145 s │ 2.146 s │ 317.33 KiB │ 1807 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.791 s │ 1.793 s │ 1.793 s │ 1.794 s │ 277.77 KiB │ 1661 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 32.188 ms │ 37.447 ms │ 36.936 ms │ 37.557 ms │ 985.94 KiB │ 13476 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 11.051 ms │ 11.114 ms │ 11.148 ms │ 11.533 ms │ 807.44 KiB │ 10746 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 9.859 ms │ 10.104 ms │ 10.136 ms │ 10.682 ms │ 707.81 KiB │ 9469 │; └───────────────┴─────┴────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┘; ```. ## This PR/branch. ```; Topologies bench",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:12188,Testability,benchmark,benchmarks,12188,"───────┼────────┤; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.922 s │ 1.922 s │ 1.967 s │ 2.058 s │ 363.61 KiB │ 2163 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.143 s │ 2.144 s │ 2.145 s │ 2.146 s │ 317.33 KiB │ 1807 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.791 s │ 1.793 s │ 1.793 s │ 1.794 s │ 277.77 KiB │ 1661 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 32.188 ms │ 37.447 ms │ 36.936 ms │ 37.557 ms │ 985.94 KiB │ 13476 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 11.051 ms │ 11.114 ms │ 11.148 ms │ 11.533 ms │ 807.44 KiB │ 10746 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 9.859 ms │ 10.104 ms │ 10.136 ms │ 10.682 ms │ 707.81 KiB │ 9469 │; └───────────────┴─────┴────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┘; ```. ## This PR/branch. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┤; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.864 s │ 1.869 s │ 1.868 s │ 1.871 s │ 363.28 KiB │ 2162 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.092 s │ 2.114 s │ 2.109 s │ 2.121 s │ 317.00 KiB │ 1806 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.780 s │ 1.796 s │ 1.801 s │ 1.828 s │ 277.47 KiB │ 1662 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 12.717 ms │ 18.315 ms │ 17.841 ms │ 18.997 ms │ 930.92 KiB │ 8295 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 10.097 ms │ 13.083 ms │ 12.793 ms │ 13.159 ms │ 939.77 KiB │ 6898 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 8.948 ms │ 10.050 ms │ 9.948 ms │ 10.128 ms │ 945.39 KiB │ 5625 │; └───────────────┴─────┴────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┘; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:131,Usability,simpl,simplify,131,"Tests all pass but code is a bit messy (especially `plan_transforms.jl`) due to lots of special cases that I'm not yet sure how to simplify so needs some work. Ran new FFT-based Poisson solver benchmarks on Tartarus (Titan V GPUs) and static ocean benchmarks for all topologies on Satori (Tesla V100 GPUs) + regression. Results are below. Will post a followup with some highlights/conclusions. # FFT-based Poisson solver benchmarks. ## Raw numbers. ```; FFT-based Poisson solver benchmarks; ┌───────────────┬─────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 560.466 ms │ 563.145 ms │ 563.074 ms │ 566.700 ms │ 192 bytes │ 4 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 434.408 ms │ 435.974 ms │ 437.003 ms │ 441.246 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 472.312 ms │ 473.340 ms │ 473.620 ms │ 475.649 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 333.460 ms │ 334.702 ms │ 334.998 ms │ 336.918 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 495.012 ms │ 497.853 ms │ 497.462 ms │ 500.181 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 363.169 ms │ 365.104 ms │ 365.891 ms │ 373.893 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 349.305 ms │ 350.431 ms │ 352.641 ms │ 371.861 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 203.109 ms │ 203.653 ms │ 204.025 ms │ 206.834 ms │ 192 bytes │ 4 │; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 7.765 ms │ 16.841 ms │ 15.934 ms │ 16.872 ms │ 84.00 KiB │ 904 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 6.492 ms │ 13.599 ms │ 12.878 ms │ 13.633 ms │ 57.50 KiB │ 651 │; │ GPU │ 192 │ (Bounded, Peri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773410660:234,Availability,down,down,234,"Some highlights/conclusions:; 1. (Periodic, Bounded, Bounded) channels used to take ~37 ms/time step on GPUs but are now takes ~18 ms/time step so it's ~2x as fast :tada:; 2. Our favorite (Periodic, Periodic, Bounded) topology slowed down a bit: from ~11 ms to ~13 ms/time step. Might be due to extra kernel launches in the discrete transforms (index permutations are now done in the discrete transforms).; 3. The `FFTBasedPoissonSolver` allocates quite a bit of memory when DCTs are involved. Should probably see if there are any obvious sources of memory allocations that can be improved but probably not absolutely required.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773410660
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773410660:438,Energy Efficiency,allocate,allocates,438,"Some highlights/conclusions:; 1. (Periodic, Bounded, Bounded) channels used to take ~37 ms/time step on GPUs but are now takes ~18 ms/time step so it's ~2x as fast :tada:; 2. Our favorite (Periodic, Periodic, Bounded) topology slowed down a bit: from ~11 ms to ~13 ms/time step. Might be due to extra kernel launches in the discrete transforms (index permutations are now done in the discrete transforms).; 3. The `FFTBasedPoissonSolver` allocates quite a bit of memory when DCTs are involved. Should probably see if there are any obvious sources of memory allocations that can be improved but probably not absolutely required.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773410660
https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773654354:15,Deployability,release,release,15,Definitely new release after this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773654354
https://github.com/CliMA/Oceananigans.jl/pull/1339#issuecomment-772789508:55,Availability,redundant,redundant,55,"How about `PrimitiveSolutionLinearHeight`? It might be redundant to refer to the surface as ""free"" in the context of the shallow water equations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1339#issuecomment-772789508
https://github.com/CliMA/Oceananigans.jl/pull/1339#issuecomment-772789508:55,Safety,redund,redundant,55,"How about `PrimitiveSolutionLinearHeight`? It might be redundant to refer to the surface as ""free"" in the context of the shallow water equations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1339#issuecomment-772789508
https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773409566:75,Testability,test,tests,75,Looks pretty good and the coding was simpler than I imagined. Provided the tests for halo regions pass is there anything else to do for ComputedFields?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773409566
https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773409566:37,Usability,simpl,simpler,37,Looks pretty good and the coding was simpler than I imagined. Provided the tests for halo regions pass is there anything else to do for ComputedFields?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773409566
https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773637784:222,Energy Efficiency,Reduce,ReducedField,222,> is there anything else to do for ComputedFields?. We may want to add boundary conditions to `KernelComputedField` as well. Other than that nothing I can think of for this PR. I think we also want boundary conditions on `ReducedField`... this will be another PR and slightly more complicated.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773637784
https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773674027:66,Testability,test,tests,66,"@tomchor added boundary conditions to `KernelComputedField`, plus tests, so the PR is ready for review.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773674027
https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773683542:185,Testability,test,test,185,"> I don't think I have enough expertise to review the coding itself. What you've mentioned is a valid review! If you can't read the code, there's a problem with the code... I can add a test for a non-default BC. There's no examples at all in the docstring for `ComputedField`... I can add one. I feel this feature may not be used all that often (only required when constructing complex chains of computations that require intermediate `ComputedField`s), so it might still be rough around the edges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773683542
https://github.com/CliMA/Oceananigans.jl/pull/1342#issuecomment-848999805:35,Modifiability,refactor,refactored,35,This PR might need to be closed or refactored. We now have `VerticallyImplicitTimeDiscretization`. A new turbulence closure called `ConvectiveAdjustmentDiffusivity` would probably useful for some users. For this the convective adjustment diffusivity should be precomputed. During this computation the vertical buoyancy gradient can be calculated on the fly with the function `∂z_b`; so there would be no need to store the vertical buoyancy gradient separately.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342#issuecomment-848999805
https://github.com/CliMA/Oceananigans.jl/pull/1343#issuecomment-775390912:27,Deployability,release,release,27,Don't forget to rename the release with an emoji. Each release gets an emoji!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1343#issuecomment-775390912
https://github.com/CliMA/Oceananigans.jl/pull/1343#issuecomment-775390912:55,Deployability,release,release,55,Don't forget to rename the release with an emoji. Each release gets an emoji!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1343#issuecomment-775390912
https://github.com/CliMA/Oceananigans.jl/pull/1343#issuecomment-775391965:29,Deployability,release,release,29,"> Don't forget to rename the release with an emoji. Each release gets an emoji!. Mostly I was stressed about picking one that's why I wanted you to do it. But I should toughen up, take responsibilities, and pick the emoji myself. :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1343#issuecomment-775391965
https://github.com/CliMA/Oceananigans.jl/pull/1343#issuecomment-775391965:57,Deployability,release,release,57,"> Don't forget to rename the release with an emoji. Each release gets an emoji!. Mostly I was stressed about picking one that's why I wanted you to do it. But I should toughen up, take responsibilities, and pick the emoji myself. :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1343#issuecomment-775391965
https://github.com/CliMA/Oceananigans.jl/pull/1346#issuecomment-775428627:99,Safety,avoid,avoid,99,Ah I think Buildkite tests did not run on this PR since we disable Buildkite on PRs from forks (to avoid random PRs executing potentially malicious code on our machines). So we usually open and merge branches from the repo itself. You should be able to do this since you're a repo collaborator.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1346#issuecomment-775428627
https://github.com/CliMA/Oceananigans.jl/pull/1346#issuecomment-775428627:21,Testability,test,tests,21,Ah I think Buildkite tests did not run on this PR since we disable Buildkite on PRs from forks (to avoid random PRs executing potentially malicious code on our machines). So we usually open and merge branches from the repo itself. You should be able to do this since you're a repo collaborator.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1346#issuecomment-775428627
https://github.com/CliMA/Oceananigans.jl/pull/1346#issuecomment-775442336:218,Testability,test,tests,218,Tried starting a new build manually from your fork but that didn't work (https://buildkite.com/clima/oceananigans/builds/1068) so I enabled Buildkite builds from forks and pushed an empty commit to this PR. Looks like tests are running now!. All future commits to this PR should trigger tests as well.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1346#issuecomment-775442336
https://github.com/CliMA/Oceananigans.jl/pull/1346#issuecomment-775442336:287,Testability,test,tests,287,Tried starting a new build manually from your fork but that didn't work (https://buildkite.com/clima/oceananigans/builds/1068) so I enabled Buildkite builds from forks and pushed an empty commit to this PR. Looks like tests are running now!. All future commits to this PR should trigger tests as well.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1346#issuecomment-775442336
https://github.com/CliMA/Oceananigans.jl/pull/1348#issuecomment-776027086:316,Testability,test,tested,316,"A question @ali-ramadhan , how much work will it be to have a stretched grid in `x`? I ask because I want to do a `ShallowWaterModel` run wtih a western boundary current and an intensified western grid. I'm happy to work on this sometime but curious as to how much effort you think this will take, after it is fully tested of course.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348#issuecomment-776027086
https://github.com/CliMA/Oceananigans.jl/pull/1348#issuecomment-776236013:318,Testability,test,tested,318,"> A question @ali-ramadhan , how much work will it be to have a stretched grid in `x`? I ask because I want to do a `ShallowWaterModel` run wtih a western boundary current and an intensified western grid. I'm happy to work on this sometime but curious as to how much effort you think this will take, after it is fully tested of course. The hardest part of implementing a vertically-stretched grid for an incompressible model was implementing and testing the pressure solver. So it should be pretty straightforward to stretch x and y for `ShallowWaterModel` (or any model without a pressure solver), just maybe a little tedious. . Right now in `Oceananigans.Operators` we have functions `Δx(i, j, k, grid)` and `Δy(i, j, k, grid)` that return the grid spacings at grid point `[i, j, k]`. Stretching the staggered grid in x and y we will need to add `ΔxC` and `ΔxF` functions (same for y) for the grid spacing between cell centers and cell faces and use them in the appropriate places (same for area and volume functions). This will probably mirror what has been done for z with `ΔzF` and `ΔzC`. Thankfully it'll probably be hard to break the code since there are so many tests in place that will fail if you miss a change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348#issuecomment-776236013
https://github.com/CliMA/Oceananigans.jl/pull/1348#issuecomment-776236013:446,Testability,test,testing,446,"> A question @ali-ramadhan , how much work will it be to have a stretched grid in `x`? I ask because I want to do a `ShallowWaterModel` run wtih a western boundary current and an intensified western grid. I'm happy to work on this sometime but curious as to how much effort you think this will take, after it is fully tested of course. The hardest part of implementing a vertically-stretched grid for an incompressible model was implementing and testing the pressure solver. So it should be pretty straightforward to stretch x and y for `ShallowWaterModel` (or any model without a pressure solver), just maybe a little tedious. . Right now in `Oceananigans.Operators` we have functions `Δx(i, j, k, grid)` and `Δy(i, j, k, grid)` that return the grid spacings at grid point `[i, j, k]`. Stretching the staggered grid in x and y we will need to add `ΔxC` and `ΔxF` functions (same for y) for the grid spacing between cell centers and cell faces and use them in the appropriate places (same for area and volume functions). This will probably mirror what has been done for z with `ΔzF` and `ΔzC`. Thankfully it'll probably be hard to break the code since there are so many tests in place that will fail if you miss a change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348#issuecomment-776236013
https://github.com/CliMA/Oceananigans.jl/pull/1348#issuecomment-776236013:1170,Testability,test,tests,1170,"> A question @ali-ramadhan , how much work will it be to have a stretched grid in `x`? I ask because I want to do a `ShallowWaterModel` run wtih a western boundary current and an intensified western grid. I'm happy to work on this sometime but curious as to how much effort you think this will take, after it is fully tested of course. The hardest part of implementing a vertically-stretched grid for an incompressible model was implementing and testing the pressure solver. So it should be pretty straightforward to stretch x and y for `ShallowWaterModel` (or any model without a pressure solver), just maybe a little tedious. . Right now in `Oceananigans.Operators` we have functions `Δx(i, j, k, grid)` and `Δy(i, j, k, grid)` that return the grid spacings at grid point `[i, j, k]`. Stretching the staggered grid in x and y we will need to add `ΔxC` and `ΔxF` functions (same for y) for the grid spacing between cell centers and cell faces and use them in the appropriate places (same for area and volume functions). This will probably mirror what has been done for z with `ΔzF` and `ΔzC`. Thankfully it'll probably be hard to break the code since there are so many tests in place that will fail if you miss a change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348#issuecomment-776236013
https://github.com/CliMA/Oceananigans.jl/pull/1348#issuecomment-782308591:3,Testability,test,tests,3,If tests pass I'll merge this so it can be used with the hydrostatic model. Also don't want it to go stale again with operators being changed. I'll open a subsequent PR that makes the vertically stretched grid work on the GPU.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348#issuecomment-782308591
https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776767674:529,Deployability,continuous,continuous,529,"> One thing that I noticed is that advection seemed to be commented out for tracers. Did I read that right?. Yes --- because we are still finalizing the user interface that controls the advection term + advection scheme for momentum and tracers. I think ideally we want to preserve the ability to use high-order advection schemes for momentum when we are on a `RegularCartesianGrid`. However, we also have to use a ""vector-invariant form"" of the advection term when running on curvilinear grids. So we need a way to specify both continuous and numerical aspects of the advection term implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776767674
https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776767674:158,Integrability,interface,interface,158,"> One thing that I noticed is that advection seemed to be commented out for tracers. Did I read that right?. Yes --- because we are still finalizing the user interface that controls the advection term + advection scheme for momentum and tracers. I think ideally we want to preserve the ability to use high-order advection schemes for momentum when we are on a `RegularCartesianGrid`. However, we also have to use a ""vector-invariant form"" of the advection term when running on curvilinear grids. So we need a way to specify both continuous and numerical aspects of the advection term implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776767674
https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776771313:238,Deployability,continuous,continuous,238,"@ali-ramadhan @francispoulin I propose that for the time being we use an abstraction where `advection` has a field `momentum` and a field for every tracer. The value of this field controls the implementation of the `advection` term, with continuous and numerical aspects ""flattened"" into a single spec. If one writes `VectorInvariant`, then we implement a second-order `VectorInvariant` form of the momentum equations. If one provides an advection scheme, when we implement a conservation form of the momentum / tracer equations with the associated stencil. When we have curvilinear grids we will need a function `validate_advection(advection, grid)` to ensure that a conservation form scheme isn't used on a curvilinear grid (for example). There's a similar consideration for stretched grids and our current WENO implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776771313
https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776789031:150,Security,validat,validate,150,"I think a single `advection` kwarg would make for a cleaner UI, since there are already lots of model kwargs. I agree it's a bit messier to parse and validate but the parsing and validation can be done by small functions in a separate file.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776789031
https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776789031:179,Security,validat,validation,179,"I think a single `advection` kwarg would make for a cleaner UI, since there are already lots of model kwargs. I agree it's a bit messier to parse and validate but the parsing and validation can be done by small functions in a separate file.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776789031
https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-777882397:38,Modifiability,rewrite,rewrite,38,@glwagner I won't ask for git history rewrite now but let's not get into the habit of calling me Dr Constantinou.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-777882397
https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778445530:132,Testability,test,tests,132,> Looks good to merge!; > ; > Won't pile onto the reviews except to say it would be good to merge master into this PR and make sure tests pass (if you haven't already) since tests are failing on master: Oceananigans won't even precompile since there's a lingering reference to `SurfaceWaves` somewhere in the hydrostatic model I think. I’ll do that. I don’t know why tests on master fail! I was puzzled also. I merged the make_example script (whose PR tests were OK) and then tests on master broke...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778445530
https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778445530:174,Testability,test,tests,174,> Looks good to merge!; > ; > Won't pile onto the reviews except to say it would be good to merge master into this PR and make sure tests pass (if you haven't already) since tests are failing on master: Oceananigans won't even precompile since there's a lingering reference to `SurfaceWaves` somewhere in the hydrostatic model I think. I’ll do that. I don’t know why tests on master fail! I was puzzled also. I merged the make_example script (whose PR tests were OK) and then tests on master broke...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778445530
https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778445530:367,Testability,test,tests,367,> Looks good to merge!; > ; > Won't pile onto the reviews except to say it would be good to merge master into this PR and make sure tests pass (if you haven't already) since tests are failing on master: Oceananigans won't even precompile since there's a lingering reference to `SurfaceWaves` somewhere in the hydrostatic model I think. I’ll do that. I don’t know why tests on master fail! I was puzzled also. I merged the make_example script (whose PR tests were OK) and then tests on master broke...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778445530
https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778445530:452,Testability,test,tests,452,> Looks good to merge!; > ; > Won't pile onto the reviews except to say it would be good to merge master into this PR and make sure tests pass (if you haven't already) since tests are failing on master: Oceananigans won't even precompile since there's a lingering reference to `SurfaceWaves` somewhere in the hydrostatic model I think. I’ll do that. I don’t know why tests on master fail! I was puzzled also. I merged the make_example script (whose PR tests were OK) and then tests on master broke...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778445530
https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778445530:476,Testability,test,tests,476,> Looks good to merge!; > ; > Won't pile onto the reviews except to say it would be good to merge master into this PR and make sure tests pass (if you haven't already) since tests are failing on master: Oceananigans won't even precompile since there's a lingering reference to `SurfaceWaves` somewhere in the hydrostatic model I think. I’ll do that. I don’t know why tests on master fail! I was puzzled also. I merged the make_example script (whose PR tests were OK) and then tests on master broke...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778445530
https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778464227:274,Modifiability,variab,variables,274,"> This is of course a lot of overlap between this model and ShallowWaterModel. @francispoulin physically yes but numerically no. `ShallowWaterModel` uses a conservative formulation that solves for the thickness-weighted velocities `hu` and `hv`. Here we use the ""primitive"" variables `u`, and `v`. In addition to that, the free surface displacement equation is linearized. In the future, we could envision generalizing `HydrostaticFreeSurfaceModel` to have a nonlinear free surface and also to have a ""layered"" implementation that might use the thickness weighted velocities like `ShallowWaterModel`. At that point there might be overlap and we can consider merging the two and combining our work...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778464227
https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778466439:465,Deployability,update,updated,465,"> Could you give a brief summary how the model equations differ from implicit to explicit free-surface?. It might be best to save that for the PR that implements the implicit free surface. Suffice to say that the implicit free surface uses a fractional step algorithm that first advances the velocity field to a predictor state U*, and then takes a free surface time-step using a backwards Euler method that utilizes U*. After that, the predictor velocity field is updated using the new barotropic pressure associated with η^{n+1}. The algorithm is described in the MITgcm docs:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#pressure-method-with-implicit-linear-free-surface",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778466439
https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778466439:312,Safety,predict,predictor,312,"> Could you give a brief summary how the model equations differ from implicit to explicit free-surface?. It might be best to save that for the PR that implements the implicit free surface. Suffice to say that the implicit free surface uses a fractional step algorithm that first advances the velocity field to a predictor state U*, and then takes a free surface time-step using a backwards Euler method that utilizes U*. After that, the predictor velocity field is updated using the new barotropic pressure associated with η^{n+1}. The algorithm is described in the MITgcm docs:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#pressure-method-with-implicit-linear-free-surface",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778466439
https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778466439:437,Safety,predict,predictor,437,"> Could you give a brief summary how the model equations differ from implicit to explicit free-surface?. It might be best to save that for the PR that implements the implicit free surface. Suffice to say that the implicit free surface uses a fractional step algorithm that first advances the velocity field to a predictor state U*, and then takes a free surface time-step using a backwards Euler method that utilizes U*. After that, the predictor velocity field is updated using the new barotropic pressure associated with η^{n+1}. The algorithm is described in the MITgcm docs:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#pressure-method-with-implicit-linear-free-surface",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778466439
https://github.com/CliMA/Oceananigans.jl/pull/1353#issuecomment-777915733:15,Usability,simpl,simplify,15,"I guess we can simplify this even more by dropping DocumenterCitations all together? The idea for this script is to be able to build the Docs with only one or a few examples. So no bibliography is needed, right?. I'll let @ali-ramadhan remark on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1353#issuecomment-777915733
https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359:182,Integrability,interface,interface,182,I think we decided we would merge this in its current form and add tests for different topologies and Helmholtz equations in a future PR. In future PR(s) we should also refactor the interface to be more consistent with the other solvers and to use CuArrays in the solver itself. I think we don't intend to use the `PreconditionedConjugateGradientSolver` with `IncompressibleModel` so I removed it from the constructor. I presume a PCG solver will be created in the hydrostatic model constructor. Although a good regression test would be to run an `IncompressibleModel` with a PCG pressure solver and make sure it matches the regression data.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359
https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359:169,Modifiability,refactor,refactor,169,I think we decided we would merge this in its current form and add tests for different topologies and Helmholtz equations in a future PR. In future PR(s) we should also refactor the interface to be more consistent with the other solvers and to use CuArrays in the solver itself. I think we don't intend to use the `PreconditionedConjugateGradientSolver` with `IncompressibleModel` so I removed it from the constructor. I presume a PCG solver will be created in the hydrostatic model constructor. Although a good regression test would be to run an `IncompressibleModel` with a PCG pressure solver and make sure it matches the regression data.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359
https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359:67,Testability,test,tests,67,I think we decided we would merge this in its current form and add tests for different topologies and Helmholtz equations in a future PR. In future PR(s) we should also refactor the interface to be more consistent with the other solvers and to use CuArrays in the solver itself. I think we don't intend to use the `PreconditionedConjugateGradientSolver` with `IncompressibleModel` so I removed it from the constructor. I presume a PCG solver will be created in the hydrostatic model constructor. Although a good regression test would be to run an `IncompressibleModel` with a PCG pressure solver and make sure it matches the regression data.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359
https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359:523,Testability,test,test,523,I think we decided we would merge this in its current form and add tests for different topologies and Helmholtz equations in a future PR. In future PR(s) we should also refactor the interface to be more consistent with the other solvers and to use CuArrays in the solver itself. I think we don't intend to use the `PreconditionedConjugateGradientSolver` with `IncompressibleModel` so I removed it from the constructor. I presume a PCG solver will be created in the hydrostatic model constructor. Although a good regression test would be to run an `IncompressibleModel` with a PCG pressure solver and make sure it matches the regression data.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359
https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781640012:29,Testability,test,test,29,> Although a good regression test would be to run an IncompressibleModel with a PCG pressure solver and make sure it matches the regression data. That might not work because the PCG doesn't get to machine precision though right?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781640012
https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781644482:281,Availability,toler,tolerance,281,> That might not work because the PCG doesn't get to machine precision though right?. You can set the precision low enough to pass the regression test. This would add extra iterations but the regression test grids are pretty small so might be feasible. Or we can just increase the tolerance on the regression test.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781644482
https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781644482:146,Testability,test,test,146,> That might not work because the PCG doesn't get to machine precision though right?. You can set the precision low enough to pass the regression test. This would add extra iterations but the regression test grids are pretty small so might be feasible. Or we can just increase the tolerance on the regression test.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781644482
https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781644482:203,Testability,test,test,203,> That might not work because the PCG doesn't get to machine precision though right?. You can set the precision low enough to pass the regression test. This would add extra iterations but the regression test grids are pretty small so might be feasible. Or we can just increase the tolerance on the regression test.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781644482
https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781644482:309,Testability,test,test,309,> That might not work because the PCG doesn't get to machine precision though right?. You can set the precision low enough to pass the regression test. This would add extra iterations but the regression test grids are pretty small so might be feasible. Or we can just increase the tolerance on the regression test.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781644482
https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780101036:48,Energy Efficiency,reduce,reduce,48,"I think the setup looks great! Hopefully we can reduce the number of import statements (especially after #1132). The 2D turbulence example always looks great but it might be nice to do something different just to have more variety in the examples. Is there a neat example that requires a shallow water model?. Alternatively we could convert the 2D turbulence example to use `ShallowWaterModel` if the output still looks cool. This would increase variety among the existing examples. Having an example with `ShallowWaterModel` would suggest it's ready for use though, so it should then be exported.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780101036
https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780104409:50,Energy Efficiency,reduce,reduce,50,"> I think the setup looks great! Hopefully we can reduce the number of import statements (especially after #1132).; > ; > The 2D turbulence example always looks great but it might be nice to do something different just to have more variety in the examples. Is there a neat example that requires a shallow water model?; > ; > Alternatively we could convert the 2D turbulence example to use `ShallowWaterModel` if it doesn't change the output much. This would increase variety among the existing examples.; > ; > Having an example with `ShallowWaterModel` would suggest it's ready for use though, so it should then be exported. Thanks @ali, for the quick and thoughtful reply. Some excellent points. Inspired by your comments, I added two bullets above. First, reduce the number of import statements. This because I did not import as much elsewhere, and I agree this should be fixed to make ti easier to use. Second, one thing that `ShallowWaterModel` has that the `IncompressibleModel` does not have are surface waves, so a divergence. I think that plotting the vorticity, which is the balanced part of the flow, and the divergence (or even the free-surface), unbalanced part of the flow, might be interesting, Or we could add the `ShallowWaterModel` as an option for the turublence example. . Third, I don't want this to be out until we are happy with the `ShallowWaterModel`. I am also working on the Bickley jet and hope to talk to @glw about that tomorrow to get it cleaned up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780104409
https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780104409:759,Energy Efficiency,reduce,reduce,759,"> I think the setup looks great! Hopefully we can reduce the number of import statements (especially after #1132).; > ; > The 2D turbulence example always looks great but it might be nice to do something different just to have more variety in the examples. Is there a neat example that requires a shallow water model?; > ; > Alternatively we could convert the 2D turbulence example to use `ShallowWaterModel` if it doesn't change the output much. This would increase variety among the existing examples.; > ; > Having an example with `ShallowWaterModel` would suggest it's ready for use though, so it should then be exported. Thanks @ali, for the quick and thoughtful reply. Some excellent points. Inspired by your comments, I added two bullets above. First, reduce the number of import statements. This because I did not import as much elsewhere, and I agree this should be fixed to make ti easier to use. Second, one thing that `ShallowWaterModel` has that the `IncompressibleModel` does not have are surface waves, so a divergence. I think that plotting the vorticity, which is the balanced part of the flow, and the divergence (or even the free-surface), unbalanced part of the flow, might be interesting, Or we could add the `ShallowWaterModel` as an option for the turublence example. . Third, I don't want this to be out until we are happy with the `ShallowWaterModel`. I am also working on the Bickley jet and hope to talk to @glw about that tomorrow to get it cleaned up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780104409
https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780111461:2,Availability,echo,echo,2,"I echo @ali-ramadhan that since examples are expensive to maintain it'd be nice to have some topical diversity. Perhaps a different initial conditions in a geometry with walls, on a beta plane... ?!? We don't have any channel geometry or `BetaPlane` examples right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780111461
https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780599859:15,Usability,feedback,feedback,15,"Thanks for the feedback @glwagner and @navidcy . I think it would be easy to do this in a channel on a beta-plane and see some zonal jets developing. That would be great to do. Also, if you turn off beta one should of course get a very similar result to the two-dimensional turbulence example. I'll get to work on this today and share what I come up with. . Do we have biharmonic diffusion in Oceananigans already? If yes I'm also happy to play with that too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780599859
https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799458870:190,Testability,test,tested,190,@Lichriszz I wanted to tell you that there is a working example of two-dimensional shallow water model in the branch `distributed-shallow-water-model`. There is an MPI version that is being tested but the serial script should work on the main branch. https://github.com/CliMA/Oceananigans.jl/blob/distributed-shallow-water/examples/serial_shallow_water_turbulence.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799458870
https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263:197,Availability,redundant,redundant,197,"I don't believe there is a strong need for this example as it is. Considering that #1430 is using two-dimensional turbulence a as a test case, and that might become an example, this PR seems a bit redundant. That is why I will close this but happy to return to it if there is interest. There was mention of introducing beta and looking at the development of zonal jets. This is easy enough to do and could be fun, but not sure if this warrents an example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263
https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263:197,Safety,redund,redundant,197,"I don't believe there is a strong need for this example as it is. Considering that #1430 is using two-dimensional turbulence a as a test case, and that might become an example, this PR seems a bit redundant. That is why I will close this but happy to return to it if there is interest. There was mention of introducing beta and looking at the development of zonal jets. This is easy enough to do and could be fun, but not sure if this warrents an example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263
https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263:132,Testability,test,test,132,"I don't believe there is a strong need for this example as it is. Considering that #1430 is using two-dimensional turbulence a as a test case, and that might become an example, this PR seems a bit redundant. That is why I will close this but happy to return to it if there is interest. There was mention of introducing beta and looking at the development of zonal jets. This is easy enough to do and could be fun, but not sure if this warrents an example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263
https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780567324:116,Deployability,pipeline,pipeline,116,> How permanent is the Bickley jet validation experiment? Is it worth adding to the validation experiment Buildkite pipeline in the future?. Let's hold off but discuss with @francispoulin about potentially turning it into something more quantitative (we can use [Poulin and Flierl (2003)](https://journals.ametsoc.org/view/journals/phoc/33/10/1520-0485_2003_033_2173_tneobu_2.0.co_2.xml) as a reference!),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780567324
https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780567324:35,Security,validat,validation,35,> How permanent is the Bickley jet validation experiment? Is it worth adding to the validation experiment Buildkite pipeline in the future?. Let's hold off but discuss with @francispoulin about potentially turning it into something more quantitative (we can use [Poulin and Flierl (2003)](https://journals.ametsoc.org/view/journals/phoc/33/10/1520-0485_2003_033_2173_tneobu_2.0.co_2.xml) as a reference!),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780567324
https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780567324:84,Security,validat,validation,84,> How permanent is the Bickley jet validation experiment? Is it worth adding to the validation experiment Buildkite pipeline in the future?. Let's hold off but discuss with @francispoulin about potentially turning it into something more quantitative (we can use [Poulin and Flierl (2003)](https://journals.ametsoc.org/view/journals/phoc/33/10/1520-0485_2003_033_2173_tneobu_2.0.co_2.xml) as a reference!),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780567324
https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780729036:34,Availability,checkpoint,checkpointer,34,@ali-ramadhan do you know why the checkpointer tests are failing?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780729036
https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780729036:47,Testability,test,tests,47,@ali-ramadhan do you know why the checkpointer tests are failing?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780729036
https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780733376:42,Availability,checkpoint,checkpointer,42,@glwagner Looks like it's just one of the checkpointer tests. They occasionally fail on the GPU. I think it's related to https://github.com/CliMA/Oceananigans.jl/issues/1179. I reran the build. Should hopefully pass now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780733376
https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780733376:55,Testability,test,tests,55,@glwagner Looks like it's just one of the checkpointer tests. They occasionally fail on the GPU. I think it's related to https://github.com/CliMA/Oceananigans.jl/issues/1179. I reran the build. Should hopefully pass now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780733376
https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780201946:248,Deployability,release,releases,248,Ah once the PR is merged you just do it via a comment (we comment on the latest commit): https://github.com/CliMA/Oceananigans.jl/commit/47caa85138047acb4584cf97092c62c3e59b3543#comments. You're a repo collaborator so you should be able to tag new releases. Under ColPrac people should merge their own PRs to avoid surprises but I'll take your comment as permission to merge and tag a new release :P,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780201946
https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780201946:389,Deployability,release,release,389,Ah once the PR is merged you just do it via a comment (we comment on the latest commit): https://github.com/CliMA/Oceananigans.jl/commit/47caa85138047acb4584cf97092c62c3e59b3543#comments. You're a repo collaborator so you should be able to tag new releases. Under ColPrac people should merge their own PRs to avoid surprises but I'll take your comment as permission to merge and tag a new release :P,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780201946
https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780201946:309,Safety,avoid,avoid,309,Ah once the PR is merged you just do it via a comment (we comment on the latest commit): https://github.com/CliMA/Oceananigans.jl/commit/47caa85138047acb4584cf97092c62c3e59b3543#comments. You're a repo collaborator so you should be able to tag new releases. Under ColPrac people should merge their own PRs to avoid surprises but I'll take your comment as permission to merge and tag a new release :P,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780201946
https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780208984:133,Deployability,release,release,133,> Under ColPrac people should merge their own PRs to avoid surprises but I'll take your comment as permission to merge and tag a new release :P. I have been doing that. I'm just not sure about the tagging thing so I thought it was best if you did it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780208984
https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780208984:53,Safety,avoid,avoid,53,> Under ColPrac people should merge their own PRs to avoid surprises but I'll take your comment as permission to merge and tag a new release :P. I have been doing that. I'm just not sure about the tagging thing so I thought it was best if you did it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780208984
https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781613405:38,Testability,test,test,38,"@whitleyv do you mind if I add a unit test to ensure that `IncompressibleModel` can take one time step with a simple `immersed_boundary`? This will exercise the code that's being added during CI, so that it can't be accidentally broken in a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781613405
https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781613405:110,Usability,simpl,simple,110,"@whitleyv do you mind if I add a unit test to ensure that `IncompressibleModel` can take one time step with a simple `immersed_boundary`? This will exercise the code that's being added during CI, so that it can't be accidentally broken in a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781613405
https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560:245,Availability,Error,Error,245,"The `ShallowWaterModel` tests are failing:. ```; [2021/02/17 14:56:04.486] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; --;   | Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /storage7/buildkite-agent/builds/tartarus-mit-edu-3/clima/oceananigans/test/test_shallow_water_models.jl:118;   | Test threw exception;   | Expression: time_stepping_shallow_water_model_works(arch, topo, nothing, nothing);   | type ShallowWaterModel has no field immersed_boundary; ```. I think what we really want to do is define a fallback `correct_immersed_tendencies!(args...) = nothing` in the `TimeSteppers` module (so that other models which do not have immersed boundary functionality can be time-stepped), and move the current definition of `correct_immersed_tendencies!` that's specific to `IncompressibleModel` to the `Models.IncompressibleModels` module. @whitleyv let me know what you'd like to do: you can make these changes, or I can help either by pair programming or making them myself.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560
https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560:24,Testability,test,tests,24,"The `ShallowWaterModel` tests are failing:. ```; [2021/02/17 14:56:04.486] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; --;   | Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /storage7/buildkite-agent/builds/tartarus-mit-edu-3/clima/oceananigans/test/test_shallow_water_models.jl:118;   | Test threw exception;   | Expression: time_stepping_shallow_water_model_works(arch, topo, nothing, nothing);   | type ShallowWaterModel has no field immersed_boundary; ```. I think what we really want to do is define a fallback `correct_immersed_tendencies!(args...) = nothing` in the `TimeSteppers` module (so that other models which do not have immersed boundary functionality can be time-stepped), and move the current definition of `correct_immersed_tendencies!` that's specific to `IncompressibleModel` to the `Models.IncompressibleModels` module. @whitleyv let me know what you'd like to do: you can make these changes, or I can help either by pair programming or making them myself.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560
https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560:80,Testability,Test,Testing,80,"The `ShallowWaterModel` tests are failing:. ```; [2021/02/17 14:56:04.486] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; --;   | Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /storage7/buildkite-agent/builds/tartarus-mit-edu-3/clima/oceananigans/test/test_shallow_water_models.jl:118;   | Test threw exception;   | Expression: time_stepping_shallow_water_model_works(arch, topo, nothing, nothing);   | type ShallowWaterModel has no field immersed_boundary; ```. I think what we really want to do is define a fallback `correct_immersed_tendencies!(args...) = nothing` in the `TimeSteppers` module (so that other models which do not have immersed boundary functionality can be time-stepped), and move the current definition of `correct_immersed_tendencies!` that's specific to `IncompressibleModel` to the `Models.IncompressibleModels` module. @whitleyv let me know what you'd like to do: you can make these changes, or I can help either by pair programming or making them myself.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560
https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560:258,Testability,Test,Test,258,"The `ShallowWaterModel` tests are failing:. ```; [2021/02/17 14:56:04.486] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; --;   | Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /storage7/buildkite-agent/builds/tartarus-mit-edu-3/clima/oceananigans/test/test_shallow_water_models.jl:118;   | Test threw exception;   | Expression: time_stepping_shallow_water_model_works(arch, topo, nothing, nothing);   | type ShallowWaterModel has no field immersed_boundary; ```. I think what we really want to do is define a fallback `correct_immersed_tendencies!(args...) = nothing` in the `TimeSteppers` module (so that other models which do not have immersed boundary functionality can be time-stepped), and move the current definition of `correct_immersed_tendencies!` that's specific to `IncompressibleModel` to the `Models.IncompressibleModels` module. @whitleyv let me know what you'd like to do: you can make these changes, or I can help either by pair programming or making them myself.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560
https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560:337,Testability,test,test,337,"The `ShallowWaterModel` tests are failing:. ```; [2021/02/17 14:56:04.486] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; --;   | Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /storage7/buildkite-agent/builds/tartarus-mit-edu-3/clima/oceananigans/test/test_shallow_water_models.jl:118;   | Test threw exception;   | Expression: time_stepping_shallow_water_model_works(arch, topo, nothing, nothing);   | type ShallowWaterModel has no field immersed_boundary; ```. I think what we really want to do is define a fallback `correct_immersed_tendencies!(args...) = nothing` in the `TimeSteppers` module (so that other models which do not have immersed boundary functionality can be time-stepped), and move the current definition of `correct_immersed_tendencies!` that's specific to `IncompressibleModel` to the `Models.IncompressibleModels` module. @whitleyv let me know what you'd like to do: you can make these changes, or I can help either by pair programming or making them myself.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560
https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560:380,Testability,Test,Test,380,"The `ShallowWaterModel` tests are failing:. ```; [2021/02/17 14:56:04.486] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; --;   | Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /storage7/buildkite-agent/builds/tartarus-mit-edu-3/clima/oceananigans/test/test_shallow_water_models.jl:118;   | Test threw exception;   | Expression: time_stepping_shallow_water_model_works(arch, topo, nothing, nothing);   | type ShallowWaterModel has no field immersed_boundary; ```. I think what we really want to do is define a fallback `correct_immersed_tendencies!(args...) = nothing` in the `TimeSteppers` module (so that other models which do not have immersed boundary functionality can be time-stepped), and move the current definition of `correct_immersed_tendencies!` that's specific to `IncompressibleModel` to the `Models.IncompressibleModels` module. @whitleyv let me know what you'd like to do: you can make these changes, or I can help either by pair programming or making them myself.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781615560
https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781743506:52,Testability,test,test,52,"@glwagner ; > @whitleyv do you mind if I add a unit test to ensure that `IncompressibleModel` can take one time step with a simple `immersed_boundary`? This will exercise the code that's being added during CI, so that it can't be accidentally broken in a future PR. By all means! Whatever will help. > I think what we really want to do is define a fallback `correct_immersed_tendencies!(args...) = nothing` in the `TimeSteppers` module . Is this different than the `correct_immersed_tendencies!(model, ::Nothing, Δt, γⁿ, ζⁿ) = nothing` I have?. > @whitleyv let me know what you'd like to do: you can make these changes, or I can help either by pair programming or making them myself. I don't mind moving the `correct_immersed_tendencies!` to the `Models.IncompressibleModels` module. I know y'all moved a lot of things away from the `Timesteppers`, which makes sense. If you have the time, it'd probably be better for you to either help me or do it yourself, since I'm not sure I'd catch all the parts I need to add. > @whitleyv should we add `correct_immersed_tendencies!` to the quasi-second-order Adams-Bashforth algorithm as well?. Right now the `correct_immersed_tendencies! ` is specific to RK3 in how we negate the tendencies, but I think the future implementation will be more versatile!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781743506
https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781743506:124,Usability,simpl,simple,124,"@glwagner ; > @whitleyv do you mind if I add a unit test to ensure that `IncompressibleModel` can take one time step with a simple `immersed_boundary`? This will exercise the code that's being added during CI, so that it can't be accidentally broken in a future PR. By all means! Whatever will help. > I think what we really want to do is define a fallback `correct_immersed_tendencies!(args...) = nothing` in the `TimeSteppers` module . Is this different than the `correct_immersed_tendencies!(model, ::Nothing, Δt, γⁿ, ζⁿ) = nothing` I have?. > @whitleyv let me know what you'd like to do: you can make these changes, or I can help either by pair programming or making them myself. I don't mind moving the `correct_immersed_tendencies!` to the `Models.IncompressibleModels` module. I know y'all moved a lot of things away from the `Timesteppers`, which makes sense. If you have the time, it'd probably be better for you to either help me or do it yourself, since I'm not sure I'd catch all the parts I need to add. > @whitleyv should we add `correct_immersed_tendencies!` to the quasi-second-order Adams-Bashforth algorithm as well?. Right now the `correct_immersed_tendencies! ` is specific to RK3 in how we negate the tendencies, but I think the future implementation will be more versatile!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781743506
https://github.com/CliMA/Oceananigans.jl/issues/1369#issuecomment-780604891:31,Usability,clear,clearer,31,I agree with this. It makes it clearer what's happening behind the scenes. I'd prefer keeping the `parameters` keyword for now though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369#issuecomment-780604891
https://github.com/CliMA/Oceananigans.jl/issues/1370#issuecomment-781514348:100,Usability,clear,clearly,100,"I guess I'm confused about these signatures. I feel like in Python the function signatures are very clearly communicated by the prompt itself, etc. But in Julia I often get confused. For example, from the lines you mentioned I'd think the signature would be. ```; KernelComputedField(kernel, arch, grid; kwargs...) ; ```. But in practice we actually call it as; ```julia; ε = KernelComputedField(Center, Center, Center, isotropic_viscous_dissipation_ccc!, model;; field_dependencies=(νₑ, u, v, w)); ```; because of multiple dispatch here: https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L70-L71. So I'd think that the signature should really be; ```; KernelComputedField(X, Y, Z, kernel, model; kwargs...) ; ```. Or, because they're all valid ways to call the function, should they be all of those?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1370#issuecomment-781514348
https://github.com/CliMA/Oceananigans.jl/pull/1371#issuecomment-780769320:71,Testability,test,test,71,I'm gonna stick to `FPlane` for now because we don't have a regression test for `BetaPlane`. Once we get the regression tests in I'll submit a new PR for `BetaPlane`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371#issuecomment-780769320
https://github.com/CliMA/Oceananigans.jl/pull/1371#issuecomment-780769320:120,Testability,test,tests,120,I'm gonna stick to `FPlane` for now because we don't have a regression test for `BetaPlane`. Once we get the regression tests in I'll submit a new PR for `BetaPlane`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371#issuecomment-780769320
https://github.com/CliMA/Oceananigans.jl/pull/1371#issuecomment-780789191:42,Testability,test,tests,42,"Ok, I suggest we merge this if regression tests pass as a sort of ""experimental"" PR. The next PR will be a bit more drastic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371#issuecomment-780789191
https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-783478944:67,Modifiability,extend,extend,67,"This sounds like a good idea!. I guess it shouldn't be too hard to extend the implementation to support `fx`, `fy`, and `fz` like you're suggesting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-783478944
https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885020205:22,Integrability,interface,interface,22,"We could implement an interface similar to `Buoyancy`, but I think this may be more easily done with `FPlane`, since `NonTraditionalFPlane` seems to be dedicated not for tilting domains, but for decomposing rotation based on latitude. We'd have something like. ```julia; θ_rad = 0.05 # radians; g̃ = (sin(θ_rad), 0, cos(θ_rad)); buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=g̃); coriolis = FPlane(f=1e-4, vertical_unit_vector=g̃); ```. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885020205
https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885183732:271,Usability,clear,clear,271,"> Might be nice to have a `vertical_unit_vector` for both, right? Tilting the Coriolis force adds identical terms that are added when considering the full Coriolis force. Does it make sense to tilt the Coriolis force but retain the traditional approximation?. Just to be clear, you're saying that it might nice to have `vertical_unit_vector` for both traditional and non-traditional f-plane implementations? If so, I'm not sure.... I'd need to think more. Although with a tilting parameter `FPlane` can kinda do everything `NonTraditionalFPlane` can do and more, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885183732
https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885270896:948,Usability,learn,learn,948,"> If the `FPlane` name really is supposed to be a vertical-component-only f-plane then it might make sense to implement it using the `NonTraditionalFPlane`.; > ; > Although, if I'm being honest, these names aren't helpful to me at all. If more people agree could we also think about renaming them? I'm not sure what names would be good here, but something with ""vertical"" and ""full""?; > ; > EDIT: Maybe we only need `FPlane` and that's it? Then passing `FPlane(f=0)` would default to `vertical_unit_vector=ZDirection()`. Although the name `vertical_unit_vector` might be inappropriate if you're trying to consider the horizontal component because you're close to the equator, not because your domain is tilted... It seems like we really just need one type, something like `BackgroundRotation`. . `FPlane` could be an alias that inserts `rotation_axis=ZDirection()` or something. But, aliases are bad for various reasons, mostly because you have to learn not only the ""real"" names of things, but their aliases too to understand code. Another point is that Oceanographers know what `FPlane` means. Long ago this was discussed (at that time, I advocated for `BackgroundRotation` or something similar), but it was rejected in favor of `FPlane` and friends. We can't have both `BackgroundRotation` and `FPlane` without an alias. We can even reuse `BackgroundRotation` for grids with a latitude-longitude coordinate system (by dispatching on `grid` and `coriolis` simultaneously).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885270896
https://github.com/CliMA/Oceananigans.jl/pull/1373#issuecomment-849929096:149,Availability,down,download,149,"It doesn't change any code so it's not stale yet. What we need to do though is figure out how to upload data to `OceananigansArtifacts.jl`, and then download it into the test using `DataDeps`. @ali-ramadhan groks `DataDeps.jl` but I haven't yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373#issuecomment-849929096
https://github.com/CliMA/Oceananigans.jl/pull/1373#issuecomment-849929096:170,Testability,test,test,170,"It doesn't change any code so it's not stale yet. What we need to do though is figure out how to upload data to `OceananigansArtifacts.jl`, and then download it into the test using `DataDeps`. @ali-ramadhan groks `DataDeps.jl` but I haven't yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373#issuecomment-849929096
https://github.com/CliMA/Oceananigans.jl/pull/1373#issuecomment-849929606:82,Testability,test,test,82,"And just to provide more context, the reason for doing this is so that regression test data doesn't blow up the git repo. This is especially important here because we are going to make big changes to `HydrostaticFreeSurfaceModel`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373#issuecomment-849929606
https://github.com/CliMA/Oceananigans.jl/issues/1378#issuecomment-781574578:246,Performance,concurren,concurrently,246,"Ah! In `HydrostaticFreeSurfaceModel`, the implicit free surface algorithm uses a pressure correction / operator splitting method. It's really a sort of pseudo-implicit treatment (because the velocity field is _corrected_ rather than time-stepped concurrently with the free surface. I think it would be possible to implement an operator splitting method in `ShallowWaterModel`. But is this useful? This could lead to a loss of accuracy (I'm not sure). In the event that the pressure / free surface displacement is passive (so one doesn't care about accuracy), it might be better to use a rigid lid approximation (and thus a two-dimensional `IncompressibleModel`, rather than `ShallowWaterModel`). But I am ready to stand corrected.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1378#issuecomment-781574578
https://github.com/CliMA/Oceananigans.jl/issues/1378#issuecomment-1479848904:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1378#issuecomment-1479848904
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187:104,Deployability,patch,patch-,104,"@ali-ramadhan, the docs log says:; ```; ┌ Info:;   | │ Buildkite config:;   | │ Commit branch: ""tomchor-patch-1"";   | │ Pull request: ""false"";   | │ Commit tag: """";   | │ Detected build type: devbranch;   | │ - ✘ ENV[""BUILDKITE_BRANCH""] matches devbranch=""master"";   | │ - ✔ ENV[""DOCUMENTER_KEY""] exists;   | └ Deploying to folder ""dev"": ✘; ```; Seems like buildkite will only reply from master? I don't see where that setting in buildkite is though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187:311,Deployability,Deploy,Deploying,311,"@ali-ramadhan, the docs log says:; ```; ┌ Info:;   | │ Buildkite config:;   | │ Commit branch: ""tomchor-patch-1"";   | │ Pull request: ""false"";   | │ Commit tag: """";   | │ Detected build type: devbranch;   | │ - ✘ ENV[""BUILDKITE_BRANCH""] matches devbranch=""master"";   | │ - ✔ ENV[""DOCUMENTER_KEY""] exists;   | └ Deploying to folder ""dev"": ✘; ```; Seems like buildkite will only reply from master? I don't see where that setting in buildkite is though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187:65,Modifiability,config,config,65,"@ali-ramadhan, the docs log says:; ```; ┌ Info:;   | │ Buildkite config:;   | │ Commit branch: ""tomchor-patch-1"";   | │ Pull request: ""false"";   | │ Commit tag: """";   | │ Detected build type: devbranch;   | │ - ✘ ENV[""BUILDKITE_BRANCH""] matches devbranch=""master"";   | │ - ✔ ENV[""DOCUMENTER_KEY""] exists;   | └ Deploying to folder ""dev"": ✘; ```; Seems like buildkite will only reply from master? I don't see where that setting in buildkite is though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187:171,Safety,Detect,Detected,171,"@ali-ramadhan, the docs log says:; ```; ┌ Info:;   | │ Buildkite config:;   | │ Commit branch: ""tomchor-patch-1"";   | │ Pull request: ""false"";   | │ Commit tag: """";   | │ Detected build type: devbranch;   | │ - ✘ ENV[""BUILDKITE_BRANCH""] matches devbranch=""master"";   | │ - ✔ ENV[""DOCUMENTER_KEY""] exists;   | └ Deploying to folder ""dev"": ✘; ```; Seems like buildkite will only reply from master? I don't see where that setting in buildkite is though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187:24,Testability,log,log,24,"@ali-ramadhan, the docs log says:; ```; ┌ Info:;   | │ Buildkite config:;   | │ Commit branch: ""tomchor-patch-1"";   | │ Pull request: ""false"";   | │ Commit tag: """";   | │ Detected build type: devbranch;   | │ - ✘ ENV[""BUILDKITE_BRANCH""] matches devbranch=""master"";   | │ - ✔ ENV[""DOCUMENTER_KEY""] exists;   | └ Deploying to folder ""dev"": ✘; ```; Seems like buildkite will only reply from master? I don't see where that setting in buildkite is though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428:231,Deployability,deploy,deployconfig,231,"@navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?. https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725 . Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428:54,Modifiability,config,config,54,"@navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?. https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725 . Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428:475,Safety,detect,detected,475,"@navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?. https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725 . Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873:239,Deployability,deploy,deployconfig,239,"> @navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?; > ; > https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725; > ; > Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?. Perhaps if we update Documenter.jl in the docs to the latest version we can alleviate that. At the moment DocumenterCitations v0.2.0 is precluding Documenter from v0.26 and later; see https://github.com/ali-ramadhan/DocumenterCitations.jl/pull/34#issuecomment-782308024.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873:577,Deployability,update,update,577,"> @navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?; > ; > https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725; > ; > Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?. Perhaps if we update Documenter.jl in the docs to the latest version we can alleviate that. At the moment DocumenterCitations v0.2.0 is precluding Documenter from v0.26 and later; see https://github.com/ali-ramadhan/DocumenterCitations.jl/pull/34#issuecomment-782308024.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873:56,Modifiability,config,config,56,"> @navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?; > ; > https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725; > ; > Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?. Perhaps if we update Documenter.jl in the docs to the latest version we can alleviate that. At the moment DocumenterCitations v0.2.0 is precluding Documenter from v0.26 and later; see https://github.com/ali-ramadhan/DocumenterCitations.jl/pull/34#issuecomment-782308024.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873:488,Safety,detect,detected,488,"> @navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?; > ; > https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725; > ; > Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?. Perhaps if we update Documenter.jl in the docs to the latest version we can alleviate that. At the moment DocumenterCitations v0.2.0 is precluding Documenter from v0.26 and later; see https://github.com/ali-ramadhan/DocumenterCitations.jl/pull/34#issuecomment-782308024.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782312211:152,Deployability,deploy,deployconfig,152,I think the same behavior is there in Documenter.jl v0.25: https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L702-L708. but would still be good to update. Thanks for catching that!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782312211
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782312211:206,Deployability,update,update,206,I think the same behavior is there in Documenter.jl v0.25: https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L702-L708. but would still be good to update. Thanks for catching that!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782312211
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782346460:469,Deployability,deploy,deployconfig,469,Hmmm I thought this line would be enough. https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150. but you're right we used to use the `TRAVIS_REPO_SLUG` environment variable for this I think. Looks like the GitHub Actions equivalent is `GITHUB_REPOSITORY` like you linked to. But there doesn't seem to be one for Buildkite... https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L644-L666,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782346460
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782346460:215,Modifiability,variab,variable,215,Hmmm I thought this line would be enough. https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150. but you're right we used to use the `TRAVIS_REPO_SLUG` environment variable for this I think. Looks like the GitHub Actions equivalent is `GITHUB_REPOSITORY` like you linked to. But there doesn't seem to be one for Buildkite... https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L644-L666,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782346460
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270:497,Deployability,deploy,deployconfig,497,> Hmmm I thought this line would be enough; > ; > https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; > ; > but you're right we used to use the `TRAVIS_REPO_SLUG` environment variable for this I think.; > ; > Looks like the GitHub Actions equivalent is `GITHUB_REPOSITORY` like you linked to.; > ; > But there doesn't seem to be one for Buildkite... https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L644-L666. Perhaps you are right that nowadays (with more recent Documenter versions) ; https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; suffices. Bit while ago it wasn't enough! :) . I'll test it though and we'll find out.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270:229,Modifiability,variab,variable,229,> Hmmm I thought this line would be enough; > ; > https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; > ; > but you're right we used to use the `TRAVIS_REPO_SLUG` environment variable for this I think.; > ; > Looks like the GitHub Actions equivalent is `GITHUB_REPOSITORY` like you linked to.; > ; > But there doesn't seem to be one for Buildkite... https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L644-L666. Perhaps you are right that nowadays (with more recent Documenter versions) ; https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; suffices. Bit while ago it wasn't enough! :) . I'll test it though and we'll find out.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270
https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270:759,Testability,test,test,759,> Hmmm I thought this line would be enough; > ; > https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; > ; > but you're right we used to use the `TRAVIS_REPO_SLUG` environment variable for this I think.; > ; > Looks like the GitHub Actions equivalent is `GITHUB_REPOSITORY` like you linked to.; > ; > But there doesn't seem to be one for Buildkite... https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L644-L666. Perhaps you are right that nowadays (with more recent Documenter versions) ; https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; suffices. Bit while ago it wasn't enough! :) . I'll test it though and we'll find out.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270
https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154:192,Integrability,depend,depends,192,"I will let @jm-c approve this one but wanted to say I looked ti over and it looks good to me. As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would `HydrostaticCurvilinearCoriolis` be appropriate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154
https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154:254,Usability,clear,clearly,254,"I will let @jm-c approve this one but wanted to say I looked ti over and it looks good to me. As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would `HydrostaticCurvilinearCoriolis` be appropriate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154
https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605:100,Integrability,depend,depends,100,"> As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would HydrostaticCurvilinearCoriolis be appropriate?. I haven't added `HydrostaticCurvilinearCoriolis` yet --- I'm planning to implement that once the PR is merged. At the current moment, I've only changed `BetaPlane`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605
https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605:162,Usability,clear,clearly,162,"> As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would HydrostaticCurvilinearCoriolis be appropriate?. I haven't added `HydrostaticCurvilinearCoriolis` yet --- I'm planning to implement that once the PR is merged. At the current moment, I've only changed `BetaPlane`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605
https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799:129,Energy Efficiency,energy,energy-conserving,129,"> I am not sure that I am following everything there. Is it for flux-form of vector-invariant ? otherwise, I don't recognize the energy-conserving discretization (thought it would have been nice to have). I didn't realize the the Coriolis implementation is different for the ""flux-form"" momentum equations than for vector-invariant momentum equations --- thanks for pointing that out @jm-c. I don't quite understand why this is the case. However, it is not that difficult to extend our Coriolis implementation to dispatch on the `advection` ""scheme"" / form if we need to. After looking into the details (see below), it would appear that the implementation we are using is correct if. 1. The horizontal grid is regular; 2. The horizontal grid is curvilinear and we are using `momentum_advection=VectorInvariant()`. Because these are the only two possible cases, I believe the current Coriolis implementation is sufficient. However when/if we support curvilinear horizontal grids with flux form advection terms, we will (if we follow the MITgcm implementation) need to dispatch the evaluation of the Coriolis term on `momentum_advection` scheme. Another question is whether it even makes sense / is physically consistent to support `FPlane` and `BetaPlane` on grids that are sectors of the sphere. Perhaps there's no point at all in implementing a curvilinear-friendly version of `FPlane` and `BetaPlane`. If this is true, we can revert back to the prior implementation of both for Rectilinear grids, and focus on a energy/enstrophy - conserving Coriolis scheme for curvilinear grids on the surface of the sphere. # Some notes on Coriolis implementations for vector-invariant and flux form momentum schemes . Focusing on the x-component, the [MITgcm documentation](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8) writes that with a vector-invariant advection scheme, the Coriolis term that preserve potential enstrophy is. <img width=""228"" alt=""image"" src=""https://user-images.gith",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799
https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799:1514,Energy Efficiency,energy,energy,1514,"on to dispatch on the `advection` ""scheme"" / form if we need to. After looking into the details (see below), it would appear that the implementation we are using is correct if. 1. The horizontal grid is regular; 2. The horizontal grid is curvilinear and we are using `momentum_advection=VectorInvariant()`. Because these are the only two possible cases, I believe the current Coriolis implementation is sufficient. However when/if we support curvilinear horizontal grids with flux form advection terms, we will (if we follow the MITgcm implementation) need to dispatch the evaluation of the Coriolis term on `momentum_advection` scheme. Another question is whether it even makes sense / is physically consistent to support `FPlane` and `BetaPlane` on grids that are sectors of the sphere. Perhaps there's no point at all in implementing a curvilinear-friendly version of `FPlane` and `BetaPlane`. If this is true, we can revert back to the prior implementation of both for Rectilinear grids, and focus on a energy/enstrophy - conserving Coriolis scheme for curvilinear grids on the surface of the sphere. # Some notes on Coriolis implementations for vector-invariant and flux form momentum schemes . Focusing on the x-component, the [MITgcm documentation](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8) writes that with a vector-invariant advection scheme, the Coriolis term that preserve potential enstrophy is. <img width=""228"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/108606976-94430280-738b-11eb-8e29-a30f25c33ab6.png"">. Note that all `h_* = 1` for the purposes of our discussion, and that in Oceananigans notation we have `Δx_g = Δxᶜᶠᶜ` (the grid length at the location of the y-velocity) and `Δx_c = Δxᶠᶜᶜ`. For a flux-form advection scheme, the [MITgcm documentation](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#coriolis-terms) states that for a hydrostatic implementation we would have. <img width=""253"" alt=""image"" src=""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799
https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799:475,Modifiability,extend,extend,475,"> I am not sure that I am following everything there. Is it for flux-form of vector-invariant ? otherwise, I don't recognize the energy-conserving discretization (thought it would have been nice to have). I didn't realize the the Coriolis implementation is different for the ""flux-form"" momentum equations than for vector-invariant momentum equations --- thanks for pointing that out @jm-c. I don't quite understand why this is the case. However, it is not that difficult to extend our Coriolis implementation to dispatch on the `advection` ""scheme"" / form if we need to. After looking into the details (see below), it would appear that the implementation we are using is correct if. 1. The horizontal grid is regular; 2. The horizontal grid is curvilinear and we are using `momentum_advection=VectorInvariant()`. Because these are the only two possible cases, I believe the current Coriolis implementation is sufficient. However when/if we support curvilinear horizontal grids with flux form advection terms, we will (if we follow the MITgcm implementation) need to dispatch the evaluation of the Coriolis term on `momentum_advection` scheme. Another question is whether it even makes sense / is physically consistent to support `FPlane` and `BetaPlane` on grids that are sectors of the sphere. Perhaps there's no point at all in implementing a curvilinear-friendly version of `FPlane` and `BetaPlane`. If this is true, we can revert back to the prior implementation of both for Rectilinear grids, and focus on a energy/enstrophy - conserving Coriolis scheme for curvilinear grids on the surface of the sphere. # Some notes on Coriolis implementations for vector-invariant and flux form momentum schemes . Focusing on the x-component, the [MITgcm documentation](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8) writes that with a vector-invariant advection scheme, the Coriolis term that preserve potential enstrophy is. <img width=""228"" alt=""image"" src=""https://user-images.gith",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799
https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782294704:175,Deployability,release,release,175,That was quick! I think we didn't rush to resolve #1377 since it's a pretty major breaking change but as long as tests pass (and people agree with the change) we should tag a release!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782294704
https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782294704:113,Testability,test,tests,113,That was quick! I think we didn't rush to resolve #1377 since it's a pretty major breaking change but as long as tests pass (and people agree with the change) we should tag a release!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782294704
https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295162:98,Availability,redundant,redundant,98,"Hmmm, doesn't rectilinear imply orthogonal?. `RegularRectilinearOrthogonalGrid` might be a little redundant?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295162
https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295162:98,Safety,redund,redundant,98,"Hmmm, doesn't rectilinear imply orthogonal?. `RegularRectilinearOrthogonalGrid` might be a little redundant?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295162
https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295927:106,Availability,redundant,redundant,106,"> Hmmm, doesn't rectilinear imply orthogonal?; > ; > `RegularRectilinearOrthogonalGrid` might be a little redundant?. No. Rectilinear just means that the axis are straight lines... But the axis could intercept in angles other than 90 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295927
https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295927:106,Safety,redund,redundant,106,"> Hmmm, doesn't rectilinear imply orthogonal?; > ; > `RegularRectilinearOrthogonalGrid` might be a little redundant?. No. Rectilinear just means that the axis are straight lines... But the axis could intercept in angles other than 90 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295927
https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782314092:275,Usability,clear,clear,275,> > What do people think of `OrthogonalRectilinearGrid`?; > ; > But `Regular` was there to differentiate from `VerticallyStretched`. So @francispoulin you are suggesting:; > ; > `OrthogonalRectilinearGrid` and `VerticallyStretchedOrthogonalRectilinearGrid`?. To be perfectly clear I suppose we could use the following. `VerticallyUniformOrthogonalRectilinearGrid` and `VerticallyStretchedOrthogonalRectilinearGrid`. but that makes for a lot of characters. Not very attractive I'm afraid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782314092
https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024:261,Safety,redund,redundancies,261,"I'm usually for verbose names as they are clearer but in this case the basic regular rectilinear grid is something every user will interact with and will show up in at the top of each example/tutorial so I agree with @francispoulin that a shorter name (without redundancies) would be good. We probably need more than just 1 approval to merge this PR, preferably unanimous consent amongst ourselves?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024
https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024:42,Usability,clear,clearer,42,"I'm usually for verbose names as they are clearer but in this case the basic regular rectilinear grid is something every user will interact with and will show up in at the top of each example/tutorial so I agree with @francispoulin that a shorter name (without redundancies) would be good. We probably need more than just 1 approval to merge this PR, preferably unanimous consent amongst ourselves?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024
https://github.com/CliMA/Oceananigans.jl/pull/1390#issuecomment-782458593:52,Testability,test,testing,52,I don’t really know what was that file. Was it just testing?. tests pass so I guess I will approve. But I’m a bit oblivious here...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1390#issuecomment-782458593
https://github.com/CliMA/Oceananigans.jl/pull/1390#issuecomment-782458593:62,Testability,test,tests,62,I don’t really know what was that file. Was it just testing?. tests pass so I guess I will approve. But I’m a bit oblivious here...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1390#issuecomment-782458593
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:623,Availability,error,error,623,"Settled on the code below. ```julia; struct SpatialWindowAverage{F, S, D} ; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) = SpatialWindowAverage(field, field_slicer, dims). function (wsa::SpatialWindowAverage)(model); compute!(wsa.field); window = view(data(wsa.field), wsa.field_slicer.i, wsa.field_slicer.j, wsa.field_slicer.k); return mean(window, dims=wsa.dims); end; ```. Which constructs an object fine, but it doesn't work when outputting. I can call `compute!` on it, but really it doesn't do anything. When including it to a `NetCDFWriter` I get this error:. <details>; <summary>Click to expand!</summary>. ```; ERROR: LoadError: Custom output Us needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Fie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:684,Availability,ERROR,ERROR,684,"Settled on the code below. ```julia; struct SpatialWindowAverage{F, S, D} ; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) = SpatialWindowAverage(field, field_slicer, dims). function (wsa::SpatialWindowAverage)(model); compute!(wsa.field); window = view(data(wsa.field), wsa.field_slicer.i, wsa.field_slicer.j, wsa.field_slicer.k); return mean(window, dims=wsa.dims); end; ```. Which constructs an object fine, but it doesn't work when outputting. I can call `compute!` on it, but really it doesn't do anything. When including it to a `NetCDFWriter` I get this error:. <details>; <summary>Click to expand!</summary>. ```; ERROR: LoadError: Custom output Us needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Fie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:755,Availability,error,error,755,"Settled on the code below. ```julia; struct SpatialWindowAverage{F, S, D} ; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) = SpatialWindowAverage(field, field_slicer, dims). function (wsa::SpatialWindowAverage)(model); compute!(wsa.field); window = view(data(wsa.field), wsa.field_slicer.i, wsa.field_slicer.j, wsa.field_slicer.k); return mean(window, dims=wsa.dims); end; ```. Which constructs an object fine, but it doesn't work when outputting. I can call `compute!` on it, but really it doesn't do anything. When including it to a `NetCDFWriter` I get this error:. <details>; <summary>Click to expand!</summary>. ```; ERROR: LoadError: Custom output Us needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Fie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:776,Availability,error,error,776,"Settled on the code below. ```julia; struct SpatialWindowAverage{F, S, D} ; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) = SpatialWindowAverage(field, field_slicer, dims). function (wsa::SpatialWindowAverage)(model); compute!(wsa.field); window = view(data(wsa.field), wsa.field_slicer.i, wsa.field_slicer.j, wsa.field_slicer.k); return mean(window, dims=wsa.dims); end; ```. Which constructs an object fine, but it doesn't work when outputting. I can call `compute!` on it, but really it doesn't do anything. When including it to a `NetCDFWriter` I get this error:. <details>; <summary>Click to expand!</summary>. ```; ERROR: LoadError: Custom output Us needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Fie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:16164,Energy Efficiency,schedul,schedule,16164,"BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}}},SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; ```; </details>. I've tried expanding the struct to include a grid parameter (based off of how `AveragedField` is programmed` and then defining `compute!` but I haven't been able to make it work. Any tips?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:16548,Modifiability,sandbox,sandbox,16548,"BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}}},SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; ```; </details>. I've tried expanding the struct to include a grid parameter (based off of how `AveragedField` is programmed` and then defining `compute!` but I haven't been able to make it work. Any tips?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:16728,Modifiability,sandbox,sandbox,16728,"BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}}},SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; ```; </details>. I've tried expanding the struct to include a grid parameter (based off of how `AveragedField` is programmed` and then defining `compute!` but I haven't been able to make it work. Any tips?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:691,Performance,Load,LoadError,691,"Settled on the code below. ```julia; struct SpatialWindowAverage{F, S, D} ; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) = SpatialWindowAverage(field, field_slicer, dims). function (wsa::SpatialWindowAverage)(model); compute!(wsa.field); window = view(data(wsa.field), wsa.field_slicer.i, wsa.field_slicer.j, wsa.field_slicer.k); return mean(window, dims=wsa.dims); end; ```. Which constructs an object fine, but it doesn't work when outputting. I can call `compute!` on it, but really it doesn't do anything. When including it to a `NetCDFWriter` I get this error:. <details>; <summary>Click to expand!</summary>. ```; ERROR: LoadError: Custom output Us needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Fie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:16548,Testability,sandbox,sandbox,16548,"BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}}},SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; ```; </details>. I've tried expanding the struct to include a grid parameter (based off of how `AveragedField` is programmed` and then defining `compute!` but I haven't been able to make it work. Any tips?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:16728,Testability,sandbox,sandbox,16728,"BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}}},SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; ```; </details>. I've tried expanding the struct to include a grid parameter (based off of how `AveragedField` is programmed` and then defining `compute!` but I haven't been able to make it work. Any tips?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675:679,Energy Efficiency,reduce,reduced,679,"Yes. To be honest after your comments I'm completely lost. I thought I was getting a grasp on how structs and multiple dispatch worked, but now I'm 100% sure that I am 0% about everything :laughing: . I've defined something like this:. ```julia; struct SpatialWindowAverage{X, Y, Z, A, G, F, S, D} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) =; SpatialWindowAverage(field.data, field.grid, field, field_slicer, dims); ```. But of course, it's missing `X, Y, Z`. But to get them I need those `drop_averaged_dims` functions and I'm not sure how to work them on reduced fields. . So far I've been looking at how `AveragedField` is defined, but that's exactly what @glwagner recommended I not do, since apparently it's difficult to adapt it for what I want... And in the mean time I'm computing these averages offline, which is taking a very long time haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675:848,Energy Efficiency,adapt,adapt,848,"Yes. To be honest after your comments I'm completely lost. I thought I was getting a grasp on how structs and multiple dispatch worked, but now I'm 100% sure that I am 0% about everything :laughing: . I've defined something like this:. ```julia; struct SpatialWindowAverage{X, Y, Z, A, G, F, S, D} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) =; SpatialWindowAverage(field.data, field.grid, field, field_slicer, dims); ```. But of course, it's missing `X, Y, Z`. But to get them I need those `drop_averaged_dims` functions and I'm not sure how to work them on reduced fields. . So far I've been looking at how `AveragedField` is defined, but that's exactly what @glwagner recommended I not do, since apparently it's difficult to adapt it for what I want... And in the mean time I'm computing these averages offline, which is taking a very long time haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675:848,Modifiability,adapt,adapt,848,"Yes. To be honest after your comments I'm completely lost. I thought I was getting a grasp on how structs and multiple dispatch worked, but now I'm 100% sure that I am 0% about everything :laughing: . I've defined something like this:. ```julia; struct SpatialWindowAverage{X, Y, Z, A, G, F, S, D} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) =; SpatialWindowAverage(field.data, field.grid, field, field_slicer, dims); ```. But of course, it's missing `X, Y, Z`. But to get them I need those `drop_averaged_dims` functions and I'm not sure how to work them on reduced fields. . So far I've been looking at how `AveragedField` is defined, but that's exactly what @glwagner recommended I not do, since apparently it's difficult to adapt it for what I want... And in the mean time I'm computing these averages offline, which is taking a very long time haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934:235,Modifiability,variab,variable,235,"Ah sorry about that! Happy to chat over Slack but don't wanna butcher @glwagner's suggestion. I guess having the `X, Y, Z` is important for `NetCDFOutputWriter` since it uses that information to know which dimensions to assign to each variable. They could be specified manually via the `dimensions` kwarg (there should be an example of this in the docstring) but ideally the dimensions should be detected automatically for an Oceananigans field. Maybe you just need to use `reduced_location` to determine the `X, Y, Z` for the `SpatialWindowAverage`? https://github.com/CliMA/Oceananigans.jl/blob/0ff8cd8e7d4565c8493ec7b81e531599277ab645/src/Fields/reduced_field.jl#L137. Maybe something like this could work?. ```julia; function SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()); X, Y, Z = reduced_location(location(field), dims=dims); return SpatialWindowAverage{X, Y, Z}(field.data, field.grid, field, field_slicer, dims); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934:396,Safety,detect,detected,396,"Ah sorry about that! Happy to chat over Slack but don't wanna butcher @glwagner's suggestion. I guess having the `X, Y, Z` is important for `NetCDFOutputWriter` since it uses that information to know which dimensions to assign to each variable. They could be specified manually via the `dimensions` kwarg (there should be an example of this in the docstring) but ideally the dimensions should be detected automatically for an Oceananigans field. Maybe you just need to use `reduced_location` to determine the `X, Y, Z` for the `SpatialWindowAverage`? https://github.com/CliMA/Oceananigans.jl/blob/0ff8cd8e7d4565c8493ec7b81e531599277ab645/src/Fields/reduced_field.jl#L137. Maybe something like this could work?. ```julia; function SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()); X, Y, Z = reduced_location(location(field), dims=dims); return SpatialWindowAverage{X, Y, Z}(field.data, field.grid, field, field_slicer, dims); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934
https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783575623:27,Integrability,rout,route,27,"By the way, an alternative route to getting ""automatic"" dimensioning for `NetCDFOutputWriter` could be to define a `default_dimensions(output::WindowedSpatialAverage, grid, field_slicer)` that does the right thing. You can put the location `X, Y, Z` in `WindowedSpatialAverage` without making the object subtype `AbstractField` (which will cause various issues with time-averaging as noted).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783575623
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783458149:267,Security,validat,validation-experiments,267,Happy to approve this if there's unanimous consent. I guess we should tag v0.50.0 with this PR and get the pain of breaking changes out of the way?. Out of paranoia I'm also running the convergence tests for this PR manually: https://buildkite.com/clima/oceananigans-validation-experiments/builds/128,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783458149
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783458149:198,Testability,test,tests,198,Happy to approve this if there's unanimous consent. I guess we should tag v0.50.0 with this PR and get the pain of breaking changes out of the way?. Out of paranoia I'm also running the convergence tests for this PR manually: https://buildkite.com/clima/oceananigans-validation-experiments/builds/128,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783458149
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783650872:131,Testability,test,tests,131,"@ali-ramadhan, @glwagner, @francispoulin, @tomchor: please hold on merging anything else until I merge this. Will do so as soon as tests pass!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783650872
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652214:22,Modifiability,sandbox,sandbox,22,Ah I think you added `sandbox/vertically_stretched_plankton.jl` back in when we meant to keep it nuked but we can worry about it after this PR is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652214
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652214:22,Testability,sandbox,sandbox,22,Ah I think you added `sandbox/vertically_stretched_plankton.jl` back in when we meant to keep it nuked but we can worry about it after this PR is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652214
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652567:36,Security,validat,validation,36,"@ali-ramadhan, should we re-run the validation tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652567
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652567:47,Testability,test,tests,47,"@ali-ramadhan, should we re-run the validation tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652567
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783653083:24,Modifiability,sandbox,sandbox,24,> Ah I think you added `sandbox/vertically_stretched_plankton.jl` back in when we meant to keep it nuked but we can worry about it after this PR is merged. I was also puzzled why that happened. I just pulled master and then `git merge master`...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783653083
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783653083:24,Testability,sandbox,sandbox,24,> Ah I think you added `sandbox/vertically_stretched_plankton.jl` back in when we meant to keep it nuked but we can worry about it after this PR is merged. I was also puzzled why that happened. I just pulled master and then `git merge master`...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783653083
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783657161:38,Security,validat,validation,38,"> @ali-ramadhan, should we re-run the validation tests?. I'm sure they're fine. They passed earlier today: https://buildkite.com/clima/oceananigans-validation-experiments/builds/128. They take a while to run. And we'll know tomorrow morning if they fail! They're set to run nightly at 3am ET.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783657161
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783657161:148,Security,validat,validation-experiments,148,"> @ali-ramadhan, should we re-run the validation tests?. I'm sure they're fine. They passed earlier today: https://buildkite.com/clima/oceananigans-validation-experiments/builds/128. They take a while to run. And we'll know tomorrow morning if they fail! They're set to run nightly at 3am ET.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783657161
https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783657161:49,Testability,test,tests,49,"> @ali-ramadhan, should we re-run the validation tests?. I'm sure they're fine. They passed earlier today: https://buildkite.com/clima/oceananigans-validation-experiments/builds/128. They take a while to run. And we'll know tomorrow morning if they fail! They're set to run nightly at 3am ET.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783657161
https://github.com/CliMA/Oceananigans.jl/issues/1394#issuecomment-783459067:34,Modifiability,sandbox,sandbox,34,Woops sorry I meant to delete the sandbox! Would be great to increase variety among the existing examples so it's a great idea.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1394#issuecomment-783459067
https://github.com/CliMA/Oceananigans.jl/issues/1394#issuecomment-783459067:34,Testability,sandbox,sandbox,34,Woops sorry I meant to delete the sandbox! Would be great to increase variety among the existing examples so it's a great idea.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1394#issuecomment-783459067
https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783494083:4,Testability,test,tests,4,Why tests fail? (Irrelevant with this PR I guess..?),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783494083
https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783500631:38,Availability,failure,failures,38,"I suspect in this particular case the failures might be related to https://github.com/CliMA/Oceananigans.jl/issues/1179 . I agree it's irrelevant to this PR so I'll go ahead and merge. Looking at the build log it looks like it's a small number of grid points that are outside the required tolerance. ```; [2021/02/22 10:57:39.093] INFO Testing oceanic large eddy simulation regression [GPU, SmagorinskyLilly, regular grid]; [2021/02/22 10:58:14.536] INFO Δu: min=-5.666049e-10, max=+3.671358e-10, mean=-2.983144e-20, absmean=+2.668769e-12, std=+2.226909e-11 (4069/4096 matching grid points); [2021/02/22 10:58:14.552] INFO Δv: min=-5.253857e-10, max=+3.415200e-10, mean=+3.250489e-20, absmean=+2.216612e-12, std=+1.693819e-11 (4087/4096 matching grid points); [2021/02/22 10:58:14.553] INFO Δw: min=-8.810720e-10, max=+3.828218e-10, mean=+1.396074e-21, absmean=+1.776769e-12, std=+1.811893e-11 (4030/4096 matching grid points); [2021/02/22 10:58:14.554] INFO ΔT: min=-3.171365e-10, max=+1.584819e-09, mean=+1.486753e-12, absmean=+2.286620e-12, std=+4.048190e-11 (4096/4096 matching grid points); [2021/02/22 10:58:14.555] INFO ΔS: min=-5.826450e-13, max=+5.613288e-13, mean=-6.418477e-17, absmean=+2.742598e-15, std=+1.726765e-14 (4096/4096 matching grid points); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783500631
https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783500631:289,Availability,toler,tolerance,289,"I suspect in this particular case the failures might be related to https://github.com/CliMA/Oceananigans.jl/issues/1179 . I agree it's irrelevant to this PR so I'll go ahead and merge. Looking at the build log it looks like it's a small number of grid points that are outside the required tolerance. ```; [2021/02/22 10:57:39.093] INFO Testing oceanic large eddy simulation regression [GPU, SmagorinskyLilly, regular grid]; [2021/02/22 10:58:14.536] INFO Δu: min=-5.666049e-10, max=+3.671358e-10, mean=-2.983144e-20, absmean=+2.668769e-12, std=+2.226909e-11 (4069/4096 matching grid points); [2021/02/22 10:58:14.552] INFO Δv: min=-5.253857e-10, max=+3.415200e-10, mean=+3.250489e-20, absmean=+2.216612e-12, std=+1.693819e-11 (4087/4096 matching grid points); [2021/02/22 10:58:14.553] INFO Δw: min=-8.810720e-10, max=+3.828218e-10, mean=+1.396074e-21, absmean=+1.776769e-12, std=+1.811893e-11 (4030/4096 matching grid points); [2021/02/22 10:58:14.554] INFO ΔT: min=-3.171365e-10, max=+1.584819e-09, mean=+1.486753e-12, absmean=+2.286620e-12, std=+4.048190e-11 (4096/4096 matching grid points); [2021/02/22 10:58:14.555] INFO ΔS: min=-5.826450e-13, max=+5.613288e-13, mean=-6.418477e-17, absmean=+2.742598e-15, std=+1.726765e-14 (4096/4096 matching grid points); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783500631
https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783500631:206,Testability,log,log,206,"I suspect in this particular case the failures might be related to https://github.com/CliMA/Oceananigans.jl/issues/1179 . I agree it's irrelevant to this PR so I'll go ahead and merge. Looking at the build log it looks like it's a small number of grid points that are outside the required tolerance. ```; [2021/02/22 10:57:39.093] INFO Testing oceanic large eddy simulation regression [GPU, SmagorinskyLilly, regular grid]; [2021/02/22 10:58:14.536] INFO Δu: min=-5.666049e-10, max=+3.671358e-10, mean=-2.983144e-20, absmean=+2.668769e-12, std=+2.226909e-11 (4069/4096 matching grid points); [2021/02/22 10:58:14.552] INFO Δv: min=-5.253857e-10, max=+3.415200e-10, mean=+3.250489e-20, absmean=+2.216612e-12, std=+1.693819e-11 (4087/4096 matching grid points); [2021/02/22 10:58:14.553] INFO Δw: min=-8.810720e-10, max=+3.828218e-10, mean=+1.396074e-21, absmean=+1.776769e-12, std=+1.811893e-11 (4030/4096 matching grid points); [2021/02/22 10:58:14.554] INFO ΔT: min=-3.171365e-10, max=+1.584819e-09, mean=+1.486753e-12, absmean=+2.286620e-12, std=+4.048190e-11 (4096/4096 matching grid points); [2021/02/22 10:58:14.555] INFO ΔS: min=-5.826450e-13, max=+5.613288e-13, mean=-6.418477e-17, absmean=+2.742598e-15, std=+1.726765e-14 (4096/4096 matching grid points); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783500631
https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783500631:336,Testability,Test,Testing,336,"I suspect in this particular case the failures might be related to https://github.com/CliMA/Oceananigans.jl/issues/1179 . I agree it's irrelevant to this PR so I'll go ahead and merge. Looking at the build log it looks like it's a small number of grid points that are outside the required tolerance. ```; [2021/02/22 10:57:39.093] INFO Testing oceanic large eddy simulation regression [GPU, SmagorinskyLilly, regular grid]; [2021/02/22 10:58:14.536] INFO Δu: min=-5.666049e-10, max=+3.671358e-10, mean=-2.983144e-20, absmean=+2.668769e-12, std=+2.226909e-11 (4069/4096 matching grid points); [2021/02/22 10:58:14.552] INFO Δv: min=-5.253857e-10, max=+3.415200e-10, mean=+3.250489e-20, absmean=+2.216612e-12, std=+1.693819e-11 (4087/4096 matching grid points); [2021/02/22 10:58:14.553] INFO Δw: min=-8.810720e-10, max=+3.828218e-10, mean=+1.396074e-21, absmean=+1.776769e-12, std=+1.811893e-11 (4030/4096 matching grid points); [2021/02/22 10:58:14.554] INFO ΔT: min=-3.171365e-10, max=+1.584819e-09, mean=+1.486753e-12, absmean=+2.286620e-12, std=+4.048190e-11 (4096/4096 matching grid points); [2021/02/22 10:58:14.555] INFO ΔS: min=-5.826450e-13, max=+5.613288e-13, mean=-6.418477e-17, absmean=+2.742598e-15, std=+1.726765e-14 (4096/4096 matching grid points); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783500631
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783693538:177,Testability,test,tests,177,"I think we could probably move it into `src/OutputWriters/windowed_spatial_average.jl` since we already have `windowed_time_average.jl` there. Probably just missing a couple of tests (one for a `WindowedSpatialAverage` of a field, and another for `ComputedField might be good?).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783693538
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783762674:41,Safety,detect,detect,41,@tomchor I think it should automatically detect dimensions for `WindowedSpatialAverage` now but the solution is not pretty since `NetCDFOutputWriter` plays nicest with fields. Could probably be made clearer though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783762674
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783762674:199,Usability,clear,clearer,199,@tomchor I think it should automatically detect dimensions for `WindowedSpatialAverage` now but the solution is not pretty since `NetCDFOutputWriter` plays nicest with fields. Could probably be made clearer though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783762674
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559:80,Availability,error,errors,80,"This seems to work out-of-the box with our simple example, but I'm encountering errors when applying to one of my complex scripts. I'm getting errors of the kind `ERROR: LoadError: Custom output b_tot needs dimensions!`. And when I do specify the dimensions manually I get `Trying to write (1, 1, 16) elements while [17, 1] are expected`. So clearly we're missing something. Looking at the behavior of `AveragedField` I think we should not `dropdim` when doing the average anymore since `AveragedField` always returns a 3D array:. ```julia; julia> bmean = AveragedField(b, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); ├── dims: (1, 2); ├── operand: Field located at (Center, Center, Center); └── status: time=0.0. julia> bmean.data; 1×1×20 OffsetArray(::Array{Float64,3}, 1:1, 1:1, -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559:143,Availability,error,errors,143,"This seems to work out-of-the box with our simple example, but I'm encountering errors when applying to one of my complex scripts. I'm getting errors of the kind `ERROR: LoadError: Custom output b_tot needs dimensions!`. And when I do specify the dimensions manually I get `Trying to write (1, 1, 16) elements while [17, 1] are expected`. So clearly we're missing something. Looking at the behavior of `AveragedField` I think we should not `dropdim` when doing the average anymore since `AveragedField` always returns a 3D array:. ```julia; julia> bmean = AveragedField(b, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); ├── dims: (1, 2); ├── operand: Field located at (Center, Center, Center); └── status: time=0.0. julia> bmean.data; 1×1×20 OffsetArray(::Array{Float64,3}, 1:1, 1:1, -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559:163,Availability,ERROR,ERROR,163,"This seems to work out-of-the box with our simple example, but I'm encountering errors when applying to one of my complex scripts. I'm getting errors of the kind `ERROR: LoadError: Custom output b_tot needs dimensions!`. And when I do specify the dimensions manually I get `Trying to write (1, 1, 16) elements while [17, 1] are expected`. So clearly we're missing something. Looking at the behavior of `AveragedField` I think we should not `dropdim` when doing the average anymore since `AveragedField` always returns a 3D array:. ```julia; julia> bmean = AveragedField(b, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); ├── dims: (1, 2); ├── operand: Field located at (Center, Center, Center); └── status: time=0.0. julia> bmean.data; 1×1×20 OffsetArray(::Array{Float64,3}, 1:1, 1:1, -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559:1254,Availability,error,error,1254,"do specify the dimensions manually I get `Trying to write (1, 1, 16) elements while [17, 1] are expected`. So clearly we're missing something. Looking at the behavior of `AveragedField` I think we should not `dropdim` when doing the average anymore since `AveragedField` always returns a 3D array:. ```julia; julia> bmean = AveragedField(b, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); ├── dims: (1, 2); ├── operand: Field located at (Center, Center, Center); └── status: time=0.0. julia> bmean.data; 1×1×20 OffsetArray(::Array{Float64,3}, 1:1, 1:1, -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Gradient,Int64},BoundaryCondition{Gradient,Int64}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}(Field located at (Cente",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559:3005,Availability,error,error,3005,", -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Gradient,Int64},BoundaryCondition{Gradient,Int64}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}(Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (5, 1028, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=ZeroFlux, north=ZeroFlux), z=(bottom=Gradient, top=Gradient), FieldSlicer{Colon,UnitRange{Int64},Colon}(Colon(), 3:7, Colon(), false), (1, 2)). julia> bwind(model); 1×1×16 Array{Float64,3}:; [:, :, 1] =; 3.3804104762232327e-9. [:, :, 2] =; -3.3870178841474065e-9. [:, :, 3] =; -5.033240008504092e-9. ... [:, :, 14] =; 4.520675322973764e-9. [:, :, 15] =; 1.7337945671947679e-9. [:, :, 16] =; -6.1358421780537424e-9; ```. PS: this is quite abstract so I'll try to come up with an example that reproduces the error when I have time",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559:170,Performance,Load,LoadError,170,"This seems to work out-of-the box with our simple example, but I'm encountering errors when applying to one of my complex scripts. I'm getting errors of the kind `ERROR: LoadError: Custom output b_tot needs dimensions!`. And when I do specify the dimensions manually I get `Trying to write (1, 1, 16) elements while [17, 1] are expected`. So clearly we're missing something. Looking at the behavior of `AveragedField` I think we should not `dropdim` when doing the average anymore since `AveragedField` always returns a 3D array:. ```julia; julia> bmean = AveragedField(b, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); ├── dims: (1, 2); ├── operand: Field located at (Center, Center, Center); └── status: time=0.0. julia> bmean.data; 1×1×20 OffsetArray(::Array{Float64,3}, 1:1, 1:1, -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559:43,Usability,simpl,simple,43,"This seems to work out-of-the box with our simple example, but I'm encountering errors when applying to one of my complex scripts. I'm getting errors of the kind `ERROR: LoadError: Custom output b_tot needs dimensions!`. And when I do specify the dimensions manually I get `Trying to write (1, 1, 16) elements while [17, 1] are expected`. So clearly we're missing something. Looking at the behavior of `AveragedField` I think we should not `dropdim` when doing the average anymore since `AveragedField` always returns a 3D array:. ```julia; julia> bmean = AveragedField(b, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); ├── dims: (1, 2); ├── operand: Field located at (Center, Center, Center); └── status: time=0.0. julia> bmean.data; 1×1×20 OffsetArray(::Array{Float64,3}, 1:1, 1:1, -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559:342,Usability,clear,clearly,342,"This seems to work out-of-the box with our simple example, but I'm encountering errors when applying to one of my complex scripts. I'm getting errors of the kind `ERROR: LoadError: Custom output b_tot needs dimensions!`. And when I do specify the dimensions manually I get `Trying to write (1, 1, 16) elements while [17, 1] are expected`. So clearly we're missing something. Looking at the behavior of `AveragedField` I think we should not `dropdim` when doing the average anymore since `AveragedField` always returns a 3D array:. ```julia; julia> bmean = AveragedField(b, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); ├── dims: (1, 2); ├── operand: Field located at (Center, Center, Center); └── status: time=0.0. julia> bmean.data; 1×1×20 OffsetArray(::Array{Float64,3}, 1:1, 1:1, -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:19,Availability,error,error,19,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:315,Availability,error,error,315,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:328,Availability,ERROR,ERROR,328,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:399,Availability,error,error,399,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:420,Availability,error,error,420,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:196,Energy Efficiency,schedul,schedule,196,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:14596,Energy Efficiency,schedul,schedule,14596,"Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:88; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; ```. I'm not really sure how to fix this one...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:14990,Modifiability,sandbox,sandbox,14990,"Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:88; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; ```. I'm not really sure how to fix this one...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:335,Performance,Load,LoadError,335,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:14990,Testability,sandbox,sandbox,14990,"Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:88; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; ```. I'm not really sure how to fix this one...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525:479,Availability,error,error,479,"> I'm not really sure how to fix this one... Not sure if I completely understand what's happening since I am not super familiar with the `NetCDFOutputWriter`, but it looks to me like an implementation of `define_output_variable` has been provided for `WindowedSpatialAverage`, but not for the case when `WindowedSpatialAverage` is wrapped inside a `WindowedTimeAverage` (in which case the type of the output is `::WindowedTimeAverage{<:WindowedSpatialAverage}` as written in the error message above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525:331,Integrability,wrap,wrapped,331,"> I'm not really sure how to fix this one... Not sure if I completely understand what's happening since I am not super familiar with the `NetCDFOutputWriter`, but it looks to me like an implementation of `define_output_variable` has been provided for `WindowedSpatialAverage`, but not for the case when `WindowedSpatialAverage` is wrapped inside a `WindowedTimeAverage` (in which case the type of the output is `::WindowedTimeAverage{<:WindowedSpatialAverage}` as written in the error message above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525:485,Integrability,message,message,485,"> I'm not really sure how to fix this one... Not sure if I completely understand what's happening since I am not super familiar with the `NetCDFOutputWriter`, but it looks to me like an implementation of `define_output_variable` has been provided for `WindowedSpatialAverage`, but not for the case when `WindowedSpatialAverage` is wrapped inside a `WindowedTimeAverage` (in which case the type of the output is `::WindowedTimeAverage{<:WindowedSpatialAverage}` as written in the error message above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:248,Availability,error,errors,248,"Changing the function call to ; ```julia; function define_output_variable!(dataset,; wsa::Union{WindowedSpatialAverage, WindowedTimeAverage{<:WindowedSpatialAverage}},; name, array_type, compression, attributes, dimensions); ```; raises some other errors and I'm not sure the best way to fix them. I think the issue is that a `WindowedTimeAverage` doesn't have the properties `field` (it has `operand`) and it doesn't have the property `dims`. . For example, running the code above I get:. ```; ERROR: LoadError: type WindowedTimeAverage has no field field; Stacktrace:; [1] getproperty(::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::Symbol) at ./Base.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryCo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:495,Availability,ERROR,ERROR,495,"Changing the function call to ; ```julia; function define_output_variable!(dataset,; wsa::Union{WindowedSpatialAverage, WindowedTimeAverage{<:WindowedSpatialAverage}},; name, array_type, compression, attributes, dimensions); ```; raises some other errors and I'm not sure the best way to fix them. I think the issue is that a `WindowedTimeAverage` doesn't have the properties `field` (it has `operand`) and it doesn't have the property `dims`. . For example, running the code above I get:. ```; ERROR: LoadError: type WindowedTimeAverage has no field field; Stacktrace:; [1] getproperty(::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::Symbol) at ./Base.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryCo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:15694,Energy Efficiency,schedul,schedule,15694,"eananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[16]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; ```. Like I said, I'm not sure the best to deal with this. Should I define another separate function to deal with the `WindowedTimeAverage` case?. Also, I'm a little confused. Does this set-up only work at the moment with the NetCDF writer? Because if so, it seems to me it wouldn't be recommended to add to Oceananigans liek this, right? I think we'd want diagnostics on Oceananigans to be independent of the writing method, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:2635,Modifiability,sandbox,sandbox,2635,"Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:62; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Field{Center,Face,Center,OffsetArrays.OffsetArray{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:16088,Modifiability,sandbox,sandbox,16088,"eananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[16]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; ```. Like I said, I'm not sure the best to deal with this. Should I define another separate function to deal with the `WindowedTimeAverage` case?. Also, I'm a little confused. Does this set-up only work at the moment with the NetCDF writer? Because if so, it seems to me it wouldn't be recommended to add to Oceananigans liek this, right? I think we'd want diagnostics on Oceananigans to be independent of the writing method, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:16262,Modifiability,sandbox,sandbox,16262,"eananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[16]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; ```. Like I said, I'm not sure the best to deal with this. Should I define another separate function to deal with the `WindowedTimeAverage` case?. Also, I'm a little confused. Does this set-up only work at the moment with the NetCDF writer? Because if so, it seems to me it wouldn't be recommended to add to Oceananigans liek this, right? I think we'd want diagnostics on Oceananigans to be independent of the writing method, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:502,Performance,Load,LoadError,502,"Changing the function call to ; ```julia; function define_output_variable!(dataset,; wsa::Union{WindowedSpatialAverage, WindowedTimeAverage{<:WindowedSpatialAverage}},; name, array_type, compression, attributes, dimensions); ```; raises some other errors and I'm not sure the best way to fix them. I think the issue is that a `WindowedTimeAverage` doesn't have the properties `field` (it has `operand`) and it doesn't have the property `dims`. . For example, running the code above I get:. ```; ERROR: LoadError: type WindowedTimeAverage has no field field; Stacktrace:; [1] getproperty(::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::Symbol) at ./Base.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryCo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:2635,Testability,sandbox,sandbox,2635,"Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:62; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Field{Center,Face,Center,OffsetArrays.OffsetArray{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:16088,Testability,sandbox,sandbox,16088,"eananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[16]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; ```. Like I said, I'm not sure the best to deal with this. Should I define another separate function to deal with the `WindowedTimeAverage` case?. Also, I'm a little confused. Does this set-up only work at the moment with the NetCDF writer? Because if so, it seems to me it wouldn't be recommended to add to Oceananigans liek this, right? I think we'd want diagnostics on Oceananigans to be independent of the writing method, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:16262,Testability,sandbox,sandbox,16262,"eananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[16]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; ```. Like I said, I'm not sure the best to deal with this. Should I define another separate function to deal with the `WindowedTimeAverage` case?. Also, I'm a little confused. Does this set-up only work at the moment with the NetCDF writer? Because if so, it seems to me it wouldn't be recommended to add to Oceananigans liek this, right? I think we'd want diagnostics on Oceananigans to be independent of the writing method, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784317252:263,Modifiability,variab,variable,263,Yeah seems like it might be easiest to define a new `define_output_variable!` that dispatches on `WindowedTimeAverage{<:WindowedSpatialAverage}`. `define_output_variable!` is only used by `NetCDFOutputWriter` since it needs to know which dimensions belong to the variable.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784317252
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784539053:479,Modifiability,refactor,refactor,479,"> Can any of you take a look to see if I'm doing anything that's wrong or ill-advised in any way? (I solved it in a pretty pythonic way...). I think your solution is fine. In more complicated scenarios it's sometimes better to use dispatch rather than if statements because the code is then more extensible (by defining new functions, which can go anywhere, rather than adding conditions to a chain of if statements in some central location). Here it's not so crucial and we can refactor later if we need to. We certainly _can_ use if statements in julia (and dispatch in python!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784539053
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784610497:65,Integrability,depend,depends,65,"I moved it to Diagnostics, but it's not compiling yet because it depends on OutputWriters, which is compiled right after Diagnostics. Compiling OutputWriters before Diagnostics doesn't work also because there are some dependencies there too. I think the `define_output_variable!` part could be moved towards `OutputWriters` (since it's only used by the NetCDF writer), but the annoying thing is that I'm also using `slice_parent` in the very definition of the average, which is defined in `field_slicer.jl`. Let me know what you think, but I actually think stuff related to `FieldSlicer` could be moved to outside of `OutputWriters` since it has found other uses outside of the NetCDF output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784610497
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784610497:218,Integrability,depend,dependencies,218,"I moved it to Diagnostics, but it's not compiling yet because it depends on OutputWriters, which is compiled right after Diagnostics. Compiling OutputWriters before Diagnostics doesn't work also because there are some dependencies there too. I think the `define_output_variable!` part could be moved towards `OutputWriters` (since it's only used by the NetCDF writer), but the annoying thing is that I'm also using `slice_parent` in the very definition of the average, which is defined in `field_slicer.jl`. Let me know what you think, but I actually think stuff related to `FieldSlicer` could be moved to outside of `OutputWriters` since it has found other uses outside of the NetCDF output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784610497
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787118994:10,Testability,test,test,10,"I added a test for `WindowedSpatialAverage` but I the docs keep failing and I don't know why. I'd appreciate some help. Btw, when I test locally everything passes, but the github tests fail somewhere that I can't figure out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787118994
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787118994:132,Testability,test,test,132,"I added a test for `WindowedSpatialAverage` but I the docs keep failing and I don't know why. I'd appreciate some help. Btw, when I test locally everything passes, but the github tests fail somewhere that I can't figure out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787118994
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787118994:179,Testability,test,tests,179,"I added a test for `WindowedSpatialAverage` but I the docs keep failing and I don't know why. I'd appreciate some help. Btw, when I test locally everything passes, but the github tests fail somewhere that I can't figure out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787118994
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787480801:350,Testability,log,log,350,"@tomchor Ah I think you accidentally left `include(""field_slicer.jl"")` commented out. I added a suggestion that would uncomment it. Might help since docs seem to be looking for this function (https://github.com/CliMA/Oceananigans.jl/blob/0da4ca7d9a3f44470596db604429c479a7449435/src/OutputWriters/field_slicer.jl#L102-L105) from looking at the build log (https://buildkite.com/clima/oceananigans/builds/1321#083a4e3e-7473-4581-9f22-b042418a7148/40-123). Not sure how the output writer tests pass without that though 😮",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787480801
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787480801:485,Testability,test,tests,485,"@tomchor Ah I think you accidentally left `include(""field_slicer.jl"")` commented out. I added a suggestion that would uncomment it. Might help since docs seem to be looking for this function (https://github.com/CliMA/Oceananigans.jl/blob/0da4ca7d9a3f44470596db604429c479a7449435/src/OutputWriters/field_slicer.jl#L102-L105) from looking at the build log (https://buildkite.com/clima/oceananigans/builds/1321#083a4e3e-7473-4581-9f22-b042418a7148/40-123). Not sure how the output writer tests pass without that though 😮",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787480801
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965:106,Integrability,message,messages,106,"Thanks for catching that! However, that's not the issue. One of the things I did (which I discussed a few messages ago) was to move `field_slicer.jl` from OutputWriter to Diagnostics, since I couldn't compile the code in the correct order for dependencies otherwise. (Plus now that FieldSlicer is used in Diagnostics, it's no longer exclusive to OutputWriters.). The test complains that it needs `short_show(fs::FieldSlicer)` in line 490 of `netcdf_output_writer.jl`: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R490. But I'm already `using` `short_show` from `Oceananigans.Diagnostics` in line 10 of the same file: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R10. This appears to work in my local set-up when testing, but somehow fails on github. Any ideas?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965:243,Integrability,depend,dependencies,243,"Thanks for catching that! However, that's not the issue. One of the things I did (which I discussed a few messages ago) was to move `field_slicer.jl` from OutputWriter to Diagnostics, since I couldn't compile the code in the correct order for dependencies otherwise. (Plus now that FieldSlicer is used in Diagnostics, it's no longer exclusive to OutputWriters.). The test complains that it needs `short_show(fs::FieldSlicer)` in line 490 of `netcdf_output_writer.jl`: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R490. But I'm already `using` `short_show` from `Oceananigans.Diagnostics` in line 10 of the same file: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R10. This appears to work in my local set-up when testing, but somehow fails on github. Any ideas?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965:367,Testability,test,test,367,"Thanks for catching that! However, that's not the issue. One of the things I did (which I discussed a few messages ago) was to move `field_slicer.jl` from OutputWriter to Diagnostics, since I couldn't compile the code in the correct order for dependencies otherwise. (Plus now that FieldSlicer is used in Diagnostics, it's no longer exclusive to OutputWriters.). The test complains that it needs `short_show(fs::FieldSlicer)` in line 490 of `netcdf_output_writer.jl`: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R490. But I'm already `using` `short_show` from `Oceananigans.Diagnostics` in line 10 of the same file: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R10. This appears to work in my local set-up when testing, but somehow fails on github. Any ideas?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965:874,Testability,test,testing,874,"Thanks for catching that! However, that's not the issue. One of the things I did (which I discussed a few messages ago) was to move `field_slicer.jl` from OutputWriter to Diagnostics, since I couldn't compile the code in the correct order for dependencies otherwise. (Plus now that FieldSlicer is used in Diagnostics, it's no longer exclusive to OutputWriters.). The test complains that it needs `short_show(fs::FieldSlicer)` in line 490 of `netcdf_output_writer.jl`: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R490. But I'm already `using` `short_show` from `Oceananigans.Diagnostics` in line 10 of the same file: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R10. This appears to work in my local set-up when testing, but somehow fails on github. Any ideas?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825:77,Availability,error,error,77,"Ah sorry, should have read your earlier message. I was able to reproduce the error locally with. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid); NetCDFOutputWriter(model, fields(model), filepath=""test.nc"", schedule=IterationInterval(1)); ```. <details><summary>Stacktrace</summary><p>. ```; Error showing value of type NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}:; ERROR: MethodError: no method matching short_show(::FieldSlicer{Colon,Colon,Colon}); Closest candidates are:; short_show(::AveragedTimeInterval) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/windowed_time_average.jl:209; Stacktrace:; [1] show(::IOContext{REPL.Terminals.TTYTerminal}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:490; [2] show(::IOContext{REPL.Terminals.TTYTerminal}, ::MIME{Symbol(""text/plain"")}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825:406,Availability,Error,Error,406,"Ah sorry, should have read your earlier message. I was able to reproduce the error locally with. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid); NetCDFOutputWriter(model, fields(model), filepath=""test.nc"", schedule=IterationInterval(1)); ```. <details><summary>Stacktrace</summary><p>. ```; Error showing value of type NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}:; ERROR: MethodError: no method matching short_show(::FieldSlicer{Colon,Colon,Colon}); Closest candidates are:; short_show(::AveragedTimeInterval) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/windowed_time_average.jl:209; Stacktrace:; [1] show(::IOContext{REPL.Terminals.TTYTerminal}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:490; [2] show(::IOContext{REPL.Terminals.TTYTerminal}, ::MIME{Symbol(""text/plain"")}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825:831,Availability,ERROR,ERROR,831,"Ah sorry, should have read your earlier message. I was able to reproduce the error locally with. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid); NetCDFOutputWriter(model, fields(model), filepath=""test.nc"", schedule=IterationInterval(1)); ```. <details><summary>Stacktrace</summary><p>. ```; Error showing value of type NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}:; ERROR: MethodError: no method matching short_show(::FieldSlicer{Colon,Colon,Colon}); Closest candidates are:; short_show(::AveragedTimeInterval) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/windowed_time_average.jl:209; Stacktrace:; [1] show(::IOContext{REPL.Terminals.TTYTerminal}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:490; [2] show(::IOContext{REPL.Terminals.TTYTerminal}, ::MIME{Symbol(""text/plain"")}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825:321,Energy Efficiency,schedul,schedule,321,"Ah sorry, should have read your earlier message. I was able to reproduce the error locally with. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid); NetCDFOutputWriter(model, fields(model), filepath=""test.nc"", schedule=IterationInterval(1)); ```. <details><summary>Stacktrace</summary><p>. ```; Error showing value of type NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}:; ERROR: MethodError: no method matching short_show(::FieldSlicer{Colon,Colon,Colon}); Closest candidates are:; short_show(::AveragedTimeInterval) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/windowed_time_average.jl:209; Stacktrace:; [1] show(::IOContext{REPL.Terminals.TTYTerminal}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:490; [2] show(::IOContext{REPL.Terminals.TTYTerminal}, ::MIME{Symbol(""text/plain"")}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825:40,Integrability,message,message,40,"Ah sorry, should have read your earlier message. I was able to reproduce the error locally with. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid); NetCDFOutputWriter(model, fields(model), filepath=""test.nc"", schedule=IterationInterval(1)); ```. <details><summary>Stacktrace</summary><p>. ```; Error showing value of type NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}:; ERROR: MethodError: no method matching short_show(::FieldSlicer{Colon,Colon,Colon}); Closest candidates are:; short_show(::AveragedTimeInterval) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/windowed_time_average.jl:209; Stacktrace:; [1] show(::IOContext{REPL.Terminals.TTYTerminal}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:490; [2] show(::IOContext{REPL.Terminals.TTYTerminal}, ::MIME{Symbol(""text/plain"")}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825:311,Testability,test,test,311,"Ah sorry, should have read your earlier message. I was able to reproduce the error locally with. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid); NetCDFOutputWriter(model, fields(model), filepath=""test.nc"", schedule=IterationInterval(1)); ```. <details><summary>Stacktrace</summary><p>. ```; Error showing value of type NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}:; ERROR: MethodError: no method matching short_show(::FieldSlicer{Colon,Colon,Colon}); Closest candidates are:; short_show(::AveragedTimeInterval) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/windowed_time_average.jl:209; Stacktrace:; [1] show(::IOContext{REPL.Terminals.TTYTerminal}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:490; [2] show(::IOContext{REPL.Terminals.TTYTerminal}, ::MIME{Symbol(""text/plain"")}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787507792:68,Testability,test,tests,68,"Awesome! Thanks, for the help @ali-ramadhan! Still not sure why the tests passed here though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787507792
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787508035:205,Testability,test,tests,205,"Ah were you in a REPL session with a long history + Revise.jl (including before the change)? In this case, a fresh REPL might have uncovered the issue. But if that wasn't it, then I'm not too sure how the tests passed...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787508035
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-788011056:45,Usability,learn,learning,45,"Thanks, everyone! Sorry it took so long, the learning curve was a little steeper than I thought. Next one will probably go smoother ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-788011056
https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-788011514:78,Deployability,release,release,78,I bumped v0.52.0 in PR #1406 but I'll wait until this PR is merged to tag the release so we can have `WindowedSpatialAverage` in v0.52.0.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-788011514
https://github.com/CliMA/Oceananigans.jl/issues/1398#issuecomment-784318930:22,Usability,clear,clear,22,"Just to be completely clear I am suggesting changing the above to. ```julia; convert_output(outputs::NamedTuple, writer) = ; NamedTuple{keys(outputs)}(Tuple(convert_output(output, writer) for output in outputs)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1398#issuecomment-784318930
https://github.com/CliMA/Oceananigans.jl/issues/1398#issuecomment-1479849426:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1398#issuecomment-1479849426
https://github.com/CliMA/Oceananigans.jl/issues/1400#issuecomment-1057337618:5,Deployability,Update,Updated,5,Yas! Updated the OP.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1400#issuecomment-1057337618
https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786242341:33,Modifiability,variab,variables,33,"Pressure is different from other variables because it doesn't have a dedicated `compute!` function. I do actually think it would be nice to ""regularize"" the code in this way by making the pressure (and eddy diffusivities) into `KernelComputedField`s (or other kinds of special fields) so that `compute!` works on them in the same way it works on other `ComputedField`s. The reason it is different is because while we have always had pressure auxiliary variables, `ComputedField`s are only a relatively recent addition to the code. In fact, it hadn't even occurred to me that it would be nice if we could use `compute!(hydrostatic_pressure)` until recently. More on the top of this issue, there is a small difference between the two kernels: in one the reference density (which is otherwise arbitrary?) appears to be `1027` and in the other its `1024`. But otherwise I don't see why it wouldn't work and I am a bit stumped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786242341
https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786242341:452,Modifiability,variab,variables,452,"Pressure is different from other variables because it doesn't have a dedicated `compute!` function. I do actually think it would be nice to ""regularize"" the code in this way by making the pressure (and eddy diffusivities) into `KernelComputedField`s (or other kinds of special fields) so that `compute!` works on them in the same way it works on other `ComputedField`s. The reason it is different is because while we have always had pressure auxiliary variables, `ComputedField`s are only a relatively recent addition to the code. In fact, it hadn't even occurred to me that it would be nice if we could use `compute!(hydrostatic_pressure)` until recently. More on the top of this issue, there is a small difference between the two kernels: in one the reference density (which is otherwise arbitrary?) appears to be `1027` and in the other its `1024`. But otherwise I don't see why it wouldn't work and I am a bit stumped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786242341
https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786245625:424,Integrability,depend,depending,424,"> More on the top of this issue, there is a small difference between the two kernels: in one the reference density (which is otherwise arbitrary?) appears to be 1027 and in the other its 1024. Sorry that was a typo. Just fixed it. > But otherwise I don't see why it wouldn't work and I am a bit stumped. Yes, I've dedicated several hours to investigating this issue also and got nothing. The issue also is that I'm actually depending on that result for research, and it's pretty expensive to calculate that offline. Do you have any suggested workarounds?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786245625
https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786312063:74,Testability,test,tested,74,"> Does the order in which you call compute! in your example matter?. Just tested it and no. > You could try making p a ComputedField. I'd tried that already and the results are the same :/. Something interesting is that the code below works:. ```julia; @kernel function pressure_correlation_z_ccc!(wp, grid, w, p); i, j, k = @index(Global, NTuple). @inbounds wp[i, j, k] = ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k] # C, C, C → C, C, F; end. wp = KernelComputedField(Center, Center, Center, pressure_correlation_z_ccc!, model;; field_dependencies=(w, p)). wp_2 = ComputedField(w*p). compute!(wp); compute!(wp_2); ```. The outputs are correct in this case. So apparently what's causing the problem is the term `∂zᵃᵃᶜ(i, j, k, grid, wp)` I think. But I cannot figure out why. Why would an interpolation operation work, but not a differentiation operation?. CC'ing @ali-ramadhan to see if he has any ideas.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786312063
https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786397904:185,Testability,test,test,185,"This:. ```julia; wp = ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k]; ```. is a number (the result of interpolating `p` in `z` and multiplying the result by `w`, at the index `i, j, k`). You can test this at the REPL by picking `i, j, k`. `∂zᵃᵃᶜ` needs to be able to index into `wp` at both `i, j, k` and `i, j, k+1` in order to calculate a derivative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786397904
https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786715346:271,Modifiability,variab,variable,271,"> If we take a look at those other kernels, maybe we can get to the bottom of it?. Actually now that I'm checking my scripts, I have always differentiated arguments passed as a `computed_dependency`. I hadn't paid attention to this before but I've never differentiated a variable that I created _inside_ the kernel, as is the case with `wp`. Apparently this is yet another limitation of GPU computing that I wasn't aware of. For my application this already solves the issue, as I can just define a vertical derivative kernel and pass the abstract operation `w*p`. But for the sake of the general user: is there any way around this limitation?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786715346
https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786817960:986,Safety,avoid,avoid,986,"Ahh hmm... I think you can get more diagnostics to work this way. The reason complex diagnostics fail, as discussed on #1241, is because of the recursive calls to `identity` (for example). We have to do this with `AbstractOperations` because that framework is written so that users don't have to ""know"" where their computations occur (or end up) --- at least not necessarily. In the above code, the user (you) is manually providing location information by selecting `∂zᵃᵃᶜ`; therefore we don't have to call an interpolation function (such as `identity`). This can be seen in the code in the crucial `getindex` function defined for all `AbstractOperations`, such as:. https://github.com/CliMA/Oceananigans.jl/blob/f6d65f8bd0f97c4e97d9e81b126c78c3e0d463c8/src/AbstractOperations/derivatives.jl#L25. I believe in this case that the function `d.▶` from the above is `identity`, which could fail because it's also called in the calculation of the binary operation `w * v`?. I think we could avoid some calls to `identity` in `AbstractOperations` if we restrict their generality. But I'm not sure that's the right philosophy. Maybe we just want to fix the compilation issues instead and preserve full generality in `AbstractOperations`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786817960
https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786854048:438,Performance,perform,performed,438,"> I believe in this case that the function d.▶ from the above is identity, which could fail because it's also called in the calculation of the binary operation w * v?. I gotta be honest that whole discussion went right over my head, haha. I think mostly because I don't really understand what's the exact use of `identities` and what the functions `d.▶` actually do. . Am I correct in assuming that if I specify where each calculation is performed (by using `@at`) I can decrease the computational complexity and maybe make `ComputedField`s easier to compile on GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786854048
https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786855273:338,Usability,feedback,feedback,338,"> What is the limitation you're referring to?. I'm referring to the fact that if you calculate a new quantity inside the kernel and then try to differentiate it the differentiation will fail because the new quantity will be a number and not a field. At least that's what I understood is happening in the piece of code below based on your feedback:. ```julia; wp = ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k]; ```. Also I'm closing the issue since my I've found a workaround to it based on your comments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786855273
https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786924993:16,Usability,clear,clear,16,"Great!. Just to clear up the conversation, I think its incorrect to refer to what we've discovered as a ""limitation"". Instead, we found a bug in the kernel function. The ""workaround"" is not a work around in the usual sense --- its just one _correct_ way to express the intent with code. There are several other ways to write this relatively simple kernel, which may be illuminating to explore. Exploiting the fact the the derivative function can be applied to functions of the form `f(i, j, k, grid, args...)` (as we have designed it) we might also write. ```julia; @inline wpᵃᵃᶠ(i, j, k, grid, w, p) = @inbounds ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k] . @kernel function pressure_distribution_z_ccc!(dwpdz_ρ, grid, w, p, ρ₀); i, j, k = @index(Global, NTuple); @inbounds dwpdz_ρ[i, j, k] = (1/ρ₀) * ∂zᵃᵃᶜ(i, j, k, grid, wpᵃᵃᶠ, w, p) # C, C, F → C, C, C; end ; ```. An even more mundane to express our intent is to manually difference the product `wp`, eg:. ```julia; @kernel function pressure_distribution_z_ccc!(dwpdz_ρ, grid, w, p, ρ₀); i, j, k = @index(Global, NTuple); @inbounds wpᵃᵃᶠ_above = ℑzᵃᵃᶠ(i, j, k+1, grid, p) * w[i, j, k+1] ; @inbounds wpᵃᵃᶠ_below = ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k] ; @inbounds dwpdz_ρ[i, j, k] = (1/ρ₀) * (wpᵃᵃᶠ_above - wpᵃᵃᶠ_below) / Δzᵃᵃᶜ(i, j, k, grid) # C, C, F → C, C, C; end ; ```. Using the differencing function is probably better (its what we do in the source) because it ensures that the indexing convection is treated correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786924993
https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786924993:341,Usability,simpl,simple,341,"Great!. Just to clear up the conversation, I think its incorrect to refer to what we've discovered as a ""limitation"". Instead, we found a bug in the kernel function. The ""workaround"" is not a work around in the usual sense --- its just one _correct_ way to express the intent with code. There are several other ways to write this relatively simple kernel, which may be illuminating to explore. Exploiting the fact the the derivative function can be applied to functions of the form `f(i, j, k, grid, args...)` (as we have designed it) we might also write. ```julia; @inline wpᵃᵃᶠ(i, j, k, grid, w, p) = @inbounds ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k] . @kernel function pressure_distribution_z_ccc!(dwpdz_ρ, grid, w, p, ρ₀); i, j, k = @index(Global, NTuple); @inbounds dwpdz_ρ[i, j, k] = (1/ρ₀) * ∂zᵃᵃᶜ(i, j, k, grid, wpᵃᵃᶠ, w, p) # C, C, F → C, C, C; end ; ```. An even more mundane to express our intent is to manually difference the product `wp`, eg:. ```julia; @kernel function pressure_distribution_z_ccc!(dwpdz_ρ, grid, w, p, ρ₀); i, j, k = @index(Global, NTuple); @inbounds wpᵃᵃᶠ_above = ℑzᵃᵃᶠ(i, j, k+1, grid, p) * w[i, j, k+1] ; @inbounds wpᵃᵃᶠ_below = ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k] ; @inbounds dwpdz_ρ[i, j, k] = (1/ρ₀) * (wpᵃᵃᶠ_above - wpᵃᵃᶠ_below) / Δzᵃᵃᶜ(i, j, k, grid) # C, C, F → C, C, C; end ; ```. Using the differencing function is probably better (its what we do in the source) because it ensures that the indexing convection is treated correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786924993
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:8232,Performance,perform,performance,8232,"PU │ 256 │ (Periodic, Bounded, Bounded) │ 25.185 ms │ 25.761 ms │ 25.702 ms │ 25.865 ms │ 29.56 KiB │ 629 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 9.832 ms │ 10.689 ms │ 10.631 ms │ 10.849 ms │ 13.06 KiB │ 290 │; └───────────────┴─────┴───────────────────────────────┴───────────┴───────────┴───────────┴───────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; Fourier-tridiagonal Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬─────────┬─────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼─────────┼─────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 50.4045 │ 21.5194 │ 32.4444 │; │ 256 │ (Bounded, Periodic, Bounded) │ 51.2039 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Bounded, Bounded) │ 52.4472 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Periodic, Bounded) │ 99.4371 │ 6.48062 │ 10.7407 │; └─────┴───────────────────────────────┴─────────┴─────────┴─────────┘; ```. ### Relative performance on the CPU. ```; Fourier-tridiagonal Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.58185 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.24529 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.27117 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴──────────┴────────┘; ```. ### Relative performance on the GPU. ```; Fourier-tridiagonal Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼──────────────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:8305,Performance,perform,performance,8305,"ms │ 13.06 KiB │ 290 │; └───────────────┴─────┴───────────────────────────────┴───────────┴───────────┴───────────┴───────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; Fourier-tridiagonal Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬─────────┬─────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼─────────┼─────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 50.4045 │ 21.5194 │ 32.4444 │; │ 256 │ (Bounded, Periodic, Bounded) │ 51.2039 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Bounded, Bounded) │ 52.4472 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Periodic, Bounded) │ 99.4371 │ 6.48062 │ 10.7407 │; └─────┴───────────────────────────────┴─────────┴─────────┴─────────┘; ```. ### Relative performance on the CPU. ```; Fourier-tridiagonal Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.58185 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.24529 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.27117 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴──────────┴────────┘; ```. ### Relative performance on the GPU. ```; Fourier-tridiagonal Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 3.12065 │ 3.32057 │ 3.02069 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 2.41833 │ 2.26316 │ 2.16897 │;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:8950,Performance,perform,performance,8950,"odic, Bounded) │ 51.2039 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Bounded, Bounded) │ 52.4472 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Periodic, Bounded) │ 99.4371 │ 6.48062 │ 10.7407 │; └─────┴───────────────────────────────┴─────────┴─────────┴─────────┘; ```. ### Relative performance on the CPU. ```; Fourier-tridiagonal Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.58185 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.24529 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.27117 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴──────────┴────────┘; ```. ### Relative performance on the GPU. ```; Fourier-tridiagonal Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 3.12065 │ 3.32057 │ 3.02069 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 2.41833 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 2.41007 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## FFT-based Poisson solver. ### Raw benchmarks. ```; FFT-based Poisson solver benchmarks ; ┌───────────────┬─────┬───────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ m",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:9023,Performance,perform,performance,9023,"──────────────────────────────┴─────────┴─────────┴─────────┘; ```. ### Relative performance on the CPU. ```; Fourier-tridiagonal Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.58185 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.24529 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.27117 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴──────────┴────────┘; ```. ### Relative performance on the GPU. ```; Fourier-tridiagonal Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 3.12065 │ 3.32057 │ 3.02069 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 2.41833 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 2.41007 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## FFT-based Poisson solver. ### Raw benchmarks. ```; FFT-based Poisson solver benchmarks ; ┌───────────────┬─────┬───────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:11727,Performance,perform,performance,11727,"110 ms │ 57.56 KiB │ 641 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 13.975 ms │ 30.948 ms │ 29.250 ms │ 30.985 ms │ 57.75 KiB │ 647 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 7.257 ms │ 15.907 ms │ 15.044 ms │ 15.927 ms │ 27.97 KiB │ 292 │; └───────────────┴─────┴───────────────────────────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; FFT-based Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬────────┬────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼────────┼────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:11779,Performance,perform,performance,11779,"7.257 ms │ 15.907 ms │ 15.044 ms │ 15.927 ms │ 27.97 KiB │ 292 │; └───────────────┴─────┴───────────────────────────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; FFT-based Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬────────┬────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼────────┼────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:12412,Performance,perform,performance,12412," 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.94553 │ 2.0648 │ 2.21575 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## System info. ```; Oceananigans v0.50.0; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; `",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:12464,Performance,perform,performance,12464,"5.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.94553 │ 2.0648 │ 2.21575 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## System info. ```; Oceananigans v0.50.0; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:2,Testability,Benchmark,Benchmarks,2,"# Benchmarks!. As mentioned [in the docs](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/poisson_solvers/#Direct-method-with-a-vertically-stretched-grid), the Fourier-tridiagonal solver is theoretically faster for large problems. Raw numbers in all their glory below but to summarize:; 1. The Fourier-tridiagonal Poisson solver is indeed faster! But only on the GPU. About ~1.5x faster for 256³ grids (15 -> 10 ms/solve).; 2. As a result, GPU incompressible models are faster with `FourierTridiagonalPoissonSolver`! But only by ~1.15x.; 3. More features with a faster solver though, seems like a win-win. ; 4. I should clarify the speedup is only enjoyed by `(Periodic, Periodic, Bounded)` on the GPU. For channel topologies, `FourierTridiagonalPoissonSolver` is slower.; 5. Oceananigans.jl is roughly as fast as it was before `HydrostaticFreeSurfaceModel`. ---. ## Vertically stretched incompressible model benchmarks. ### Raw benchmarks. ```; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 6.370 ms │ 7.323 ms │ 7.089 ms │ 7.649 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 64 │ 48.449 ms │ 49.064 ms │ 49.345 ms │ 51.689 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 128 │ 400.112 ms │ 402.124 ms │ 409.183 ms │ 469.727 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 256 │ 4.036 s │ 4.074 s │ 4.074 s │ 4.112 s │ 139.61 KiB │ 1832 │; │ CPU │ Float64 │ 32 │ 6.343 ms │ 6.425 ms │ 6.573 ms │ 7.301 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 64 │ 47.988 ms │ 48.355 ms │ 48.603 ms │ 50.857 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 128 │ 405.724 ms │ 408.699 ms │ 409.013 ms │ 414.735 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 256 │ 4.333 s │ 4.333 s │ 4.333 s │ 4.334 s │ 139.84 K",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:943,Testability,benchmark,benchmarks,943,"# Benchmarks!. As mentioned [in the docs](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/poisson_solvers/#Direct-method-with-a-vertically-stretched-grid), the Fourier-tridiagonal solver is theoretically faster for large problems. Raw numbers in all their glory below but to summarize:; 1. The Fourier-tridiagonal Poisson solver is indeed faster! But only on the GPU. About ~1.5x faster for 256³ grids (15 -> 10 ms/solve).; 2. As a result, GPU incompressible models are faster with `FourierTridiagonalPoissonSolver`! But only by ~1.15x.; 3. More features with a faster solver though, seems like a win-win. ; 4. I should clarify the speedup is only enjoyed by `(Periodic, Periodic, Bounded)` on the GPU. For channel topologies, `FourierTridiagonalPoissonSolver` is slower.; 5. Oceananigans.jl is roughly as fast as it was before `HydrostaticFreeSurfaceModel`. ---. ## Vertically stretched incompressible model benchmarks. ### Raw benchmarks. ```; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 6.370 ms │ 7.323 ms │ 7.089 ms │ 7.649 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 64 │ 48.449 ms │ 49.064 ms │ 49.345 ms │ 51.689 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 128 │ 400.112 ms │ 402.124 ms │ 409.183 ms │ 469.727 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 256 │ 4.036 s │ 4.074 s │ 4.074 s │ 4.112 s │ 139.61 KiB │ 1832 │; │ CPU │ Float64 │ 32 │ 6.343 ms │ 6.425 ms │ 6.573 ms │ 7.301 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 64 │ 47.988 ms │ 48.355 ms │ 48.603 ms │ 50.857 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 128 │ 405.724 ms │ 408.699 ms │ 409.013 ms │ 414.735 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 256 │ 4.333 s │ 4.333 s │ 4.333 s │ 4.334 s │ 139.84 K",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:963,Testability,benchmark,benchmarks,963,"# Benchmarks!. As mentioned [in the docs](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/poisson_solvers/#Direct-method-with-a-vertically-stretched-grid), the Fourier-tridiagonal solver is theoretically faster for large problems. Raw numbers in all their glory below but to summarize:; 1. The Fourier-tridiagonal Poisson solver is indeed faster! But only on the GPU. About ~1.5x faster for 256³ grids (15 -> 10 ms/solve).; 2. As a result, GPU incompressible models are faster with `FourierTridiagonalPoissonSolver`! But only by ~1.15x.; 3. More features with a faster solver though, seems like a win-win. ; 4. I should clarify the speedup is only enjoyed by `(Periodic, Periodic, Bounded)` on the GPU. For channel topologies, `FourierTridiagonalPoissonSolver` is slower.; 5. Oceananigans.jl is roughly as fast as it was before `HydrostaticFreeSurfaceModel`. ---. ## Vertically stretched incompressible model benchmarks. ### Raw benchmarks. ```; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 6.370 ms │ 7.323 ms │ 7.089 ms │ 7.649 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 64 │ 48.449 ms │ 49.064 ms │ 49.345 ms │ 51.689 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 128 │ 400.112 ms │ 402.124 ms │ 409.183 ms │ 469.727 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 256 │ 4.036 s │ 4.074 s │ 4.074 s │ 4.112 s │ 139.61 KiB │ 1832 │; │ CPU │ Float64 │ 32 │ 6.343 ms │ 6.425 ms │ 6.573 ms │ 7.301 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 64 │ 47.988 ms │ 48.355 ms │ 48.603 ms │ 50.857 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 128 │ 405.724 ms │ 408.699 ms │ 409.013 ms │ 414.735 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 256 │ 4.333 s │ 4.333 s │ 4.333 s │ 4.334 s │ 139.84 K",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:3505,Testability,benchmark,benchmarks,3505,ms │ 3.709 ms │ 547.70 KiB │ 6657 │; │ GPU │ Float64 │ 128 │ 4.682 ms │ 4.725 ms │ 4.880 ms │ 5.654 ms │ 632.67 KiB │ 6655 │; │ GPU │ Float64 │ 256 │ 25.907 ms │ 32.091 ms │ 31.487 ms │ 32.483 ms │ 801.86 KiB │ 6763 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ### CPU to GPU speedup. ```; ┌─────────────┬─────┬─────────┬─────────┬─────────┐; │ Float_types │ Ns │ speedup │ memory │ allocs │; ├─────────────┼─────┼─────────┼─────────┼─────────┤; │ Float32 │ 32 │ 2.93732 │ 3.62888 │ 3.63319 │; │ Float32 │ 64 │ 17.443 │ 3.9155 │ 3.63373 │; │ Float32 │ 128 │ 86.446 │ 4.52412 │ 3.63264 │; │ Float32 │ 256 │ 127.777 │ 5.72434 │ 3.63483 │; │ Float64 │ 32 │ 2.51868 │ 3.63039 │ 3.63319 │; │ Float64 │ 64 │ 17.1005 │ 3.91654 │ 3.63373 │; │ Float64 │ 128 │ 86.4912 │ 4.52413 │ 3.63264 │; │ Float64 │ 256 │ 135.031 │ 5.73397 │ 3.69159 │; └─────────────┴─────┴─────────┴─────────┴─────────┘; ```. ---. ## Incompressible model benchmarks (regular Rectilinear grid). ### Raw benchmarks. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 5.408 ms │ 5.713 ms │ 5.871 ms │ 6.634 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 64 │ 36.120 ms │ 38.174 ms │ 38.435 ms │ 41.795 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 128 │ 304.741 ms │ 311.332 ms │ 311.085 ms │ 315.204 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 256 │ 2.598 s │ 2.598 s │ 2.598 s │ 2.599 s │ 287.98 KiB │ 2136 │; │ CPU │ Float64 │ 32 │ 6.419 ms │ 6.647 ms │ 6.733 ms │ 7.657 ms │ 350.52 KiB │ 2136 │; │ CPU │ Float64 │ 64 │ 42.856 ms │ 46.229 ms │ 45.719 ms │ 47.103 ms │ 350.52 KiB │ 2136 │; │ CPU │ Float64 │ 128 │ 369.043 ms │ 380.330 ms │ 380.214 ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:3552,Testability,benchmark,benchmarks,3552, │ Float64 │ 128 │ 4.682 ms │ 4.725 ms │ 4.880 ms │ 5.654 ms │ 632.67 KiB │ 6655 │; │ GPU │ Float64 │ 256 │ 25.907 ms │ 32.091 ms │ 31.487 ms │ 32.483 ms │ 801.86 KiB │ 6763 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ### CPU to GPU speedup. ```; ┌─────────────┬─────┬─────────┬─────────┬─────────┐; │ Float_types │ Ns │ speedup │ memory │ allocs │; ├─────────────┼─────┼─────────┼─────────┼─────────┤; │ Float32 │ 32 │ 2.93732 │ 3.62888 │ 3.63319 │; │ Float32 │ 64 │ 17.443 │ 3.9155 │ 3.63373 │; │ Float32 │ 128 │ 86.446 │ 4.52412 │ 3.63264 │; │ Float32 │ 256 │ 127.777 │ 5.72434 │ 3.63483 │; │ Float64 │ 32 │ 2.51868 │ 3.63039 │ 3.63319 │; │ Float64 │ 64 │ 17.1005 │ 3.91654 │ 3.63373 │; │ Float64 │ 128 │ 86.4912 │ 4.52413 │ 3.63264 │; │ Float64 │ 256 │ 135.031 │ 5.73397 │ 3.69159 │; └─────────────┴─────┴─────────┴─────────┴─────────┘; ```. ---. ## Incompressible model benchmarks (regular Rectilinear grid). ### Raw benchmarks. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 5.408 ms │ 5.713 ms │ 5.871 ms │ 6.634 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 64 │ 36.120 ms │ 38.174 ms │ 38.435 ms │ 41.795 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 128 │ 304.741 ms │ 311.332 ms │ 311.085 ms │ 315.204 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 256 │ 2.598 s │ 2.598 s │ 2.598 s │ 2.599 s │ 287.98 KiB │ 2136 │; │ CPU │ Float64 │ 32 │ 6.419 ms │ 6.647 ms │ 6.733 ms │ 7.657 ms │ 350.52 KiB │ 2136 │; │ CPU │ Float64 │ 64 │ 42.856 ms │ 46.229 ms │ 45.719 ms │ 47.103 ms │ 350.52 KiB │ 2136 │; │ CPU │ Float64 │ 128 │ 369.043 ms │ 380.330 ms │ 380.214 ms │ 385.820 ms │ 350.52 KiB │ 2136 │; │ ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:3590,Testability,benchmark,benchmarks,3590,──────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ### CPU to GPU speedup. ```; ┌─────────────┬─────┬─────────┬─────────┬─────────┐; │ Float_types │ Ns │ speedup │ memory │ allocs │; ├─────────────┼─────┼─────────┼─────────┼─────────┤; │ Float32 │ 32 │ 2.93732 │ 3.62888 │ 3.63319 │; │ Float32 │ 64 │ 17.443 │ 3.9155 │ 3.63373 │; │ Float32 │ 128 │ 86.446 │ 4.52412 │ 3.63264 │; │ Float32 │ 256 │ 127.777 │ 5.72434 │ 3.63483 │; │ Float64 │ 32 │ 2.51868 │ 3.63039 │ 3.63319 │; │ Float64 │ 64 │ 17.1005 │ 3.91654 │ 3.63373 │; │ Float64 │ 128 │ 86.4912 │ 4.52413 │ 3.63264 │; │ Float64 │ 256 │ 135.031 │ 5.73397 │ 3.69159 │; └─────────────┴─────┴─────────┴─────────┴─────────┘; ```. ---. ## Incompressible model benchmarks (regular Rectilinear grid). ### Raw benchmarks. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 5.408 ms │ 5.713 ms │ 5.871 ms │ 6.634 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 64 │ 36.120 ms │ 38.174 ms │ 38.435 ms │ 41.795 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 128 │ 304.741 ms │ 311.332 ms │ 311.085 ms │ 315.204 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 256 │ 2.598 s │ 2.598 s │ 2.598 s │ 2.599 s │ 287.98 KiB │ 2136 │; │ CPU │ Float64 │ 32 │ 6.419 ms │ 6.647 ms │ 6.733 ms │ 7.657 ms │ 350.52 KiB │ 2136 │; │ CPU │ Float64 │ 64 │ 42.856 ms │ 46.229 ms │ 45.719 ms │ 47.103 ms │ 350.52 KiB │ 2136 │; │ CPU │ Float64 │ 128 │ 369.043 ms │ 380.330 ms │ 380.214 ms │ 385.820 ms │ 350.52 KiB │ 2136 │; │ CPU │ Float64 │ 256 │ 3.934 s │ 3.943 s │ 3.943 s │ 3.953 s │ 350.52 KiB │ 2136 │; │ GPU │ Float32 │ 32 │ 2.520 ms │ 2.588 ms │ 2.663 ms │ 3.287 ms │ 685.19 KiB │ 7043 │; │ GPU │ Float32 │ 64 │ 2.6,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:6182,Testability,benchmark,benchmarks,6182,"; │ GPU │ Float64 │ 128 │ 4.960 ms │ 5.049 ms │ 5.117 ms │ 5.493 ms │ 916.33 KiB │ 7061 │; │ GPU │ Float64 │ 256 │ 22.908 ms │ 36.834 ms │ 35.414 ms │ 36.918 ms │ 1.06 MiB │ 7045 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ## CPU to GPU speedup. ```; Incompressible model CPU -> GPU speedup; ┌─────────────┬─────┬─────────┬─────────┬─────────┐; │ Float_types │ Ns │ speedup │ memory │ allocs │; ├─────────────┼─────┼─────────┼─────────┼─────────┤; │ Float32 │ 32 │ 2.20733 │ 2.37925 │ 3.29728 │; │ Float32 │ 64 │ 13.9392 │ 2.51685 │ 3.29354 │; │ Float32 │ 128 │ 90.5074 │ 2.81265 │ 3.29916 │; │ Float32 │ 256 │ 121.854 │ 3.39417 │ 3.29822 │; │ Float64 │ 32 │ 2.34399 │ 2.25752 │ 3.29728 │; │ Float64 │ 64 │ 16.2694 │ 2.37057 │ 3.29354 │; │ Float64 │ 128 │ 75.3331 │ 2.61423 │ 3.30571 │; │ Float64 │ 256 │ 107.062 │ 3.09138 │ 3.29822 │; └─────────────┴─────┴─────────┴─────────┴─────────┘; ```. ---. ## Fourier-tridiagonal Poisson solver benchmarks. ### Raw benchmarks; ```; Fourier-tridiagonal Poisson solver benchmarks ; ┌───────────────┬─────┬───────────────────────────────┬───────────┬───────────┬───────────┬───────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼───────────┼───────────┼───────────┼───────────┼───────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.679 s │ 1.681 s │ 1.703 s │ 1.747 s │ 2.02 KiB │ 27 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.319 s │ 1.324 s │ 1.332 s │ 1.363 s │ 1.86 KiB │ 27 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.349 s │ 1.351 s │ 1.374 s │ 1.444 s │ 1.86 KiB │ 27 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.052 s │ 1.063 s │ 1.062 s │ 1.068 s │ 2.02 KiB │ 27 │; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 32.863 ms │ 33.356 ms │ 33.347 ms │ 33.543 ms │ 43.38 KiB │ 876 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 25",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:6202,Testability,benchmark,benchmarks,6202,"─────┴────────────┴────────────┴────────┘; ```. ## CPU to GPU speedup. ```; Incompressible model CPU -> GPU speedup; ┌─────────────┬─────┬─────────┬─────────┬─────────┐; │ Float_types │ Ns │ speedup │ memory │ allocs │; ├─────────────┼─────┼─────────┼─────────┼─────────┤; │ Float32 │ 32 │ 2.20733 │ 2.37925 │ 3.29728 │; │ Float32 │ 64 │ 13.9392 │ 2.51685 │ 3.29354 │; │ Float32 │ 128 │ 90.5074 │ 2.81265 │ 3.29916 │; │ Float32 │ 256 │ 121.854 │ 3.39417 │ 3.29822 │; │ Float64 │ 32 │ 2.34399 │ 2.25752 │ 3.29728 │; │ Float64 │ 64 │ 16.2694 │ 2.37057 │ 3.29354 │; │ Float64 │ 128 │ 75.3331 │ 2.61423 │ 3.30571 │; │ Float64 │ 256 │ 107.062 │ 3.09138 │ 3.29822 │; └─────────────┴─────┴─────────┴─────────┴─────────┘; ```. ---. ## Fourier-tridiagonal Poisson solver benchmarks. ### Raw benchmarks; ```; Fourier-tridiagonal Poisson solver benchmarks ; ┌───────────────┬─────┬───────────────────────────────┬───────────┬───────────┬───────────┬───────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼───────────┼───────────┼───────────┼───────────┼───────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.679 s │ 1.681 s │ 1.703 s │ 1.747 s │ 2.02 KiB │ 27 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.319 s │ 1.324 s │ 1.332 s │ 1.363 s │ 1.86 KiB │ 27 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.349 s │ 1.351 s │ 1.374 s │ 1.444 s │ 1.86 KiB │ 27 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.052 s │ 1.063 s │ 1.062 s │ 1.068 s │ 2.02 KiB │ 27 │; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 32.863 ms │ 33.356 ms │ 33.347 ms │ 33.543 ms │ 43.38 KiB │ 876 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 25.173 ms │ 25.849 ms │ 25.794 ms │ 25.928 ms │ 29.56 KiB │ 629 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 25.185 ms │ 25.761 ms │ 25.702 ms │ 25.865 ms │ 29.56 KiB │ 629 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 9.832 ms │ 10.689 ms │ 10.631 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:6254,Testability,benchmark,benchmarks,6254,"─────┴────────────┴────────────┴────────┘; ```. ## CPU to GPU speedup. ```; Incompressible model CPU -> GPU speedup; ┌─────────────┬─────┬─────────┬─────────┬─────────┐; │ Float_types │ Ns │ speedup │ memory │ allocs │; ├─────────────┼─────┼─────────┼─────────┼─────────┤; │ Float32 │ 32 │ 2.20733 │ 2.37925 │ 3.29728 │; │ Float32 │ 64 │ 13.9392 │ 2.51685 │ 3.29354 │; │ Float32 │ 128 │ 90.5074 │ 2.81265 │ 3.29916 │; │ Float32 │ 256 │ 121.854 │ 3.39417 │ 3.29822 │; │ Float64 │ 32 │ 2.34399 │ 2.25752 │ 3.29728 │; │ Float64 │ 64 │ 16.2694 │ 2.37057 │ 3.29354 │; │ Float64 │ 128 │ 75.3331 │ 2.61423 │ 3.30571 │; │ Float64 │ 256 │ 107.062 │ 3.09138 │ 3.29822 │; └─────────────┴─────┴─────────┴─────────┴─────────┘; ```. ---. ## Fourier-tridiagonal Poisson solver benchmarks. ### Raw benchmarks; ```; Fourier-tridiagonal Poisson solver benchmarks ; ┌───────────────┬─────┬───────────────────────────────┬───────────┬───────────┬───────────┬───────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼───────────┼───────────┼───────────┼───────────┼───────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.679 s │ 1.681 s │ 1.703 s │ 1.747 s │ 2.02 KiB │ 27 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.319 s │ 1.324 s │ 1.332 s │ 1.363 s │ 1.86 KiB │ 27 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.349 s │ 1.351 s │ 1.374 s │ 1.444 s │ 1.86 KiB │ 27 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.052 s │ 1.063 s │ 1.062 s │ 1.068 s │ 2.02 KiB │ 27 │; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 32.863 ms │ 33.356 ms │ 33.347 ms │ 33.543 ms │ 43.38 KiB │ 876 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 25.173 ms │ 25.849 ms │ 25.794 ms │ 25.928 ms │ 29.56 KiB │ 629 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 25.185 ms │ 25.761 ms │ 25.702 ms │ 25.865 ms │ 29.56 KiB │ 629 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 9.832 ms │ 10.689 ms │ 10.631 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:9711,Testability,benchmark,benchmarks,9711,"│ 256 │ (Periodic, Bounded, Bounded) │ 1.27117 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴──────────┴────────┘; ```. ### Relative performance on the GPU. ```; Fourier-tridiagonal Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 3.12065 │ 3.32057 │ 3.02069 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 2.41833 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 2.41007 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## FFT-based Poisson solver. ### Raw benchmarks. ```; FFT-based Poisson solver benchmarks ; ┌───────────────┬─────┬───────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.366 s │ 1.370 s │ 1.369 s │ 1.373 s │ 192 bytes │ 4 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.138 s │ 1.146 s │ 1.148 s │ 1.157 s │ 160 bytes │ 2 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.147 s │ 1.148 s │ 1.152 s │ 1.161 s │ 160 bytes │ 2 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 843.212 ms │ 849.492 ms │ 849.080 ms │ 853.401 ms │ 160 bytes │ 2 │; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 17.252 ms │ 38.642 ms │ 36.505 ms │ 38.756 ms │ 84.38 KiB │ 898 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 13.979 ms │ 31.085 ms │ 29.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:9753,Testability,benchmark,benchmarks,9753,"## Relative performance on the GPU. ```; Fourier-tridiagonal Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 3.12065 │ 3.32057 │ 3.02069 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 2.41833 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 2.41007 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## FFT-based Poisson solver. ### Raw benchmarks. ```; FFT-based Poisson solver benchmarks ; ┌───────────────┬─────┬───────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.366 s │ 1.370 s │ 1.369 s │ 1.373 s │ 192 bytes │ 4 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.138 s │ 1.146 s │ 1.148 s │ 1.157 s │ 160 bytes │ 2 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.147 s │ 1.148 s │ 1.152 s │ 1.161 s │ 160 bytes │ 2 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 843.212 ms │ 849.492 ms │ 849.080 ms │ 853.401 ms │ 160 bytes │ 2 │; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 17.252 ms │ 38.642 ms │ 36.505 ms │ 38.756 ms │ 84.38 KiB │ 898 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 13.979 ms │ 31.085 ms │ 29.365 ms │ 31.110 ms │ 57.56 KiB │ 641 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 13.975 ms │ 30.948 ms │ 29.250 ms │ 30.985 ms │ 57.75 KiB │ 647 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 7.257 ms │ 15.907 ms │ 15.044",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050
https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786816292:144,Security,validat,validation,144,"A git merge/rebase master might help with review, but only thought I had was: would it be too much work to add tests to CI that run the two new validation experiment? This would help ensure they don't go out of date and that we can easily run them on Buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786816292
https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786816292:111,Testability,test,tests,111,"A git merge/rebase master might help with review, but only thought I had was: would it be too much work to add tests to CI that run the two new validation experiment? This would help ensure they don't go out of date and that we can easily run them on Buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786816292
https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786820370:92,Security,validat,validation,92,"> only thought I had was: would it be too much work to add tests to CI that run the two new validation experiment? This would help ensure they don't go out of date and that we can easily run them on Buildkite. No, I think we should do this for the solid body validation experiment. I will implement this after I finish a quantitative analysis of the results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786820370
https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786820370:259,Security,validat,validation,259,"> only thought I had was: would it be too much work to add tests to CI that run the two new validation experiment? This would help ensure they don't go out of date and that we can easily run them on Buildkite. No, I think we should do this for the solid body validation experiment. I will implement this after I finish a quantitative analysis of the results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786820370
https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786820370:59,Testability,test,tests,59,"> only thought I had was: would it be too much work to add tests to CI that run the two new validation experiment? This would help ensure they don't go out of date and that we can easily run them on Buildkite. No, I think we should do this for the solid body validation experiment. I will implement this after I finish a quantitative analysis of the results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786820370
https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-789067613:496,Security,validat,validation,496,"The dynamics test exhibits some ""breathing"":. https://user-images.githubusercontent.com/15271942/109686870-acb3d980-7b50-11eb-86c5-437fb7257d6b.mp4. https://user-images.githubusercontent.com/15271942/109686850-a887bc00-7b50-11eb-8939-803a1de29261.mp4. this could be because the initial condition doesn't satisfy discrete geostrophic balance, or a continuing issue with the coriolis implementation. However, I suggest we merge this PR now (since it has some bug fixes) and continue working on the validation tests in a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-789067613
https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-789067613:13,Testability,test,test,13,"The dynamics test exhibits some ""breathing"":. https://user-images.githubusercontent.com/15271942/109686870-acb3d980-7b50-11eb-86c5-437fb7257d6b.mp4. https://user-images.githubusercontent.com/15271942/109686850-a887bc00-7b50-11eb-8939-803a1de29261.mp4. this could be because the initial condition doesn't satisfy discrete geostrophic balance, or a continuing issue with the coriolis implementation. However, I suggest we merge this PR now (since it has some bug fixes) and continue working on the validation tests in a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-789067613
https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-789067613:507,Testability,test,tests,507,"The dynamics test exhibits some ""breathing"":. https://user-images.githubusercontent.com/15271942/109686870-acb3d980-7b50-11eb-86c5-437fb7257d6b.mp4. https://user-images.githubusercontent.com/15271942/109686850-a887bc00-7b50-11eb-8939-803a1de29261.mp4. this could be because the initial condition doesn't satisfy discrete geostrophic balance, or a continuing issue with the coriolis implementation. However, I suggest we merge this PR now (since it has some bug fixes) and continue working on the validation tests in a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-789067613
https://github.com/CliMA/Oceananigans.jl/issues/1405#issuecomment-1479851578:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1405#issuecomment-1479851578
https://github.com/CliMA/Oceananigans.jl/pull/1415#issuecomment-789160016:18,Testability,test,tests,18,"""A PR without its tests is doomed."". (folklore saying)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1415#issuecomment-789160016
https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-788883027:0,Testability,Test,Tests,0,Tests will fail while we wait for https://github.com/CliMA/CubedSphere.jl to become a fully-fledged Julia package. Hopefully just one more day of waiting... https://github.com/JuliaRegistries/General/pull/30963,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-788883027
https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-788891174:65,Security,validat,validation,65,It would be really cool to put some viz in the docs. Could add a validation test just for the grid to `validation` perhaps with viz in it too (perhaps as a stop gap if there isn't time to whip up nice docs).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-788891174
https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-788891174:103,Security,validat,validation,103,It would be really cool to put some viz in the docs. Could add a validation test just for the grid to `validation` perhaps with viz in it too (perhaps as a stop gap if there isn't time to whip up nice docs).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-788891174
https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-788891174:76,Testability,test,test,76,It would be really cool to put some viz in the docs. Could add a validation test just for the grid to `validation` perhaps with viz in it too (perhaps as a stop gap if there isn't time to whip up nice docs).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-788891174
https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-796838672:96,Testability,test,test,96,@christophernhill suggested just doing `ConformalCubedSphereFaceGrid` in this PR which we could test by itself before worrying about the full `ConformalCubedSphereGrid` + halo exchange in a separate PR. So I'll do this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-796838672
https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-797074745:707,Testability,test,tests,707,"We should now be able to create cubed sphere face grids from the JLD2 files in https://github.com/CliMA/OceananigansArtifacts.jl using. ```julia; using DataDeps; using Oceananigans. dd = DataDep(""cubed_sphere_32_grid"",; ""Conformal cubed sphere grid with 32×32 grid points on each face"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cubed_sphere_32_grid.jld2"",; ""3cc5d86290c3af028cddfa47e61e095ee470fe6f8d779c845de09da2f1abeb15"" # sha256sum; ). DataDeps.register(dd). cs32_filepath = datadep""cubed_sphere_32_grid/cubed_sphere_32_grid.jld2""; grid = ConformalCubedSphereFaceGrid(cs32_filepath, face=6, Nz=1, z=(-1, 0)); ```. so we should be able to start running some simple tests on single faces!. Should we merge and work on testing in subsequent PRs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-797074745
https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-797074745:759,Testability,test,testing,759,"We should now be able to create cubed sphere face grids from the JLD2 files in https://github.com/CliMA/OceananigansArtifacts.jl using. ```julia; using DataDeps; using Oceananigans. dd = DataDep(""cubed_sphere_32_grid"",; ""Conformal cubed sphere grid with 32×32 grid points on each face"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cubed_sphere_32_grid.jld2"",; ""3cc5d86290c3af028cddfa47e61e095ee470fe6f8d779c845de09da2f1abeb15"" # sha256sum; ). DataDeps.register(dd). cs32_filepath = datadep""cubed_sphere_32_grid/cubed_sphere_32_grid.jld2""; grid = ConformalCubedSphereFaceGrid(cs32_filepath, face=6, Nz=1, z=(-1, 0)); ```. so we should be able to start running some simple tests on single faces!. Should we merge and work on testing in subsequent PRs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-797074745
https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-797074745:700,Usability,simpl,simple,700,"We should now be able to create cubed sphere face grids from the JLD2 files in https://github.com/CliMA/OceananigansArtifacts.jl using. ```julia; using DataDeps; using Oceananigans. dd = DataDep(""cubed_sphere_32_grid"",; ""Conformal cubed sphere grid with 32×32 grid points on each face"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cubed_sphere_32_grid.jld2"",; ""3cc5d86290c3af028cddfa47e61e095ee470fe6f8d779c845de09da2f1abeb15"" # sha256sum; ). DataDeps.register(dd). cs32_filepath = datadep""cubed_sphere_32_grid/cubed_sphere_32_grid.jld2""; grid = ConformalCubedSphereFaceGrid(cs32_filepath, face=6, Nz=1, z=(-1, 0)); ```. so we should be able to start running some simple tests on single faces!. Should we merge and work on testing in subsequent PRs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-797074745
https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-799811016:350,Modifiability,variab,variable,350,"> Blast. How about `x′`, `y′`?; >; > Can also change the vorticity notation in field_metric_products to something else. I'm okay with `x′`, `y′` but I'll leave it for now since it's localized to the grid constructor so it hopefully shouldn't cause any confusion (and there's a comment). Could be cool if we had like a notation list/glossary so every variable had one meaning like some books have, but we'd probably run out of letters very quickly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-799811016
https://github.com/CliMA/Oceananigans.jl/issues/1419#issuecomment-790728343:79,Deployability,release,release,79,Ah I can have a look at this. @glwagner bumped v0.52.1 but we haven't tagged a release yet so if we can fix/merge this soon it can make it into v0.52.1.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1419#issuecomment-790728343
https://github.com/CliMA/Oceananigans.jl/issues/1420#issuecomment-1479851181:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420#issuecomment-1479851181
https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-790717920:332,Availability,error,errors,332,"I noticed this change last week but I thought it was intentional. I don't have a strong opinion here. . If we're trying to cater to more inexperienced users (of which Oceananigans will probably attract a lot of, since it's always portrayed as user-friendly) then it might make sense to try and guard against this somehow (since the errors you get when trying to do stuff with timedeltas that can't be done aren't very useful). . Otherwise I'd say it's up to the user to deal with this, since on the Oceananigans end the change was (imho) for the better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-790717920
https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-790717920:243,Usability,user-friendly,user-friendly,243,"I noticed this change last week but I thought it was intentional. I don't have a strong opinion here. . If we're trying to cater to more inexperienced users (of which Oceananigans will probably attract a lot of, since it's always portrayed as user-friendly) then it might make sense to try and guard against this somehow (since the errors you get when trying to do stuff with timedeltas that can't be done aren't very useful). . Otherwise I'd say it's up to the user to deal with this, since on the Oceananigans end the change was (imho) for the better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-790717920
https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791008380:98,Integrability,depend,depends,98,"But Oceananigans doesn't really output time in ""seconds"", does it? The time unit is arbitrary, or depends on user inputs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791008380
https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791012283:260,Modifiability,config,configurable,260,"Right, another reason to allow the user to specify the time attribute when using `NetCDFOutputWriter`. The default `IncompressibleModel` uses seconds so that could be an argument for ""seconds"" being the default for `NetCDFOutputWriter`. But right now it's not configurable by the user so I'll keep this issue open until this is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791012283
https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791485502:87,Energy Efficiency,meter,meters,87,"> Can spatial units be set?. Spatial attributes can be set but Oceananigans.jl assumes meters right now so more unit misattribution. If the time units can be set, then we should be able to set the spatial units. > Are packages like Unitful.jl not mature enough to be used for these purposes? I understand this is a pretty extreme solution for this problem specifically, but It would be pretty cool if Oceananigans could understand units. I think it's mature enough but not I guess we're not sure where to use it (we discussed a bit in #1116). Would be perfect for specifying these kinds of units as long as it's not a heavy dependency. For other simulations, e.g. icy moons, it's nice to use rotation periods. Another place where units are assumed is `prettytime` so the `Simulation` always thinks your units are SI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791485502
https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791485502:624,Integrability,depend,dependency,624,"> Can spatial units be set?. Spatial attributes can be set but Oceananigans.jl assumes meters right now so more unit misattribution. If the time units can be set, then we should be able to set the spatial units. > Are packages like Unitful.jl not mature enough to be used for these purposes? I understand this is a pretty extreme solution for this problem specifically, but It would be pretty cool if Oceananigans could understand units. I think it's mature enough but not I guess we're not sure where to use it (we discussed a bit in #1116). Would be perfect for specifying these kinds of units as long as it's not a heavy dependency. For other simulations, e.g. icy moons, it's nice to use rotation periods. Another place where units are assumed is `prettytime` so the `Simulation` always thinks your units are SI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791485502
https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791618889:271,Security,access,accessibility,271,"Agree that SI default makes sense for a code called ""Oceananigans"". Note that some of the examples are non-dimensional, so an SI default will indeed add code to those examples --- which are likely some of the most-read scripts in the Oceananigans-verse. I also think for accessibility it could make sense to prioritize ease-of-use in a classroom context, where non-dimensional runs are the norm.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791618889
https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-1479872542:127,Energy Efficiency,meter,meters,127,"Personally, I think things are working well as they are now. We're assuming time is in seconds, but also that positions are in meters and so on. We could create a flat in `NetCDFWriter` that switches from metric no nondimensional, but unless other users seem bothered by this, I say we just close the issue for now. Ideally we'd solve this issue for Oceananigans as a whole by using `Unitful` and such, but that's probably a very big effort...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-1479872542
https://github.com/CliMA/Oceananigans.jl/issues/1422#issuecomment-811595869:819,Energy Efficiency,allocate,allocated,819,"Thinking about this a bit more --- do we need to use `mapreduce` at all? Supposedly `mean` will take an iterator as an argument:. ```julia; help?> mean; search: mean mean! median median! SegmentationFault macroexpand @macroexpand @macroexpand1 Meta numerator enumerate timedwait promote_shape MethodSummary. mean(itr). Compute the mean of all elements in a collection.; ```. Does this mean we can use `AbstractOperations` directly in `mean` (if they iterate correctly?) . This may also provide a way to compute correct averages on-the-fly on stretched grids, combined with #1452 (which we haven't discussed yet). I might be missing something about specifically how we would use `mapreduce`. As a side note, if we do need to use `mapreduce`, we may want to use `Base.mapreducedim!` (which stores results in a previously allocated array, as I think we want).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1422#issuecomment-811595869
https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-791482111:838,Integrability,interface,interface,838,"As far as I can tell the main purpose of `CLIMAParameters` is to provide a central / global place to specify common parameters found in different model components. For example, `HydrostaticFreeSurfaceModel` has a `gravitational_acceleration` for both `buoyancy` and `free_surface`. On the other hand, it turns out that it's sometimes convenient for these to be different for testing and experimentation, which may impose additional requirements on `CLIMAParameters` that were not part of the original design. One possible solution might be to build a global `CLIMAParameters` instance in `Oceananigans` that's referenced in model constructors for default parameter values (but we can still let users change parameters when instantiating various model components if they want). A possible goal of CLIMAParameters is to _restrict_ the user interface so that users ""can't mess up""; eg users can't accidentally set `gravitational_acceleration` in `free_surface` and erroneously expect that this also changes `gravitational_acceleration` for buoyancy. Food for thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-791482111
https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-791482111:375,Testability,test,testing,375,"As far as I can tell the main purpose of `CLIMAParameters` is to provide a central / global place to specify common parameters found in different model components. For example, `HydrostaticFreeSurfaceModel` has a `gravitational_acceleration` for both `buoyancy` and `free_surface`. On the other hand, it turns out that it's sometimes convenient for these to be different for testing and experimentation, which may impose additional requirements on `CLIMAParameters` that were not part of the original design. One possible solution might be to build a global `CLIMAParameters` instance in `Oceananigans` that's referenced in model constructors for default parameter values (but we can still let users change parameters when instantiating various model components if they want). A possible goal of CLIMAParameters is to _restrict_ the user interface so that users ""can't mess up""; eg users can't accidentally set `gravitational_acceleration` in `free_surface` and erroneously expect that this also changes `gravitational_acceleration` for buoyancy. Food for thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-791482111
https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-1479852422:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-1479852422
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791560413:11,Testability,test,testing,11,"Thanks for testing out the `VerticallyStretchedRectilinearGrid`!. > 1. The `OutputWriter` is complaining that there is no field `zC`. Right yeah `RegularRectilinearGrid` called it `grid.zC` but `VerticallyStretchedRectilinearGrid` calls it `grid.zᵃᵃᶠ` to be more consistent with the curvilinear grids being added, but the output writers might not know this yet. We should add some output writer tests for the different grids now. I think this might be an issue with `RegularLatitudeLongitudeGrid` as well. > 2. It didn't work with the `FT=Float64` argument. Ah how did you do call the constructor? Julia uses a `semicolon` to separate regular arguments from keyword arguments (https://docs.julialang.org/en/v1/manual/functions/#Keyword-Arguments). So maybe you meant to call. ```julia; grid = VerticallyStretchedRectilinearGrid(Float64, ...); ```. instead of. ```julia; grid = VerticallyStretchedRectilinearGrid(FT=Float64, ...); ```. ?. I guess it could be a bit confusing since `FT` is only what the function calls it but seems to be standard to include it in the docstring to give some idea of what the argument is. Well, the real solution would be a better docstring with examples. > 3. It asks me to use: `halo = (3, 3, 3)` and not `halo = (1, 1, 1)` . Yes. If you use higher-order advection schemes you might need larger halos. `RegularRectilinearGrid` automatically increased the halo size as needed but `VerticallyStretchedRectilinearGrid` doesn't do this yet. Should be possible to do it automatically though. > 4. For testing purposes, I tried using a linear grid with `zF = collect(-160:2.5:0)`. I ran for 1 short timestep and it produces NaN's in the `u` field. However, using the same linear grid with `RegularRectilinearGrid(size=(Nx, Ny, Nz), extent=(Δx*Nx, Δy*Ny, Δz*Nz), topology = (Periodic, Bounded, Bounded))` works fine. Hmmm, how small was the time step? There's a division by Δt in the pressure solve so that could blow things up but usually only if `Δt = 0` I think. Also, does",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791560413
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791560413:395,Testability,test,tests,395,"Thanks for testing out the `VerticallyStretchedRectilinearGrid`!. > 1. The `OutputWriter` is complaining that there is no field `zC`. Right yeah `RegularRectilinearGrid` called it `grid.zC` but `VerticallyStretchedRectilinearGrid` calls it `grid.zᵃᵃᶠ` to be more consistent with the curvilinear grids being added, but the output writers might not know this yet. We should add some output writer tests for the different grids now. I think this might be an issue with `RegularLatitudeLongitudeGrid` as well. > 2. It didn't work with the `FT=Float64` argument. Ah how did you do call the constructor? Julia uses a `semicolon` to separate regular arguments from keyword arguments (https://docs.julialang.org/en/v1/manual/functions/#Keyword-Arguments). So maybe you meant to call. ```julia; grid = VerticallyStretchedRectilinearGrid(Float64, ...); ```. instead of. ```julia; grid = VerticallyStretchedRectilinearGrid(FT=Float64, ...); ```. ?. I guess it could be a bit confusing since `FT` is only what the function calls it but seems to be standard to include it in the docstring to give some idea of what the argument is. Well, the real solution would be a better docstring with examples. > 3. It asks me to use: `halo = (3, 3, 3)` and not `halo = (1, 1, 1)` . Yes. If you use higher-order advection schemes you might need larger halos. `RegularRectilinearGrid` automatically increased the halo size as needed but `VerticallyStretchedRectilinearGrid` doesn't do this yet. Should be possible to do it automatically though. > 4. For testing purposes, I tried using a linear grid with `zF = collect(-160:2.5:0)`. I ran for 1 short timestep and it produces NaN's in the `u` field. However, using the same linear grid with `RegularRectilinearGrid(size=(Nx, Ny, Nz), extent=(Δx*Nx, Δy*Ny, Δz*Nz), topology = (Periodic, Bounded, Bounded))` works fine. Hmmm, how small was the time step? There's a division by Δt in the pressure solve so that could blow things up but usually only if `Δt = 0` I think. Also, does",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791560413
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791560413:1528,Testability,test,testing,1528,"zC` but `VerticallyStretchedRectilinearGrid` calls it `grid.zᵃᵃᶠ` to be more consistent with the curvilinear grids being added, but the output writers might not know this yet. We should add some output writer tests for the different grids now. I think this might be an issue with `RegularLatitudeLongitudeGrid` as well. > 2. It didn't work with the `FT=Float64` argument. Ah how did you do call the constructor? Julia uses a `semicolon` to separate regular arguments from keyword arguments (https://docs.julialang.org/en/v1/manual/functions/#Keyword-Arguments). So maybe you meant to call. ```julia; grid = VerticallyStretchedRectilinearGrid(Float64, ...); ```. instead of. ```julia; grid = VerticallyStretchedRectilinearGrid(FT=Float64, ...); ```. ?. I guess it could be a bit confusing since `FT` is only what the function calls it but seems to be standard to include it in the docstring to give some idea of what the argument is. Well, the real solution would be a better docstring with examples. > 3. It asks me to use: `halo = (3, 3, 3)` and not `halo = (1, 1, 1)` . Yes. If you use higher-order advection schemes you might need larger halos. `RegularRectilinearGrid` automatically increased the halo size as needed but `VerticallyStretchedRectilinearGrid` doesn't do this yet. Should be possible to do it automatically though. > 4. For testing purposes, I tried using a linear grid with `zF = collect(-160:2.5:0)`. I ran for 1 short timestep and it produces NaN's in the `u` field. However, using the same linear grid with `RegularRectilinearGrid(size=(Nx, Ny, Nz), extent=(Δx*Nx, Δy*Ny, Δz*Nz), topology = (Periodic, Bounded, Bounded))` works fine. Hmmm, how small was the time step? There's a division by Δt in the pressure solve so that could blow things up but usually only if `Δt = 0` I think. Also, does it blow up with `topology = (Periodic, Periodic, Bounded)`?. All topologies should be fine but I tested it more with `(Periodic, Periodic, Bounded)` so maybe there's a lingering issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791560413
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791560413:2099,Testability,test,tested,2099,"zC` but `VerticallyStretchedRectilinearGrid` calls it `grid.zᵃᵃᶠ` to be more consistent with the curvilinear grids being added, but the output writers might not know this yet. We should add some output writer tests for the different grids now. I think this might be an issue with `RegularLatitudeLongitudeGrid` as well. > 2. It didn't work with the `FT=Float64` argument. Ah how did you do call the constructor? Julia uses a `semicolon` to separate regular arguments from keyword arguments (https://docs.julialang.org/en/v1/manual/functions/#Keyword-Arguments). So maybe you meant to call. ```julia; grid = VerticallyStretchedRectilinearGrid(Float64, ...); ```. instead of. ```julia; grid = VerticallyStretchedRectilinearGrid(FT=Float64, ...); ```. ?. I guess it could be a bit confusing since `FT` is only what the function calls it but seems to be standard to include it in the docstring to give some idea of what the argument is. Well, the real solution would be a better docstring with examples. > 3. It asks me to use: `halo = (3, 3, 3)` and not `halo = (1, 1, 1)` . Yes. If you use higher-order advection schemes you might need larger halos. `RegularRectilinearGrid` automatically increased the halo size as needed but `VerticallyStretchedRectilinearGrid` doesn't do this yet. Should be possible to do it automatically though. > 4. For testing purposes, I tried using a linear grid with `zF = collect(-160:2.5:0)`. I ran for 1 short timestep and it produces NaN's in the `u` field. However, using the same linear grid with `RegularRectilinearGrid(size=(Nx, Ny, Nz), extent=(Δx*Nx, Δy*Ny, Δz*Nz), topology = (Periodic, Bounded, Bounded))` works fine. Hmmm, how small was the time step? There's a division by Δt in the pressure solve so that could blow things up but usually only if `Δt = 0` I think. Also, does it blow up with `topology = (Periodic, Periodic, Bounded)`?. All topologies should be fine but I tested it more with `(Periodic, Periodic, Bounded)` so maybe there's a lingering issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791560413
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388:229,Modifiability,refactor,refactor,229,"> Right yeah RegularRectilinearGrid called it grid.zC but VerticallyStretchedRectilinearGrid calls it grid.zᵃᵃᶠ to be more consistent with the curvilinear grids being added, but the output writers might not know this yet. Can we refactor the tests to use `all_z_nodes`? This could avoid issues with property names.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388:281,Safety,avoid,avoid,281,"> Right yeah RegularRectilinearGrid called it grid.zC but VerticallyStretchedRectilinearGrid calls it grid.zᵃᵃᶠ to be more consistent with the curvilinear grids being added, but the output writers might not know this yet. Can we refactor the tests to use `all_z_nodes`? This could avoid issues with property names.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388:242,Testability,test,tests,242,"> Right yeah RegularRectilinearGrid called it grid.zC but VerticallyStretchedRectilinearGrid calls it grid.zᵃᵃᶠ to be more consistent with the curvilinear grids being added, but the output writers might not know this yet. Can we refactor the tests to use `all_z_nodes`? This could avoid issues with property names.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007:986,Availability,error,error,986,"Thanks for the help!. `Julia uses a semicolon to separate regular arguments from keyword arguments`. Ah yeah, I thought `Float64` should be passed as a keyword argument. The following works now:. ```; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),; size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF,; halo = (3, 3, 3),; topology = (Periodic, Periodic, Bounded)); ```. `Hmmm, how small was the time step? `. I tried a few different values ranging from 1 sec to 60 sec. . I found that the `NaN` issue has to do with the `AnisotropicBiharmonicDiffusivity`. The following works:. ```; closure = AnisotropicDiffusivity(νh=kappaH_tmp, κh=kappaH_tmp, κz = kappaV, νz = kappaV); ```. but not this: . ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ```. Also, `topology = (Periodic, Periodic, Bounded)` runs fine now, but `topology = (Periodic, Bounded, Bounded)` gives the following error:. ```; Loaded all modules; Starting the simulation...; ┌ Warning: You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow.; └ @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/gCqmh/src/Simulations/simulation.jl:68; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::CuArray{Float64,3}, ::CuArray{Float64,3}, ::CuArray{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}) ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007:1289,Availability,ERROR,ERROR,1289,"ded)); ```. `Hmmm, how small was the time step? `. I tried a few different values ranging from 1 sec to 60 sec. . I found that the `NaN` issue has to do with the `AnisotropicBiharmonicDiffusivity`. The following works:. ```; closure = AnisotropicDiffusivity(νh=kappaH_tmp, κh=kappaH_tmp, κz = kappaV, νz = kappaV); ```. but not this: . ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ```. Also, `topology = (Periodic, Periodic, Bounded)` runs fine now, but `topology = (Periodic, Bounded, Bounded)` gives the following error:. ```; Loaded all modules; Starting the simulation...; ┌ Warning: You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow.; └ @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/gCqmh/src/Simulations/simulation.jl:68; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::CuArray{Float64,3}, ::CuArray{Float64,3}, ::CuArray{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}) at /home/guptam/.julia/packages/Oceananigans/gCqmh/src/Utils/cell_advection_timescale.jl:9; [3] cell_advection_timescale(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007:999,Performance,Load,Loaded,999,"p!. `Julia uses a semicolon to separate regular arguments from keyword arguments`. Ah yeah, I thought `Float64` should be passed as a keyword argument. The following works now:. ```; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),; size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF,; halo = (3, 3, 3),; topology = (Periodic, Periodic, Bounded)); ```. `Hmmm, how small was the time step? `. I tried a few different values ranging from 1 sec to 60 sec. . I found that the `NaN` issue has to do with the `AnisotropicBiharmonicDiffusivity`. The following works:. ```; closure = AnisotropicDiffusivity(νh=kappaH_tmp, κh=kappaH_tmp, κz = kappaV, νz = kappaV); ```. but not this: . ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ```. Also, `topology = (Periodic, Periodic, Bounded)` runs fine now, but `topology = (Periodic, Bounded, Bounded)` gives the following error:. ```; Loaded all modules; Starting the simulation...; ┌ Warning: You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow.; └ @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/gCqmh/src/Simulations/simulation.jl:68; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::CuArray{Float64,3}, ::CuArray{Float64,3}, ::CuArray{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}) at /home/guptam/.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007:1296,Performance,Load,LoadError,1296,"ded)); ```. `Hmmm, how small was the time step? `. I tried a few different values ranging from 1 sec to 60 sec. . I found that the `NaN` issue has to do with the `AnisotropicBiharmonicDiffusivity`. The following works:. ```; closure = AnisotropicDiffusivity(νh=kappaH_tmp, κh=kappaH_tmp, κz = kappaV, νz = kappaV); ```. but not this: . ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ```. Also, `topology = (Periodic, Periodic, Bounded)` runs fine now, but `topology = (Periodic, Bounded, Bounded)` gives the following error:. ```; Loaded all modules; Starting the simulation...; ┌ Warning: You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow.; └ @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/gCqmh/src/Simulations/simulation.jl:68; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::CuArray{Float64,3}, ::CuArray{Float64,3}, ::CuArray{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}) at /home/guptam/.julia/packages/Oceananigans/gCqmh/src/Utils/cell_advection_timescale.jl:9; [3] cell_advection_timescale(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-794035595:150,Availability,error,error,150,"Ah it's possible that `AnisotropicBiharmonicDiffusivity` isn't doing the right thing on a vertically stretched grid... Certainly it's not tested. The error you're getting with `topology = (Periodic, Bounded, Bounded)` seem related to `cell_advection_timescale` not doing the right thing on a vertically stretched grid as well... It's used to compute CFL by the `TimeStepWizard`. We should fix these soon but for now you could try running with a constant time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-794035595
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-794035595:138,Testability,test,tested,138,"Ah it's possible that `AnisotropicBiharmonicDiffusivity` isn't doing the right thing on a vertically stretched grid... Certainly it's not tested. The error you're getting with `topology = (Periodic, Bounded, Bounded)` seem related to `cell_advection_timescale` not doing the right thing on a vertically stretched grid as well... It's used to compute CFL by the `TimeStepWizard`. We should fix these soon but for now you could try running with a constant time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-794035595
https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-794434733:6,Availability,error,error,6,"> The error you're getting with `topology = (Periodic, Bounded, Bounded)` seem related to cell_advection_timescale not doing the right thing on a vertically stretched grid as well... It's used to compute CFL by the `TimeStepWizard`. Ah yes, you're right. It runs ok with constant time step. So it's not an issue with topology. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-794434733
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347:155,Availability,error,error,155,"@ali-ramadhan , I tried running the example using the following `julia --project -p 4 mpi_shallow_water_turbulence.jl; `, and it seemed to fail because of error, see below. Any idea what I might have done wrong?. ```; ERROR: LoadError: ProcessExitedException(3). ...and 2 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347:218,Availability,ERROR,ERROR,218,"@ali-ramadhan , I tried running the example using the following `julia --project -p 4 mpi_shallow_water_turbulence.jl; `, and it seemed to fail because of error, see below. Any idea what I might have done wrong?. ```; ERROR: LoadError: ProcessExitedException(3). ...and 2 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347:225,Performance,Load,LoadError,225,"@ali-ramadhan , I tried running the example using the following `julia --project -p 4 mpi_shallow_water_turbulence.jl; `, and it seemed to fail because of error, see below. Any idea what I might have done wrong?. ```; ERROR: LoadError: ProcessExitedException(3). ...and 2 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347:679,Performance,load,loading,679,"@ali-ramadhan , I tried running the example using the following `julia --project -p 4 mpi_shallow_water_turbulence.jl; `, and it seemed to fail because of error, see below. Any idea what I might have done wrong?. ```; ERROR: LoadError: ProcessExitedException(3). ...and 2 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347:732,Performance,load,loading,732,"@ali-ramadhan , I tried running the example using the following `julia --project -p 4 mpi_shallow_water_turbulence.jl; `, and it seemed to fail because of error, see below. Any idea what I might have done wrong?. ```; ERROR: LoadError: ProcessExitedException(3). ...and 2 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794029661:39,Availability,error,error,39,@francispoulin Ah I have not seen that error before but will try to reproduce. > Yes - but there isn't anything to review much in #1430 otherwise?. Ah this PR is still a draft and might change a lot so not ready for review just yet. My plan was to merge #590 (which is marked ready for review) then rebase this branch/PR on master so @francispoulin and I could work on it more.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794029661
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378:40,Availability,error,error,40,"I tried it again and received a similar error, copied below. What I find strange is that it mentions worker 5 but I only asked for 4. . @ali-ramadhan , what did you do to run this file exactly?. ```; ERROR: LoadError: Worker 5 terminated.ProcessExitedException(2). ...and 3 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378:200,Availability,ERROR,ERROR,200,"I tried it again and received a similar error, copied below. What I find strange is that it mentions worker 5 but I only asked for 4. . @ali-ramadhan , what did you do to run this file exactly?. ```; ERROR: LoadError: Worker 5 terminated.ProcessExitedException(2). ...and 3 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378:207,Performance,Load,LoadError,207,"I tried it again and received a similar error, copied below. What I find strange is that it mentions worker 5 but I only asked for 4. . @ali-ramadhan , what did you do to run this file exactly?. ```; ERROR: LoadError: Worker 5 terminated.ProcessExitedException(2). ...and 3 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378:681,Performance,load,loading,681,"I tried it again and received a similar error, copied below. What I find strange is that it mentions worker 5 but I only asked for 4. . @ali-ramadhan , what did you do to run this file exactly?. ```; ERROR: LoadError: Worker 5 terminated.ProcessExitedException(2). ...and 3 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378:734,Performance,load,loading,734,"I tried it again and received a similar error, copied below. What I find strange is that it mentions worker 5 but I only asked for 4. . @ali-ramadhan , what did you do to run this file exactly?. ```; ERROR: LoadError: Worker 5 terminated.ProcessExitedException(2). ...and 3 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794318967:52,Usability,learn,learned,52,I was not calling the script correctl. I have since learned I should be doing the following . ```; mpiexec -n 4 julia --project mpi_shallow_water_turbulence.jl; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794318967
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794345782:70,Testability,test,testing,70,"@francispoulin That's awesome that it works now! I guess we can start testing different domain decompositions, topologies, scaling, etc. (or anything we want) with the distributed shallow water model now!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794345782
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-797794664:1678,Energy Efficiency,efficient,efficients,1678,"I am sharing the first set of results that look at the strong scaling of the distributed `ShallowWaterModel`. I should say that I'm doing this on my desktop while zoom is running, so it would certainly be redone elsewhere. But the results are copied below. ```; Shallow water model strong scaling benchmark; ┌──────────────┬───────┬─────────┬─────────┬─────────┬─────────┬────────────┬────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │; ├──────────────┼───────┼─────────┼─────────┼─────────┼─────────┼────────────┼────────┤; │ (4096, 4096) │ 1 │ 8.738 s │ 8.738 s │ 8.738 s │ 8.738 s │ 392.52 KiB │ 2763 │; │ (4096, 4096) │ 2 │ 7.677 s │ 7.677 s │ 7.677 s │ 7.677 s │ 372.27 KiB │ 3195 │; │ (4096, 4096) │ 4 │ 5.063 s │ 5.063 s │ 5.063 s │ 5.063 s │ 372.41 KiB │ 3204 │; │ (4096, 4096) │ 8 │ 2.369 s │ 2.460 s │ 2.439 s │ 2.488 s │ 372.41 KiB │ 3204 │; │ (4096, 4096) │ 16 │ 1.356 s │ 1.381 s │ 1.389 s │ 1.438 s │ 371.72 KiB │ 3160 │; └──────────────┴───────┴─────────┴─────────┴─────────┴─────────┴────────────┴────────┘; [2021/03/12 17:32:56.309] INFO Writing Shallow_water_model_strong_scaling_benchmark.html...; Shallow water model strong scaling speedup; ┌──────────────┬───────┬─────────┬──────────┬─────────┐; │ size │ ranks │ speedup │ memory │ allocs │; ├──────────────┼───────┼─────────┼──────────┼─────────┤; │ (4096, 4096) │ 1 │ 1.0 │ 1.0 │ 1.0 │; │ (4096, 4096) │ 2 │ 1.13814 │ 0.94841 │ 1.15635 │; │ (4096, 4096) │ 4 │ 1.72589 │ 0.948768 │ 1.15961 │; │ (4096, 4096) │ 8 │ 3.55262 │ 0.948768 │ 1.15961 │; │ (4096, 4096) │ 16 │ 6.32625 │ 0.947016 │ 1.14368 │; └──────────────┴───────┴─────────┴──────────┴─────────┘. ```. Using the means the efficients would be. ```; np effiiciency; == ========; 2 0.56; 4 0.43; 8 0.45; 16 0.39. ```. I suspect on a different day, or different computer, we will get better numbers. We will see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-797794664
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-797794664:297,Testability,benchmark,benchmark,297,"I am sharing the first set of results that look at the strong scaling of the distributed `ShallowWaterModel`. I should say that I'm doing this on my desktop while zoom is running, so it would certainly be redone elsewhere. But the results are copied below. ```; Shallow water model strong scaling benchmark; ┌──────────────┬───────┬─────────┬─────────┬─────────┬─────────┬────────────┬────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │; ├──────────────┼───────┼─────────┼─────────┼─────────┼─────────┼────────────┼────────┤; │ (4096, 4096) │ 1 │ 8.738 s │ 8.738 s │ 8.738 s │ 8.738 s │ 392.52 KiB │ 2763 │; │ (4096, 4096) │ 2 │ 7.677 s │ 7.677 s │ 7.677 s │ 7.677 s │ 372.27 KiB │ 3195 │; │ (4096, 4096) │ 4 │ 5.063 s │ 5.063 s │ 5.063 s │ 5.063 s │ 372.41 KiB │ 3204 │; │ (4096, 4096) │ 8 │ 2.369 s │ 2.460 s │ 2.439 s │ 2.488 s │ 372.41 KiB │ 3204 │; │ (4096, 4096) │ 16 │ 1.356 s │ 1.381 s │ 1.389 s │ 1.438 s │ 371.72 KiB │ 3160 │; └──────────────┴───────┴─────────┴─────────┴─────────┴─────────┴────────────┴────────┘; [2021/03/12 17:32:56.309] INFO Writing Shallow_water_model_strong_scaling_benchmark.html...; Shallow water model strong scaling speedup; ┌──────────────┬───────┬─────────┬──────────┬─────────┐; │ size │ ranks │ speedup │ memory │ allocs │; ├──────────────┼───────┼─────────┼──────────┼─────────┤; │ (4096, 4096) │ 1 │ 1.0 │ 1.0 │ 1.0 │; │ (4096, 4096) │ 2 │ 1.13814 │ 0.94841 │ 1.15635 │; │ (4096, 4096) │ 4 │ 1.72589 │ 0.948768 │ 1.15961 │; │ (4096, 4096) │ 8 │ 3.55262 │ 0.948768 │ 1.15961 │; │ (4096, 4096) │ 16 │ 6.32625 │ 0.947016 │ 1.14368 │; └──────────────┴───────┴─────────┴──────────┴─────────┘. ```. Using the means the efficients would be. ```; np effiiciency; == ========; 2 0.56; 4 0.43; 8 0.45; 16 0.39. ```. I suspect on a different day, or different computer, we will get better numbers. We will see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-797794664
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799473915:551,Testability,benchmark,benchmark,551,"These are the first results from a weak scaling. I have not modified how the speedup is changed but looking at the mean times should be informative. As we add the number of cores, each core has the same number of degrees of freedom. Ideally, the total time should not change. There is a big difference going from 1 to 2, but after that the difference does not seem nearly as bad. @ali-ramadhan and I are talking about how to profile this but if anyone has any thoughts or suggestions, we are happy to hear them!. ```; Shallow water model weak scaling benchmark; ┌──────────────┬───────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │; ├──────────────┼───────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ (4096, 256) │ 1 │ 523.845 ms │ 529.054 ms │ 528.660 ms │ 532.950 ms │ 391.83 KiB │ 2719 │; │ (4096, 512) │ 2 │ 1.014 s │ 1.015 s │ 1.017 s │ 1.023 s │ 371.58 KiB │ 3151 │; │ (4096, 1024) │ 4 │ 1.210 s │ 1.216 s │ 1.219 s │ 1.238 s │ 371.72 KiB │ 3160 │; │ (4096, 2048) │ 8 │ 1.109 s │ 1.124 s │ 1.180 s │ 1.296 s │ 371.72 KiB │ 3160 │; │ (4096, 4096) │ 16 │ 1.259 s │ 1.307 s │ 1.302 s │ 1.337 s │ 371.72 KiB │ 3160 │; └──────────────┴───────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; [2021/03/15 10:34:57.910] INFO Writing Shallow_water_model_weak_scaling_benchmark.html...; Shallow water model weak scaling speedup; ┌──────────────┬───────┬──────────┬──────────┬─────────┐; │ size │ ranks │ speedup │ memory │ allocs │; ├──────────────┼───────┼──────────┼──────────┼─────────┤; │ (4096, 256) │ 1 │ 1.0 │ 1.0 │ 1.0 │; │ (4096, 512) │ 2 │ 0.521109 │ 0.948319 │ 1.15888 │; │ (4096, 1024) │ 4 │ 0.434976 │ 0.948678 │ 1.16219 │; │ (4096, 2048) │ 8 │ 0.47074 │ 0.948678 │ 1.16219 │; │ (4096, 4096) │ 16 │ 0.40486 │ 0.948678 │ 1.16219 │; └──────────────┴───────┴──────────┴──────────┴─────────┘; [2021/03/15 10:34:58.558] INFO Writing Shallow_w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799473915
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799554920:151,Testability,test,tests,151,@francispoulin Should we consider merging this soon since it seems we have a working distributed shallow water model? Might just be missing some basic tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799554920
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799556216:36,Availability,error,error,36,Ah we should probably add a warning/error in the `MultiGPU` constructor if `MPI.has_cuda() == false` in case a user tries to use `MultiGPU` without CUDA-aware MPI?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799556216
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799564558:172,Testability,test,tests,172,"Yes, merging soon is a great idea, before `main` changes too much. . Do you think we need to get `MultiGPU` working or try and merge what we have with `MultiCPU` plus some tests? I'm tempted to merge sooner rather than later since already this is a big addition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799564558
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799567039:69,Testability,test,tests,69,"Since we have started to build a `MultiGPU` architecture, I did some tests on my desktop to compure `ShallowWaterModel` under `CPUs` and `GPUs`, as a build up to `MultiCPUs` and `MultiGPUs`. The results are below and shows that at the highest resolution, GPUs are more than 200 times faster (if I'm reading this correctly). . ```; Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float64 │ 32 │ 1.100 ms │ 1.174 ms │ 1.179 ms │ 1.330 ms │ 350.78 KiB │ 2315 │; │ CPU │ Float64 │ 64 │ 2.125 ms │ 2.308 ms │ 2.317 ms │ 2.507 ms │ 350.78 KiB │ 2315 │; │ CPU │ Float64 │ 128 │ 5.627 ms │ 5.796 ms │ 5.819 ms │ 6.274 ms │ 350.78 KiB │ 2315 │; │ CPU │ Float64 │ 256 │ 19.994 ms │ 20.857 ms │ 21.210 ms │ 24.729 ms │ 350.78 KiB │ 2315 │; │ CPU │ Float64 │ 512 │ 108.709 ms │ 109.811 ms │ 111.243 ms │ 116.733 ms │ 352.16 KiB │ 2403 │; │ CPU │ Float64 │ 1024 │ 461.325 ms │ 462.072 ms │ 462.734 ms │ 466.383 ms │ 352.16 KiB │ 2403 │; │ GPU │ Float64 │ 32 │ 1.740 ms │ 1.774 ms │ 1.868 ms │ 2.691 ms │ 722.42 KiB │ 7010 │; │ GPU │ Float64 │ 64 │ 1.814 ms │ 1.934 ms │ 2.086 ms │ 3.466 ms │ 739.64 KiB │ 6888 │; │ GPU │ Float64 │ 128 │ 1.920 ms │ 1.976 ms │ 2.187 ms │ 3.866 ms │ 774.52 KiB │ 6888 │; │ GPU │ Float64 │ 256 │ 2.095 ms │ 2.208 ms │ 2.237 ms │ 2.596 ms │ 849.89 KiB │ 6888 │; │ GPU │ Float64 │ 512 │ 1.988 ms │ 2.039 ms │ 2.150 ms │ 3.175 ms │ 995.27 KiB │ 6976 │; │ GPU │ Float64 │ 1024 │ 1.965 ms │ 2.080 ms │ 2.188 ms │ 3.242 ms │ 1.25 MiB │ 6976 │; └───────────────┴─────────────┴──────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; [2021/03/15 12:35:06.674] INFO Writing Shallow_water_model_benchmarks.html...; Shallow water model CPU -> GPU speedup; ┌────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799567039
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799567039:351,Testability,benchmark,benchmarks,351,"Since we have started to build a `MultiGPU` architecture, I did some tests on my desktop to compure `ShallowWaterModel` under `CPUs` and `GPUs`, as a build up to `MultiCPUs` and `MultiGPUs`. The results are below and shows that at the highest resolution, GPUs are more than 200 times faster (if I'm reading this correctly). . ```; Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float64 │ 32 │ 1.100 ms │ 1.174 ms │ 1.179 ms │ 1.330 ms │ 350.78 KiB │ 2315 │; │ CPU │ Float64 │ 64 │ 2.125 ms │ 2.308 ms │ 2.317 ms │ 2.507 ms │ 350.78 KiB │ 2315 │; │ CPU │ Float64 │ 128 │ 5.627 ms │ 5.796 ms │ 5.819 ms │ 6.274 ms │ 350.78 KiB │ 2315 │; │ CPU │ Float64 │ 256 │ 19.994 ms │ 20.857 ms │ 21.210 ms │ 24.729 ms │ 350.78 KiB │ 2315 │; │ CPU │ Float64 │ 512 │ 108.709 ms │ 109.811 ms │ 111.243 ms │ 116.733 ms │ 352.16 KiB │ 2403 │; │ CPU │ Float64 │ 1024 │ 461.325 ms │ 462.072 ms │ 462.734 ms │ 466.383 ms │ 352.16 KiB │ 2403 │; │ GPU │ Float64 │ 32 │ 1.740 ms │ 1.774 ms │ 1.868 ms │ 2.691 ms │ 722.42 KiB │ 7010 │; │ GPU │ Float64 │ 64 │ 1.814 ms │ 1.934 ms │ 2.086 ms │ 3.466 ms │ 739.64 KiB │ 6888 │; │ GPU │ Float64 │ 128 │ 1.920 ms │ 1.976 ms │ 2.187 ms │ 3.866 ms │ 774.52 KiB │ 6888 │; │ GPU │ Float64 │ 256 │ 2.095 ms │ 2.208 ms │ 2.237 ms │ 2.596 ms │ 849.89 KiB │ 6888 │; │ GPU │ Float64 │ 512 │ 1.988 ms │ 2.039 ms │ 2.150 ms │ 3.175 ms │ 995.27 KiB │ 6976 │; │ GPU │ Float64 │ 1024 │ 1.965 ms │ 2.080 ms │ 2.188 ms │ 3.242 ms │ 1.25 MiB │ 6976 │; └───────────────┴─────────────┴──────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; [2021/03/15 12:35:06.674] INFO Writing Shallow_water_model_benchmarks.html...; Shallow water model CPU -> GPU speedup; ┌────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799567039
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799598593:370,Performance,bottleneck,bottlenecks,370,Indeed those are some great speedups! Doesn't even look like the GPU is saturated yet. > Do you think we need to get `MultiGPU` working or try and merge what we have with `MultiCPU` plus some tests? I'm tempted to merge sooner rather than later since already this is a big addition. It does seem to work :P But maybe it just needs some profiling to understand where the bottlenecks are. I guess we need to get some CUDA-aware MPI on Buildkite to test `MultiGPU` so maybe we don't have to explicitly test it just yet in this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799598593
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799598593:192,Testability,test,tests,192,Indeed those are some great speedups! Doesn't even look like the GPU is saturated yet. > Do you think we need to get `MultiGPU` working or try and merge what we have with `MultiCPU` plus some tests? I'm tempted to merge sooner rather than later since already this is a big addition. It does seem to work :P But maybe it just needs some profiling to understand where the bottlenecks are. I guess we need to get some CUDA-aware MPI on Buildkite to test `MultiGPU` so maybe we don't have to explicitly test it just yet in this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799598593
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799598593:446,Testability,test,test,446,Indeed those are some great speedups! Doesn't even look like the GPU is saturated yet. > Do you think we need to get `MultiGPU` working or try and merge what we have with `MultiCPU` plus some tests? I'm tempted to merge sooner rather than later since already this is a big addition. It does seem to work :P But maybe it just needs some profiling to understand where the bottlenecks are. I guess we need to get some CUDA-aware MPI on Buildkite to test `MultiGPU` so maybe we don't have to explicitly test it just yet in this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799598593
https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799598593:499,Testability,test,test,499,Indeed those are some great speedups! Doesn't even look like the GPU is saturated yet. > Do you think we need to get `MultiGPU` working or try and merge what we have with `MultiCPU` plus some tests? I'm tempted to merge sooner rather than later since already this is a big addition. It does seem to work :P But maybe it just needs some profiling to understand where the bottlenecks are. I guess we need to get some CUDA-aware MPI on Buildkite to test `MultiGPU` so maybe we don't have to explicitly test it just yet in this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799598593
https://github.com/CliMA/Oceananigans.jl/issues/1432#issuecomment-791953056:1216,Testability,test,testing,1216,"NaNs often occur either because the time step is too small, or because the problem being posed is too extreme or not physical (such that a reasonable and stable time step cannot be found). One issue is that the use of `ValueBoundaryCondition` is incorrect here:. ```julia; w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)); ```. You are trying to specify an impenetrable boundary condition on the vertical velocity, which requires `NormalFlowBoundaryCondition`:. ```julia; w_bcs = WVelocityBoundaryConditions(grid, top = NormalFlowBoundaryCondition(0.0), bottom=NormalFlowBoundaryCondition(0.0)); ```. this is also the default for a grid with `topology(grid) = (Periodic, Periodic, Bounded)`, so there's no need to specify it explicitly. In other words, try changing . ```julia; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)); ```. to . ```julia; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); ```. in your constructor for `IncompressibleModel`. A good approach for developing a complex simulation is to start with something simple (or something that worked previously) and modify the script incrementally (slowly!), re-running and re-testing the script after each significant change. For this is useful to run either a two-dimensional version of the problem or a very low resolution simulation. I also suggest adding some lines at the bottom of your script to plot the solution so you can visually inspect it after a run. Your setup looks like a laboratory-scale simulation of convection. I think starting with uniform cooling (rather than spatially varying), omitting the effect of salinity, and using an `IsotropicDiffusivity` in two-dimensions (rather than starting out in three dimensions) might be a good path forward for working and building up your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1432#issuecomment-791953056
https://github.com/CliMA/Oceananigans.jl/issues/1432#issuecomment-791953056:1106,Usability,simpl,simple,1106,"NaNs often occur either because the time step is too small, or because the problem being posed is too extreme or not physical (such that a reasonable and stable time step cannot be found). One issue is that the use of `ValueBoundaryCondition` is incorrect here:. ```julia; w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)); ```. You are trying to specify an impenetrable boundary condition on the vertical velocity, which requires `NormalFlowBoundaryCondition`:. ```julia; w_bcs = WVelocityBoundaryConditions(grid, top = NormalFlowBoundaryCondition(0.0), bottom=NormalFlowBoundaryCondition(0.0)); ```. this is also the default for a grid with `topology(grid) = (Periodic, Periodic, Bounded)`, so there's no need to specify it explicitly. In other words, try changing . ```julia; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)); ```. to . ```julia; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); ```. in your constructor for `IncompressibleModel`. A good approach for developing a complex simulation is to start with something simple (or something that worked previously) and modify the script incrementally (slowly!), re-running and re-testing the script after each significant change. For this is useful to run either a two-dimensional version of the problem or a very low resolution simulation. I also suggest adding some lines at the bottom of your script to plot the solution so you can visually inspect it after a run. Your setup looks like a laboratory-scale simulation of convection. I think starting with uniform cooling (rather than spatially varying), omitting the effect of salinity, and using an `IsotropicDiffusivity` in two-dimensions (rather than starting out in three dimensions) might be a good path forward for working and building up your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1432#issuecomment-791953056
https://github.com/CliMA/Oceananigans.jl/pull/1433#issuecomment-798604616:1067,Testability,test,test,1067,"> > Do you know how this layer thickness compares to the grid scale?; > ; > At the central latitude of 45 deg, I get `L = (nu / beta)^(1/3) ~ 70 km` (with `nu = 5e3` and `β = 1.62e-11`). This is almost equal to the grid spacing, so I guess we are barely resolving the Munk boundary layer in the 1 degree simulations.; > ; > I'm hoping to get eddies at higher resolutions though, so I guess if / when the solution becomes turbulent, the Munk solution no longer applies. I agree that eventually, maybe the Munk layer might not apply, but it will initially. When the gyre spins up it is going to develop a western boundary current that had a thickness on the order of the Munk solution, and this can certain give rise to vorticies and subsequent turbulence. But I do believe you need to resolve this layer initially otherwise you can't resolve the western boundary current and things will not develop properly. . I would suggest pickin the Munk layer thickness to by, say, 5 times that of the coarsest grid. This may give rise to laminar flow but it should allow you to test convergence with higher resolution. But when you go to higher resolution, you can decrease the Munk layer thickness respecitvely, and this should eventually give rise meandering and vorticies.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1433#issuecomment-798604616
https://github.com/CliMA/Oceananigans.jl/pull/1433#issuecomment-799817584:87,Testability,test,test,87,"If there's no objection, I propose merging this PR now and working on converting it to test `ImplicitFreeSurface` in a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1433#issuecomment-799817584
https://github.com/CliMA/Oceananigans.jl/pull/1435#issuecomment-793202207:39,Availability,error,error,39,@charleskawczynski Ah no just a random error but I reran the Buildkite pipeline out of habit. Feel free to merge!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1435#issuecomment-793202207
https://github.com/CliMA/Oceananigans.jl/pull/1435#issuecomment-793202207:71,Deployability,pipeline,pipeline,71,@charleskawczynski Ah no just a random error but I reran the Buildkite pipeline out of habit. Feel free to merge!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1435#issuecomment-793202207
https://github.com/CliMA/Oceananigans.jl/issues/1437#issuecomment-793437861:45,Availability,down,downside,45,`\varphi` is indeed better than `\phi`. Only downside that it's a bit more cumbersome to type..,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1437#issuecomment-793437861
https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703:2010,Modifiability,evolve,evolve,2010,"e. I guess you're trying to couple an agent-based larvae model to an ocean model?. Oceananigans.jl should have the features you need I think: mainly Lagrangian particle tracking to advect the larvae around and arbitrary forced passive tracers for the odor from the reef?. I've actually been meaning to set up an example of an agent-based model coupled to Oceananigans.jl (simulating interacting ""microbes"" in the ocean). It's not fully complete yet but might give you some ideas of how to use Lagrangian particles as agents: https://github.com/CliMA/Oceananigans.jl/pull/1244. > If that works, I will implement a continuity equation to simulate the odor which comes from the reef and which is supposed to help the larvae to find back to the home reef. What is the continuity equation for the odor? It should be easy to advect the odor around as a passive tracer but just curious what the equation looks like. > Since I have found Oceananigans, which is also a CFD tool, I was wondering what you think the differences are between that and WaterLily.jl? Given my description of the project above, would you tend to use either of them?. I'm not super familiar with WaterLily.jl but it's definitely a very nice package (and a great README)!. I think WaterLily.jl has a more mature immersed boundary implementation if you need to have complex boundaries and is auto-diff friendly if you need to do some optimization/inference. @weymouth might be able to elaborate!. Oceananigans.jl has native support for Lagrangian particle tracking and might have more mature diagnostics (e.g. if you need to compute vorticity or other statistics) and more mature output writers (among other quality of life features). The examples in the docs should give a pretty good of the current set of mature features. E.g. this example shows how to add in a passive tracer for plankton and evolve it according to some (continuity?) equation: https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703
https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703:1547,Performance,optimiz,optimization,1547,"e. I guess you're trying to couple an agent-based larvae model to an ocean model?. Oceananigans.jl should have the features you need I think: mainly Lagrangian particle tracking to advect the larvae around and arbitrary forced passive tracers for the odor from the reef?. I've actually been meaning to set up an example of an agent-based model coupled to Oceananigans.jl (simulating interacting ""microbes"" in the ocean). It's not fully complete yet but might give you some ideas of how to use Lagrangian particles as agents: https://github.com/CliMA/Oceananigans.jl/pull/1244. > If that works, I will implement a continuity equation to simulate the odor which comes from the reef and which is supposed to help the larvae to find back to the home reef. What is the continuity equation for the odor? It should be easy to advect the odor around as a passive tracer but just curious what the equation looks like. > Since I have found Oceananigans, which is also a CFD tool, I was wondering what you think the differences are between that and WaterLily.jl? Given my description of the project above, would you tend to use either of them?. I'm not super familiar with WaterLily.jl but it's definitely a very nice package (and a great README)!. I think WaterLily.jl has a more mature immersed boundary implementation if you need to have complex boundaries and is auto-diff friendly if you need to do some optimization/inference. @weymouth might be able to elaborate!. Oceananigans.jl has native support for Lagrangian particle tracking and might have more mature diagnostics (e.g. if you need to compute vorticity or other statistics) and more mature output writers (among other quality of life features). The examples in the docs should give a pretty good of the current set of mature features. E.g. this example shows how to add in a passive tracer for plankton and evolve it according to some (continuity?) equation: https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703
https://github.com/CliMA/Oceananigans.jl/pull/1441#issuecomment-794125642:15,Testability,test,test,15,"If you want to test that flux boundary conditions work correctly, you can test that budgets are correct like we do for IncompressibleModel in `test_dynamics.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1441#issuecomment-794125642
https://github.com/CliMA/Oceananigans.jl/pull/1441#issuecomment-794125642:74,Testability,test,test,74,"If you want to test that flux boundary conditions work correctly, you can test that budgets are correct like we do for IncompressibleModel in `test_dynamics.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1441#issuecomment-794125642
https://github.com/CliMA/Oceananigans.jl/pull/1441#issuecomment-794278463:91,Testability,test,tests,91,"I will merge this PR but created an issue, #1448 , to modify `test_dynamics.jl` to include tests for `ShallowWaterModel`. Alternatively, we could have `test_shallow_water_dynamics.jl`. The latter does have a nice ring to it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1441#issuecomment-794278463
https://github.com/CliMA/Oceananigans.jl/issues/1446#issuecomment-934522905:76,Integrability,message,message,76,When the `Oceananigans` github page is opened it might present this helpful message:. ![image](https://user-images.githubusercontent.com/15271942/136055771-2191957e-eced-4696-9362-03aac3e10722.png). Copy/pastable commands:. ```; git branch -m master main; git fetch origin; git branch -u origin/main main; git remote set-head origin -a; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1446#issuecomment-934522905
https://github.com/CliMA/Oceananigans.jl/issues/1448#issuecomment-794495504:10,Testability,test,test,10,"Since our test scripts are already too long, I suggest creating a new script `test_shallow_water_dynamics.jl`. We also need this if we want to run the script in the `shallow_water` `TEST_GROUP`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1448#issuecomment-794495504
https://github.com/CliMA/Oceananigans.jl/issues/1448#issuecomment-1479871820:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1448#issuecomment-1479871820
https://github.com/CliMA/Oceananigans.jl/pull/1449#issuecomment-796257534:90,Energy Efficiency,adapt,adapted,90,> Maybe compute_w_from_continuity! is missing a datatuple or something is missing from an adapted struct?. But it's only with the `RegularLatitudeLongitudeGrid` -- a model with `RegularRectilinearGrid` passes. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449#issuecomment-796257534
https://github.com/CliMA/Oceananigans.jl/pull/1449#issuecomment-796257534:90,Modifiability,adapt,adapted,90,> Maybe compute_w_from_continuity! is missing a datatuple or something is missing from an adapted struct?. But it's only with the `RegularLatitudeLongitudeGrid` -- a model with `RegularRectilinearGrid` passes. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449#issuecomment-796257534
https://github.com/CliMA/Oceananigans.jl/issues/1450#issuecomment-1479867412:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open. @simone-silvestri feel free to add info if you have it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1450#issuecomment-1479867412
https://github.com/CliMA/Oceananigans.jl/issues/1451#issuecomment-795869987:146,Testability,test,tests,146,Thanks @ali-ramadhan for doing this. I wonder if we could modify this script and run it on `ShallowWaterModel` to start doing some strong scaling tests for that model?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451#issuecomment-795869987
https://github.com/CliMA/Oceananigans.jl/issues/1452#issuecomment-796338616:23,Availability,down,down,23,I just wanted to write down the details of the idea while it was in my head!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1452#issuecomment-796338616
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057:143,Integrability,rout,route,143,"Do we think maybe just extending the existing pattern of input validation functions (`validate_coriolis`, `validate_advection`, etc) is a good route?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057:23,Modifiability,extend,extending,23,"Do we think maybe just extending the existing pattern of input validation functions (`validate_coriolis`, `validate_advection`, etc) is a good route?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057:63,Security,validat,validation,63,"Do we think maybe just extending the existing pattern of input validation functions (`validate_coriolis`, `validate_advection`, etc) is a good route?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796342103:219,Deployability,configurat,configurations,219,"Yeah that would definitely help with modularization. They might need to take in the whole model, e.g. `validate_coriolis(model)`, `validate_advection(model)`, etc. since it seems hard to anticipate all the inconsistent configurations. I remember you raised the concern of slowdowns in the case of running tons of small/column models. So maybe a kwarg like `check_consistency=true` would be good to add with this feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796342103
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796342103:219,Modifiability,config,configurations,219,"Yeah that would definitely help with modularization. They might need to take in the whole model, e.g. `validate_coriolis(model)`, `validate_advection(model)`, etc. since it seems hard to anticipate all the inconsistent configurations. I remember you raised the concern of slowdowns in the case of running tons of small/column models. So maybe a kwarg like `check_consistency=true` would be good to add with this feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796342103
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847:432,Availability,error,error,432,"That could work --- though I'd point out that listing the model components that can be inconsistent with one another might be more explicit. I would advocate for a ""blacklisting"" method whereby blacklisted combinations of components are listed local to the implementation of the component. For example, in `beta_plane.jl` we could add. ```julia; validate_coriolis(::BetaPlane, ::AbstractGrid{FT, TX, <:Periodic}) where {FT, TX} = # error; ```. we also need, in `hydrostatic_spherical_coriolis.jl`,. ```julia; validate_coriolis(::HydrostaticSphericalCoriolis, ::AbstractRectilinearGrid) = # error; ```. I think a warning is better than an error for `WENO5` on a curvilinear grid. That'd be a fun scheme to experiment with and we don't know ""how wrong"" it is. If the curvilinear grid is almost regular, we have reason to think it might work. In cases like these where we aren't completely, rock-solid positive that a certain model configuration is invalid I think we should also err conservative and allow such models to be constructed. . We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Specialty applications can just avoid the kwarg-based constructor so I'm not sure we should worry much about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847:590,Availability,error,error,590,"That could work --- though I'd point out that listing the model components that can be inconsistent with one another might be more explicit. I would advocate for a ""blacklisting"" method whereby blacklisted combinations of components are listed local to the implementation of the component. For example, in `beta_plane.jl` we could add. ```julia; validate_coriolis(::BetaPlane, ::AbstractGrid{FT, TX, <:Periodic}) where {FT, TX} = # error; ```. we also need, in `hydrostatic_spherical_coriolis.jl`,. ```julia; validate_coriolis(::HydrostaticSphericalCoriolis, ::AbstractRectilinearGrid) = # error; ```. I think a warning is better than an error for `WENO5` on a curvilinear grid. That'd be a fun scheme to experiment with and we don't know ""how wrong"" it is. If the curvilinear grid is almost regular, we have reason to think it might work. In cases like these where we aren't completely, rock-solid positive that a certain model configuration is invalid I think we should also err conservative and allow such models to be constructed. . We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Specialty applications can just avoid the kwarg-based constructor so I'm not sure we should worry much about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847:638,Availability,error,error,638,"That could work --- though I'd point out that listing the model components that can be inconsistent with one another might be more explicit. I would advocate for a ""blacklisting"" method whereby blacklisted combinations of components are listed local to the implementation of the component. For example, in `beta_plane.jl` we could add. ```julia; validate_coriolis(::BetaPlane, ::AbstractGrid{FT, TX, <:Periodic}) where {FT, TX} = # error; ```. we also need, in `hydrostatic_spherical_coriolis.jl`,. ```julia; validate_coriolis(::HydrostaticSphericalCoriolis, ::AbstractRectilinearGrid) = # error; ```. I think a warning is better than an error for `WENO5` on a curvilinear grid. That'd be a fun scheme to experiment with and we don't know ""how wrong"" it is. If the curvilinear grid is almost regular, we have reason to think it might work. In cases like these where we aren't completely, rock-solid positive that a certain model configuration is invalid I think we should also err conservative and allow such models to be constructed. . We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Specialty applications can just avoid the kwarg-based constructor so I'm not sure we should worry much about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847:929,Deployability,configurat,configuration,929,"That could work --- though I'd point out that listing the model components that can be inconsistent with one another might be more explicit. I would advocate for a ""blacklisting"" method whereby blacklisted combinations of components are listed local to the implementation of the component. For example, in `beta_plane.jl` we could add. ```julia; validate_coriolis(::BetaPlane, ::AbstractGrid{FT, TX, <:Periodic}) where {FT, TX} = # error; ```. we also need, in `hydrostatic_spherical_coriolis.jl`,. ```julia; validate_coriolis(::HydrostaticSphericalCoriolis, ::AbstractRectilinearGrid) = # error; ```. I think a warning is better than an error for `WENO5` on a curvilinear grid. That'd be a fun scheme to experiment with and we don't know ""how wrong"" it is. If the curvilinear grid is almost regular, we have reason to think it might work. In cases like these where we aren't completely, rock-solid positive that a certain model configuration is invalid I think we should also err conservative and allow such models to be constructed. . We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Specialty applications can just avoid the kwarg-based constructor so I'm not sure we should worry much about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847:929,Modifiability,config,configuration,929,"That could work --- though I'd point out that listing the model components that can be inconsistent with one another might be more explicit. I would advocate for a ""blacklisting"" method whereby blacklisted combinations of components are listed local to the implementation of the component. For example, in `beta_plane.jl` we could add. ```julia; validate_coriolis(::BetaPlane, ::AbstractGrid{FT, TX, <:Periodic}) where {FT, TX} = # error; ```. we also need, in `hydrostatic_spherical_coriolis.jl`,. ```julia; validate_coriolis(::HydrostaticSphericalCoriolis, ::AbstractRectilinearGrid) = # error; ```. I think a warning is better than an error for `WENO5` on a curvilinear grid. That'd be a fun scheme to experiment with and we don't know ""how wrong"" it is. If the curvilinear grid is almost regular, we have reason to think it might work. In cases like these where we aren't completely, rock-solid positive that a certain model configuration is invalid I think we should also err conservative and allow such models to be constructed. . We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Specialty applications can just avoid the kwarg-based constructor so I'm not sure we should worry much about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847:1281,Safety,avoid,avoid,1281,"That could work --- though I'd point out that listing the model components that can be inconsistent with one another might be more explicit. I would advocate for a ""blacklisting"" method whereby blacklisted combinations of components are listed local to the implementation of the component. For example, in `beta_plane.jl` we could add. ```julia; validate_coriolis(::BetaPlane, ::AbstractGrid{FT, TX, <:Periodic}) where {FT, TX} = # error; ```. we also need, in `hydrostatic_spherical_coriolis.jl`,. ```julia; validate_coriolis(::HydrostaticSphericalCoriolis, ::AbstractRectilinearGrid) = # error; ```. I think a warning is better than an error for `WENO5` on a curvilinear grid. That'd be a fun scheme to experiment with and we don't know ""how wrong"" it is. If the curvilinear grid is almost regular, we have reason to think it might work. In cases like these where we aren't completely, rock-solid positive that a certain model configuration is invalid I think we should also err conservative and allow such models to be constructed. . We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Specialty applications can just avoid the kwarg-based constructor so I'm not sure we should worry much about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796846731:310,Availability,error,errors,310,"> We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Yes to be clear I should have said that I'm just advocating for printing warnings, not throwing errors. Users should be able to run whatever they want. I would say that these warnings make the software more useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796846731
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796846731:224,Usability,clear,clear,224,"> We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Yes to be clear I should have said that I'm just advocating for printing warnings, not throwing errors. Users should be able to run whatever they want. I would say that these warnings make the software more useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796846731
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799734876:106,Availability,failure,failure,106,Another idea: check that the grid architecture and model architecture match to avoid issues like the test failure in #1467.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799734876
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799734876:79,Safety,avoid,avoid,79,Another idea: check that the grid architecture and model architecture match to avoid issues like the test failure in #1467.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799734876
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799734876:101,Testability,test,test,101,Another idea: check that the grid architecture and model architecture match to avoid issues like the test failure in #1467.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799734876
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799746052:475,Modifiability,refactor,refactoring,475,"Yes that would be ideal!. Actually I guess right now it might be tricky since you have to create the grid first for stretched and curvilinear grids. But for multi-architectures, you need to pass the grid as the grid topology could change the rank connectivity. So you end up having to specify `CPU()` for the grid, then pass it to the `MultiCPU` constructor, then pass that to the model. Would be great if we can specify the architecture in one place, but might require some refactoring that we'd have to think more about.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799746052
https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-1479856892:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-1479856892
https://github.com/CliMA/Oceananigans.jl/pull/1454#issuecomment-796822490:41,Modifiability,parameteriz,parameterization,41,"> Stokes vorticity?. Ah, when using a GM parameterization?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1454#issuecomment-796822490
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796844407:99,Availability,failure,failure,99,"Is there more to the log? Might be useful if you can paste the whole log. Sometimes the `makedocs` failure is due to some warning much earlier in the build log, especially with `strict = true`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796844407
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796844407:21,Testability,log,log,21,"Is there more to the log? Might be useful if you can paste the whole log. Sometimes the `makedocs` failure is due to some warning much earlier in the build log, especially with `strict = true`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796844407
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796844407:69,Testability,log,log,69,"Is there more to the log? Might be useful if you can paste the whole log. Sometimes the `makedocs` failure is due to some warning much earlier in the build log, especially with `strict = true`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796844407
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796844407:156,Testability,log,log,156,"Is there more to the log? Might be useful if you can paste the whole log. Sometimes the `makedocs` failure is due to some warning much earlier in the build log, especially with `strict = true`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796844407
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:615,Availability,Error,Error,615,"Thanks @ali-ramadhan for the suggestion. It seems to be the same type of thing over and over and I am copying the first one here, but if you want more I can certainly copy those, but they will take up a lot of space. ```; (base) fpoulin@vortex2:~/software/Oceananigans.jl$ julia --project=docs/ docs/make.jl; [ Info: generating markdown page from `~/software/Oceananigans.jl/examples/one_dimensional_diffusion.jl`; [ Info: writing result to `~/software/Oceananigans.jl/docs/src/generated/one_dimensional_diffusion.md`; [ Info: SetupBuildDirectory: setting up build directory.; [ Info: Doctest: running doctests.; ┌ Error: doctest failure in src/model_setup/output_writers.md:55-76; │ ; │ ```jldoctest netcdf1; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ # output; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ```; │ ; │ Subexpression:; │ ; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:630,Availability,failure,failure,630,"Thanks @ali-ramadhan for the suggestion. It seems to be the same type of thing over and over and I am copying the first one here, but if you want more I can certainly copy those, but they will take up a lot of space. ```; (base) fpoulin@vortex2:~/software/Oceananigans.jl$ julia --project=docs/ docs/make.jl; [ Info: generating markdown page from `~/software/Oceananigans.jl/examples/one_dimensional_diffusion.jl`; [ Info: writing result to `~/software/Oceananigans.jl/docs/src/generated/one_dimensional_diffusion.md`; [ Info: SetupBuildDirectory: setting up build directory.; [ Info: Doctest: running doctests.; ┌ Error: doctest failure in src/model_setup/output_writers.md:55-76; │ ; │ ```jldoctest netcdf1; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ # output; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ```; │ ; │ Subexpression:; │ ; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:2149,Availability,error,errors,2149,"iter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ```; │ ; │ Subexpression:; │ ; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ diff =; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:3137,Availability,error,errors,3137,"u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ diff =; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; └ @ Documenter.DocTests ~/.julia/packages/Documenter/lul8Y/src/DocTests.jl:369; ┌ Error: doctest failure in src/model_setup/output_writers.md:78-90; │ . ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:3700,Availability,Error,Error,3700,"u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ diff =; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; └ @ Documenter.DocTests ~/.julia/packages/Documenter/lul8Y/src/DocTests.jl:369; ┌ Error: doctest failure in src/model_setup/output_writers.md:78-90; │ . ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:3715,Availability,failure,failure,3715,"u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ diff =; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; └ @ Documenter.DocTests ~/.julia/packages/Documenter/lul8Y/src/DocTests.jl:369; ┌ Error: doctest failure in src/model_setup/output_writers.md:78-90; │ . ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:1130,Energy Efficiency,schedul,schedule,1130,"take up a lot of space. ```; (base) fpoulin@vortex2:~/software/Oceananigans.jl$ julia --project=docs/ docs/make.jl; [ Info: generating markdown page from `~/software/Oceananigans.jl/examples/one_dimensional_diffusion.jl`; [ Info: writing result to `~/software/Oceananigans.jl/docs/src/generated/one_dimensional_diffusion.md`; [ Info: SetupBuildDirectory: setting up build directory.; [ Info: Doctest: running doctests.; ┌ Error: doctest failure in src/model_setup/output_writers.md:55-76; │ ; │ ```jldoctest netcdf1; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ # output; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ```; │ ; │ Subexpression:; │ ; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:1195,Energy Efficiency,schedul,scheduled,1195,"take up a lot of space. ```; (base) fpoulin@vortex2:~/software/Oceananigans.jl$ julia --project=docs/ docs/make.jl; [ Info: generating markdown page from `~/software/Oceananigans.jl/examples/one_dimensional_diffusion.jl`; [ Info: writing result to `~/software/Oceananigans.jl/docs/src/generated/one_dimensional_diffusion.md`; [ Info: SetupBuildDirectory: setting up build directory.; [ Info: Doctest: running doctests.; ┌ Error: doctest failure in src/model_setup/output_writers.md:55-76; │ ; │ ```jldoctest netcdf1; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ # output; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ```; │ ; │ Subexpression:; │ ; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:1916,Energy Efficiency,schedul,schedule,1916,"ds = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ # output; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ```; │ ; │ Subexpression:; │ ; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ di",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:2362,Energy Efficiency,schedul,scheduled,2362," slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ```; │ ; │ Subexpression:; │ ; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ diff =; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 min",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:2679,Energy Efficiency,schedul,scheduled,2679,"=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ diff =; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:3350,Energy Efficiency,schedul,scheduled,3350,"u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ diff =; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; └ @ Documenter.DocTests ~/.julia/packages/Documenter/lul8Y/src/DocTests.jl:369; ┌ Error: doctest failure in src/model_setup/output_writers.md:78-90; │ . ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994:405,Availability,error,errors,405,"Ah ok so I think this is just an issue with running `makedocs` multiple times after each other without cleaning up what `makedocs` has done before. So it's complaining that when it ran the `jldoctest` a second time it got this message:. ```; more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; ```. so the output is different. I guess we have 3 possible automated fixes (manual fix being to remove the files manually):; 1. We can clean up and remove these files as part of `make.jl`.; 2. Using `NetCDFOutputWriter` in `jldoctest` we should use the `mode = ""c""` kwarg to avoid the info/warning message.; 3. `jldoctest` blocks should remove files at the end of the block (and there should be a way to hide this from the docs but not 100% sure right now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994:227,Integrability,message,message,227,"Ah ok so I think this is just an issue with running `makedocs` multiple times after each other without cleaning up what `makedocs` has done before. So it's complaining that when it ran the `jldoctest` a second time it got this message:. ```; more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; ```. so the output is different. I guess we have 3 possible automated fixes (manual fix being to remove the files manually):; 1. We can clean up and remove these files as part of `make.jl`.; 2. Using `NetCDFOutputWriter` in `jldoctest` we should use the `mode = ""c""` kwarg to avoid the info/warning message.; 3. `jldoctest` blocks should remove files at the end of the block (and there should be a way to hide this from the docs but not 100% sure right now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994:789,Integrability,message,message,789,"Ah ok so I think this is just an issue with running `makedocs` multiple times after each other without cleaning up what `makedocs` has done before. So it's complaining that when it ran the `jldoctest` a second time it got this message:. ```; more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; ```. so the output is different. I guess we have 3 possible automated fixes (manual fix being to remove the files manually):; 1. We can clean up and remove these files as part of `make.jl`.; 2. Using `NetCDFOutputWriter` in `jldoctest` we should use the `mode = ""c""` kwarg to avoid the info/warning message.; 3. `jldoctest` blocks should remove files at the end of the block (and there should be a way to hide this from the docs but not 100% sure right now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994:766,Safety,avoid,avoid,766,"Ah ok so I think this is just an issue with running `makedocs` multiple times after each other without cleaning up what `makedocs` has done before. So it's complaining that when it ran the `jldoctest` a second time it got this message:. ```; more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; ```. so the output is different. I guess we have 3 possible automated fixes (manual fix being to remove the files manually):; 1. We can clean up and remove these files as part of `make.jl`.; 2. Using `NetCDFOutputWriter` in `jldoctest` we should use the `mode = ""c""` kwarg to avoid the info/warning message.; 3. `jldoctest` blocks should remove files at the end of the block (and there should be a way to hide this from the docs but not 100% sure right now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796858215:33,Availability,failure,failure,33,"You are referring to the doctest failure? That is what I get on my second attempt, and it makes sense that this might happen as I did not clean anything up. But does wouldn't resolve the initial error, would it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796858215
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796858215:195,Availability,error,error,195,"You are referring to the doctest failure? That is what I get on my second attempt, and it makes sense that this might happen as I did not clean anything up. But does wouldn't resolve the initial error, would it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796858215
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796861405:34,Availability,error,error,34,@francispoulin Ah was the initial error different?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796861405
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901:59,Availability,error,error,59,"Sorry that I didn't emphasize this but this is the initial error. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901:110,Availability,ERROR,ERROR,110,"Sorry that I didn't emphasize this but this is the initial error. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901:154,Availability,error,error,154,"Sorry that I didn't emphasize this but this is the initial error. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901:197,Availability,error,error,197,"Sorry that I didn't emphasize this but this is the initial error. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901:218,Availability,error,error,218,"Sorry that I didn't emphasize this but this is the initial error. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901:117,Performance,Load,LoadError,117,"Sorry that I didn't emphasize this but this is the initial error. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796869175:53,Availability,error,error,53,Ah right sorry I missed that! Unfortunately yeah the error by itself isn't super helpful... Did the initial error come with any more info higher up in the log? Could also be nice to post the full log (if there's more to it).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796869175
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796869175:108,Availability,error,error,108,Ah right sorry I missed that! Unfortunately yeah the error by itself isn't super helpful... Did the initial error come with any more info higher up in the log? Could also be nice to post the full log (if there's more to it).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796869175
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796869175:155,Testability,log,log,155,Ah right sorry I missed that! Unfortunately yeah the error by itself isn't super helpful... Did the initial error come with any more info higher up in the log? Could also be nice to post the full log (if there's more to it).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796869175
https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796869175:196,Testability,log,log,196,Ah right sorry I missed that! Unfortunately yeah the error by itself isn't super helpful... Did the initial error come with any more info higher up in the log? Could also be nice to post the full log (if there's more to it).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796869175
https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-797812605:251,Availability,mask,mask,251,"Note that the implementation in `IncompressibleModel` is really experimental and doesn't enforce boundary conditions or work for tracers. I think we might be able to improve on what's done for `IncompressibleModel`. A simple implementation would just mask the immersed boundary in `update_state!`. We have to work a bit harder to make sure that boundary conditions are satisfied, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-797812605
https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-797812605:218,Usability,simpl,simple,218,"Note that the implementation in `IncompressibleModel` is really experimental and doesn't enforce boundary conditions or work for tracers. I think we might be able to improve on what's done for `IncompressibleModel`. A simple implementation would just mask the immersed boundary in `update_state!`. We have to work a bit harder to make sure that boundary conditions are satisfied, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-797812605
https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-798606318:162,Testability,test,testing,162,thanks @glwagner . Maybe we could plan to meet for an hour this week and give this a try? It would be great for `ShallowWaterModel` and could also be helpful for testing the immersed boundary methods in a simpler model. Happy to disucss on slack as you like.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-798606318
https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-798606318:205,Usability,simpl,simpler,205,thanks @glwagner . Maybe we could plan to meet for an hour this week and give this a try? It would be great for `ShallowWaterModel` and could also be helpful for testing the immersed boundary methods in a simpler model. Happy to disucss on slack as you like.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-798606318
https://github.com/CliMA/Oceananigans.jl/issues/1459#issuecomment-799404046:100,Safety,avoid,avoid,100,"We should probably find these figures and add them back in, but probably not as part of the repo to avoid inflating the repo size. We could use a GitHub issue for figures or we could use https://github.com/CliMA/OceananigansArtifacts.jl for figures as well. X-Ref: https://github.com/CliMA/Oceananigans.jl/issues/1212",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1459#issuecomment-799404046
https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798789091:70,Integrability,message,message,70,"Tbh I didn't give it as much thought as you may be implying with your message above :). But I just realized that the ShallowWater example talks about ""equations in conservative form"" and some users may have no idea what we are talking about... Let's see what @glwagner and @ali-ramadhan think on this. Perhaps with the current status of fast development it makes sense to hold on Docs for later..?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798789091
https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798799226:381,Modifiability,evolve,evolve,381,"I am very curious to hear what people think but do think it would make sense to have a tab called Models where we state briefly the model equations. This way the user knows exactly what their getting themselves into. We have that for `IncompressibleModel` in the `Physics` section, and feel the other two models should get a bit of converge. Even though the numerical methods will evolve, the governing equations will not change. Or if they do we'll be adding more into them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798799226
https://github.com/CliMA/Oceananigans.jl/issues/1462#issuecomment-1031692310:450,Energy Efficiency,meter,meters,450,"Just like to discuss this a little more. I think it'd be nice to have some awareness of units in the code. Some places we assume units, like `prettytime`. Other places we don't mention units, like `@show grid`. The two important cases are SI units and ""no units"". Maybe we can just have `grid.units = u""m""` by default, where. ```; julia> using Unitful. julia> typeof(u""m""); Unitful.FreeUnits{(m,), 𝐋, nothing; ```. is the `Unitful.jl` way of saying ""meters"". We could also choose `grid.units = nothing` by default. From the length of grid, we can infer the units for every other quantity. I think we should start unambitious and just have `grid.units` and `clock.units`; if `grid.units === u""m""` then we'll set `clock.units = u""s""`. If `isnothing(grid.units)` then every unit `isnothing`. We'll then use these units in things like `prettytime` and `@show grid`. In principle, we also need `field.units`; field quantities have units that cannot be derived from `grid`. But for Oceananigans, units are really just sugar for showing and displaying things. So it may not make sense to add units to `field`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1462#issuecomment-1031692310
https://github.com/CliMA/Oceananigans.jl/issues/1462#issuecomment-1031704826:91,Availability,down,downside,91,"Thinking about it more I think we should have `grid.units = nothing` as default. This is a downside for people who primarily do ""realistic"" simulations. But we're always printing correctly if we don't assume units (just verbosely, perhaps). On the other hand `t = 1.5 minutes` is wrong if `t` is non-dimensional. And `t` is often non-dimensional (eg a bunch of our examples).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1462#issuecomment-1031704826
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:150,Availability,error,error,150,"Just for completion, I realized I posted a bug in the first message but not the code that generates it. Sorry! So below is a way to reproduce it. The error emerges because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::Vertically",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:1220,Availability,error,error,1220,"the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:1238,Availability,ERROR,ERROR,1238,"anigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::FieldSlicer{Colon,Colon,Colon}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:1140,Energy Efficiency,schedul,schedule,1140,"es because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:17032,Energy Efficiency,schedul,schedule,17032,"s.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:38; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[21]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:60,Integrability,message,message,60,"Just for completion, I realized I posted a bug in the first message but not the code that generates it. Sorry! So below is a way to reproduce it. The error emerges because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::Vertically",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:177,Integrability,rout,routine,177,"Just for completion, I realized I posted a bug in the first message but not the code that generates it. Sorry! So below is a way to reproduce it. The error emerges because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::Vertically",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:17418,Modifiability,sandbox,sandbox,17418,"s.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:38; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[21]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:17579,Modifiability,sandbox,sandbox,17579,"s.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:38; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[21]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:1245,Performance,Load,LoadError,1245,"anigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::FieldSlicer{Colon,Colon,Colon}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:212,Security,access,access,212,"Just for completion, I realized I posted a bug in the first message but not the code that generates it. Sorry! So below is a way to reproduce it. The error emerges because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::Vertically",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:17418,Testability,sandbox,sandbox,17418,"s.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:38; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[21]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:17579,Testability,sandbox,sandbox,17579,"s.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:38; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[21]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799796801:343,Security,validat,validate,343,"> Should we limit this discussion to the names of locations and grid spacings? The issue currently only refers to ""more bugs"" which could be a bit too open-ended to make useful progress on. That's a good point, and I apologize for being too general with the title. I still would like to solve that specific bug relatively soon since I want to validate the tilted buoyancy on a tilted bottom boundary layer soon. Should I create a separate issue for that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799796801
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799798339:903,Energy Efficiency,schedul,schedule,903,"> We are in the process of implementing curvilinear grids, which require more specificity for the location of grid lengths, areas, and volumes. As a result we are attempting to standardize our notation, using three-letter codes to be completely explicit. These changes have been made in the vertically stretched grid and regular lat-lon grid, but not in the regular rectilinear grid yet. Would just a change from `xC` to `xᶜᵃᵃ` and so on in Regular grids do it?. Also, we need to be careful if the notation with superscripts are the default when writing to NetCDF. These ""uncommon"" unicode characters aren't very easy to access from a lot (most?) of programming languages. As an example, here's me trying to access an attribute named `u₀` using `xarray` in Python:. ```python; In [91]: vid.attrs; Out[91]: ; {'N2_inf': 4e-05,; 'f0': 0.0001,; 'σy': 1600,; 'z_0': -250.0,; 'u₀': -0.4,; 'N2_pyc': 4e-05,; 'schedule': 'TimeInterval',; 'name': 'CIintjet01',; 'interval': 5400.0,; 'Lz': 500,; 'Julia': 'This file was generated using Julia Version 1.5.2\nCommit 539f3ce (2020-09-23 23:17 UTC)\nPlatform Info:\n OS: Linux (x86_64-pc-linux-gnu)\n CPU: Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz\n WORD_SIZE: 64\n LIBM: libopenlibm\n LLVM: libLLVM-9.0.1 (ORCJIT, skylake-avx512)\n GPU: Tesla V100-SXM2-32GB\n',; 'output time interval': 'Output was saved every 1.500 hours.',; 'T_inertial': 62831.85307179586,; 'σz': 80,; 'u_0': -0.4,; 'Nz': 512,; 'z₀': -250.0,; 'LES': 0,; 'Ny': 8192,; 'date': 'This file was generated on 2021-03-08T15:14:07.533.',; 'Ly': 15000,; 'b0': -4e-05,; 'y₀': 5000.0,; 'Oceananigans': 'This file was generated using Oceananigans v0.52.1',; 'y_0': 5000.0}. In [92]: vid.u₀; File ""<ipython-input-92-9d34f4e5eca9>"", line 1; vid.u₀; ^; SyntaxError: invalid character '₀' (U+2080). In [93]: vid.attrs[""u₀""]; Out[93]: -0.4; ```. So as you can see it's possible, but it definitely takes some extra effort (especially since you can't type `u₀` in Python and need to copy paste from somewhere else",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799798339
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799798339:621,Security,access,access,621,"> We are in the process of implementing curvilinear grids, which require more specificity for the location of grid lengths, areas, and volumes. As a result we are attempting to standardize our notation, using three-letter codes to be completely explicit. These changes have been made in the vertically stretched grid and regular lat-lon grid, but not in the regular rectilinear grid yet. Would just a change from `xC` to `xᶜᵃᵃ` and so on in Regular grids do it?. Also, we need to be careful if the notation with superscripts are the default when writing to NetCDF. These ""uncommon"" unicode characters aren't very easy to access from a lot (most?) of programming languages. As an example, here's me trying to access an attribute named `u₀` using `xarray` in Python:. ```python; In [91]: vid.attrs; Out[91]: ; {'N2_inf': 4e-05,; 'f0': 0.0001,; 'σy': 1600,; 'z_0': -250.0,; 'u₀': -0.4,; 'N2_pyc': 4e-05,; 'schedule': 'TimeInterval',; 'name': 'CIintjet01',; 'interval': 5400.0,; 'Lz': 500,; 'Julia': 'This file was generated using Julia Version 1.5.2\nCommit 539f3ce (2020-09-23 23:17 UTC)\nPlatform Info:\n OS: Linux (x86_64-pc-linux-gnu)\n CPU: Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz\n WORD_SIZE: 64\n LIBM: libopenlibm\n LLVM: libLLVM-9.0.1 (ORCJIT, skylake-avx512)\n GPU: Tesla V100-SXM2-32GB\n',; 'output time interval': 'Output was saved every 1.500 hours.',; 'T_inertial': 62831.85307179586,; 'σz': 80,; 'u_0': -0.4,; 'Nz': 512,; 'z₀': -250.0,; 'LES': 0,; 'Ny': 8192,; 'date': 'This file was generated on 2021-03-08T15:14:07.533.',; 'Ly': 15000,; 'b0': -4e-05,; 'y₀': 5000.0,; 'Oceananigans': 'This file was generated using Oceananigans v0.52.1',; 'y_0': 5000.0}. In [92]: vid.u₀; File ""<ipython-input-92-9d34f4e5eca9>"", line 1; vid.u₀; ^; SyntaxError: invalid character '₀' (U+2080). In [93]: vid.attrs[""u₀""]; Out[93]: -0.4; ```. So as you can see it's possible, but it definitely takes some extra effort (especially since you can't type `u₀` in Python and need to copy paste from somewhere else",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799798339
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799798339:708,Security,access,access,708,"> We are in the process of implementing curvilinear grids, which require more specificity for the location of grid lengths, areas, and volumes. As a result we are attempting to standardize our notation, using three-letter codes to be completely explicit. These changes have been made in the vertically stretched grid and regular lat-lon grid, but not in the regular rectilinear grid yet. Would just a change from `xC` to `xᶜᵃᵃ` and so on in Regular grids do it?. Also, we need to be careful if the notation with superscripts are the default when writing to NetCDF. These ""uncommon"" unicode characters aren't very easy to access from a lot (most?) of programming languages. As an example, here's me trying to access an attribute named `u₀` using `xarray` in Python:. ```python; In [91]: vid.attrs; Out[91]: ; {'N2_inf': 4e-05,; 'f0': 0.0001,; 'σy': 1600,; 'z_0': -250.0,; 'u₀': -0.4,; 'N2_pyc': 4e-05,; 'schedule': 'TimeInterval',; 'name': 'CIintjet01',; 'interval': 5400.0,; 'Lz': 500,; 'Julia': 'This file was generated using Julia Version 1.5.2\nCommit 539f3ce (2020-09-23 23:17 UTC)\nPlatform Info:\n OS: Linux (x86_64-pc-linux-gnu)\n CPU: Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz\n WORD_SIZE: 64\n LIBM: libopenlibm\n LLVM: libLLVM-9.0.1 (ORCJIT, skylake-avx512)\n GPU: Tesla V100-SXM2-32GB\n',; 'output time interval': 'Output was saved every 1.500 hours.',; 'T_inertial': 62831.85307179586,; 'σz': 80,; 'u_0': -0.4,; 'Nz': 512,; 'z₀': -250.0,; 'LES': 0,; 'Ny': 8192,; 'date': 'This file was generated on 2021-03-08T15:14:07.533.',; 'Ly': 15000,; 'b0': -4e-05,; 'y₀': 5000.0,; 'Oceananigans': 'This file was generated using Oceananigans v0.52.1',; 'y_0': 5000.0}. In [92]: vid.u₀; File ""<ipython-input-92-9d34f4e5eca9>"", line 1; vid.u₀; ^; SyntaxError: invalid character '₀' (U+2080). In [93]: vid.attrs[""u₀""]; Out[93]: -0.4; ```. So as you can see it's possible, but it definitely takes some extra effort (especially since you can't type `u₀` in Python and need to copy paste from somewhere else",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799798339
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799800872:160,Security,access,access,160,"> Also, we need to be careful if the notation with superscripts are the default when writing to NetCDF. These ""uncommon"" unicode characters aren't very easy to access from a lot (most?) of programming languages. That's an interesting consideration. I believe MATLAB, Python, and Julia all support Unicode, but perhaps languages like R do not? This could be a thorny question...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799800872
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731:901,Modifiability,variab,variable,901,"> I think we should fix this problem first by generalizing the code so that explicit references to grid properties don't appear anywhere (instead we should use functions like all_x_nodes, etc). Changing the name of the grid property can come last (as a purely aesthetic improvement). Interesting consideration. I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. > Ah, I think you using IPython, rather than python, correct? I believe Jupyter notebooks support backslash / latex notation for expressing unicode, but IPython may not. Jupyter uses IPython for it's kernel (by default at least I think), so that ability comes from IPython. In any case, that doesn't work for all unicode characters. Just the ones that python can recognize as valid variable names (which I believe is [every unicode character that represents characters in written languages](https://python-3-for-scientists.readthedocs.io/en/latest/python3_features.html)). So all greek letters can be typed LaTeX style, but subscripts and supercripts can't, along with many other ones that are valid names in Julia. So if nothing is done to ""translate"" these variable names when writing NetCDF files, it's unfortunately going to be hard to deal with Oceananigans output outside of Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731:1278,Modifiability,variab,variable,1278,"> I think we should fix this problem first by generalizing the code so that explicit references to grid properties don't appear anywhere (instead we should use functions like all_x_nodes, etc). Changing the name of the grid property can come last (as a purely aesthetic improvement). Interesting consideration. I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. > Ah, I think you using IPython, rather than python, correct? I believe Jupyter notebooks support backslash / latex notation for expressing unicode, but IPython may not. Jupyter uses IPython for it's kernel (by default at least I think), so that ability comes from IPython. In any case, that doesn't work for all unicode characters. Just the ones that python can recognize as valid variable names (which I believe is [every unicode character that represents characters in written languages](https://python-3-for-scientists.readthedocs.io/en/latest/python3_features.html)). So all greek letters can be typed LaTeX style, but subscripts and supercripts can't, along with many other ones that are valid names in Julia. So if nothing is done to ""translate"" these variable names when writing NetCDF files, it's unfortunately going to be hard to deal with Oceananigans output outside of Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731:375,Security,validat,validation,375,"> I think we should fix this problem first by generalizing the code so that explicit references to grid properties don't appear anywhere (instead we should use functions like all_x_nodes, etc). Changing the name of the grid property can come last (as a purely aesthetic improvement). Interesting consideration. I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. > Ah, I think you using IPython, rather than python, correct? I believe Jupyter notebooks support backslash / latex notation for expressing unicode, but IPython may not. Jupyter uses IPython for it's kernel (by default at least I think), so that ability comes from IPython. In any case, that doesn't work for all unicode characters. Just the ones that python can recognize as valid variable names (which I believe is [every unicode character that represents characters in written languages](https://python-3-for-scientists.readthedocs.io/en/latest/python3_features.html)). So all greek letters can be typed LaTeX style, but subscripts and supercripts can't, along with many other ones that are valid names in Julia. So if nothing is done to ""translate"" these variable names when writing NetCDF files, it's unfortunately going to be hard to deal with Oceananigans output outside of Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900:287,Availability,error,errors,287,"> I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. I believe my suggestion regarding `default_dimensions` will solve one of the errors encountered in this issue, but I'm not sure about other similar errors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900:358,Availability,error,errors,358,"> I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. I believe my suggestion regarding `default_dimensions` will solve one of the errors encountered in this issue, but I'm not sure about other similar errors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900:66,Security,validat,validation,66,"> I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. I believe my suggestion regarding `default_dimensions` will solve one of the errors encountered in this issue, but I'm not sure about other similar errors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546:253,Modifiability,variab,variable,253,"As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546:336,Modifiability,variab,variable,336,"As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546:52,Testability,test,tests,52,"As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309:280,Modifiability,variab,variable,280,"> As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Good to hear! Thanks!. > Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython... I don't think there is a _problem_, because NetCDF accepts unicode names, etc, and Python (and most other modern programming languages I thnik) also do. The issue that I pointed out is that, because most other programming languages don't let you write code with all unicode characters, most source-code editors/prompts don't let you type all unicode characters easily. So you can write the following in Python and it'll work (I think, I haven't tested); ; ```Python; ds.plot(x=""xᶜᵃᵃ""); ```. But every time you wanna do it (or write other characters like `xᶜᵃᵃ`) you have to copy paste those characters from somewhere else, which is kind of a hassle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309:363,Modifiability,variab,variable,363,"> As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Good to hear! Thanks!. > Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython... I don't think there is a _problem_, because NetCDF accepts unicode names, etc, and Python (and most other modern programming languages I thnik) also do. The issue that I pointed out is that, because most other programming languages don't let you write code with all unicode characters, most source-code editors/prompts don't let you type all unicode characters easily. So you can write the following in Python and it'll work (I think, I haven't tested); ; ```Python; ds.plot(x=""xᶜᵃᵃ""); ```. But every time you wanna do it (or write other characters like `xᶜᵃᵃ`) you have to copy paste those characters from somewhere else, which is kind of a hassle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309:54,Testability,test,tests,54,"> As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Good to hear! Thanks!. > Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython... I don't think there is a _problem_, because NetCDF accepts unicode names, etc, and Python (and most other modern programming languages I thnik) also do. The issue that I pointed out is that, because most other programming languages don't let you write code with all unicode characters, most source-code editors/prompts don't let you type all unicode characters easily. So you can write the following in Python and it'll work (I think, I haven't tested); ; ```Python; ds.plot(x=""xᶜᵃᵃ""); ```. But every time you wanna do it (or write other characters like `xᶜᵃᵃ`) you have to copy paste those characters from somewhere else, which is kind of a hassle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309:860,Testability,test,tested,860,"> As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Good to hear! Thanks!. > Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython... I don't think there is a _problem_, because NetCDF accepts unicode names, etc, and Python (and most other modern programming languages I thnik) also do. The issue that I pointed out is that, because most other programming languages don't let you write code with all unicode characters, most source-code editors/prompts don't let you type all unicode characters easily. So you can write the following in Python and it'll work (I think, I haven't tested); ; ```Python; ds.plot(x=""xᶜᵃᵃ""); ```. But every time you wanna do it (or write other characters like `xᶜᵃᵃ`) you have to copy paste those characters from somewhere else, which is kind of a hassle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309
https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799835492:140,Security,validat,validate,140,"Ah we can figure out the best names in the future PR then?. > I still would like to solve that specific bug relatively soon since I want to validate the tilted buoyancy on a tilted bottom boundary layer soon. Should I create a separate issue for that?. Maybe the fastest thing to do for now would be to use `JLD2OutputWriter`? It should work with the grids no problem until we sort out `NetCDFOutputWriter`. I've been able to open JLD2 files in Python with h5py in the past if that's helpful, but yeah no xarray.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799835492
https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799591051:377,Energy Efficiency,reduce,reduced,377,"I just created this quickly so that I could pull the created branch locally and start coding. I think the final approach will be very different. I now think the best way is to especially `min_Δx`, etc, and use that everywhere we can. After all, there;s also the diffusive time scale to worry about. Although, like you said, we should probably consider calculating the CFL as a reduced field in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799591051
https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799625441:37,Deployability,patch,patch,37,@tomchor Might also be good to tag a patch release (v0.53.1) so it's easier to make use of this fix.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799625441
https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799625441:43,Deployability,release,release,43,@tomchor Might also be good to tag a patch release (v0.53.1) so it's easier to make use of this fix.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799625441
https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063:98,Modifiability,refactor,refactored,98,"Alright so as suggested I added a test for CFL calculation with a vertically stretched grid. Also refactored where the minΔx functinos go like @glwagner suggested, so if the tests pass I believe this should be good to go. @ali-ramadhan should I just call JuliaRegistrator to register this after it's merged?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063
https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063:34,Testability,test,test,34,"Alright so as suggested I added a test for CFL calculation with a vertically stretched grid. Also refactored where the minΔx functinos go like @glwagner suggested, so if the tests pass I believe this should be good to go. @ali-ramadhan should I just call JuliaRegistrator to register this after it's merged?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063
https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063:174,Testability,test,tests,174,"Alright so as suggested I added a test for CFL calculation with a vertically stretched grid. Also refactored where the minΔx functinos go like @glwagner suggested, so if the tests pass I believe this should be good to go. @ali-ramadhan should I just call JuliaRegistrator to register this after it's merged?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063
https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799711547:80,Availability,error,error,80,"So, the test is failing on the GPU, but not on the CPU so I can't reproduce the error locally and I don't understand why it's failing. Can anyone give me a hand?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799711547
https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799711547:8,Testability,test,test,8,"So, the test is failing on the GPU, but not on the CPU so I can't reproduce the error locally and I don't understand why it's failing. Can anyone give me a hand?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799711547
https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799634970:141,Availability,down,download,141,Ah Julia 1.1 is quite old and will end up using an ancient version of Oceananigans.jl so you probably need Julia 1.5+ (you should be able to download a binary from https://julialang.org/downloads/). But in this case I think Oceananigans is mispelled as Oceanigans.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799634970
https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799634970:186,Availability,down,downloads,186,Ah Julia 1.1 is quite old and will end up using an ancient version of Oceananigans.jl so you probably need Julia 1.5+ (you should be able to download a binary from https://julialang.org/downloads/). But in this case I think Oceananigans is mispelled as Oceanigans.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799634970
https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799638254:40,Deployability,update,update,40,"Thanks @ali-ramadhan . I hope they will update a newer version, otherwise I can try and install it myself and I don't imagine they will have any problem with that. We will see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799638254
https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799638254:88,Deployability,install,install,88,"Thanks @ali-ramadhan . I hope they will update a newer version, otherwise I can try and install it myself and I don't imagine they will have any problem with that. We will see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799638254
https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799814031:42,Deployability,update,update,42,"> Thanks @ali-ramadhan . I hope they will update a newer version, otherwise I can try and install it myself and I don't imagine they will have any problem with that. We will see. Install Julia yourself and don't rely on IT... :); (that's what I do on Australia's HPC...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799814031
https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799814031:90,Deployability,install,install,90,"> Thanks @ali-ramadhan . I hope they will update a newer version, otherwise I can try and install it myself and I don't imagine they will have any problem with that. We will see. Install Julia yourself and don't rely on IT... :); (that's what I do on Australia's HPC...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799814031
https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799814031:179,Deployability,Install,Install,179,"> Thanks @ali-ramadhan . I hope they will update a newer version, otherwise I can try and install it myself and I don't imagine they will have any problem with that. We will see. Install Julia yourself and don't rely on IT... :); (that's what I do on Australia's HPC...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799814031
https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716:63,Deployability,install,install,63,"Excellent advice @navidcy , I will probably do just that. I do install it on my ubuntu machine but suppose I need to learn to install it for a user only. A good thing to learn.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716
https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716:126,Deployability,install,install,126,"Excellent advice @navidcy , I will probably do just that. I do install it on my ubuntu machine but suppose I need to learn to install it for a user only. A good thing to learn.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716
https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716:117,Usability,learn,learn,117,"Excellent advice @navidcy , I will probably do just that. I do install it on my ubuntu machine but suppose I need to learn to install it for a user only. A good thing to learn.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716
https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716:170,Usability,learn,learn,170,"Excellent advice @navidcy , I will probably do just that. I do install it on my ubuntu machine but suppose I need to learn to install it for a user only. A good thing to learn.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716
https://github.com/CliMA/Oceananigans.jl/pull/1469#issuecomment-799665254:224,Deployability,pipeline,pipeline,224,Ah haha honest mistake. Not sure why CompatHelper fails but I think Buildkite adds Oceananigans.jl locally with this command. https://github.com/CliMA/Oceananigans.jl/blob/c34e6cd2166bbaa057186ffa795d348c1802485f/.buildkite/pipeline.yml#L326. so perhaps Buildkite won't fail because of this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1469#issuecomment-799665254
https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799764461:168,Availability,error,error,168,I think it's helpful to use different names; we're seeing the benefit of `ᵃ` now because much of the code that doesn't generalize to curvilinear grids will fortunately error rather than running but producing bogus results.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799764461
https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799768537:255,Integrability,interface,interface,255,"Let's start here with documentation: a three letter superscript indicates the _location_ at which a function or object is defined. There is one letter for each direction x, y, z, in that order. And there are three locations:. * `ᶠ`: stands for ""face"" or ""interface"" with respect to a tracer cell.; * `ᶜ`: stands for ""center"" with respect to a tracer cell; * `ᵃ`: stands for ""any"", which means the operator / object is valid at either faces or interfaces. For example, the x-velocity `u` is located at `Face, Center, Center`. So the grid area (with `x`-normal) defined at `u` locations is `Axᶠᶜᶜ`. Another example is `Δyᶠᶜᵃ`, which is the _grid spacing in y_ defined at `Face, Center, Any`. Such a grid spacing arises in grids that are vertically rectilinear but horizontally-curvilinear (eg a horizontally-curvilinear that is extruded in the `z` direction). A spacing like `Δyᶠᶜᵃ(i, j, k, grid)` returns the distance from the cell center north of the `y`-node at `Face, Center, Any`, to the cell center south of the `y`-node at `Face, Center, Any`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799768537
https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799768537:443,Integrability,interface,interfaces,443,"Let's start here with documentation: a three letter superscript indicates the _location_ at which a function or object is defined. There is one letter for each direction x, y, z, in that order. And there are three locations:. * `ᶠ`: stands for ""face"" or ""interface"" with respect to a tracer cell.; * `ᶜ`: stands for ""center"" with respect to a tracer cell; * `ᵃ`: stands for ""any"", which means the operator / object is valid at either faces or interfaces. For example, the x-velocity `u` is located at `Face, Center, Center`. So the grid area (with `x`-normal) defined at `u` locations is `Axᶠᶜᶜ`. Another example is `Δyᶠᶜᵃ`, which is the _grid spacing in y_ defined at `Face, Center, Any`. Such a grid spacing arises in grids that are vertically rectilinear but horizontally-curvilinear (eg a horizontally-curvilinear that is extruded in the `z` direction). A spacing like `Δyᶠᶜᵃ(i, j, k, grid)` returns the distance from the cell center north of the `y`-node at `Face, Center, Any`, to the cell center south of the `y`-node at `Face, Center, Any`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799768537
https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799772332:382,Deployability,install,installed,382,"Registration pull request created: [JuliaRegistries/General/32030](https://github.com/JuliaRegistries/General/pull/32030). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if the [Julia TagBot GitHub Action](https://github.com/marketplace/actions/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.53.1 -m ""<description of version>"" 7682a3df3c65a1a7e1df2bb05d86a8ce033a91ff; git push origin v0.53.1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799772332
https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799772332:436,Integrability,interface,interface,436,"Registration pull request created: [JuliaRegistries/General/32030](https://github.com/JuliaRegistries/General/pull/32030). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if the [Julia TagBot GitHub Action](https://github.com/marketplace/actions/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.53.1 -m ""<description of version>"" 7682a3df3c65a1a7e1df2bb05d86a8ce033a91ff; git push origin v0.53.1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799772332
https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799813301:52,Usability,simpl,simpler,52,"Yes, should have mentioned it @tomchor. That's much simpler :) (no need to open issue etc..)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799813301
https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800175997:223,Modifiability,variab,variable,223,"From the stacktrace, it looks like it's complaining about `ω̄ ` and looking at the script: . https://github.com/CliMA/Oceananigans.jl/blob/master/examples/Bickley_jet_shallow_water.jl#L92. it looks like it's using a global variable `U` in the definition of `ω̄ ` which won't work in a GPU kernel. Probably the easiest solution is to just define `const U = 1.0` since `const` global variables can be referenced in GPU kernels. Not sure if there's a clean way of putting in `U` as a parameter (like with forcing functions) since you're using `ω̄ ` in an abstract operation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800175997
https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800175997:382,Modifiability,variab,variables,382,"From the stacktrace, it looks like it's complaining about `ω̄ ` and looking at the script: . https://github.com/CliMA/Oceananigans.jl/blob/master/examples/Bickley_jet_shallow_water.jl#L92. it looks like it's using a global variable `U` in the definition of `ω̄ ` which won't work in a GPU kernel. Probably the easiest solution is to just define `const U = 1.0` since `const` global variables can be referenced in GPU kernels. Not sure if there's a clean way of putting in `U` as a parameter (like with forcing functions) since you're using `ω̄ ` in an abstract operation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800175997
https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000:263,Availability,ERROR,ERROR,263,"Thanks @ali-ramadhan and @navidcy . Adding `const U = 1.0` definitely seemed to help as now it has gone further. However, at this stage I believe it's complaining about the norm. Below is the beginning part of the output, in case this makes sense to others. ```; ERROR: LoadError: scalar getindex is disallowed; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] assertscalar(::String) at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:41; [3] getindex at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:96 [inlined]; [4] getindex at /home/fpoulin/.julia/packages/OffsetArrays/lli7H/src/OffsetArrays.jl:300 [inlined]; [5] getindex at ./subarray.jl:257 [inlined]; [6] _getindex at ./abstractarray.jl:1100 [inlined]; [7] getindex at ./abstractarray.jl:1060 [inlined]; [8] iterate at ./abstractarray.jl:986 [inlined]; [9] iterate at ./abstractarray.jl:984 [inlined]; [10] generic_normInf(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:445; [11] normInf at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:536 [inlined]; [12] generic_norm2(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:477; [13] norm2 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:538 [inlined]; [14] norm(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}, ::Int64) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:607; [15] norm(::SubArray{Float64,3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000
https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000:329,Availability,error,error,329,"Thanks @ali-ramadhan and @navidcy . Adding `const U = 1.0` definitely seemed to help as now it has gone further. However, at this stage I believe it's complaining about the norm. Below is the beginning part of the output, in case this makes sense to others. ```; ERROR: LoadError: scalar getindex is disallowed; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] assertscalar(::String) at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:41; [3] getindex at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:96 [inlined]; [4] getindex at /home/fpoulin/.julia/packages/OffsetArrays/lli7H/src/OffsetArrays.jl:300 [inlined]; [5] getindex at ./subarray.jl:257 [inlined]; [6] _getindex at ./abstractarray.jl:1100 [inlined]; [7] getindex at ./abstractarray.jl:1060 [inlined]; [8] iterate at ./abstractarray.jl:986 [inlined]; [9] iterate at ./abstractarray.jl:984 [inlined]; [10] generic_normInf(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:445; [11] normInf at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:536 [inlined]; [12] generic_norm2(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:477; [13] norm2 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:538 [inlined]; [14] norm(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}, ::Int64) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:607; [15] norm(::SubArray{Float64,3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000
https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000:350,Availability,error,error,350,"Thanks @ali-ramadhan and @navidcy . Adding `const U = 1.0` definitely seemed to help as now it has gone further. However, at this stage I believe it's complaining about the norm. Below is the beginning part of the output, in case this makes sense to others. ```; ERROR: LoadError: scalar getindex is disallowed; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] assertscalar(::String) at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:41; [3] getindex at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:96 [inlined]; [4] getindex at /home/fpoulin/.julia/packages/OffsetArrays/lli7H/src/OffsetArrays.jl:300 [inlined]; [5] getindex at ./subarray.jl:257 [inlined]; [6] _getindex at ./abstractarray.jl:1100 [inlined]; [7] getindex at ./abstractarray.jl:1060 [inlined]; [8] iterate at ./abstractarray.jl:986 [inlined]; [9] iterate at ./abstractarray.jl:984 [inlined]; [10] generic_normInf(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:445; [11] normInf at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:536 [inlined]; [12] generic_norm2(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:477; [13] norm2 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:538 [inlined]; [14] norm(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}, ::Int64) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:607; [15] norm(::SubArray{Float64,3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000
https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000:270,Performance,Load,LoadError,270,"Thanks @ali-ramadhan and @navidcy . Adding `const U = 1.0` definitely seemed to help as now it has gone further. However, at this stage I believe it's complaining about the norm. Below is the beginning part of the output, in case this makes sense to others. ```; ERROR: LoadError: scalar getindex is disallowed; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] assertscalar(::String) at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:41; [3] getindex at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:96 [inlined]; [4] getindex at /home/fpoulin/.julia/packages/OffsetArrays/lli7H/src/OffsetArrays.jl:300 [inlined]; [5] getindex at ./subarray.jl:257 [inlined]; [6] _getindex at ./abstractarray.jl:1100 [inlined]; [7] getindex at ./abstractarray.jl:1060 [inlined]; [8] iterate at ./abstractarray.jl:986 [inlined]; [9] iterate at ./abstractarray.jl:984 [inlined]; [10] generic_normInf(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:445; [11] normInf at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:536 [inlined]; [12] generic_norm2(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:477; [13] norm2 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:538 [inlined]; [14] norm(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}, ::Int64) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:607; [15] norm(::SubArray{Float64,3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000
https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000:367,Testability,assert,assertscalar,367,"Thanks @ali-ramadhan and @navidcy . Adding `const U = 1.0` definitely seemed to help as now it has gone further. However, at this stage I believe it's complaining about the norm. Below is the beginning part of the output, in case this makes sense to others. ```; ERROR: LoadError: scalar getindex is disallowed; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] assertscalar(::String) at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:41; [3] getindex at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:96 [inlined]; [4] getindex at /home/fpoulin/.julia/packages/OffsetArrays/lli7H/src/OffsetArrays.jl:300 [inlined]; [5] getindex at ./subarray.jl:257 [inlined]; [6] _getindex at ./abstractarray.jl:1100 [inlined]; [7] getindex at ./abstractarray.jl:1060 [inlined]; [8] iterate at ./abstractarray.jl:986 [inlined]; [9] iterate at ./abstractarray.jl:984 [inlined]; [10] generic_normInf(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:445; [11] normInf at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:536 [inlined]; [12] generic_norm2(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:477; [13] norm2 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:538 [inlined]; [14] norm(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}, ::Int64) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:607; [15] norm(::SubArray{Float64,3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800468178:231,Performance,perform,performance,231,"I completely agree. I'd even go further and suggest a section for simulation tips in general, and then a subsection for GPU tips specifically. As an example, I noticed that defining as many things as `const` as possible helps with performance, even if I'm running on a CPU. It seems kinda obvious in hindsight, but it took me a few months to think of that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800468178
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800492316:211,Testability,test,tests,211,"> @tomchor Thanks for pointing out the const as I had no idea before today that this would help. Just a disclaimer, I did notice it when running some stuff on my laptop, but I also never ran any actual rigorous tests, so there's the possibility that it was a fluke too :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800492316
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800502949:2,Usability,learn,learned,2,"I learned today that cuda failed if I did not define a parameter as a constant, which I had no idea about before.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800502949
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436:38,Modifiability,variab,variables,38,"It makes sense that using `const` for variables referenced ""globally"" in functions increases CPU performance, see: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436:186,Modifiability,variab,variables,186,"It makes sense that using `const` for variables referenced ""globally"" in functions increases CPU performance, see: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436:97,Performance,perform,performance,97,"It makes sense that using `const` for variables referenced ""globally"" in functions increases CPU performance, see: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436:155,Performance,perform,performance-tips,155,"It makes sense that using `const` for variables referenced ""globally"" in functions increases CPU performance, see: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436:173,Safety,Avoid,Avoid-global-variables,173,"It makes sense that using `const` for variables referenced ""globally"" in functions increases CPU performance, see: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:474,Energy Efficiency,reduce,reduce,474,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:872,Energy Efficiency,efficient,efficient,872,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:1026,Energy Efficiency,reduce,reduce,1026,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:1206,Energy Efficiency,monitor,monitor,1206,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:281,Modifiability,variab,variables,281,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:592,Modifiability,variab,variable,592,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:385,Performance,optimiz,optimize,385,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:1307,Safety,avoid,avoid,1307,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:618,Security,access,accessed,618,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:778,Usability,simpl,simple,778,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-804942693:75,Performance,perform,performance-tips,75,True. Should probably also link to https://docs.julialang.org/en/v1/manual/performance-tips/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-804942693
https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-812678465:84,Usability,guid,guidelines,84,"Leaving this here for future reference, but also for discussion: maybe include some guidelines on using, slicing, and even viewing arrays when working on GPUs. These are definitely not obvious. It might be useful for users using external data (as arrays) in simulations, such as https://github.com/CliMA/Oceananigans.jl/issues/1509.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-812678465
https://github.com/CliMA/Oceananigans.jl/pull/1480#issuecomment-809299564:290,Security,validat,validation,290,Not sure if this is fully correct but qualitatively the Gaussian blob remains coherent due to geostrophic balance and we get Kelvin waves on the boundary. Was hoping we could merge this PR as it gets the cubed sphere face grid working (and it seems to be working okay pending more rigorous validation tests). Not sure if we'll keep the surface gravity waves validation experiment but might be good to use it for the full cubed sphere as well. https://user-images.githubusercontent.com/20099589/112829246-d6342800-905e-11eb-89fc-4f77a3eb8521.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480#issuecomment-809299564
https://github.com/CliMA/Oceananigans.jl/pull/1480#issuecomment-809299564:358,Security,validat,validation,358,Not sure if this is fully correct but qualitatively the Gaussian blob remains coherent due to geostrophic balance and we get Kelvin waves on the boundary. Was hoping we could merge this PR as it gets the cubed sphere face grid working (and it seems to be working okay pending more rigorous validation tests). Not sure if we'll keep the surface gravity waves validation experiment but might be good to use it for the full cubed sphere as well. https://user-images.githubusercontent.com/20099589/112829246-d6342800-905e-11eb-89fc-4f77a3eb8521.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480#issuecomment-809299564
https://github.com/CliMA/Oceananigans.jl/pull/1480#issuecomment-809299564:301,Testability,test,tests,301,Not sure if this is fully correct but qualitatively the Gaussian blob remains coherent due to geostrophic balance and we get Kelvin waves on the boundary. Was hoping we could merge this PR as it gets the cubed sphere face grid working (and it seems to be working okay pending more rigorous validation tests). Not sure if we'll keep the surface gravity waves validation experiment but might be good to use it for the full cubed sphere as well. https://user-images.githubusercontent.com/20099589/112829246-d6342800-905e-11eb-89fc-4f77a3eb8521.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480#issuecomment-809299564
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025:135,Energy Efficiency,efficient,efficient,135,"The library computes the derivatives that are required to compute the tendencies, but they are not stored since that would not be very efficient. Getting some of these values but I don't know what that would look like. Also, if you are not computing this field at every time step, the cost of computing it sepratelyl might not be that high, but that of course depends on the particular problem you are dealing with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025:360,Integrability,depend,depends,360,"The library computes the derivatives that are required to compute the tendencies, but they are not stored since that would not be very efficient. Getting some of these values but I don't know what that would look like. Also, if you are not computing this field at every time step, the cost of computing it sepratelyl might not be that high, but that of course depends on the particular problem you are dealing with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1161,Availability,down,down,1161,"ns currently does not store intermediate terms in the computation of a PDE's right hand side (with notable exceptions hydrostatic pressure and eddy diffusivities). In other words, a single, sometimes large kernel that evaluates the right hand side at each grid point `i, j, k` is compiled for each PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap m",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1907,Integrability,depend,depend,1907,"ably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1.data, field2.data, field1.operand, field2.operand); end; ```. and the kernel. ```julia; @kernel function _compute_two!(data1, data2, operand1, operand2); i, j, k = @index(Global, NTuple); @inbounds data1[i, j, k] = operand1[i, j, k]; @inbounds data2[i, j, k] = operand2[i, j, k]; end; ```. There should also be a way to generalize to the nth case using some `ntuple` magic. (Note that we tried this with tracer kernels previously without obtaining any speed up, but overlapping `ComputedField`s could be a more promising application of this technique.). # Using `mapreduce` ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:484,Performance,optimiz,optimization,484,"For better or for worse, Oceananigans currently does not store intermediate terms in the computation of a PDE's right hand side (with notable exceptions hydrostatic pressure and eddy diffusivities). In other words, a single, sometimes large kernel that evaluates the right hand side at each grid point `i, j, k` is compiled for each PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:693,Performance,bottleneck,bottleneck,693,"For better or for worse, Oceananigans currently does not store intermediate terms in the computation of a PDE's right hand side (with notable exceptions hydrostatic pressure and eddy diffusivities). In other words, a single, sometimes large kernel that evaluates the right hand side at each grid point `i, j, k` is compiled for each PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1196,Performance,perform,performed,1196,"ns currently does not store intermediate terms in the computation of a PDE's right hand side (with notable exceptions hydrostatic pressure and eddy diffusivities). In other words, a single, sometimes large kernel that evaluates the right hand side at each grid point `i, j, k` is compiled for each PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap m",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1411,Performance,optimiz,optimization,1411," PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1475,Performance,optimiz,optimize,1475,"ering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1.data, field2.data, field1.operand, field2.operand); end; ```. and the kernel. ```julia; @kernel function _compute_two!(data1, data2, operand1, op",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:931,Security,access,accesses,931,"ns currently does not store intermediate terms in the computation of a PDE's right hand side (with notable exceptions hydrostatic pressure and eddy diffusivities). In other words, a single, sometimes large kernel that evaluates the right hand side at each grid point `i, j, k` is compiled for each PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap m",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:2042,Security,access,accesses,2042,"quent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1.data, field2.data, field1.operand, field2.operand); end; ```. and the kernel. ```julia; @kernel function _compute_two!(data1, data2, operand1, operand2); i, j, k = @index(Global, NTuple); @inbounds data1[i, j, k] = operand1[i, j, k]; @inbounds data2[i, j, k] = operand2[i, j, k]; end; ```. There should also be a way to generalize to the nth case using some `ntuple` magic. (Note that we tried this with tracer kernels previously without obtaining any speed up, but overlapping `ComputedField`s could be a more promising application of this technique.). # Using `mapreduce` for averaging `AbstractOperations`. We also might be able to apply `mapreduce` directly to `AbstractOperati",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800583803:137,Energy Efficiency,efficient,efficient,137,"> The library computes the derivatives that are required to compute the tendencies, but they are not stored since that would not be very efficient. Oh yeah, for sure! The idea is that they would be stored only if the user specified interest in them. That way instead of calculating twice and storing once, the code would calculate and store once. The default behavior still would be calculating and not storing though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800583803
https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800597659:1004,Modifiability,refactor,refactoring,1004,"> That's a really cool idea. I can see how we could do that with KernelComputedFields, but I can't really see how to do it for ComputedFields. I think we understand how to write a `compute!` function that fuses the kernels for multiple `ComputedField`s or `KernelComputedField`s. But the harder part is designing an API that implements fusion for an output writer. We might need to add a property called something like `fused_compute` to both `OutputWriter`s. For example, `JLD2OutputWriter` fetches output in a loop:. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/OutputWriters/jld2_output_writer.jl#L195-L196. where `fetch_and_convert_output` calls `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/OutputWriters/fetch_output.jl#L13-L16. which in turn calls `compute_at!`. But we want to trigger _one_ call to `compute_at!` for all the outputs at the same time ... I think ... so that requires some refactoring and API design.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800597659
https://github.com/CliMA/Oceananigans.jl/pull/1484#issuecomment-800523987:33,Testability,test,tests,33,The implicit free surface solver tests are also failing on the main branch: https://buildkite.com/clima/oceananigans/builds/1644 but this seems like it would be a trivial fix.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1484#issuecomment-800523987
https://github.com/CliMA/Oceananigans.jl/pull/1484#issuecomment-800549709:209,Integrability,depend,depend,209,"It seems reasonable to add `architecture` to `AbstractField`. I think we actually might need this to make `AbstractOperations` work generically on distributed systems (in particular, `AbstractOperations` that depend on `Field`s or `ComputedField`s).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1484#issuecomment-800549709
https://github.com/CliMA/Oceananigans.jl/pull/1485#issuecomment-903978139:9,Modifiability,refactor,refactoring,9,"We'll be refactoring the way grids and architectures work soon, so this PR isn't needed anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1485#issuecomment-903978139
https://github.com/CliMA/Oceananigans.jl/pull/1487#issuecomment-800738324:21,Testability,test,test,21,"> Definitely agree a test would be good but I'm working on a PR that tests output for different grids in more detail so I could cover it there. . That's okay by me. All I did was fix a bug so, even if we don't test this right now, the change is still positive. And you could do it in time for 0.53.2. Let's wait to see if your change fixes the tests!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1487#issuecomment-800738324
https://github.com/CliMA/Oceananigans.jl/pull/1487#issuecomment-800738324:69,Testability,test,tests,69,"> Definitely agree a test would be good but I'm working on a PR that tests output for different grids in more detail so I could cover it there. . That's okay by me. All I did was fix a bug so, even if we don't test this right now, the change is still positive. And you could do it in time for 0.53.2. Let's wait to see if your change fixes the tests!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1487#issuecomment-800738324
https://github.com/CliMA/Oceananigans.jl/pull/1487#issuecomment-800738324:210,Testability,test,test,210,"> Definitely agree a test would be good but I'm working on a PR that tests output for different grids in more detail so I could cover it there. . That's okay by me. All I did was fix a bug so, even if we don't test this right now, the change is still positive. And you could do it in time for 0.53.2. Let's wait to see if your change fixes the tests!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1487#issuecomment-800738324
https://github.com/CliMA/Oceananigans.jl/pull/1487#issuecomment-800738324:344,Testability,test,tests,344,"> Definitely agree a test would be good but I'm working on a PR that tests output for different grids in more detail so I could cover it there. . That's okay by me. All I did was fix a bug so, even if we don't test this right now, the change is still positive. And you could do it in time for 0.53.2. Let's wait to see if your change fixes the tests!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1487#issuecomment-800738324
https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587:275,Modifiability,parameteriz,parameterization,275,"I think we should do 1. and 2., keeping them separate. On Wed, Mar 17, 2021, 8:53 PM Ali Ramadhan ***@***.***> wrote:. > Some time ago @sandreza <https://github.com/sandreza> and @xiaozhour; > <https://github.com/xiaozhour> suggested it would be useful to add the; > GM-Redi parameterization to Oceananigans.jl since we may want to train; > mesoscale eddy parameterizations.; >; > I'm opening this issue to discuss on what exactly needs to be implemented.; > My main reference is; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html; >; > It seems that there are three different new closures that could; > potentially be added:; >; > 1. Redi (symmetric) tensor diffusivity.; > 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; > 3. GM-Redi combining the two.; >; > Note: @glwagner <https://github.com/glwagner> has already implemented; > parts of the Redi tensor and GM for TwoDimensionalLeith so GM-Redi might; > not need too much extra work:; > https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl; > Questions/proposal; >; > 1. Do we make the small-angle approximation? I would say yes.; >; > In Oceananigans.jl right now each component of the tensor diffusivity is; > calculated on-the-fly so the unapproximated tensor could end up being 2-4x; > more expensive to compute. We cannot compute the full tensor in one go; > (reusing the isopycnal slopes) and we may not want to since it takes up a; > lot of memory (9 extra field?). But maybe there's a good reason to not make; > the small-angle approximation? We could eventually support both; > (unapproximated and small-angle approximation).; >; > See; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion; > for a comparison of the two.; >; > 1. Is GM-Redi the main parameterization of interest? Would people use; > the fully symmetric or the fully anti-symmetric diffusivity tensor by; > themsel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587
https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587:356,Modifiability,parameteriz,parameterizations,356,"I think we should do 1. and 2., keeping them separate. On Wed, Mar 17, 2021, 8:53 PM Ali Ramadhan ***@***.***> wrote:. > Some time ago @sandreza <https://github.com/sandreza> and @xiaozhour; > <https://github.com/xiaozhour> suggested it would be useful to add the; > GM-Redi parameterization to Oceananigans.jl since we may want to train; > mesoscale eddy parameterizations.; >; > I'm opening this issue to discuss on what exactly needs to be implemented.; > My main reference is; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html; >; > It seems that there are three different new closures that could; > potentially be added:; >; > 1. Redi (symmetric) tensor diffusivity.; > 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; > 3. GM-Redi combining the two.; >; > Note: @glwagner <https://github.com/glwagner> has already implemented; > parts of the Redi tensor and GM for TwoDimensionalLeith so GM-Redi might; > not need too much extra work:; > https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl; > Questions/proposal; >; > 1. Do we make the small-angle approximation? I would say yes.; >; > In Oceananigans.jl right now each component of the tensor diffusivity is; > calculated on-the-fly so the unapproximated tensor could end up being 2-4x; > more expensive to compute. We cannot compute the full tensor in one go; > (reusing the isopycnal slopes) and we may not want to since it takes up a; > lot of memory (9 extra field?). But maybe there's a good reason to not make; > the small-angle approximation? We could eventually support both; > (unapproximated and small-angle approximation).; >; > See; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion; > for a comparison of the two.; >; > 1. Is GM-Redi the main parameterization of interest? Would people use; > the fully symmetric or the fully anti-symmetric diffusivity tensor by; > themsel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587
https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587:1871,Modifiability,parameteriz,parameterization,1871,"the Redi tensor and GM for TwoDimensionalLeith so GM-Redi might; > not need too much extra work:; > https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl; > Questions/proposal; >; > 1. Do we make the small-angle approximation? I would say yes.; >; > In Oceananigans.jl right now each component of the tensor diffusivity is; > calculated on-the-fly so the unapproximated tensor could end up being 2-4x; > more expensive to compute. We cannot compute the full tensor in one go; > (reusing the isopycnal slopes) and we may not want to since it takes up a; > lot of memory (9 extra field?). But maybe there's a good reason to not make; > the small-angle approximation? We could eventually support both; > (unapproximated and small-angle approximation).; >; > See; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion; > for a comparison of the two.; >; > 1. Is GM-Redi the main parameterization of interest? Would people use; > the fully symmetric or the fully anti-symmetric diffusivity tensor by; > themselves?; >; > If not then maybe we can save some time by just implementing one new; > closure, GMRedi or GentMcWilliamsRedi. If we take the isopycnal; > diffusivity to be the same for both the symmetric and anti-symmetric tensor; > then we the resulting tensor is quite cheap to compute (only 3 components); > if performance is important:; >; > From; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#griffies-skew-flux; > [image: image]; > <https://user-images.githubusercontent.com/20099589/111556957-1abbeb80-8762-11eb-9fb3-870d447efa5f.png>; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1492>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT2T2NK46W7G7ZS5ULTEFFH5ANCNFSM4ZLUCVJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587
https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587:2311,Performance,perform,performance,2311,"the Redi tensor and GM for TwoDimensionalLeith so GM-Redi might; > not need too much extra work:; > https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl; > Questions/proposal; >; > 1. Do we make the small-angle approximation? I would say yes.; >; > In Oceananigans.jl right now each component of the tensor diffusivity is; > calculated on-the-fly so the unapproximated tensor could end up being 2-4x; > more expensive to compute. We cannot compute the full tensor in one go; > (reusing the isopycnal slopes) and we may not want to since it takes up a; > lot of memory (9 extra field?). But maybe there's a good reason to not make; > the small-angle approximation? We could eventually support both; > (unapproximated and small-angle approximation).; >; > See; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion; > for a comparison of the two.; >; > 1. Is GM-Redi the main parameterization of interest? Would people use; > the fully symmetric or the fully anti-symmetric diffusivity tensor by; > themselves?; >; > If not then maybe we can save some time by just implementing one new; > closure, GMRedi or GentMcWilliamsRedi. If we take the isopycnal; > diffusivity to be the same for both the symmetric and anti-symmetric tensor; > then we the resulting tensor is quite cheap to compute (only 3 components); > if performance is important:; >; > From; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#griffies-skew-flux; > [image: image]; > <https://user-images.githubusercontent.com/20099589/111556957-1abbeb80-8762-11eb-9fb3-870d447efa5f.png>; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1492>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT2T2NK46W7G7ZS5ULTEFFH5ANCNFSM4ZLUCVJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801617027:97,Security,validat,validation,97,There's a preliminary implementation here:. https://github.com/CliMA/Oceananigans.jl/blob/master/validation/bickley_jet/disk_time_series.jl. It's used for plotting the Bickley jet here:. https://github.com/CliMA/Oceananigans.jl/blob/62c8abb1f39fb2f4fd24e274165ee2765e130933/validation/bickley_jet/bickley_jet.jl#L142-L159. The principal change that's needed for `JLD2OutputWriter` is to serialize a bit more information. This is done manually for the Bickley jet:. https://github.com/CliMA/Oceananigans.jl/blob/62c8abb1f39fb2f4fd24e274165ee2765e130933/validation/bickley_jet/bickley_jet.jl#L101-L107. but it would be easy to implement saving this kind of metadata as a default.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801617027
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801617027:274,Security,validat,validation,274,There's a preliminary implementation here:. https://github.com/CliMA/Oceananigans.jl/blob/master/validation/bickley_jet/disk_time_series.jl. It's used for plotting the Bickley jet here:. https://github.com/CliMA/Oceananigans.jl/blob/62c8abb1f39fb2f4fd24e274165ee2765e130933/validation/bickley_jet/bickley_jet.jl#L142-L159. The principal change that's needed for `JLD2OutputWriter` is to serialize a bit more information. This is done manually for the Bickley jet:. https://github.com/CliMA/Oceananigans.jl/blob/62c8abb1f39fb2f4fd24e274165ee2765e130933/validation/bickley_jet/bickley_jet.jl#L101-L107. but it would be easy to implement saving this kind of metadata as a default.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801617027
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801617027:552,Security,validat,validation,552,There's a preliminary implementation here:. https://github.com/CliMA/Oceananigans.jl/blob/master/validation/bickley_jet/disk_time_series.jl. It's used for plotting the Bickley jet here:. https://github.com/CliMA/Oceananigans.jl/blob/62c8abb1f39fb2f4fd24e274165ee2765e130933/validation/bickley_jet/bickley_jet.jl#L142-L159. The principal change that's needed for `JLD2OutputWriter` is to serialize a bit more information. This is done manually for the Bickley jet:. https://github.com/CliMA/Oceananigans.jl/blob/62c8abb1f39fb2f4fd24e274165ee2765e130933/validation/bickley_jet/bickley_jet.jl#L101-L107. but it would be easy to implement saving this kind of metadata as a default.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801617027
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801936801:57,Deployability,integrat,integrate,57,Ah that looks quite nice. Would it make sense to try and integrate `DiskTimeSeries` with a `DimensionalData.DimArray` to get named axis behavior?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801936801
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801936801:57,Integrability,integrat,integrate,57,Ah that looks quite nice. Would it make sense to try and integrate `DiskTimeSeries` with a `DimensionalData.DimArray` to get named axis behavior?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801936801
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801953852:37,Deployability,integrat,integrate,37,@ali-ramadhan that sounds neat! Also integrate DimArray with AbstractField so the spatial dimensions can also be named? That might be the first thing to do; then we just have to add Time to DiskTimeSeries. You are a lot more familiar with DimArray so whatever makes sense.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801953852
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801953852:37,Integrability,integrat,integrate,37,@ali-ramadhan that sounds neat! Also integrate DimArray with AbstractField so the spatial dimensions can also be named? That might be the first thing to do; then we just have to add Time to DiskTimeSeries. You are a lot more familiar with DimArray so whatever makes sense.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801953852
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405:103,Integrability,depend,depending,103,"The main advantage of having `DiskTimeSeries` in `Oceananigans` would be to use it in examples without depending on another package. I think the implementation of `DiskTimeSeries` is light. It also _requires_ certain features (for example, location metadata must be saved by `JLD2OutputWriter` for `DiskTimeSeries` to work). This tight coupling between `DiskTimeSeries` and `OutputWriters` could motivate including `DiskTimeSeries` in `Oceananigans.jl`. Other aspects of analyzing Oceananigans data might be more appropriate in another package. I'm not exactly sure what specific features are up for debate in this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405:336,Modifiability,coupling,coupling,336,"The main advantage of having `DiskTimeSeries` in `Oceananigans` would be to use it in examples without depending on another package. I think the implementation of `DiskTimeSeries` is light. It also _requires_ certain features (for example, location metadata must be saved by `JLD2OutputWriter` for `DiskTimeSeries` to work). This tight coupling between `DiskTimeSeries` and `OutputWriters` could motivate including `DiskTimeSeries` in `Oceananigans.jl`. Other aspects of analyzing Oceananigans data might be more appropriate in another package. I'm not exactly sure what specific features are up for debate in this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908:1043,Energy Efficiency,power,powerful,1043,"> The main advantage of having DiskTimeSeries in Oceananigans would be to use it in examples without depending on another package. I'm not sure what `DiskTimeSeries` specifically is, I guess I missed that discussion, so take my comments with a grain of salt. But I don't think Oceananigans examples depending on other packages is necessarily a bad thing. In fact I see it as a good thing. . Right now there is at least one package, possibly two (LESbrary.jl and Oceanostics.jl) that can make the user's life easier when running Oceananigans. At the moment, there is no way for the user to find out that these packages exist, unless they joined the slack or stumbled upon them in an Oceananigans issue (unless I missed something in the docs). I also bet there are many other useful Julia packages that could make one's life easier in Oeananigans that I and many users have never used or heard of. I think including these packages in at least some examples would encourage users to experiment and explore. One of the advantages of python is its powerful ecosystem of packages, and I guess this could be the start of something similar for physical oceanographers in Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908:101,Integrability,depend,depending,101,"> The main advantage of having DiskTimeSeries in Oceananigans would be to use it in examples without depending on another package. I'm not sure what `DiskTimeSeries` specifically is, I guess I missed that discussion, so take my comments with a grain of salt. But I don't think Oceananigans examples depending on other packages is necessarily a bad thing. In fact I see it as a good thing. . Right now there is at least one package, possibly two (LESbrary.jl and Oceanostics.jl) that can make the user's life easier when running Oceananigans. At the moment, there is no way for the user to find out that these packages exist, unless they joined the slack or stumbled upon them in an Oceananigans issue (unless I missed something in the docs). I also bet there are many other useful Julia packages that could make one's life easier in Oeananigans that I and many users have never used or heard of. I think including these packages in at least some examples would encourage users to experiment and explore. One of the advantages of python is its powerful ecosystem of packages, and I guess this could be the start of something similar for physical oceanographers in Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908:299,Integrability,depend,depending,299,"> The main advantage of having DiskTimeSeries in Oceananigans would be to use it in examples without depending on another package. I'm not sure what `DiskTimeSeries` specifically is, I guess I missed that discussion, so take my comments with a grain of salt. But I don't think Oceananigans examples depending on other packages is necessarily a bad thing. In fact I see it as a good thing. . Right now there is at least one package, possibly two (LESbrary.jl and Oceanostics.jl) that can make the user's life easier when running Oceananigans. At the moment, there is no way for the user to find out that these packages exist, unless they joined the slack or stumbled upon them in an Oceananigans issue (unless I missed something in the docs). I also bet there are many other useful Julia packages that could make one's life easier in Oeananigans that I and many users have never used or heard of. I think including these packages in at least some examples would encourage users to experiment and explore. One of the advantages of python is its powerful ecosystem of packages, and I guess this could be the start of something similar for physical oceanographers in Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810488923:149,Energy Efficiency,power,powerful,149,"> I think including these packages in at least some examples would encourage users to experiment and explore. One of the advantages of python is its powerful ecosystem of packages, and I guess this could be the start of something similar for physical oceanographers in Julia. That's a fair point that we can use any external packages we like in examples. I guess my question is whether `DiskTimeSeries` itself warrants an independent package. I think perhaps a more logical division of packages would move the entire Grid + Field + Operators + AbstractOperations framework for finite volume calculations outside of Oceananigans. Then Oceananigans would be devoted purely to ocean-specific physics and modeling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810488923
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810488923:466,Testability,log,logical,466,"> I think including these packages in at least some examples would encourage users to experiment and explore. One of the advantages of python is its powerful ecosystem of packages, and I guess this could be the start of something similar for physical oceanographers in Julia. That's a fair point that we can use any external packages we like in examples. I guess my question is whether `DiskTimeSeries` itself warrants an independent package. I think perhaps a more logical division of packages would move the entire Grid + Field + Operators + AbstractOperations framework for finite volume calculations outside of Oceananigans. Then Oceananigans would be devoted purely to ocean-specific physics and modeling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810488923
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-821749204:525,Energy Efficiency,Reduce,ReducedField,525,"Couple thoughts from a discussion with @ali-ramadhan today:. To get `DiskTimeSeries` working with `JLD2OutputWriter`, we'll need to 1) serialize the grid (mostly for convenience...) and 2) serialize ""meta"" for fields by adding lines like. ```julia; file[""serialized/grid""] = model.grid. for (i, out) in enumerate(outputs); field_name = keys(outputs)[i]; out isa AbstractField && (file[""timeseries/$field_name/meta/location""] = location(out)); end; ```. to the `JLD2OutputWriter` constructor. We need a bit of extra work for `ReducedField`... though on second though it might be easier to build this logic into `DiskTimeSeries`. Some logic for serializing boundary conditions might be nice too (sometimes, but not always possible). This, plus changing the default `FieldSlicer` to `nothing`, are the primary changes that's needed for `JLD2OutputWriter`, I think. For `NetCDFOutputWriter`, the field location needs to be saved as a string in the field's attributes. I think we have what we need to reconstruct the grid otherwise. @ali-ramadhan can comment. I think we also want to make the default `field_slicer` to `nothing` so that the framework is friendly. The broadcasting infrastructure being developed on #1596 will make analysis with Oceananigans fields even nicer (since we can bypass `ComputedField` and launch kernels / make computations immediately via julia's broadcasting syntax).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-821749204
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-821749204:599,Testability,log,logic,599,"Couple thoughts from a discussion with @ali-ramadhan today:. To get `DiskTimeSeries` working with `JLD2OutputWriter`, we'll need to 1) serialize the grid (mostly for convenience...) and 2) serialize ""meta"" for fields by adding lines like. ```julia; file[""serialized/grid""] = model.grid. for (i, out) in enumerate(outputs); field_name = keys(outputs)[i]; out isa AbstractField && (file[""timeseries/$field_name/meta/location""] = location(out)); end; ```. to the `JLD2OutputWriter` constructor. We need a bit of extra work for `ReducedField`... though on second though it might be easier to build this logic into `DiskTimeSeries`. Some logic for serializing boundary conditions might be nice too (sometimes, but not always possible). This, plus changing the default `FieldSlicer` to `nothing`, are the primary changes that's needed for `JLD2OutputWriter`, I think. For `NetCDFOutputWriter`, the field location needs to be saved as a string in the field's attributes. I think we have what we need to reconstruct the grid otherwise. @ali-ramadhan can comment. I think we also want to make the default `field_slicer` to `nothing` so that the framework is friendly. The broadcasting infrastructure being developed on #1596 will make analysis with Oceananigans fields even nicer (since we can bypass `ComputedField` and launch kernels / make computations immediately via julia's broadcasting syntax).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-821749204
https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-821749204:633,Testability,log,logic,633,"Couple thoughts from a discussion with @ali-ramadhan today:. To get `DiskTimeSeries` working with `JLD2OutputWriter`, we'll need to 1) serialize the grid (mostly for convenience...) and 2) serialize ""meta"" for fields by adding lines like. ```julia; file[""serialized/grid""] = model.grid. for (i, out) in enumerate(outputs); field_name = keys(outputs)[i]; out isa AbstractField && (file[""timeseries/$field_name/meta/location""] = location(out)); end; ```. to the `JLD2OutputWriter` constructor. We need a bit of extra work for `ReducedField`... though on second though it might be easier to build this logic into `DiskTimeSeries`. Some logic for serializing boundary conditions might be nice too (sometimes, but not always possible). This, plus changing the default `FieldSlicer` to `nothing`, are the primary changes that's needed for `JLD2OutputWriter`, I think. For `NetCDFOutputWriter`, the field location needs to be saved as a string in the field's attributes. I think we have what we need to reconstruct the grid otherwise. @ali-ramadhan can comment. I think we also want to make the default `field_slicer` to `nothing` so that the framework is friendly. The broadcasting infrastructure being developed on #1596 will make analysis with Oceananigans fields even nicer (since we can bypass `ComputedField` and launch kernels / make computations immediately via julia's broadcasting syntax).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-821749204
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802250849:150,Usability,simpl,simply,150,"Good! :); If it runs, then before merging just add a remark before saying ""We construct the model to run on GPU by `architectures=...`; to run on CPU simply change to `architecture = CPU()`.""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802250849
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:76,Availability,error,error,76,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:159,Availability,ERROR,ERROR,159,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:203,Availability,error,error,203,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:254,Availability,error,error,254,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:275,Availability,error,error,275,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:1444,Availability,Error,Error,1444,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:82,Integrability,message,message,82,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:166,Performance,Load,LoadError,166,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802273792:99,Energy Efficiency,efficient,efficient,99,"If @ali-ramadhan wants us to try this but I'm tempted to say we save this for another PR. If it is efficient to use GPUs then we probably want to change more than one, but I'm fine with anything really.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802273792
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802307902:317,Deployability,pipeline,pipeline,317,Ah sorry for the slow reply. Docs build on `tartarus.mit.edu` through Buildkite which has GPUs but we disable the GPU through the Buildkite config. I think if we just remove this line we can build examples on the GPU!. https://github.com/CliMA/Oceananigans.jl/blob/81d9c0e061cae4aa5a0ec770ff8348be7517aa53/.buildkite/pipeline.yml#L324. Doesn't have to happen in this PR of course.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802307902
https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802307902:140,Modifiability,config,config,140,Ah sorry for the slow reply. Docs build on `tartarus.mit.edu` through Buildkite which has GPUs but we disable the GPU through the Buildkite config. I think if we just remove this line we can build examples on the GPU!. https://github.com/CliMA/Oceananigans.jl/blob/81d9c0e061cae4aa5a0ec770ff8348be7517aa53/.buildkite/pipeline.yml#L324. Doesn't have to happen in this PR of course.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802307902
https://github.com/CliMA/Oceananigans.jl/issues/1496#issuecomment-802026091:73,Availability,down,down,73,"Interesting problem. I guess in the standard case, we know gravity poins down but usually have a negative in the buoyancy term and then define the unit vector to be upwards `(0,0,1)`. I agree that to be consistent with convention, picking the `gravitational_unit_vector` to be antiparallel to the gravitation force, makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1496#issuecomment-802026091
https://github.com/CliMA/Oceananigans.jl/issues/1496#issuecomment-802037770:190,Usability,simpl,simple,190,"> That'd be a nice name, but alas we may want to apply the same terminology to the Coriolis force, since it would also need to be rotated with the domain. Yeah, I'm all in favor of having a simple name that is unified for `FPlane()` and `Buoyancy()`. My vote goes to `vertical_unit_vector`, as it is intuitive and works for both (with the trade-off that the vertical direction doesn't always align perfectly with the geopotential normal, but I think that's okay). I'll make the PR as soon as we agree on a name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1496#issuecomment-802037770
https://github.com/CliMA/Oceananigans.jl/issues/1496#issuecomment-802037770:300,Usability,intuit,intuitive,300,"> That'd be a nice name, but alas we may want to apply the same terminology to the Coriolis force, since it would also need to be rotated with the domain. Yeah, I'm all in favor of having a simple name that is unified for `FPlane()` and `Buoyancy()`. My vote goes to `vertical_unit_vector`, as it is intuitive and works for both (with the trade-off that the vertical direction doesn't always align perfectly with the geopotential normal, but I think that's okay). I'll make the PR as soon as we agree on a name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1496#issuecomment-802037770
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:96,Availability,down,download,96,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:232,Availability,avail,available,232,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:13,Performance,optimiz,optimizing,13,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:202,Performance,optimiz,optimized,202,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:532,Performance,optimiz,optimized,532,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:576,Performance,perform,performance,576,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:638,Security,expose,exposed,638,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811204289:173,Usability,simpl,simply,173,"Thanks @maleadt! I didn't know about `Base.mapreducedim`. Will look into using it when I revisit this PR!. > I don't see any problem with this but as a user, since both are simply estiamtes (we need to pick a scaling factor in both cases) I am probably more inclined to pick the faster more conservative estimate, but why not give the user the choice and they can decide?. Yes definitely agree. The default can be the very fast `cell_advection_timescale` function while this PR can add a new `accurate_cell_advection_timescale`. The main use for `accurate_cell_advection_timescale` will be for curvilinear grids where a fast method is probably too conservative or for when you want an accurate CFL diagnostic. I've been using it on the cubed sphere in PR #1522 and it seems to work great fast enough on the CPU. > @ali-ramadhan can you explain in greater detail why this problem requires nested calls to mapreduce?. Yes. We essentially want to `mapreduce` over operations like `w / Δz` but `w` and `Δz` need to have the same size for `mapreduce` to work on multiple iterators (`w` and `Δz`). They have different sizes on all grids right now. Only way I could figure out how to do it using just `mapreduce` was to do an ""inner `mapreduce`"" where e.g. `w[i, j, :]` and `Δz` have the same size and the ""outer `mapreduce`"" iterates over the other dimensions. So we would also need slightly different `mapreduce` implementations for the different grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811204289
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811437698:230,Energy Efficiency,reduce,reduced,230,> Yes. We essentially want to mapreduce over operations like w / Δz but w and Δz need to have the same size for mapreduce to work on multiple iterators (w and Δz). They have different sizes on all grids right now. Can we wrap the reduced objects somehow so that the iterators for both objects match?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811437698
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811437698:221,Integrability,wrap,wrap,221,> Yes. We essentially want to mapreduce over operations like w / Δz but w and Δz need to have the same size for mapreduce to work on multiple iterators (w and Δz). They have different sizes on all grids right now. Can we wrap the reduced objects somehow so that the iterators for both objects match?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811437698
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984:18,Energy Efficiency,reduce,reduced,18,> Can we wrap the reduced objects somehow so that the iterators for both objects match?. That should work. Could be done with a new `Field` type?. Would you object to merging this PR in it's current form though? It's an optional feature that works for curvilinear grids and is tested. It's been helpful for debugging cubed sphere validation experiments so I'm using it in PR #1522.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984:9,Integrability,wrap,wrap,9,> Can we wrap the reduced objects somehow so that the iterators for both objects match?. That should work. Could be done with a new `Field` type?. Would you object to merging this PR in it's current form though? It's an optional feature that works for curvilinear grids and is tested. It's been helpful for debugging cubed sphere validation experiments so I'm using it in PR #1522.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984:330,Security,validat,validation,330,> Can we wrap the reduced objects somehow so that the iterators for both objects match?. That should work. Could be done with a new `Field` type?. Would you object to merging this PR in it's current form though? It's an optional feature that works for curvilinear grids and is tested. It's been helpful for debugging cubed sphere validation experiments so I'm using it in PR #1522.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984
https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984:277,Testability,test,tested,277,> Can we wrap the reduced objects somehow so that the iterators for both objects match?. That should work. Could be done with a new `Field` type?. Would you object to merging this PR in it's current form though? It's an optional feature that works for curvilinear grids and is tested. It's been helpful for debugging cubed sphere validation experiments so I'm using it in PR #1522.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-802876917:129,Deployability,update,updated,129,@francispoulin I'll do that as soon as I have something that I know it's right. So far the results aren't exactly as expected (I updated the PR heading to give a better description of what's missing!),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-802876917
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-802879976:62,Security,access,access,62,"This is a link to the PDF, in case someone does not have easy access to JPO. https://www.researchgate.net/publication/341332653_Centrifugal_and_Symmetric_Instability_during_Ekman_Adjustment_of_the_Bottom_Boundary_Layer",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-802879976
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-802887219:131,Deployability,update,updated,131,> @francispoulin I'll do that as soon as I have something that I know it's right. So far the results aren't exactly as expected (I updated the PR heading to give a better description of what's missing!). If you show us a simulation maybe that might help to give a clue as to what's not working correctly?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-802887219
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885034251:48,Availability,down,down,48,"Movies look very nice! If we have fluid falling down the slope, to the left, I think it's reasoanble to expect it to start to the right. Because it's periodic that makes things a little complicated because the fluid falls out through the left and then enters in on the right. . Out of curiosity, would it be possible to try this with `Bounded` in `x`? I wonder what that would look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885034251
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885039992:212,Testability,test,test,212,"> Out of curiosity, would it be possible to try this with Bounded in x? I wonder what that would look like. I think it would, although I'm not sure if I have time to investigate that at the moment. I might run a test like that my next free evening :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885039992
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885050727:27,Availability,down,down,27,"> If we have fluid falling down the slope, to the left, I think it's reasoanble to expect it to start to the right. Because it's periodic that makes things a little complicated because the fluid falls out through the left and then enters in on the right. Keep in mind though that this isn't a gravity current, but rather Ekman transport down the slope due to a uniform along-slope velocity. My expectation would be that the downslope Ekman flow should start uniformly across the slope (not at a boundary). . > Out of curiosity, would it be possible to try this with Bounded in x? I wonder what that would look like. Here you would develop an overturning circulation up through the water column (upward branch at the left boundary, descending at the right boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885050727
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885050727:337,Availability,down,down,337,"> If we have fluid falling down the slope, to the left, I think it's reasoanble to expect it to start to the right. Because it's periodic that makes things a little complicated because the fluid falls out through the left and then enters in on the right. Keep in mind though that this isn't a gravity current, but rather Ekman transport down the slope due to a uniform along-slope velocity. My expectation would be that the downslope Ekman flow should start uniformly across the slope (not at a boundary). . > Out of curiosity, would it be possible to try this with Bounded in x? I wonder what that would look like. Here you would develop an overturning circulation up through the water column (upward branch at the left boundary, descending at the right boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885050727
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885050727:424,Availability,down,downslope,424,"> If we have fluid falling down the slope, to the left, I think it's reasoanble to expect it to start to the right. Because it's periodic that makes things a little complicated because the fluid falls out through the left and then enters in on the right. Keep in mind though that this isn't a gravity current, but rather Ekman transport down the slope due to a uniform along-slope velocity. My expectation would be that the downslope Ekman flow should start uniformly across the slope (not at a boundary). . > Out of curiosity, would it be possible to try this with Bounded in x? I wonder what that would look like. Here you would develop an overturning circulation up through the water column (upward branch at the left boundary, descending at the right boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885050727
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885166453:84,Availability,down,down,84,"> Keep in mind though that this isn't a gravity current, but rather Ekman transport down the slope due to a uniform along-slope velocity. My expectation would be that the downslope Ekman flow should start uniformly across the slope (not at a boundary). Yes, that was my thinking too. Plus, the set-up is homogeneous and periodic in the horizontal directions, so really there should be no preference in `x` for motion to start. I also can't find anything in the code that would introduce an asymmetry so I need to investigate this further in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885166453
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885166453:171,Availability,down,downslope,171,"> Keep in mind though that this isn't a gravity current, but rather Ekman transport down the slope due to a uniform along-slope velocity. My expectation would be that the downslope Ekman flow should start uniformly across the slope (not at a boundary). Yes, that was my thinking too. Plus, the set-up is homogeneous and periodic in the horizontal directions, so really there should be no preference in `x` for motion to start. I also can't find anything in the code that would introduce an asymmetry so I need to investigate this further in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885166453
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885189080:794,Usability,guid,guides,794,"> > Can you add plotting code to the example so that we can reproduce the animation?; > ; > I can, but it might take a little since I'm not at all familiar with animating in Julia. I'd have to go off of the examples in the docs. I think the horizontal convection is our most state-of-art plotting example, right? If `FieldTimeSeries` works with NetCDF output thenit should be faster :). `FieldTimeSeries` doesn't work with `NetCDFOutputWriter` (we need to design a system for saving and extracting field location for that to work). The constructors for the two output writers are almost identical so it does not take long to switch between them. With `FieldTimeSeries` you don't interact with the file so you don't need to know anything about JLD2 in particular. I hope the examples are useful guides to animating...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885189080
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885211037:594,Availability,down,downslope,594,"> A short summary of the physics of this example and what we expect to see would be useful for helping debug issues with the setup. @wenegrat Feel free to correct / chime-in here. But here's a short summary from what I understand:. This script simulates a bottom boundary layer developing over a sloping bottom. This is simulated in a horizontally-periodic set-up (horizontally meaning parallel to the bathymetry) starting from rest with a uniform flow in the y-direction that is immediately subject to bottom drag. The interaction between flow and topography creates a bottom Ekman layer with downslope Ekman transport that crosses isobaths and advects lighter fluid under dense fluid, creating convective mixing. Furthermore, when this BBL reaches thermal wind balance (or possibly even earlier than that I guess) it also creates a region of negative potential vorticity, which is unstable to symmetric/centrifugal instabilities. So basically we expect turbulence at the bottom due to gravitational and symmetric/centrifugal instabilities (in addition to the some shear instabilities I guess).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885211037
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676:1394,Availability,down,downside,1394,"I think the simulation is ready and physically/numerically correct. I ran a high-reynolds-number version of this simulation and results look like those from the original paper (even quantitatively). Here's what the v-velocity and the y-vorticity look like (in this current resolution):. https://user-images.githubusercontent.com/13205162/138630652-3c1f3180-793a-42f4-8402-8ad2a921e2d7.mp4. https://user-images.githubusercontent.com/13205162/138630663-abcc59cd-0334-4037-ae92-1ece165a3536.mp4. Now the question is what to do with this. My idea was to transform this into a docs example, but I can also leave it as a validation. If it were a docs example I think this would then teach users how to:. - use the `Buoyancy()` constructor with a specified vertical direction; - use `ConstantCoriolis`, also with a specified vertical direction (these last two are mostly useful for tilted domains I think); - Possibly also how to use NetCDF output writers, which no example does for now. A few ideas that I had for the docs example which might be controversial are. - Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES).; - Use Python/xarrray to read and plot the data. The major downside of these (especially the python one) is that it would add dependencies to the docs environment. Eager to hear some thoughts. CC: @glwagner @navidcy @francispoulin @wenegrat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676:1461,Integrability,depend,dependencies,1461,"I think the simulation is ready and physically/numerically correct. I ran a high-reynolds-number version of this simulation and results look like those from the original paper (even quantitatively). Here's what the v-velocity and the y-vorticity look like (in this current resolution):. https://user-images.githubusercontent.com/13205162/138630652-3c1f3180-793a-42f4-8402-8ad2a921e2d7.mp4. https://user-images.githubusercontent.com/13205162/138630663-abcc59cd-0334-4037-ae92-1ece165a3536.mp4. Now the question is what to do with this. My idea was to transform this into a docs example, but I can also leave it as a validation. If it were a docs example I think this would then teach users how to:. - use the `Buoyancy()` constructor with a specified vertical direction; - use `ConstantCoriolis`, also with a specified vertical direction (these last two are mostly useful for tilted domains I think); - Possibly also how to use NetCDF output writers, which no example does for now. A few ideas that I had for the docs example which might be controversial are. - Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES).; - Use Python/xarrray to read and plot the data. The major downside of these (especially the python one) is that it would add dependencies to the docs environment. Eager to hear some thoughts. CC: @glwagner @navidcy @francispoulin @wenegrat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676:615,Security,validat,validation,615,"I think the simulation is ready and physically/numerically correct. I ran a high-reynolds-number version of this simulation and results look like those from the original paper (even quantitatively). Here's what the v-velocity and the y-vorticity look like (in this current resolution):. https://user-images.githubusercontent.com/13205162/138630652-3c1f3180-793a-42f4-8402-8ad2a921e2d7.mp4. https://user-images.githubusercontent.com/13205162/138630663-abcc59cd-0334-4037-ae92-1ece165a3536.mp4. Now the question is what to do with this. My idea was to transform this into a docs example, but I can also leave it as a validation. If it were a docs example I think this would then teach users how to:. - use the `Buoyancy()` constructor with a specified vertical direction; - use `ConstantCoriolis`, also with a specified vertical direction (these last two are mostly useful for tilted domains I think); - Possibly also how to use NetCDF output writers, which no example does for now. A few ideas that I had for the docs example which might be controversial are. - Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES).; - Use Python/xarrray to read and plot the data. The major downside of these (especially the python one) is that it would add dependencies to the docs environment. Eager to hear some thoughts. CC: @glwagner @navidcy @francispoulin @wenegrat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-951263873:688,Integrability,depend,depends,688,"> Those animations look great @tomchor, thanks for working so hard to put this together.; > ; > One observation is that the first plot, the velocity, shows that the initial structures are very small scale in both the horizontal and the vertical. I wonder if increasing \nu would produce an aniamtion that is better resolved?. Yes, this simulation is a bit underresolved I think. Increasing ν would definitely help. The reason I didn't do this is because when I increase it to the point that the simulation is well-resolved, then the videos become pretty boring! I'd need to increase the number of points too and then it would be too costly of a simulation for a docs example. . This also depends on the philosophy behind the docs examples. Do we want them to be simulations that absolutely hold scientific scrutiny from all fronts? If so then yeah, I should probably make it better-resolved. I see the docs example as having some wiggle room, though, as long as it teaches users something valuable. But that's obviously up for debate. > ; > As for what to do with this, you are the creator, but I would sugget creating a doc. This is a great opportunity to show the nice results and help teach people how to use different features. By creating a doc, do you mean docs example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-951263873
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953850791:369,Integrability,depend,depends,369,"> Yes, this simulation is a bit underresolved I think. Increasing ν would definitely help. The reason I didn't do this is because when I increase it to the point that the simulation is well-resolved, then the videos become pretty boring! I'd need to increase the number of points too and then it would be too costly of a simulation for a docs example.; > ; > This also depends on the philosophy behind the docs examples. Do we want them to be simulations that absolutely hold scientific scrutiny from all fronts? If so then yeah, I should probably make it better-resolved. I see the docs example as having some wiggle room, though, as long as it teaches users something valuable. But that's obviously up for debate. I think underresolution is ok; many of the examples are underresolved, mostly because we want them to be cheap. The docs examples (in my opinion) are to demonstrate code functionality; eg give users the tools and inspiration they need to set up their own experiments. . A great docs example does go above and beyond and also includes lessons about physics, style and scripting practices, and creative uses of the code. So we could imagine a docs example that illustrates the _concept_ of numerical convergence, and how to build such a test using Oceananigans. But I don't think the mere _realization_ of convergence is that helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953850791
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953850791:1251,Testability,test,test,1251,"> Yes, this simulation is a bit underresolved I think. Increasing ν would definitely help. The reason I didn't do this is because when I increase it to the point that the simulation is well-resolved, then the videos become pretty boring! I'd need to increase the number of points too and then it would be too costly of a simulation for a docs example.; > ; > This also depends on the philosophy behind the docs examples. Do we want them to be simulations that absolutely hold scientific scrutiny from all fronts? If so then yeah, I should probably make it better-resolved. I see the docs example as having some wiggle room, though, as long as it teaches users something valuable. But that's obviously up for debate. I think underresolution is ok; many of the examples are underresolved, mostly because we want them to be cheap. The docs examples (in my opinion) are to demonstrate code functionality; eg give users the tools and inspiration they need to set up their own experiments. . A great docs example does go above and beyond and also includes lessons about physics, style and scripting practices, and creative uses of the code. So we could imagine a docs example that illustrates the _concept_ of numerical convergence, and how to build such a test using Oceananigans. But I don't think the mere _realization_ of convergence is that helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953850791
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263:1280,Availability,mainten,maintenance,1280,"> * Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES). I think it's a nice idea to illustrate using `Oceanostics` for something that would be challenging for a user to implement themselves, like calculating viscous dissipation. Can we visualize dissipation and buoyancy flux, and then illustrate closing the domain-integrated TKE budget using domain-averages of those quantities?. (Note that we do illustrate interfacing with other packages like `Random`, `JLD2`, `NCDatasets`, `Plots`, etc --- but showcasing packages in our ""ecosystem"" specifically is certainly in our interest.). > * Use Python/xarrray to read and plot the data. To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain. I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263:538,Deployability,integrat,integrated,538,"> * Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES). I think it's a nice idea to illustrate using `Oceanostics` for something that would be challenging for a user to implement themselves, like calculating viscous dissipation. Can we visualize dissipation and buoyancy flux, and then illustrate closing the domain-integrated TKE budget using domain-averages of those quantities?. (Note that we do illustrate interfacing with other packages like `Random`, `JLD2`, `NCDatasets`, `Plots`, etc --- but showcasing packages in our ""ecosystem"" specifically is certainly in our interest.). > * Use Python/xarrray to read and plot the data. To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain. I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263:538,Integrability,integrat,integrated,538,"> * Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES). I think it's a nice idea to illustrate using `Oceanostics` for something that would be challenging for a user to implement themselves, like calculating viscous dissipation. Can we visualize dissipation and buoyancy flux, and then illustrate closing the domain-integrated TKE budget using domain-averages of those quantities?. (Note that we do illustrate interfacing with other packages like `Random`, `JLD2`, `NCDatasets`, `Plots`, etc --- but showcasing packages in our ""ecosystem"" specifically is certainly in our interest.). > * Use Python/xarrray to read and plot the data. To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain. I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953910752:262,Deployability,integrat,integrated,262,"> I think it's a nice idea to illustrate using `Oceanostics` for something that would be challenging for a user to implement themselves, like calculating viscous dissipation. Can we visualize dissipation and buoyancy flux, and then illustrate closing the domain-integrated TKE budget using domain-averages of those quantities?. It's definitely possible, but I think this isn't the example to do that. Since it's a tilted boundary layer, there's some extra complexity in the TKE budget. It's not a technical obstacle of anything, but it would require more explanation. I think the ocean convection example would be a much better option for a TKE budget.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953910752
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953910752:262,Integrability,integrat,integrated,262,"> I think it's a nice idea to illustrate using `Oceanostics` for something that would be challenging for a user to implement themselves, like calculating viscous dissipation. Can we visualize dissipation and buoyancy flux, and then illustrate closing the domain-integrated TKE budget using domain-averages of those quantities?. It's definitely possible, but I think this isn't the example to do that. Since it's a tilted boundary layer, there's some extra complexity in the TKE budget. It's not a technical obstacle of anything, but it would require more explanation. I think the ocean convection example would be a much better option for a TKE budget.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953910752
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953913965:433,Availability,mainten,maintenance,433,"> To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain.; > ; > I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance... Yes I think we'd need to use `Pycall`. I agree that's hard to maintain so let's not pursue that now. I still think it'd be good to show one example with `NetCDF` writer though. Here's a question: is post-processing results directly in julia (making animations, plots, etc.) using the `NetCDF` output as easy as with the `jld2` output?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953913965
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449:433,Availability,mainten,maintenance,433,"> > To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain.; > > I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...; > ; > Yes I think we'd need to use `Pycall`. I agree that's hard to maintain so let's not pursue that now.; > ; > I still think it'd be good to show one example with `NetCDF` writer though. Here's a question: is post-processing results directly in julia (making animations, plots, etc.) using the `NetCDF` output as easy as with the `jld2` output?. There's currently one example with NetCDF: https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/. I'm not totally sure what's meant by easy. If plotting arrays, then the tasks are identical. If using `FieldTimeSeries` (to perform non-trivial finite volume calculations in post-processing for example) then that isn't supported with `NetCDFOutputWriter` (this is possible, but requires someone passionate about NetCDF to put in the effort there).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449:1060,Performance,perform,perform,1060,"> > To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain.; > > I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...; > ; > Yes I think we'd need to use `Pycall`. I agree that's hard to maintain so let's not pursue that now.; > ; > I still think it'd be good to show one example with `NetCDF` writer though. Here's a question: is post-processing results directly in julia (making animations, plots, etc.) using the `NetCDF` output as easy as with the `jld2` output?. There's currently one example with NetCDF: https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/. I'm not totally sure what's meant by easy. If plotting arrays, then the tasks are identical. If using `FieldTimeSeries` (to perform non-trivial finite volume calculations in post-processing for example) then that isn't supported with `NetCDFOutputWriter` (this is possible, but requires someone passionate about NetCDF to put in the effort there).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974127562:146,Usability,simpl,simplify,146,"@tomchor do you want help with this? I'd be happy to help move this along (looks like we need to merge with master). I'm also wondering if we can simplify the setup. For example, I don't think `BackgroundField` is essential --- we can just run an initial value problem and obtain very similar physics and visualizations. I also think we can get rid of the sponge layer at the top of the domain. I think these simplifications might make the example a little easier to interpret and focus attention on the novel parts of the example (mostly, the tilting of gravity + Coriolis).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974127562
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974127562:409,Usability,simpl,simplifications,409,"@tomchor do you want help with this? I'd be happy to help move this along (looks like we need to merge with master). I'm also wondering if we can simplify the setup. For example, I don't think `BackgroundField` is essential --- we can just run an initial value problem and obtain very similar physics and visualizations. I also think we can get rid of the sponge layer at the top of the domain. I think these simplifications might make the example a little easier to interpret and focus attention on the novel parts of the example (mostly, the tilting of gravity + Coriolis).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974127562
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974301910:685,Safety,avoid,avoid,685,"> @tomchor do you want help with this? I'd be happy to help move this along (looks like we need to merge with master). I'm also wondering if we can simplify the setup. For example, I don't think `BackgroundField` is essential --- we can just run an initial value problem and obtain very similar physics and visualizations. I also think we can get rid of the sponge layer at the top of the domain. I think these simplifications might make the example a little easier to interpret and focus attention on the novel parts of the example (mostly, the tilting of gravity + Coriolis). Thanks for the offer! I'm actually making progress very slowly on this branch. I just haven't pushed it to avoid running CI (I have the feeling that the CI servers have been kinda overwhelmed lately?). But some help would definitely be nice :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974301910
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974301910:148,Usability,simpl,simplify,148,"> @tomchor do you want help with this? I'd be happy to help move this along (looks like we need to merge with master). I'm also wondering if we can simplify the setup. For example, I don't think `BackgroundField` is essential --- we can just run an initial value problem and obtain very similar physics and visualizations. I also think we can get rid of the sponge layer at the top of the domain. I think these simplifications might make the example a little easier to interpret and focus attention on the novel parts of the example (mostly, the tilting of gravity + Coriolis). Thanks for the offer! I'm actually making progress very slowly on this branch. I just haven't pushed it to avoid running CI (I have the feeling that the CI servers have been kinda overwhelmed lately?). But some help would definitely be nice :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974301910
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974301910:411,Usability,simpl,simplifications,411,"> @tomchor do you want help with this? I'd be happy to help move this along (looks like we need to merge with master). I'm also wondering if we can simplify the setup. For example, I don't think `BackgroundField` is essential --- we can just run an initial value problem and obtain very similar physics and visualizations. I also think we can get rid of the sponge layer at the top of the domain. I think these simplifications might make the example a little easier to interpret and focus attention on the novel parts of the example (mostly, the tilting of gravity + Coriolis). Thanks for the offer! I'm actually making progress very slowly on this branch. I just haven't pushed it to avoid running CI (I have the feeling that the CI servers have been kinda overwhelmed lately?). But some help would definitely be nice :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974301910
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974306630:408,Energy Efficiency,efficient,efficient,408,"Like @hdrake, I think we need a buoyancy background field to make the buoyancy (fluctuations) periodic, although we can probably get away without a background `v` field. I can try removing the sponge layer, but the last time I tried I saw significant internal wave build up. I think the reason is that centrifugal-symmetric instabilities (of which we see a lot in this BBL example) are known to particularly efficient at exciting internal waves (compared to upper ocean convection, for example). But I'll try it out and post the results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974306630
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974318893:417,Energy Efficiency,efficient,efficient,417,"> Like @hdrake, I think we need a buoyancy background field to make the buoyancy (fluctuations) periodic, although we can probably get away without a background `v` field.; > ; > I can try removing the sponge layer, but the last time I tried I saw significant internal wave build up. I think the reason is that centrifugal-symmetric instabilities (of which we see a lot in this BBL example) are known to particularly efficient at exciting internal waves (compared to upper ocean convection, for example).; > ; > But I'll try it out and post the results. Sounds good. For the other boundary layer examples we don't use a sponge layer because the simulations are fairly short, I think. I realized after talking with @xiaozhour that it probably won't be simple to remove the background velocity field. The reason is that there is an (implicit) pressure gradient that maintains the flow. So, we either have to add this pressure gradient and a matching initial condition, or we have to use a background field for the velocity (using an initial condition `v=1` will produce an inertial oscillation, not a steady flow). With that consideration, it seems like it might probably simpler to use a background field. The main annoyance is the drag boundary condition, which requires explanation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974318893
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974318893:751,Usability,simpl,simple,751,"> Like @hdrake, I think we need a buoyancy background field to make the buoyancy (fluctuations) periodic, although we can probably get away without a background `v` field.; > ; > I can try removing the sponge layer, but the last time I tried I saw significant internal wave build up. I think the reason is that centrifugal-symmetric instabilities (of which we see a lot in this BBL example) are known to particularly efficient at exciting internal waves (compared to upper ocean convection, for example).; > ; > But I'll try it out and post the results. Sounds good. For the other boundary layer examples we don't use a sponge layer because the simulations are fairly short, I think. I realized after talking with @xiaozhour that it probably won't be simple to remove the background velocity field. The reason is that there is an (implicit) pressure gradient that maintains the flow. So, we either have to add this pressure gradient and a matching initial condition, or we have to use a background field for the velocity (using an initial condition `v=1` will produce an inertial oscillation, not a steady flow). With that consideration, it seems like it might probably simpler to use a background field. The main annoyance is the drag boundary condition, which requires explanation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974318893
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974318893:1170,Usability,simpl,simpler,1170,"> Like @hdrake, I think we need a buoyancy background field to make the buoyancy (fluctuations) periodic, although we can probably get away without a background `v` field.; > ; > I can try removing the sponge layer, but the last time I tried I saw significant internal wave build up. I think the reason is that centrifugal-symmetric instabilities (of which we see a lot in this BBL example) are known to particularly efficient at exciting internal waves (compared to upper ocean convection, for example).; > ; > But I'll try it out and post the results. Sounds good. For the other boundary layer examples we don't use a sponge layer because the simulations are fairly short, I think. I realized after talking with @xiaozhour that it probably won't be simple to remove the background velocity field. The reason is that there is an (implicit) pressure gradient that maintains the flow. So, we either have to add this pressure gradient and a matching initial condition, or we have to use a background field for the velocity (using an initial condition `v=1` will produce an inertial oscillation, not a steady flow). With that consideration, it seems like it might probably simpler to use a background field. The main annoyance is the drag boundary condition, which requires explanation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974318893
https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974338816:138,Testability,test,tested,138,"It turns out that results look OK without a sponge layer. I think because this is a viscous DNS, so the fluctuations get dampened (when I tested this, I did it with a LES). Here's the vorticity field without the sponge layer:. https://user-images.githubusercontent.com/13205162/142678582-00f6deb0-6376-4e7d-a15a-d378026a6b82.mp4. In hindsight I also agree with @glwagner's point about `v` being a background field. It would most likely create inertial oscillations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974338816
https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292:143,Modifiability,extend,extend,143,"I have a start to this soon to be PR (I hope) but nothing working yet. . One issue that comes up is that `automatic_halo_sizing.jl` should not extend the halo if the topology is flat This is easy enough to set this up in principle, however, when I try telling it what `Flat` means using the following `using Oceananigans.Grids: Flat`, it fails. . How should I load `Flat` at this stage?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292
https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292:360,Performance,load,load,360,"I have a start to this soon to be PR (I hope) but nothing working yet. . One issue that comes up is that `automatic_halo_sizing.jl` should not extend the halo if the topology is flat This is easy enough to set this up in principle, however, when I try telling it what `Flat` means using the following `using Oceananigans.Grids: Flat`, it fails. . How should I load `Flat` at this stage?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292
https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-804501731:597,Availability,error,error,597,"The code for setting up `RegularRectilinearGrid` with a `Flat` dimension should be in place. The issues being resolved on #1024 are associated with finite volume operations; for example if the grid spacing is 0 in the vertical, then the rectilinear volume is zero. This leads to 0/0 and thus NaNs for the operators used in `IncompressibleModel`. For `ShallowWaterModel` the situation is different because different operators are used. Presumably there are fewer issues with `ShallowWaterModel`. @francispoulin can you please try to use `Flat` in one of the shallow water examples and tell us what error you get, or if you get NaNs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-804501731
https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-804528710:403,Deployability,Update,Update,403,"Thanks @glwagner and I have been using #1024 a whole lot in developing `fjp/flat-for-shallow-water-model`. So far the example above works for the grid part and the model part. When I run a solution I get `NaN` after the first time step when one of the fields is `Flat`. I suspect this is because the derivatives might need to be modified to account for a `Flat` dimension. I hope to know more tomorrow. Update: I have found that the tendencies for height work fine. The problems are with the advection terms in the momentum equations as well as the gradient of the height field. Each of these terms, if pressent, will cause a `NaNs`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-804528710
https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-804929696:4,Testability,test,test,4,"The test cases using a RegularRectilinearGrid and Flat. The dispatch seems to use the first one but I think we need to define the dispatch a bit differently, but I don't know how to do that. A subdispatch sounds attractive but don't know if that's really a thing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-804929696
https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-804938362:20,Usability,clear,clear,20,"Sorry for not being clear, wil try again with code. Consider the following. ```; grid = RegularRectilinearGrid(size=(4,4), extent=(1,1), topology=(Periodic,Periodic,Flat)); model = ShallowWaterModel(grid=grid, gravitational_acceleration=1); ```. The first line says we are using a `RegularRectilinearGrid` and the second line says we have `Flat` in the vertical. . The three options to compute the vertical grid spacing are the following,. ```; @inline ΔzF(i, j, k, grid::RegularRectilinearGrid) = grid.Δz; @inline ΔzF(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.Δzᵃᵃᶜ[k]; @inline ΔzF(i, j, k, grid::AbstractGrid{FT, TX, TY, Flat}) where {FT, TX, TY} = one(FT); ```; It seems like the first and third functions are both options. When I tried it, even though I had `Flat` in the vertical, it used the first and computed the spacing in the vertical to be `0` instead of `1`. This resulted in a lot of `NaNs`. I should say that I am calling it using the following syntax `ΔzF(i,j,k,grid)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-804938362
https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805032204:67,Safety,sanity check,sanity check,67,"No, the method looks correct to me. This is some kind of bug. As a sanity check, you might try defining. ```julia; @inline ΔzF(i, j, k, grid::RegularRectilinearGrid{FT, TX, TY, Flat}) where {FT, TX, TY} = one(FT); ```. However, we definitely want to get the method working for `grid::AbstractGrid{FT, TX, TY, Flat}` so that we don't have to redefine `ΔzF` for every grid type.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805032204
https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805044250:416,Usability,learn,learned,416,"> > I guess I'm not sure how the grids are defined differently in the different cases.; > ; > What do you mean?. In the three methods we seem to have three different types of grids were considering,. ```; RegularRectilinearGrid; VerticallyStretchedRectilinearGrid; AbstractGrid{FT, TX, TY, Flat}; ```. From the above, it is definitely `RegularRectilinearGrid` with a `Flat` dimension I looked at `Grids.jl` and have learned that `RegularRectilinearGrid` is of type `AbstractRectilinearGrid` and this is a subtype of `AbstractGrid. I guess this explains the hiearchy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805044250
https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805124968:522,Testability,test,tests,522,"Problem solved! @ali-ramadhan figured out that if we instead use the following then julia figures out how to dispatch correctly. ```; @inline Δx(i, j, k, grid::RegularRectilinearGrid{FT, Flat}) where FT = one(FT); @inline Δy(i, j, k, grid::RegularRectilinearGrid{FT, TX, Flat}) where {FT, TX} = one(FT); @inline ΔzC(i, j, k, grid::RegularRectilinearGrid{FT, TX, TY, Flat}) where {FT, TX, TY} = one(FT); @inline ΔzF(i, j, k, grid::RegularRectilinearGrid{FT, TX, TY, Flat}) where {FT, TX, TY} = one(FT); ```. I will do some tests, cleaning up and then push a PR to move the disucssion there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805124968
https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805147225:124,Availability,error,error,124,> Happy to say it is true!. I'm totally perplexed why dispatch seems to be failing silently. Often in these cases we get an error that a method is ambiguous. I'm stumped.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805147225
https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805147648:110,Usability,learn,learned,110,"> From the above, it is definitely RegularRectilinearGrid with a Flat dimension I looked at Grids.jl and have learned that RegularRectilinearGrid is of type AbstractRectilinearGrid and this is a subtype of `AbstractGrid. I guess this explains the hiearchy. Yes, that is the type hierarchy and why I thought the above code pattern would work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805147648
https://github.com/CliMA/Oceananigans.jl/issues/1501#issuecomment-804961658:168,Safety,avoid,avoid,168,"How about this?. ```julia; @warn ""Inflating model grid halo size to ($Hx, $Hy, $Hz) and recreating grid. "" *; ""The model grid will be different from the input grid. To avoid this warning, "" *; ""pass halo=($Hx, $Hy, $Hz) when constructing the grid.""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1501#issuecomment-804961658
https://github.com/CliMA/Oceananigans.jl/issues/1501#issuecomment-805046294:180,Safety,avoid,avoid,180,"> How about this?; > ; > ```julia; > @warn ""Inflating model grid halo size to ($Hx, $Hy, $Hz) and recreating grid. "" *; > ""The model grid will be different from the input grid. To avoid this warning, "" *; > ""pass halo=($Hx, $Hy, $Hz) when constructing the grid.""; > ```. Sounds great! I have added it in my branch. I will close this issue and we cna modify this when the branch makes its way as a PR. Soon I hope!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1501#issuecomment-805046294
https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804952861:56,Performance,multi-thread,multi-threaded,56,True. I guess we don't have a separate architecture for multi-threaded. I agree that `MPI_CPU` or `MPICPU` would be more precise. What do you think of `DistributedCPU` and `DistributedGPU`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804952861
https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804964762:484,Performance,multi-thread,multi-threaded,484,"I am happy with both names but do we need a distributed for each framework? I thought they were almost identical but don't remember the details. Francis; ________________________________; From: Ali Ramadhan ***@***.***>; Sent: Tuesday, March 23, 2021 10:34:09 AM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Author ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] `MultiCPU` or `MPI_CPU` (#1502). True. I guess we don't have a separate architecture for multi-threaded. I agree that MPI_CPU or MPICPU would be more precise. What do you think of DistributedCPU and DistributedGPU?. -; You are receiving this because you authored the thread.; Reply to this email directly, view it on GitHub<https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804952861>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB63PQIRKGMIJUKMEU5CYQTTFCRGDANCNFSM4ZUIJ5FQ>.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804964762
https://github.com/CliMA/Oceananigans.jl/pull/1504#issuecomment-805152260:44,Safety,avoid,avoid,44,"> I feel we need a more general solution to avoid boilerplate when new grids are added. If we really can't crack this problem then we can merge this as an experimental feature. But I feel we really will want many more grid types that accept stretching, curvilinearity, cubed sphere, etc. I agree that we can do better and am keen to try things out. I need to think about this a little more before I can suggest an alternative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1504#issuecomment-805152260
https://github.com/CliMA/Oceananigans.jl/pull/1504#issuecomment-805154965:158,Deployability,update,update,158,"> I agree that we can do better and am keen to try things out. I need to think about this a little more before I can suggest an alternative. We might need to update the operators so that they specify when a dimension is ""not flat"". For example, for x-spacing we need the function. ```julia; const NonFlat = Union{Periodic, Bounded}; @inline Δx(i, j, k, grid::RegularRectilinearGrid{FT, NonFlat}) where FT = grid.Δx; ```. Instead of just. ```julia; @inline Δx(i, j, k, grid::RegularRectilinearGrid) = grid.Δx; ```. Hopefully we can then dispatch on `AbstractGrid` (or `AbstractRectilinearGrid`) as in. ```julia; @inline Δx(i, j, k, grid::AbstractGrid{FT, Flat}) where FT = one(FT); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1504#issuecomment-805154965
https://github.com/CliMA/Oceananigans.jl/pull/1504#issuecomment-806235788:178,Availability,error,errors,178,"Note to @glwagner : In this PR I had changed the default halo size from 1 to 3. Unfortunately, lots of the tests have implicitly assumed the halo size is 1, hence I had over 200 errors. I have therefore changed it back to 1 I think it should be changed in a separate PR as it is not a trivial task.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1504#issuecomment-806235788
https://github.com/CliMA/Oceananigans.jl/pull/1504#issuecomment-806235788:107,Testability,test,tests,107,"Note to @glwagner : In this PR I had changed the default halo size from 1 to 3. Unfortunately, lots of the tests have implicitly assumed the halo size is 1, hence I had over 200 errors. I have therefore changed it back to 1 I think it should be changed in a separate PR as it is not a trivial task.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1504#issuecomment-806235788
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585:277,Energy Efficiency,allocate,allocated,277,Two questions:. > Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Is this one node or multiple nodes? . Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585:45,Integrability,depend,dependent,45,Two questions:. > Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Is this one node or multiple nodes? . Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539:498,Energy Efficiency,allocate,allocated,498,"> Is this one node or multiple nodes?. This is all done on one Satori node. Side note: I couldn't get the benchmark to work with 64 ranks on one Satori node even though it should have 80 ranks per node I think. Also wasn't sure of the best place to immediately benchmark up to 4 ~ 8 nodes (128 ~ 256 ranks?). Probably any old cluster would do but I didn't get a quick `srun -N 8` job allocation so I left it for later. > Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?. The memory measurement should be the amount of memory allocated during a single time step as reported by `BenchmarkTools.@benchmark`: generally I think from kernel launches, broadcasts, probably other stuff, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539:583,Energy Efficiency,allocate,allocated,583,"> Is this one node or multiple nodes?. This is all done on one Satori node. Side note: I couldn't get the benchmark to work with 64 ranks on one Satori node even though it should have 80 ranks per node I think. Also wasn't sure of the best place to immediately benchmark up to 4 ~ 8 nodes (128 ~ 256 ranks?). Probably any old cluster would do but I didn't get a quick `srun -N 8` job allocation so I left it for later. > Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?. The memory measurement should be the amount of memory allocated during a single time step as reported by `BenchmarkTools.@benchmark`: generally I think from kernel launches, broadcasts, probably other stuff, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539:106,Testability,benchmark,benchmark,106,"> Is this one node or multiple nodes?. This is all done on one Satori node. Side note: I couldn't get the benchmark to work with 64 ranks on one Satori node even though it should have 80 ranks per node I think. Also wasn't sure of the best place to immediately benchmark up to 4 ~ 8 nodes (128 ~ 256 ranks?). Probably any old cluster would do but I didn't get a quick `srun -N 8` job allocation so I left it for later. > Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?. The memory measurement should be the amount of memory allocated during a single time step as reported by `BenchmarkTools.@benchmark`: generally I think from kernel launches, broadcasts, probably other stuff, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539:261,Testability,benchmark,benchmark,261,"> Is this one node or multiple nodes?. This is all done on one Satori node. Side note: I couldn't get the benchmark to work with 64 ranks on one Satori node even though it should have 80 ranks per node I think. Also wasn't sure of the best place to immediately benchmark up to 4 ~ 8 nodes (128 ~ 256 ranks?). Probably any old cluster would do but I didn't get a quick `srun -N 8` job allocation so I left it for later. > Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?. The memory measurement should be the amount of memory allocated during a single time step as reported by `BenchmarkTools.@benchmark`: generally I think from kernel launches, broadcasts, probably other stuff, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539:635,Testability,Benchmark,BenchmarkTools,635,"> Is this one node or multiple nodes?. This is all done on one Satori node. Side note: I couldn't get the benchmark to work with 64 ranks on one Satori node even though it should have 80 ranks per node I think. Also wasn't sure of the best place to immediately benchmark up to 4 ~ 8 nodes (128 ~ 256 ranks?). Probably any old cluster would do but I didn't get a quick `srun -N 8` job allocation so I left it for later. > Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?. The memory measurement should be the amount of memory allocated during a single time step as reported by `BenchmarkTools.@benchmark`: generally I think from kernel launches, broadcasts, probably other stuff, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539:651,Testability,benchmark,benchmark,651,"> Is this one node or multiple nodes?. This is all done on one Satori node. Side note: I couldn't get the benchmark to work with 64 ranks on one Satori node even though it should have 80 ranks per node I think. Also wasn't sure of the best place to immediately benchmark up to 4 ~ 8 nodes (128 ~ 256 ranks?). Probably any old cluster would do but I didn't get a quick `srun -N 8` job allocation so I left it for later. > Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?. The memory measurement should be the amount of memory allocated during a single time step as reported by `BenchmarkTools.@benchmark`: generally I think from kernel launches, broadcasts, probably other stuff, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805921539
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805927808:72,Availability,down,down,72,"I guess if we run this on different nodes the efficiency is bound to go down, but that's a problem with the architecture I guess and not something we can change with software. Unless there is something I don't know about?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805927808
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413:74,Availability,down,down,74,"> I guess if we run this on different nodes the efficiency is bound to go down, but that's a problem with the architecture I guess and not something we can change with software. Unless there is something I don't know about?. Yeah I don't have much experience with scaling MPI but I'm guessing single-node scaling depends on your software while multi-node scaling depends more on the cluster/hardware?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413:313,Integrability,depend,depends,313,"> I guess if we run this on different nodes the efficiency is bound to go down, but that's a problem with the architecture I guess and not something we can change with software. Unless there is something I don't know about?. Yeah I don't have much experience with scaling MPI but I'm guessing single-node scaling depends on your software while multi-node scaling depends more on the cluster/hardware?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413
https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413:363,Integrability,depend,depends,363,"> I guess if we run this on different nodes the efficiency is bound to go down, but that's a problem with the architecture I guess and not something we can change with software. Unless there is something I don't know about?. Yeah I don't have much experience with scaling MPI but I'm guessing single-node scaling depends on your software while multi-node scaling depends more on the cluster/hardware?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413
https://github.com/CliMA/Oceananigans.jl/issues/1506#issuecomment-805955833:619,Integrability,depend,depends,619,"Normalizing the different grids would definitely be good if we can do it. I would also add the grid properties. Right now there's also e.g. `grid.Δx` and `grid.Δλᶜᶜᵃ`. > After starting to use `RegularLatitudeLongitudeGrid`, I see that the defualts are quite different, you need to specify latitude, longitude, and z. I guess the main limitation is that the different grids use different coordinates (which have different names). Not sure I see a way around this besides calling `longitude` `x` and `latitude` `y` etc. > Also, there is no topology option at all. Yeah for the `RegularLatitudeLongitudeGrid` the topology depends on the `longitude` bounds. I thought it made sense to make y and z `Bounded` and only make x `Periodic` if `longitude = (-180, 180)`. So then not sure what would happen if a user passes an inconsistent `topology`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1506#issuecomment-805955833
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807259095:69,Availability,error,error,69,"Hi @maeckha, could you post exactly what you try to run and what the error is? Also the output of ; ```julia; julia> using Pkg; Pkg.status(); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807259095
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:850,Availability,ERROR,ERROR,850,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:2346,Availability,error,errors,2346,"] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:15; [6] top-level scope at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; in expression starting at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; ```. So basically there are six errors starting with the lid_driven_cavity at the top level going all the way down to input_validation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:2424,Availability,down,down,2424,"] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:15; [6] top-level scope at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; in expression starting at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; ```. So basically there are six errors starting with the lid_driven_cavity at the top level going all the way down to input_validation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:154,Energy Efficiency,Adapt,Adapt,154,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:154,Modifiability,Adapt,Adapt,154,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:857,Performance,Load,LoadError,857,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:578,Safety,Safe,SafeTestsets,578,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:1985,Security,validat,validation,1985,"] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:15; [6] top-level scope at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; in expression starting at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; ```. So basically there are six errors starting with the lid_driven_cavity at the top level going all the way down to input_validation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:2121,Security,validat,validation,2121,"] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:15; [6] top-level scope at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; in expression starting at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; ```. So basically there are six errors starting with the lid_driven_cavity at the top level going all the way down to input_validation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:2260,Security,validat,validation,2260,"] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:15; [6] top-level scope at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; in expression starting at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; ```. So basically there are six errors starting with the lid_driven_cavity at the top level going all the way down to input_validation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:754,Testability,Log,Logging,754,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807385070:4,Availability,error,errors,4,The errors come up when you call Pkg.status()?. it’ll be helpful to see what exactly you try to run and getting these errors.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807385070
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807385070:118,Availability,error,errors,118,The errors come up when you call Pkg.status()?. it’ll be helpful to see what exactly you try to run and getting these errors.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807385070
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807393183:212,Availability,ERROR,ERROR,212,"I copied the output of pgk.status as per your request. The second part comes out when I am running lid_driven_cavity.jl. I run it in VS Codium. ```; julia> simulate_lid_driven_cavity(Re=100, N=128, end_time=15); ERROR: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:15; [6] top-level scope at REPL[2]:1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807393183
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807393183:1336,Security,validat,validation,1336,"I copied the output of pgk.status as per your request. The second part comes out when I am running lid_driven_cavity.jl. I run it in VS Codium. ```; julia> simulate_lid_driven_cavity(Re=100, N=128, end_time=15); ERROR: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:15; [6] top-level scope at REPL[2]:1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807393183
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807433587:42,Security,validat,validation,42,@ali-ramadhan is there anything broken in validation exps in v0.53.0?. @maeckha if you try to run some example from the docs is it all ok or similar issues?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807433587
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260:30,Availability,error,error,30,@maeckha I can reproduce your error when calling `simulate_lid_driven_cavity()`. I feel that this validation experiment was done with an older version of Oceananigans compared to the v0.53.0 are running and some things are deprecated. @ali-ramadhan might comment more on that perhaps. But the thermal bubble example from the Readme (just copy paste the code from there) runs just fine! Do you get an error with that also?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260:400,Availability,error,error,400,@maeckha I can reproduce your error when calling `simulate_lid_driven_cavity()`. I feel that this validation experiment was done with an older version of Oceananigans compared to the v0.53.0 are running and some things are deprecated. @ali-ramadhan might comment more on that perhaps. But the thermal bubble example from the Readme (just copy paste the code from there) runs just fine! Do you get an error with that also?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260:98,Security,validat,validation,98,@maeckha I can reproduce your error when calling `simulate_lid_driven_cavity()`. I feel that this validation experiment was done with an older version of Oceananigans compared to the v0.53.0 are running and some things are deprecated. @ali-ramadhan might comment more on that perhaps. But the thermal bubble example from the Readme (just copy paste the code from there) runs just fine! Do you get an error with that also?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807688276:2,Usability,simpl,simply,2,"I simply paste the code from the README in a Julia REPL. ```Julia; julia> using Oceananigans; [ Info: Oceananigans will use 12 threads. julia> N = Nx = Ny = Nz = 128 # Number of grid points in each dimension.; 128. julia> L = Lx = Ly = Lz = 2000 # Length of each dimension.; 2000. julia> topology = (Periodic, Periodic, Bounded); (Periodic, Periodic, Bounded). julia> model = IncompressibleModel(; architecture = CPU(),; grid = RegularRectilinearGrid(topology=topology, size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz)),; closure = IsotropicDiffusivity(ν=4e-2, κ=4e-2); ); IncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=128, Ny=128, Nz=128); ├── tracers: (:T, :S); ├── closure: IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}; ├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}; └── coriolis: Nothing. julia> # Set a temperature perturbation with a Gaussian profile located at the center.; # This will create a buoyant thermal bubble that will rise with time.; x₀, z₀ = Lx/2, Lz/2; (1000.0, 1000.0). julia> T₀(x, y, z) = 20 + 0.01 * exp(-100 * ((x - x₀)^2 + (z - z₀)^2) / (Lx^2 + Lz^2)); T₀ (generic function with 1 method). julia> set!(model, T=T₀); julia> simulation = Simulation(model, Δt=10, stop_iteration=5000); Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step (Int64): 10 seconds; ├── Iteration interval: 1; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: Inf years, stop iteration: 5000; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. julia> run!(simulation); ```. How were you",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807688276
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594:187,Deployability,continuous,continuously,187,"Hm, I see... you might be trying to run the one found inside the `validation` directory, right?. I suggest you start of by trying to run the scripts in the `examples` directory. They are continuously tested and should run with the latest version. We'll figure out though the issues and fix the problems for the scripts that live in the `validation` directory (if you are specifically interested on one of those).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594:66,Security,validat,validation,66,"Hm, I see... you might be trying to run the one found inside the `validation` directory, right?. I suggest you start of by trying to run the scripts in the `examples` directory. They are continuously tested and should run with the latest version. We'll figure out though the issues and fix the problems for the scripts that live in the `validation` directory (if you are specifically interested on one of those).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594:337,Security,validat,validation,337,"Hm, I see... you might be trying to run the one found inside the `validation` directory, right?. I suggest you start of by trying to run the scripts in the `examples` directory. They are continuously tested and should run with the latest version. We'll figure out though the issues and fix the problems for the scripts that live in the `validation` directory (if you are specifically interested on one of those).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594:200,Testability,test,tested,200,"Hm, I see... you might be trying to run the one found inside the `validation` directory, right?. I suggest you start of by trying to run the scripts in the `examples` directory. They are continuously tested and should run with the latest version. We'll figure out though the issues and fix the problems for the scripts that live in the `validation` directory (if you are specifically interested on one of those).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-809320083:165,Deployability,update,updated,165,Hi @maeckha sorry for the out-of-date scripts. I've been meaning to add the validation experiments to CI so this doesn't happen. I can open a PR later today with an updated lid-driven cavity script if that would be helpful.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-809320083
https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-809320083:76,Security,validat,validation,76,Hi @maeckha sorry for the out-of-date scripts. I've been meaning to add the validation experiments to CI so this doesn't happen. I can open a PR later today with an updated lid-driven cavity script if that would be helpful.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-809320083
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808453777:117,Integrability,depend,depending,117,"Hello @sam12396 , I am glad you have been able to run Oceananigans on GPUs. That could speed things up a great deal, depending on what you are trying to do. Oceananigans has been written in such a way that the user does not need to do anything different in terms of setting up a problem on CPUs vs GPUs. To illustrate my point, consider the shallow water Bickley jet example [here](https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/). The default is set up to run on CPUs but if you want to run it on GPUs, then it's easy. Where you define the model you need to add one line,. ```; model = ShallowWaterModel(; architecture=GPU(),; timestepper=:RungeKutta3,; advection=WENO5(),; grid=grid,; gravitational_acceleration=g,; coriolis=FPlane(f=f),; ); ``` ; When you make that one change (setting the architecture in the second line above), then the code will use GPUs. The producing of the data and reading and writing is then all done with GPUs. There is nothing else for you to do. In particular, if you define your forcing and initial conditions using functions, as the examples tend to do, then nothing needs to change. If you want to use Oceananigans.jl, are you sure you need to program things differently?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808453777
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747:1262,Availability,error,errors,1262,"For simple cases, like @francispoulin mentioned, changing the architecture from `CPU()` to `GPU()` are often enough. Although if you wanna run simulations that are a bit more complicated, there are a few other things you might need to worry about. You can see a recent discussion about it [here](https://github.com/CliMA/Oceananigans.jl/issues/1509). Mostly you have to define everything that is being used in the model calculations as a constant, otherwise the GPU won't know what to do with it. So for example you probably will need to change some of your lines to. ```julia; const Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; const Hz = grid.Lz; Ξ(z) = randn() * z / Hz * (1 + z / Hz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile; ```; (probably the same goes in other places too.). I recommend you first run the very simple examples that appear in the `README` document of this repo on a GPU to make sure that Oceananigans+GPU is working correctly. And then only after that you should try to change your example to a GPU one. If you come across some errors that you can't solve we can take it from there :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747:907,Energy Efficiency,reduce,reduce,907,"For simple cases, like @francispoulin mentioned, changing the architecture from `CPU()` to `GPU()` are often enough. Although if you wanna run simulations that are a bit more complicated, there are a few other things you might need to worry about. You can see a recent discussion about it [here](https://github.com/CliMA/Oceananigans.jl/issues/1509). Mostly you have to define everything that is being used in the model calculations as a constant, otherwise the GPU won't know what to do with it. So for example you probably will need to change some of your lines to. ```julia; const Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; const Hz = grid.Lz; Ξ(z) = randn() * z / Hz * (1 + z / Hz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile; ```; (probably the same goes in other places too.). I recommend you first run the very simple examples that appear in the `README` document of this repo on a GPU to make sure that Oceananigans+GPU is working correctly. And then only after that you should try to change your example to a GPU one. If you come across some errors that you can't solve we can take it from there :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747:4,Usability,simpl,simple,4,"For simple cases, like @francispoulin mentioned, changing the architecture from `CPU()` to `GPU()` are often enough. Although if you wanna run simulations that are a bit more complicated, there are a few other things you might need to worry about. You can see a recent discussion about it [here](https://github.com/CliMA/Oceananigans.jl/issues/1509). Mostly you have to define everything that is being used in the model calculations as a constant, otherwise the GPU won't know what to do with it. So for example you probably will need to change some of your lines to. ```julia; const Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; const Hz = grid.Lz; Ξ(z) = randn() * z / Hz * (1 + z / Hz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile; ```; (probably the same goes in other places too.). I recommend you first run the very simple examples that appear in the `README` document of this repo on a GPU to make sure that Oceananigans+GPU is working correctly. And then only after that you should try to change your example to a GPU one. If you come across some errors that you can't solve we can take it from there :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747:1029,Usability,simpl,simple,1029,"For simple cases, like @francispoulin mentioned, changing the architecture from `CPU()` to `GPU()` are often enough. Although if you wanna run simulations that are a bit more complicated, there are a few other things you might need to worry about. You can see a recent discussion about it [here](https://github.com/CliMA/Oceananigans.jl/issues/1509). Mostly you have to define everything that is being used in the model calculations as a constant, otherwise the GPU won't know what to do with it. So for example you probably will need to change some of your lines to. ```julia; const Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; const Hz = grid.Lz; Ξ(z) = randn() * z / Hz * (1 + z / Hz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile; ```; (probably the same goes in other places too.). I recommend you first run the very simple examples that appear in the `README` document of this repo on a GPU to make sure that Oceananigans+GPU is working correctly. And then only after that you should try to change your example to a GPU one. If you come across some errors that you can't solve we can take it from there :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-811561274:1910,Availability,error,error,1910,"`CUDA.CuArray`](https://juliagpu.gitlab.io/CUDA.jl/usage/array/https://juliagpu.gitlab.io/CUDA.jl/usage/array/). It looks like you are using an object called `df.taux` that comes out of the `CSV` package:. ```julia; spl_taux = Spline1D(secs, df.taux / ρₒ, k=1); ```. Provided that whatever `Spline1D` does is GPU-friendly (and it may not be), then you may only need to convert `df.taux / ρₒ` to a `CuArray` prior to passing it to `Spline1D`. I don't know if this code would work, but as an example of something you _might_ do:. ```julia; using CUDA. kinematic_x_momentum_flux = Array(df.taux / ρₒ); kinematic_x_momentum_flux = CuArray(kinematic_x_momentum_flux). spl_taux = Spline1D(secs, kinematic_x_momentum_flux, k=1); ```. The array `secs` may also need to be converted:. ```julia; secs = CuArray(secs); ```. `Spline1D` may not work on the GPU, but there seem to be other options. A google search for ""interpolation GPU julia"" turned up this page:. https://juliagpu.org/2020-10-30-cuda_2.1/. which has instructions for using some CUDA built-in interpolation functionality. In summary, if you're working with arrays on the GPU, you'll need to. * convert arrays to `CuArray` when using the GPU; * use interpolation / other functionality that's GPU-friendly. As a side note, a convenient way to program a script to be switchable from CPU to GPU easily is to include a line at the top like. ```julia; DeviceArrayType = arch isa GPU ? CuArray : Array; ```. and then use patterns like. ```julia; data = Array(df.data); data = convert(DeviceArrayType, data); ```. This allows you to switch between `arch = GPU()` and `arch = CPU()` with a single line at the top of your script. As a side, side note, julia does not require you to put semi-colons to end lines!. Please don't be afraid to simply try running your script and reporting the error you get (if any!) With a concrete error, we can make concrete suggestions to solve your problem (without having to run the script ourselves, which is more work).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-811561274
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-811561274:1950,Availability,error,error,1950,"`CUDA.CuArray`](https://juliagpu.gitlab.io/CUDA.jl/usage/array/https://juliagpu.gitlab.io/CUDA.jl/usage/array/). It looks like you are using an object called `df.taux` that comes out of the `CSV` package:. ```julia; spl_taux = Spline1D(secs, df.taux / ρₒ, k=1); ```. Provided that whatever `Spline1D` does is GPU-friendly (and it may not be), then you may only need to convert `df.taux / ρₒ` to a `CuArray` prior to passing it to `Spline1D`. I don't know if this code would work, but as an example of something you _might_ do:. ```julia; using CUDA. kinematic_x_momentum_flux = Array(df.taux / ρₒ); kinematic_x_momentum_flux = CuArray(kinematic_x_momentum_flux). spl_taux = Spline1D(secs, kinematic_x_momentum_flux, k=1); ```. The array `secs` may also need to be converted:. ```julia; secs = CuArray(secs); ```. `Spline1D` may not work on the GPU, but there seem to be other options. A google search for ""interpolation GPU julia"" turned up this page:. https://juliagpu.org/2020-10-30-cuda_2.1/. which has instructions for using some CUDA built-in interpolation functionality. In summary, if you're working with arrays on the GPU, you'll need to. * convert arrays to `CuArray` when using the GPU; * use interpolation / other functionality that's GPU-friendly. As a side note, a convenient way to program a script to be switchable from CPU to GPU easily is to include a line at the top like. ```julia; DeviceArrayType = arch isa GPU ? CuArray : Array; ```. and then use patterns like. ```julia; data = Array(df.data); data = convert(DeviceArrayType, data); ```. This allows you to switch between `arch = GPU()` and `arch = CPU()` with a single line at the top of your script. As a side, side note, julia does not require you to put semi-colons to end lines!. Please don't be afraid to simply try running your script and reporting the error you get (if any!) With a concrete error, we can make concrete suggestions to solve your problem (without having to run the script ourselves, which is more work).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-811561274
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-811561274:1861,Usability,simpl,simply,1861,"`CUDA.CuArray`](https://juliagpu.gitlab.io/CUDA.jl/usage/array/https://juliagpu.gitlab.io/CUDA.jl/usage/array/). It looks like you are using an object called `df.taux` that comes out of the `CSV` package:. ```julia; spl_taux = Spline1D(secs, df.taux / ρₒ, k=1); ```. Provided that whatever `Spline1D` does is GPU-friendly (and it may not be), then you may only need to convert `df.taux / ρₒ` to a `CuArray` prior to passing it to `Spline1D`. I don't know if this code would work, but as an example of something you _might_ do:. ```julia; using CUDA. kinematic_x_momentum_flux = Array(df.taux / ρₒ); kinematic_x_momentum_flux = CuArray(kinematic_x_momentum_flux). spl_taux = Spline1D(secs, kinematic_x_momentum_flux, k=1); ```. The array `secs` may also need to be converted:. ```julia; secs = CuArray(secs); ```. `Spline1D` may not work on the GPU, but there seem to be other options. A google search for ""interpolation GPU julia"" turned up this page:. https://juliagpu.org/2020-10-30-cuda_2.1/. which has instructions for using some CUDA built-in interpolation functionality. In summary, if you're working with arrays on the GPU, you'll need to. * convert arrays to `CuArray` when using the GPU; * use interpolation / other functionality that's GPU-friendly. As a side note, a convenient way to program a script to be switchable from CPU to GPU easily is to include a line at the top like. ```julia; DeviceArrayType = arch isa GPU ? CuArray : Array; ```. and then use patterns like. ```julia; data = Array(df.data); data = convert(DeviceArrayType, data); ```. This allows you to switch between `arch = GPU()` and `arch = CPU()` with a single line at the top of your script. As a side, side note, julia does not require you to put semi-colons to end lines!. Please don't be afraid to simply try running your script and reporting the error you get (if any!) With a concrete error, we can make concrete suggestions to solve your problem (without having to run the script ourselves, which is more work).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-811561274
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328:211,Deployability,update,update,211,Hi all! . Thank you for the helpful advice and sorry for my delayed response! I am using shared gpu resources on my school's HPC and have not been able to access any resources to test anything out yet so I will update here once I can get some testing done on my side. Thank you again for the help!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328:155,Security,access,access,155,Hi all! . Thank you for the helpful advice and sorry for my delayed response! I am using shared gpu resources on my school's HPC and have not been able to access any resources to test anything out yet so I will update here once I can get some testing done on my side. Thank you again for the help!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328:179,Testability,test,test,179,Hi all! . Thank you for the helpful advice and sorry for my delayed response! I am using shared gpu resources on my school's HPC and have not been able to access any resources to test anything out yet so I will update here once I can get some testing done on my side. Thank you again for the help!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328
https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328:243,Testability,test,testing,243,Hi all! . Thank you for the helpful advice and sorry for my delayed response! I am using shared gpu resources on my school's HPC and have not been able to access any resources to test anything out yet so I will update here once I can get some testing done on my side. Thank you again for the help!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328
https://github.com/CliMA/Oceananigans.jl/pull/1510#issuecomment-808801571:509,Testability,test,tests,509,"I have included `closure` in `ShallowWaterModel` and I believe that is working correctly. However, when I try running `examples/test_advection_shallow_water.jl` I find that I get `NaN` after the first time step. . I know that the operator `∇_κ_∇c` does work with `Flat` as I have changed the one-dimensinal-diffusion-example and that does not have a problem. I guess I need to figure out what is not compatable with this operator and shallow water. If anyone has any idea what's wrong please let me know. All tests pass and I could merge but I think I will wait to get this sorted out before I merge. Might be good to add in a test afterwards to make sure that `ShallowWaterModel` can diffuse tracers without a problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1510#issuecomment-808801571
https://github.com/CliMA/Oceananigans.jl/pull/1510#issuecomment-808801571:627,Testability,test,test,627,"I have included `closure` in `ShallowWaterModel` and I believe that is working correctly. However, when I try running `examples/test_advection_shallow_water.jl` I find that I get `NaN` after the first time step. . I know that the operator `∇_κ_∇c` does work with `Flat` as I have changed the one-dimensinal-diffusion-example and that does not have a problem. I guess I need to figure out what is not compatable with this operator and shallow water. If anyone has any idea what's wrong please let me know. All tests pass and I could merge but I think I will wait to get this sorted out before I merge. Might be good to add in a test afterwards to make sure that `ShallowWaterModel` can diffuse tracers without a problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1510#issuecomment-808801571
https://github.com/CliMA/Oceananigans.jl/pull/1510#issuecomment-808929216:332,Testability,test,tests,332,I believe I have fixed `spacings_and_areas_and_volumes.jl` to allow this example to work. `Flat` should also work for `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. I haven't touched curvilinear grids but we should be able; to fix those in a similar way. Or we can do something else. I guess we will see how the tests do and go from there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1510#issuecomment-808929216
https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-809903134:89,Modifiability,extend,extending,89,None other than it requires typing the code and adding a test or two. Are you suggesting extending the capabilities of `FieldSlicer`? I think that's a nice idea if so!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-809903134
https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-809903134:57,Testability,test,test,57,None other than it requires typing the code and adding a test or two. Are you suggesting extending the capabilities of `FieldSlicer`? I think that's a nice idea if so!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-809903134
https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-810573826:26,Usability,simpl,simply,26,"It might be reasonable to simply generalize `parent_slice_indices` for `AbstractRange`s:. https://github.com/CliMA/Oceananigans.jl/blob/a4be062049b096ce20ac0908ee40f0b81b16d5ae/src/Diagnostics/field_slicer.jl#L61. We might want to use `minimum(rng)` rather than `rng[1]`:. https://github.com/CliMA/Oceananigans.jl/blob/a4be062049b096ce20ac0908ee40f0b81b16d5ae/src/Diagnostics/field_slicer.jl#L64. And we can return `StepRange(left, step(rng), right)` rather than `UnitRange(left, right)`:. https://github.com/CliMA/Oceananigans.jl/blob/a4be062049b096ce20ac0908ee40f0b81b16d5ae/src/Diagnostics/field_slicer.jl#L71",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-810573826
https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-810574949:28,Energy Efficiency,reduce,reduced,28,Note that functionality for reduced fields also would need to be generalized from `UnitRange` to `AbstractRange`:. https://github.com/CliMA/Oceananigans.jl/blob/a4be062049b096ce20ac0908ee40f0b81b16d5ae/src/Diagnostics/field_slicer.jl#L54,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-810574949
https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-810643745:40,Testability,test,tested,40,"Yeah, that's great! Thanks! Also I just tested it and it appears to work fine so kudos for get that working so fast",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-810643745
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809307893:311,Testability,test,tests,311,This would be a great change! I agree that examples should use `Flat` but we should probably fully support `Flat` before merging otherwise users might get `NaN`s when changing their scripts from 2D to 3D. I'm guessing that once you merge PR #1510 into the main branch then into this branch/PR the shallow water tests should pass?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809307893
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809430737:75,Deployability,update,update,75,"I agree @ali-ramadhan that we should make sure that `Flat` works before we update the examples on `master`. I thought that updating the examples might be a good way to figure out what's not working, and it has helped with that so it's been time well spent. Still some work to do though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809430737
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809440414:26,Deployability,update,updated,26,"I can confirm that when I updated this branch with what is currently on master, the shallow water tests do pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809440414
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809440414:98,Testability,test,tests,98,"I can confirm that when I updated this branch with what is currently on master, the shallow water tests do pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809440414
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040:295,Availability,fault,fault,295,"I have modified the timestepwizard to deal with `Flat` topologies. The good news is that `convecting_plankton.jl` and `lid_driven_cavity.jl` now work just fine. . The one outstanding example that I can't seem to get to work is `geostrophic_adjustment.jl`. Everytime I try running it I get a seg fault. See below. Anyone have any ideas what's going wrong?. ```; julia> include(""geostrophic_adjustment.jl""); ┌ Warning: HydrostaticFreeSurfaceModel is experimental. Use with caution!; └ @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/software/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:98. signal (11): Segmentation fault; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/geostrophic_adjustment.jl:92; jl_gc_pool_alloc at /buildworker/worker/package_linux64/build/src/gc.c:1148; jl_gc_alloc_ at /buildworker/worker/package_linux64/build/src/julia_internal.h:277 [inlined]; jl_gc_alloc at /buildworker/worker/package_linux64/build/src/gc.c:3150; jl_gc_alloc_buf at /buildworker/worker/package_linux64/build/src/julia_internal.h:304 [inlined]; array_resize_buffer at /buildworker/worker/package_linux64/build/src/array.c:686; jl_array_grow_at_end at /buildworker/worker/package_linux64/build/src/array.c:875 [inlined]; jl_array_grow_end at /buildworker/worker/package_linux64/build/src/array.c:939; jl_array_sizehint at /buildworker/worker/package_linux64/build/src/array.c:1139; sizehint! at ./array.jl:1103 [inlined]; BitSet at ./bitset.jl:18; BitSet at ./bitset.jl:29 [inlined]; construct_ssa! at ./compiler/ssair/slot2ssa.jl:780; slot2reg at ./compiler/ssair/driver.jl:127 [inlined]; run_passes at ./compiler/ssair/driver.jl:134; optimize at ./compiler/optimize.jl:174; typeinf at ./compiler/typeinfer.jl:33; abstract_call_method_with_const_args at ./compiler/abstractinterpretation.jl:266; abstract_call_gf_by_type at ./compiler/abstractinterpretation.jl:134; abstract_call_known at ./compiler/abstractinterpretation.jl:904;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040:665,Availability,fault,fault,665,"I have modified the timestepwizard to deal with `Flat` topologies. The good news is that `convecting_plankton.jl` and `lid_driven_cavity.jl` now work just fine. . The one outstanding example that I can't seem to get to work is `geostrophic_adjustment.jl`. Everytime I try running it I get a seg fault. See below. Anyone have any ideas what's going wrong?. ```; julia> include(""geostrophic_adjustment.jl""); ┌ Warning: HydrostaticFreeSurfaceModel is experimental. Use with caution!; └ @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/software/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:98. signal (11): Segmentation fault; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/geostrophic_adjustment.jl:92; jl_gc_pool_alloc at /buildworker/worker/package_linux64/build/src/gc.c:1148; jl_gc_alloc_ at /buildworker/worker/package_linux64/build/src/julia_internal.h:277 [inlined]; jl_gc_alloc at /buildworker/worker/package_linux64/build/src/gc.c:3150; jl_gc_alloc_buf at /buildworker/worker/package_linux64/build/src/julia_internal.h:304 [inlined]; array_resize_buffer at /buildworker/worker/package_linux64/build/src/array.c:686; jl_array_grow_at_end at /buildworker/worker/package_linux64/build/src/array.c:875 [inlined]; jl_array_grow_end at /buildworker/worker/package_linux64/build/src/array.c:939; jl_array_sizehint at /buildworker/worker/package_linux64/build/src/array.c:1139; sizehint! at ./array.jl:1103 [inlined]; BitSet at ./bitset.jl:18; BitSet at ./bitset.jl:29 [inlined]; construct_ssa! at ./compiler/ssair/slot2ssa.jl:780; slot2reg at ./compiler/ssair/driver.jl:127 [inlined]; run_passes at ./compiler/ssair/driver.jl:134; optimize at ./compiler/optimize.jl:174; typeinf at ./compiler/typeinfer.jl:33; abstract_call_method_with_const_args at ./compiler/abstractinterpretation.jl:266; abstract_call_gf_by_type at ./compiler/abstractinterpretation.jl:134; abstract_call_known at ./compiler/abstractinterpretation.jl:904;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040:11767,Availability,fault,fault,11767,ild/src/gf.c:2214 [inlined]; jl_apply_generic at /buildworker/worker/package_linux64/build/src/gf.c:2398; eval_user_input at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:134; repl_backend_loop at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; start_repl_backend at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; #run_repl#37 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; run_repl at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; _jl_invoke at /buildworker/worker/package_linux64/build/src/gf.c:2231 [inlined]; jl_apply_generic at /buildworker/worker/package_linux64/build/src/gf.c:2398; #807 at ./client.jl:399; jfptr_YY.807_64838.clone_1 at /opt/julia-1.5.2/lib/julia/sys.so (unknown line); _jl_invoke at /buildworker/worker/package_linux64/build/src/gf.c:2214 [inlined]; jl_apply_generic at /buildworker/worker/package_linux64/build/src/gf.c:2398; jl_apply at /buildworker/worker/package_linux64/build/src/julia.h:1690 [inlined]; do_apply at /buildworker/worker/package_linux64/build/src/builtins.c:655; jl_f__apply_latest at /buildworker/worker/package_linux64/build/src/builtins.c:705; #invokelatest#1 at ./essentials.jl:710 [inlined]; invokelatest at ./essentials.jl:709 [inlined]; run_main_repl at ./client.jl:383; exec_options at ./client.jl:313; _start at ./client.jl:506; jfptr__start_60376.clone_1 at /opt/julia-1.5.2/lib/julia/sys.so (unknown line); _jl_invoke at /buildworker/worker/package_linux64/build/src/gf.c:2214 [inlined]; jl_apply_generic at /buildworker/worker/package_linux64/build/src/gf.c:2398; unknown function (ip: 0x401931); unknown function (ip: 0x401533); __libc_start_main at /lib/x86_64-linux-gnu/libc.so.6 (unknown line); unknown function (ip: 0x4015d4); Allocations: 145096714 (Pool: 145057800; Big: 38914); GC: 123; Segmentation fault. ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040:1706,Performance,optimiz,optimize,1706,lin/software/Oceananigans.jl/examples/geostrophic_adjustment.jl:92; jl_gc_pool_alloc at /buildworker/worker/package_linux64/build/src/gc.c:1148; jl_gc_alloc_ at /buildworker/worker/package_linux64/build/src/julia_internal.h:277 [inlined]; jl_gc_alloc at /buildworker/worker/package_linux64/build/src/gc.c:3150; jl_gc_alloc_buf at /buildworker/worker/package_linux64/build/src/julia_internal.h:304 [inlined]; array_resize_buffer at /buildworker/worker/package_linux64/build/src/array.c:686; jl_array_grow_at_end at /buildworker/worker/package_linux64/build/src/array.c:875 [inlined]; jl_array_grow_end at /buildworker/worker/package_linux64/build/src/array.c:939; jl_array_sizehint at /buildworker/worker/package_linux64/build/src/array.c:1139; sizehint! at ./array.jl:1103 [inlined]; BitSet at ./bitset.jl:18; BitSet at ./bitset.jl:29 [inlined]; construct_ssa! at ./compiler/ssair/slot2ssa.jl:780; slot2reg at ./compiler/ssair/driver.jl:127 [inlined]; run_passes at ./compiler/ssair/driver.jl:134; optimize at ./compiler/optimize.jl:174; typeinf at ./compiler/typeinfer.jl:33; abstract_call_method_with_const_args at ./compiler/abstractinterpretation.jl:266; abstract_call_gf_by_type at ./compiler/abstractinterpretation.jl:134; abstract_call_known at ./compiler/abstractinterpretation.jl:904; abstract_call at ./compiler/abstractinterpretation.jl:926; abstract_call at ./compiler/abstractinterpretation.jl:911; abstract_eval at ./compiler/abstractinterpretation.jl:1005; typeinf_local at ./compiler/abstractinterpretation.jl:1270; typeinf_nocycle at ./compiler/abstractinterpretation.jl:1326; typeinf at ./compiler/typeinfer.jl:12; abstract_call_method_with_const_args at ./compiler/abstractinterpretation.jl:266; abstract_call_gf_by_type at ./compiler/abstractinterpretation.jl:134; abstract_call_known at ./compiler/abstractinterpretation.jl:904; abstract_call at ./compiler/abstractinterpretation.jl:926; abstract_call at ./compiler/abstractinterpretation.jl:911; abstract_eval at ./compiler/abstr,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040:1729,Performance,optimiz,optimize,1729,igans.jl/examples/geostrophic_adjustment.jl:92; jl_gc_pool_alloc at /buildworker/worker/package_linux64/build/src/gc.c:1148; jl_gc_alloc_ at /buildworker/worker/package_linux64/build/src/julia_internal.h:277 [inlined]; jl_gc_alloc at /buildworker/worker/package_linux64/build/src/gc.c:3150; jl_gc_alloc_buf at /buildworker/worker/package_linux64/build/src/julia_internal.h:304 [inlined]; array_resize_buffer at /buildworker/worker/package_linux64/build/src/array.c:686; jl_array_grow_at_end at /buildworker/worker/package_linux64/build/src/array.c:875 [inlined]; jl_array_grow_end at /buildworker/worker/package_linux64/build/src/array.c:939; jl_array_sizehint at /buildworker/worker/package_linux64/build/src/array.c:1139; sizehint! at ./array.jl:1103 [inlined]; BitSet at ./bitset.jl:18; BitSet at ./bitset.jl:29 [inlined]; construct_ssa! at ./compiler/ssair/slot2ssa.jl:780; slot2reg at ./compiler/ssair/driver.jl:127 [inlined]; run_passes at ./compiler/ssair/driver.jl:134; optimize at ./compiler/optimize.jl:174; typeinf at ./compiler/typeinfer.jl:33; abstract_call_method_with_const_args at ./compiler/abstractinterpretation.jl:266; abstract_call_gf_by_type at ./compiler/abstractinterpretation.jl:134; abstract_call_known at ./compiler/abstractinterpretation.jl:904; abstract_call at ./compiler/abstractinterpretation.jl:926; abstract_call at ./compiler/abstractinterpretation.jl:911; abstract_eval at ./compiler/abstractinterpretation.jl:1005; typeinf_local at ./compiler/abstractinterpretation.jl:1270; typeinf_nocycle at ./compiler/abstractinterpretation.jl:1326; typeinf at ./compiler/typeinfer.jl:12; abstract_call_method_with_const_args at ./compiler/abstractinterpretation.jl:266; abstract_call_gf_by_type at ./compiler/abstractinterpretation.jl:134; abstract_call_known at ./compiler/abstractinterpretation.jl:904; abstract_call at ./compiler/abstractinterpretation.jl:926; abstract_call at ./compiler/abstractinterpretation.jl:911; abstract_eval at ./compiler/abstractinterpretation.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809880779:432,Testability,test,testing,432,"I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?. I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809880779
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000:1035,Energy Efficiency,adapt,adapt,1035,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000:1035,Modifiability,adapt,adapt,1035,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000:440,Testability,test,testing,440,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000:830,Testability,test,tests,830,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000:1745,Testability,test,tests,1745,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000
https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000:1000,Usability,clear,clear,1000,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809380865:50,Testability,test,tests,50,Everything looks good on the CPU but the GPU unit tests segfault when testing field setting (tried debugging but can't figure out why). All the other GPU tests pass although CI seems much slower for GPU tests (~3x slower?). Could be related to segfault in https://github.com/CliMA/ClimateMachine.jl/pull/2146 ? @charleskawczynski @jakebolewski were you able to figure out why it was segfaulting?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809380865
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809380865:70,Testability,test,testing,70,Everything looks good on the CPU but the GPU unit tests segfault when testing field setting (tried debugging but can't figure out why). All the other GPU tests pass although CI seems much slower for GPU tests (~3x slower?). Could be related to segfault in https://github.com/CliMA/ClimateMachine.jl/pull/2146 ? @charleskawczynski @jakebolewski were you able to figure out why it was segfaulting?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809380865
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809380865:154,Testability,test,tests,154,Everything looks good on the CPU but the GPU unit tests segfault when testing field setting (tried debugging but can't figure out why). All the other GPU tests pass although CI seems much slower for GPU tests (~3x slower?). Could be related to segfault in https://github.com/CliMA/ClimateMachine.jl/pull/2146 ? @charleskawczynski @jakebolewski were you able to figure out why it was segfaulting?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809380865
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809380865:203,Testability,test,tests,203,Everything looks good on the CPU but the GPU unit tests segfault when testing field setting (tried debugging but can't figure out why). All the other GPU tests pass although CI seems much slower for GPU tests (~3x slower?). Could be related to segfault in https://github.com/CliMA/ClimateMachine.jl/pull/2146 ? @charleskawczynski @jakebolewski were you able to figure out why it was segfaulting?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809380865
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809391386:117,Testability,test,test,117,Okay so the segfault was because we were trying to set a field using an `Int128` or `UInt128`. It's not an important test so I removed it but it's a little weird that it just started failing since the test has been in since Oceananigans.jl v0.1.0...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809391386
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809391386:201,Testability,test,test,201,Okay so the segfault was because we were trying to set a field using an `Int128` or `UInt128`. It's not an important test so I removed it but it's a little weird that it just started failing since the test has been in since Oceananigans.jl v0.1.0...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809391386
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809465177:20,Testability,test,tests,20,"> All the other GPU tests pass although CI seems much slower for GPU tests (~3x slower?). 😞. > Could be related to segfault in [CliMA/ClimateMachine.jl#2146](https://github.com/CliMA/ClimateMachine.jl/pull/2146) ? @charleskawczynski @jakebolewski were you able to figure out why it was segfaulting?. Not yet, I'm going to try looking into it. @jakebolewski suggested first upgrading some packages first-- so I'm doing that now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809465177
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809465177:69,Testability,test,tests,69,"> All the other GPU tests pass although CI seems much slower for GPU tests (~3x slower?). 😞. > Could be related to segfault in [CliMA/ClimateMachine.jl#2146](https://github.com/CliMA/ClimateMachine.jl/pull/2146) ? @charleskawczynski @jakebolewski were you able to figure out why it was segfaulting?. Not yet, I'm going to try looking into it. @jakebolewski suggested first upgrading some packages first-- so I'm doing that now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809465177
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809493617:129,Availability,error,error,129,"hmm good to know about possible performance issues, we should be on the lookout. I suspect that (one of the) segfaults is an OOB error that got masked by `@inbounds`, running that now locally.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809493617
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809493617:144,Availability,mask,masked,144,"hmm good to know about possible performance issues, we should be on the lookout. I suspect that (one of the) segfaults is an OOB error that got masked by `@inbounds`, running that now locally.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809493617
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809493617:32,Performance,perform,performance,32,"hmm good to know about possible performance issues, we should be on the lookout. I suspect that (one of the) segfaults is an OOB error that got masked by `@inbounds`, running that now locally.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809493617
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809568648:153,Performance,perform,performance,153,I opened an issue about the `Int128`/`UInt128` segfault (https://github.com/JuliaGPU/CUDA.jl/issues/793) but will revisit this PR later to look into the performance regression.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809568648
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002:14,Availability,failure,failures,14,Hmmm a lot of failures due to CUDA scalar `getindex` operations even though we explicitly set `CUDA.allowscalar(true)` in `runtests.jl`... We could take this opportunity to get rid of all scalar operations in the tests and just use `CUDA.@allowscalar` where it's needed. Maybe new CUDA scalar operations are hurting performance and that's why GPU CI has slowed down?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002:361,Availability,down,down,361,Hmmm a lot of failures due to CUDA scalar `getindex` operations even though we explicitly set `CUDA.allowscalar(true)` in `runtests.jl`... We could take this opportunity to get rid of all scalar operations in the tests and just use `CUDA.@allowscalar` where it's needed. Maybe new CUDA scalar operations are hurting performance and that's why GPU CI has slowed down?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002:316,Performance,perform,performance,316,Hmmm a lot of failures due to CUDA scalar `getindex` operations even though we explicitly set `CUDA.allowscalar(true)` in `runtests.jl`... We could take this opportunity to get rid of all scalar operations in the tests and just use `CUDA.@allowscalar` where it's needed. Maybe new CUDA scalar operations are hurting performance and that's why GPU CI has slowed down?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002:213,Testability,test,tests,213,Hmmm a lot of failures due to CUDA scalar `getindex` operations even though we explicitly set `CUDA.allowscalar(true)` in `runtests.jl`... We could take this opportunity to get rid of all scalar operations in the tests and just use `CUDA.@allowscalar` where it's needed. Maybe new CUDA scalar operations are hurting performance and that's why GPU CI has slowed down?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189:218,Performance,perform,performance,218,"That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189:181,Safety,safe,safety,181,"That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189:274,Usability,simpl,simple,274,"That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393:422,Availability,error,error,422,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393:220,Performance,perform,performance,220,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393:183,Safety,safe,safety,183,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393:276,Usability,simpl,simple,276,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-819477263:68,Availability,fault,fault,68,"Ah good point, thanks for looking into this @navidcy! Definitely my fault for using `Base.typename` when I knew it was an internal unexported function. Will revisit this PR soon now that docs aren't getting stuck on Buildkite + Julia 1.5 anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-819477263
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-820084281:57,Testability,test,test,57,"A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-820084281
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-820084281:150,Testability,test,test,150,"A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-820084281
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-820938485:25,Testability,test,tests,25,now at least all the CPU tests pass... note how `CUDA.@allowscalar` had to be changed in https://github.com/CliMA/Oceananigans.jl/pull/1514/commits/8313b7d3e0524d5891611e2b7431793b8d6cc68b,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-820938485
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104:135,Availability,failure,failures,135,"Thanks for working on this @navidcy! I'll try to `git merge master` which should fix some tests and then I'll look at fixing the other failures. > A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?. Ideally yeah we would test on both 1.5 and 1.6 but I don't think we have the CI resources to do so :(. We could set up some GitHub Actions pipelines to test Mac and Windows with 1.5 and only run a subset of the tests so it doesn't massively slow down CI. It wouldn't be comprehensive but we'd get more coverage. Not sure if we'll have to only support Julia 1.6+ only soon, but that would save us from having to test on 1.5. We might not want to jump ship to 1.6 too soon though. I experienced longer compilation times when using Julia 1.6 in developing PR #1522 so I had to switch back to 1.5. Maybe I just had a weird setup though, I should investigate more carefully. I could be the only one who's had issues... Might be good to beta test 1.6 a little bit before switching completely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104:640,Availability,down,down,640,"Thanks for working on this @navidcy! I'll try to `git merge master` which should fix some tests and then I'll look at fixing the other failures. > A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?. Ideally yeah we would test on both 1.5 and 1.6 but I don't think we have the CI resources to do so :(. We could set up some GitHub Actions pipelines to test Mac and Windows with 1.5 and only run a subset of the tests so it doesn't massively slow down CI. It wouldn't be comprehensive but we'd get more coverage. Not sure if we'll have to only support Julia 1.6+ only soon, but that would save us from having to test on 1.5. We might not want to jump ship to 1.6 too soon though. I experienced longer compilation times when using Julia 1.6 in developing PR #1522 so I had to switch back to 1.5. Maybe I just had a weird setup though, I should investigate more carefully. I could be the only one who's had issues... Might be good to beta test 1.6 a little bit before switching completely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104:533,Deployability,pipeline,pipelines,533,"Thanks for working on this @navidcy! I'll try to `git merge master` which should fix some tests and then I'll look at fixing the other failures. > A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?. Ideally yeah we would test on both 1.5 and 1.6 but I don't think we have the CI resources to do so :(. We could set up some GitHub Actions pipelines to test Mac and Windows with 1.5 and only run a subset of the tests so it doesn't massively slow down CI. It wouldn't be comprehensive but we'd get more coverage. Not sure if we'll have to only support Julia 1.6+ only soon, but that would save us from having to test on 1.5. We might not want to jump ship to 1.6 too soon though. I experienced longer compilation times when using Julia 1.6 in developing PR #1522 so I had to switch back to 1.5. Maybe I just had a weird setup though, I should investigate more carefully. I could be the only one who's had issues... Might be good to beta test 1.6 a little bit before switching completely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104:90,Testability,test,tests,90,"Thanks for working on this @navidcy! I'll try to `git merge master` which should fix some tests and then I'll look at fixing the other failures. > A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?. Ideally yeah we would test on both 1.5 and 1.6 but I don't think we have the CI resources to do so :(. We could set up some GitHub Actions pipelines to test Mac and Windows with 1.5 and only run a subset of the tests so it doesn't massively slow down CI. It wouldn't be comprehensive but we'd get more coverage. Not sure if we'll have to only support Julia 1.6+ only soon, but that would save us from having to test on 1.5. We might not want to jump ship to 1.6 too soon though. I experienced longer compilation times when using Julia 1.6 in developing PR #1522 so I had to switch back to 1.5. Maybe I just had a weird setup though, I should investigate more carefully. I could be the only one who's had issues... Might be good to beta test 1.6 a little bit before switching completely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104:204,Testability,test,test,204,"Thanks for working on this @navidcy! I'll try to `git merge master` which should fix some tests and then I'll look at fixing the other failures. > A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?. Ideally yeah we would test on both 1.5 and 1.6 but I don't think we have the CI resources to do so :(. We could set up some GitHub Actions pipelines to test Mac and Windows with 1.5 and only run a subset of the tests so it doesn't massively slow down CI. It wouldn't be comprehensive but we'd get more coverage. Not sure if we'll have to only support Julia 1.6+ only soon, but that would save us from having to test on 1.5. We might not want to jump ship to 1.6 too soon though. I experienced longer compilation times when using Julia 1.6 in developing PR #1522 so I had to switch back to 1.5. Maybe I just had a weird setup though, I should investigate more carefully. I could be the only one who's had issues... Might be good to beta test 1.6 a little bit before switching completely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104:297,Testability,test,test,297,"Thanks for working on this @navidcy! I'll try to `git merge master` which should fix some tests and then I'll look at fixing the other failures. > A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?. Ideally yeah we would test on both 1.5 and 1.6 but I don't think we have the CI resources to do so :(. We could set up some GitHub Actions pipelines to test Mac and Windows with 1.5 and only run a subset of the tests so it doesn't massively slow down CI. It wouldn't be comprehensive but we'd get more coverage. Not sure if we'll have to only support Julia 1.6+ only soon, but that would save us from having to test on 1.5. We might not want to jump ship to 1.6 too soon though. I experienced longer compilation times when using Julia 1.6 in developing PR #1522 so I had to switch back to 1.5. Maybe I just had a weird setup though, I should investigate more carefully. I could be the only one who's had issues... Might be good to beta test 1.6 a little bit before switching completely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104:416,Testability,test,test,416,"Thanks for working on this @navidcy! I'll try to `git merge master` which should fix some tests and then I'll look at fixing the other failures. > A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?. Ideally yeah we would test on both 1.5 and 1.6 but I don't think we have the CI resources to do so :(. We could set up some GitHub Actions pipelines to test Mac and Windows with 1.5 and only run a subset of the tests so it doesn't massively slow down CI. It wouldn't be comprehensive but we'd get more coverage. Not sure if we'll have to only support Julia 1.6+ only soon, but that would save us from having to test on 1.5. We might not want to jump ship to 1.6 too soon though. I experienced longer compilation times when using Julia 1.6 in developing PR #1522 so I had to switch back to 1.5. Maybe I just had a weird setup though, I should investigate more carefully. I could be the only one who's had issues... Might be good to beta test 1.6 a little bit before switching completely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104:546,Testability,test,test,546,"Thanks for working on this @navidcy! I'll try to `git merge master` which should fix some tests and then I'll look at fixing the other failures. > A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?. Ideally yeah we would test on both 1.5 and 1.6 but I don't think we have the CI resources to do so :(. We could set up some GitHub Actions pipelines to test Mac and Windows with 1.5 and only run a subset of the tests so it doesn't massively slow down CI. It wouldn't be comprehensive but we'd get more coverage. Not sure if we'll have to only support Julia 1.6+ only soon, but that would save us from having to test on 1.5. We might not want to jump ship to 1.6 too soon though. I experienced longer compilation times when using Julia 1.6 in developing PR #1522 so I had to switch back to 1.5. Maybe I just had a weird setup though, I should investigate more carefully. I could be the only one who's had issues... Might be good to beta test 1.6 a little bit before switching completely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104:605,Testability,test,tests,605,"Thanks for working on this @navidcy! I'll try to `git merge master` which should fix some tests and then I'll look at fixing the other failures. > A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?. Ideally yeah we would test on both 1.5 and 1.6 but I don't think we have the CI resources to do so :(. We could set up some GitHub Actions pipelines to test Mac and Windows with 1.5 and only run a subset of the tests so it doesn't massively slow down CI. It wouldn't be comprehensive but we'd get more coverage. Not sure if we'll have to only support Julia 1.6+ only soon, but that would save us from having to test on 1.5. We might not want to jump ship to 1.6 too soon though. I experienced longer compilation times when using Julia 1.6 in developing PR #1522 so I had to switch back to 1.5. Maybe I just had a weird setup though, I should investigate more carefully. I could be the only one who's had issues... Might be good to beta test 1.6 a little bit before switching completely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104:805,Testability,test,test,805,"Thanks for working on this @navidcy! I'll try to `git merge master` which should fix some tests and then I'll look at fixing the other failures. > A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?. Ideally yeah we would test on both 1.5 and 1.6 but I don't think we have the CI resources to do so :(. We could set up some GitHub Actions pipelines to test Mac and Windows with 1.5 and only run a subset of the tests so it doesn't massively slow down CI. It wouldn't be comprehensive but we'd get more coverage. Not sure if we'll have to only support Julia 1.6+ only soon, but that would save us from having to test on 1.5. We might not want to jump ship to 1.6 too soon though. I experienced longer compilation times when using Julia 1.6 in developing PR #1522 so I had to switch back to 1.5. Maybe I just had a weird setup though, I should investigate more carefully. I could be the only one who's had issues... Might be good to beta test 1.6 a little bit before switching completely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104:1130,Testability,test,test,1130,"Thanks for working on this @navidcy! I'll try to `git merge master` which should fix some tests and then I'll look at fixing the other failures. > A question that comes about is that after this PR: do we test *only* on v1.6? If so, how are we making sure that code works smooth on v1.5? Should we test on both? Should we bump the julia compat requirement in the `Project.toml` file to `^1.6`?. Ideally yeah we would test on both 1.5 and 1.6 but I don't think we have the CI resources to do so :(. We could set up some GitHub Actions pipelines to test Mac and Windows with 1.5 and only run a subset of the tests so it doesn't massively slow down CI. It wouldn't be comprehensive but we'd get more coverage. Not sure if we'll have to only support Julia 1.6+ only soon, but that would save us from having to test on 1.5. We might not want to jump ship to 1.6 too soon though. I experienced longer compilation times when using Julia 1.6 in developing PR #1522 so I had to switch back to 1.5. Maybe I just had a weird setup though, I should investigate more carefully. I could be the only one who's had issues... Might be good to beta test 1.6 a little bit before switching completely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-821192104
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-822144443:26,Availability,error,errors,26,I'm wondering whether the errors in the `gpu simulation tests` group are related to Tullio.jl. Seems like only `Tullio#master` mentions/uses `CUDAKernels`... https://github.com/mcabbott/Tullio.jl/commit/d3c4fde63c37ebae31b6d13413531a3a9241d59c,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-822144443
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-822144443:56,Testability,test,tests,56,I'm wondering whether the errors in the `gpu simulation tests` group are related to Tullio.jl. Seems like only `Tullio#master` mentions/uses `CUDAKernels`... https://github.com/mcabbott/Tullio.jl/commit/d3c4fde63c37ebae31b6d13413531a3a9241d59c,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-822144443
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-822433768:19,Testability,test,tests,19,"@ali-ramadhan, all tests pass except those related with Tullio.jl I think!. I don't understand why CUDA.@allowscalar creates issues... But it does apparently. Am I wrong?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-822433768
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-822762230:41,Testability,test,tests,41,"@ali-ramadhan, also the gpu cubed-sphere tests don't pass. Any ideas why?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-822762230
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-824365320:79,Deployability,release,release,79,Yeah only a few more fixes!. CUDA.jl 3.0 only supports Julia 1.6+ and the next release of KernelAbstractions.jl should switch to CUDA.jl 3.0 so if this PR is open for a bit longer we might as well bump Oceananigans.jl to only support Julia 1.6 as well. We could also potentially leave behind the weird Julia 1.5 hanging issue (e.g. #1601)... X-Ref: https://github.com/JuliaGPU/KernelAbstractions.jl/pull/242,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-824365320
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912:53,Availability,avail,available,53,"So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Can you guys give an ETA of long until the Julia 1.6 migration is complete? Looks like it's relatively close but depending on the answer I might need to change my research plans for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912:170,Availability,avail,available,170,"So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Can you guys give an ETA of long until the Julia 1.6 migration is complete? Looks like it's relatively close but depending on the answer I might need to change my research plans for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912:73,Energy Efficiency,energy,energy,73,"So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Can you guys give an ETA of long until the Julia 1.6 migration is complete? Looks like it's relatively close but depending on the answer I might need to change my research plans for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912:353,Integrability,depend,depending,353,"So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Can you guys give an ETA of long until the Julia 1.6 migration is complete? Looks like it's relatively close but depending on the answer I might need to change my research plans for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942070:18,Deployability,continuous,continuously,18,I'm working on it continuously... :); As soon as all tests pass we can discuss. We are almost there @tomchor I feel... only something Tullio-related was not passing the previous time. Now I updated Tullio and trying again. Hold on to your chair!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942070
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942070:190,Deployability,update,updated,190,I'm working on it continuously... :); As soon as all tests pass we can discuss. We are almost there @tomchor I feel... only something Tullio-related was not passing the previous time. Now I updated Tullio and trying again. Hold on to your chair!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942070
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942070:53,Testability,test,tests,53,I'm working on it continuously... :); As soon as all tests pass we can discuss. We are almost there @tomchor I feel... only something Tullio-related was not passing the previous time. Now I updated Tullio and trying again. Hold on to your chair!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942070
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942363:55,Availability,avail,available,55,"> So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Just to add --- as a first step, you might try first copying your data to the CPU and sorting there. If you don't have to do it too often, you won't suffer much of a penalty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942363
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942363:172,Availability,avail,available,172,"> So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Just to add --- as a first step, you might try first copying your data to the CPU and sorting there. If you don't have to do it too often, you won't suffer much of a penalty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942363
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942363:75,Energy Efficiency,energy,energy,75,"> So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Just to add --- as a first step, you might try first copying your data to the CPU and sorting there. If you don't have to do it too often, you won't suffer much of a penalty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942363
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825983782:41,Availability,error,errors,41,I think now only some output writer test errors are only pending. Will try to sort them out today.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825983782
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825983782:36,Testability,test,test,36,I think now only some output writer test errors are only pending. Will try to sort them out today.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825983782
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-831586344:40,Testability,test,test,40,"This went astray... It takes so long to test that always there is some new feature coming in and then conflicts, etc... :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-831586344
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508:56,Availability,ERROR,ERROR,56,"On the CPU it seems like things are failing with `FATAL ERROR: Symbol ""__nv_llabs""not found`. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). GPU tests don't want to run (CUDA driver might be too old on Sverdrup?) but GPU regression tests passed on Tartarus so things might be fine there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508:124,Availability,down,down,124,"On the CPU it seems like things are failing with `FATAL ERROR: Symbol ""__nv_llabs""not found`. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). GPU tests don't want to run (CUDA driver might be too old on Sverdrup?) but GPU regression tests passed on Tartarus so things might be fine there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508:114,Energy Efficiency,reduce,reduce,114,"On the CPU it seems like things are failing with `FATAL ERROR: Symbol ""__nv_llabs""not found`. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). GPU tests don't want to run (CUDA driver might be too old on Sverdrup?) but GPU regression tests passed on Tartarus so things might be fine there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508:195,Testability,test,tests,195,"On the CPU it seems like things are failing with `FATAL ERROR: Symbol ""__nv_llabs""not found`. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). GPU tests don't want to run (CUDA driver might be too old on Sverdrup?) but GPU regression tests passed on Tartarus so things might be fine there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508:282,Testability,test,tests,282,"On the CPU it seems like things are failing with `FATAL ERROR: Symbol ""__nv_llabs""not found`. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). GPU tests don't want to run (CUDA driver might be too old on Sverdrup?) but GPU regression tests passed on Tartarus so things might be fine there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832178508
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832204669:195,Deployability,release,release,195,"```; (base) glwagner@sverdrup:~$ nvcc --version; nvcc: NVIDIA (R) Cuda compiler driver; Copyright (c) 2005-2018 NVIDIA Corporation; Built on Sat_Aug_25_21:08:01_CDT_2018; Cuda compilation tools, release 10.0, V10.0.130; ```. What do we need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832204669
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832211264:51,Availability,error,erroring,51,"> What do we need?. Maybe just CUDA v10.1+? Before erroring, all the builds seem to print this warning:. ```; Warning: This version of CUDA.jl only supports NVIDIA drivers for CUDA 10.1 or higher (yours is for CUDA 10.0.0); ```. https://buildkite.com/clima/oceananigans/builds/2396#4a537d8f-9863-489f-bb11-2520a00b83de/16-233. I feel like I've seen this warning on Buildkite before, but maybe now CUDA.jl means it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832211264
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010:8,Availability,ERROR,ERROR,8,"> FATAL ERROR: Symbol ""__nv_llabs""not found. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). I have seen this error when working with `KernelAbstractions` without any CUDA dependency.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010:75,Availability,down,down,75,"> FATAL ERROR: Symbol ""__nv_llabs""not found. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). I have seen this error when working with `KernelAbstractions` without any CUDA dependency.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010:159,Availability,error,error,159,"> FATAL ERROR: Symbol ""__nv_llabs""not found. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). I have seen this error when working with `KernelAbstractions` without any CUDA dependency.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010:65,Energy Efficiency,reduce,reduce,65,"> FATAL ERROR: Symbol ""__nv_llabs""not found. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). I have seen this error when working with `KernelAbstractions` without any CUDA dependency.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010:221,Integrability,depend,dependency,221,"> FATAL ERROR: Symbol ""__nv_llabs""not found. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). I have seen this error when working with `KernelAbstractions` without any CUDA dependency.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-838548217:50,Testability,test,tests,50,"Thanks @vchuravy, with Cassette.jl v0.3.6 the CPU tests all pass now!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-838548217
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-839082254:230,Testability,test,tests,230,WENO is failing on the GPU because CUDAKernels.jl is trying to overdub `^` with `CUDA.pow` which doesn't exist anymore: https://github.com/JuliaGPU/KernelAbstractions.jl/pull/249. Otherwise we should be pretty close to having all tests passing!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-839082254
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118:157,Deployability,release,release,157,"Finally all tests pass 🎉 Thanks @navidcy and @vchuravy for all your help!. @glwagner Let me know when it would be a good time to merge this PR and tag a new release. Ran the incompressible model benchmarks and in general it seems that with Julia 1.6 Oceananigans allocates more memory and is a bit slower on the CPU but a bit faster on the GPU. # Quick benchmark. ## Julia 1.6. ```; Oceananigans v0.57.2; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 4.996 ms │ 5.047 ms │ 5.113 ms │ 5.770 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 64 │ 34.951 ms │ 35.967 ms │ 36.414 ms │ 41.417 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 128 │ 301.074 ms │ 301.964 ms │ 302.498 ms │ 307.989 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 256 │ 2.894 s │ 2.895 s │ 2.895 s │ 2.896 s │ 1.77 MiB │ 2301 │ 2 │; │ GPU │ Float64 │ 32 │ 2.859 ms │ 2.923 ms │ 3.025 ms │ 3.987 ms │ 2.80 MiB │ 6914 │ 10 │; │ GPU │ Float64 │ 64 │ 2.912 ms │ 3.101 ms │ 3.308 ms │ 5.368 ms │ 2.78 MiB │ 6993 │ 10 │; │ GPU │ Float64 │ 128 │ 4.894 ms │ 5.019 ms │ 5.360 ms │ 8.565 ms │ 2.80 MiB │ 8667 │ 10 │; │ GPU │ Float64 │ 256 │ 33.569 ms │ 36.266 ms │ 36.029 ms │ 36.883 ms │ 3.24 MiB │ 37307 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘; ```. ## Julia 1.5. ```; Oceananigans v0.57.2; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118:263,Energy Efficiency,allocate,allocates,263,"Finally all tests pass 🎉 Thanks @navidcy and @vchuravy for all your help!. @glwagner Let me know when it would be a good time to merge this PR and tag a new release. Ran the incompressible model benchmarks and in general it seems that with Julia 1.6 Oceananigans allocates more memory and is a bit slower on the CPU but a bit faster on the GPU. # Quick benchmark. ## Julia 1.6. ```; Oceananigans v0.57.2; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 4.996 ms │ 5.047 ms │ 5.113 ms │ 5.770 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 64 │ 34.951 ms │ 35.967 ms │ 36.414 ms │ 41.417 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 128 │ 301.074 ms │ 301.964 ms │ 302.498 ms │ 307.989 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 256 │ 2.894 s │ 2.895 s │ 2.895 s │ 2.896 s │ 1.77 MiB │ 2301 │ 2 │; │ GPU │ Float64 │ 32 │ 2.859 ms │ 2.923 ms │ 3.025 ms │ 3.987 ms │ 2.80 MiB │ 6914 │ 10 │; │ GPU │ Float64 │ 64 │ 2.912 ms │ 3.101 ms │ 3.308 ms │ 5.368 ms │ 2.78 MiB │ 6993 │ 10 │; │ GPU │ Float64 │ 128 │ 4.894 ms │ 5.019 ms │ 5.360 ms │ 8.565 ms │ 2.80 MiB │ 8667 │ 10 │; │ GPU │ Float64 │ 256 │ 33.569 ms │ 36.266 ms │ 36.029 ms │ 36.883 ms │ 3.24 MiB │ 37307 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘; ```. ## Julia 1.5. ```; Oceananigans v0.57.2; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118:12,Testability,test,tests,12,"Finally all tests pass 🎉 Thanks @navidcy and @vchuravy for all your help!. @glwagner Let me know when it would be a good time to merge this PR and tag a new release. Ran the incompressible model benchmarks and in general it seems that with Julia 1.6 Oceananigans allocates more memory and is a bit slower on the CPU but a bit faster on the GPU. # Quick benchmark. ## Julia 1.6. ```; Oceananigans v0.57.2; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 4.996 ms │ 5.047 ms │ 5.113 ms │ 5.770 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 64 │ 34.951 ms │ 35.967 ms │ 36.414 ms │ 41.417 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 128 │ 301.074 ms │ 301.964 ms │ 302.498 ms │ 307.989 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 256 │ 2.894 s │ 2.895 s │ 2.895 s │ 2.896 s │ 1.77 MiB │ 2301 │ 2 │; │ GPU │ Float64 │ 32 │ 2.859 ms │ 2.923 ms │ 3.025 ms │ 3.987 ms │ 2.80 MiB │ 6914 │ 10 │; │ GPU │ Float64 │ 64 │ 2.912 ms │ 3.101 ms │ 3.308 ms │ 5.368 ms │ 2.78 MiB │ 6993 │ 10 │; │ GPU │ Float64 │ 128 │ 4.894 ms │ 5.019 ms │ 5.360 ms │ 8.565 ms │ 2.80 MiB │ 8667 │ 10 │; │ GPU │ Float64 │ 256 │ 33.569 ms │ 36.266 ms │ 36.029 ms │ 36.883 ms │ 3.24 MiB │ 37307 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘; ```. ## Julia 1.5. ```; Oceananigans v0.57.2; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118:195,Testability,benchmark,benchmarks,195,"Finally all tests pass 🎉 Thanks @navidcy and @vchuravy for all your help!. @glwagner Let me know when it would be a good time to merge this PR and tag a new release. Ran the incompressible model benchmarks and in general it seems that with Julia 1.6 Oceananigans allocates more memory and is a bit slower on the CPU but a bit faster on the GPU. # Quick benchmark. ## Julia 1.6. ```; Oceananigans v0.57.2; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 4.996 ms │ 5.047 ms │ 5.113 ms │ 5.770 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 64 │ 34.951 ms │ 35.967 ms │ 36.414 ms │ 41.417 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 128 │ 301.074 ms │ 301.964 ms │ 302.498 ms │ 307.989 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 256 │ 2.894 s │ 2.895 s │ 2.895 s │ 2.896 s │ 1.77 MiB │ 2301 │ 2 │; │ GPU │ Float64 │ 32 │ 2.859 ms │ 2.923 ms │ 3.025 ms │ 3.987 ms │ 2.80 MiB │ 6914 │ 10 │; │ GPU │ Float64 │ 64 │ 2.912 ms │ 3.101 ms │ 3.308 ms │ 5.368 ms │ 2.78 MiB │ 6993 │ 10 │; │ GPU │ Float64 │ 128 │ 4.894 ms │ 5.019 ms │ 5.360 ms │ 8.565 ms │ 2.80 MiB │ 8667 │ 10 │; │ GPU │ Float64 │ 256 │ 33.569 ms │ 36.266 ms │ 36.029 ms │ 36.883 ms │ 3.24 MiB │ 37307 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘; ```. ## Julia 1.5. ```; Oceananigans v0.57.2; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118:353,Testability,benchmark,benchmark,353,"Finally all tests pass 🎉 Thanks @navidcy and @vchuravy for all your help!. @glwagner Let me know when it would be a good time to merge this PR and tag a new release. Ran the incompressible model benchmarks and in general it seems that with Julia 1.6 Oceananigans allocates more memory and is a bit slower on the CPU but a bit faster on the GPU. # Quick benchmark. ## Julia 1.6. ```; Oceananigans v0.57.2; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 4.996 ms │ 5.047 ms │ 5.113 ms │ 5.770 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 64 │ 34.951 ms │ 35.967 ms │ 36.414 ms │ 41.417 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 128 │ 301.074 ms │ 301.964 ms │ 302.498 ms │ 307.989 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 256 │ 2.894 s │ 2.895 s │ 2.895 s │ 2.896 s │ 1.77 MiB │ 2301 │ 2 │; │ GPU │ Float64 │ 32 │ 2.859 ms │ 2.923 ms │ 3.025 ms │ 3.987 ms │ 2.80 MiB │ 6914 │ 10 │; │ GPU │ Float64 │ 64 │ 2.912 ms │ 3.101 ms │ 3.308 ms │ 5.368 ms │ 2.78 MiB │ 6993 │ 10 │; │ GPU │ Float64 │ 128 │ 4.894 ms │ 5.019 ms │ 5.360 ms │ 8.565 ms │ 2.80 MiB │ 8667 │ 10 │; │ GPU │ Float64 │ 256 │ 33.569 ms │ 36.266 ms │ 36.029 ms │ 36.883 ms │ 3.24 MiB │ 37307 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘; ```. ## Julia 1.5. ```; Oceananigans v0.57.2; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118:689,Testability,benchmark,benchmarks,689,"Finally all tests pass 🎉 Thanks @navidcy and @vchuravy for all your help!. @glwagner Let me know when it would be a good time to merge this PR and tag a new release. Ran the incompressible model benchmarks and in general it seems that with Julia 1.6 Oceananigans allocates more memory and is a bit slower on the CPU but a bit faster on the GPU. # Quick benchmark. ## Julia 1.6. ```; Oceananigans v0.57.2; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 4.996 ms │ 5.047 ms │ 5.113 ms │ 5.770 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 64 │ 34.951 ms │ 35.967 ms │ 36.414 ms │ 41.417 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 128 │ 301.074 ms │ 301.964 ms │ 302.498 ms │ 307.989 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 256 │ 2.894 s │ 2.895 s │ 2.895 s │ 2.896 s │ 1.77 MiB │ 2301 │ 2 │; │ GPU │ Float64 │ 32 │ 2.859 ms │ 2.923 ms │ 3.025 ms │ 3.987 ms │ 2.80 MiB │ 6914 │ 10 │; │ GPU │ Float64 │ 64 │ 2.912 ms │ 3.101 ms │ 3.308 ms │ 5.368 ms │ 2.78 MiB │ 6993 │ 10 │; │ GPU │ Float64 │ 128 │ 4.894 ms │ 5.019 ms │ 5.360 ms │ 8.565 ms │ 2.80 MiB │ 8667 │ 10 │; │ GPU │ Float64 │ 256 │ 33.569 ms │ 36.266 ms │ 36.029 ms │ 36.883 ms │ 3.24 MiB │ 37307 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘; ```. ## Julia 1.5. ```; Oceananigans v0.57.2; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118:2231,Testability,benchmark,benchmarks,2231,"│; │ GPU │ Float64 │ 32 │ 2.859 ms │ 2.923 ms │ 3.025 ms │ 3.987 ms │ 2.80 MiB │ 6914 │ 10 │; │ GPU │ Float64 │ 64 │ 2.912 ms │ 3.101 ms │ 3.308 ms │ 5.368 ms │ 2.78 MiB │ 6993 │ 10 │; │ GPU │ Float64 │ 128 │ 4.894 ms │ 5.019 ms │ 5.360 ms │ 8.565 ms │ 2.80 MiB │ 8667 │ 10 │; │ GPU │ Float64 │ 256 │ 33.569 ms │ 36.266 ms │ 36.029 ms │ 36.883 ms │ 3.24 MiB │ 37307 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘; ```. ## Julia 1.5. ```; Oceananigans v0.57.2; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬─────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼─────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 4.905 ms │ 5.116 ms │ 5.237 ms │ 6.262 ms │ 360.44 KiB │ 2142 │ 10 │; │ CPU │ Float64 │ 64 │ 34.327 ms │ 36.419 ms │ 36.188 ms │ 37.507 ms │ 360.44 KiB │ 2142 │ 10 │; │ CPU │ Float64 │ 128 │ 297.567 ms │ 299.404 ms │ 299.856 ms │ 303.081 ms │ 360.44 KiB │ 2142 │ 10 │; │ CPU │ Float64 │ 256 │ 2.786 s │ 2.786 s │ 2.786 s │ 2.787 s │ 360.44 KiB │ 2142 │ 2 │; │ GPU │ Float64 │ 32 │ 2.729 ms │ 2.781 ms │ 2.885 ms │ 3.717 ms │ 839.83 KiB │ 7132 │ 10 │; │ GPU │ Float64 │ 64 │ 2.894 ms │ 3.055 ms │ 3.136 ms │ 4.046 ms │ 879.45 KiB │ 7124 │ 10 │; │ GPU │ Float64 │ 128 │ 4.107 ms │ 4.836 ms │ 4.890 ms │ 6.086 ms │ 964.73 KiB │ 7142 │ 10 │; │ GPU │ Float64 │ 256 │ 21.667 ms │ 35.642 ms │ 34.245 ms │ 35.746 ms │ 1.11 MiB │ 7134 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴──",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843636118
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843693187:215,Testability,benchmark,benchmarks,215,> Quick quick question: Should we be concerned about the GPU memory allocations? They're roughly 3x larger for 1.6 which is a pretty big difference! Especially considering the size limitations on GPUs. Ah so in the benchmarks those are just CPU memory allocations since BenchmarkTools.jl doesn't measure GPU allocations. `CUDA.@time` can measure GPU allocations but I haven't used it much on Oceananigans. I don't think it's a cause for worry but it might be good to do some profiling at some point to figure out where the extra memory allocations are coming from. Interestingly the benchmarks suggest that GPU models are actually a bit faster now :eyes:,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843693187
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843693187:270,Testability,Benchmark,BenchmarkTools,270,> Quick quick question: Should we be concerned about the GPU memory allocations? They're roughly 3x larger for 1.6 which is a pretty big difference! Especially considering the size limitations on GPUs. Ah so in the benchmarks those are just CPU memory allocations since BenchmarkTools.jl doesn't measure GPU allocations. `CUDA.@time` can measure GPU allocations but I haven't used it much on Oceananigans. I don't think it's a cause for worry but it might be good to do some profiling at some point to figure out where the extra memory allocations are coming from. Interestingly the benchmarks suggest that GPU models are actually a bit faster now :eyes:,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843693187
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843693187:583,Testability,benchmark,benchmarks,583,> Quick quick question: Should we be concerned about the GPU memory allocations? They're roughly 3x larger for 1.6 which is a pretty big difference! Especially considering the size limitations on GPUs. Ah so in the benchmarks those are just CPU memory allocations since BenchmarkTools.jl doesn't measure GPU allocations. `CUDA.@time` can measure GPU allocations but I haven't used it much on Oceananigans. I don't think it's a cause for worry but it might be good to do some profiling at some point to figure out where the extra memory allocations are coming from. Interestingly the benchmarks suggest that GPU models are actually a bit faster now :eyes:,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-843693187
https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-844319959:312,Performance,perform,performance,312,I'm not sure --- but it's possible that some GPU utilities not under Oceananigans.jl control incur memory allocations. I don't think we have much GPU-specific code in our codebase (except for pressure solvers...) Definitely a good thing to keep tabs on and open issues in the relevant packages if it affects the performance of our code.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-844319959
https://github.com/CliMA/Oceananigans.jl/pull/1516#issuecomment-809505375:191,Deployability,update,updated,191,"I'm playing with trying `Flat` in this example and as with `convectiong_plankton.jl` I found that removing `progress` and `wizard` seemed to make it work. Clearly these two things need to be updated before we can start to use `Flat`. I am not suggesting this be changed here, but I mention this in reference to #1513 .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1516#issuecomment-809505375
https://github.com/CliMA/Oceananigans.jl/pull/1516#issuecomment-809505375:155,Usability,Clear,Clearly,155,"I'm playing with trying `Flat` in this example and as with `convectiong_plankton.jl` I found that removing `progress` and `wizard` seemed to make it work. Clearly these two things need to be updated before we can start to use `Flat`. I am not suggesting this be changed here, but I mention this in reference to #1513 .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1516#issuecomment-809505375
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809484323:9,Energy Efficiency,reduce,reduce,9,When you reduce the averaging window do differences diminish? What if your averaging window is a dt?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809484323
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746:282,Integrability,depend,dependent,282,"Very thorough write-up, thank you!. My initial reaction is that maybe something is not wrong. Intuitively I feel that TKE statistics are generally less noisy than dissipation statistics, but I agree the difference between snapshot and time average is pretty big. This is simulation dependent and I'm sure you've thought about all this though. The two should agree in the limit that the averaging window (and output interval) goes to zero? Otherwise there's a bug. I think we have pretty good time averaging tests for NetCDF with analytic solutions (https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_netcdf_output_writer.jl#L476-L570) but we don't explicitly test `NetCDFOutputWriter` + `KernelComputedField` + `AveragedTimeInterval` so there could be a bug. What does a movie of dissipation look like?. I notice the time step is `Δt = 20minutes` while the output interval is `100minutes` so at most a time average will contain 4-5 iterations worth of data. If dissipation changes rapidly (or has a period) then I can see the average being quite different from the snapshot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746:507,Testability,test,tests,507,"Very thorough write-up, thank you!. My initial reaction is that maybe something is not wrong. Intuitively I feel that TKE statistics are generally less noisy than dissipation statistics, but I agree the difference between snapshot and time average is pretty big. This is simulation dependent and I'm sure you've thought about all this though. The two should agree in the limit that the averaging window (and output interval) goes to zero? Otherwise there's a bug. I think we have pretty good time averaging tests for NetCDF with analytic solutions (https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_netcdf_output_writer.jl#L476-L570) but we don't explicitly test `NetCDFOutputWriter` + `KernelComputedField` + `AveragedTimeInterval` so there could be a bug. What does a movie of dissipation look like?. I notice the time step is `Δt = 20minutes` while the output interval is `100minutes` so at most a time average will contain 4-5 iterations worth of data. If dissipation changes rapidly (or has a period) then I can see the average being quite different from the snapshot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746:602,Testability,test,test,602,"Very thorough write-up, thank you!. My initial reaction is that maybe something is not wrong. Intuitively I feel that TKE statistics are generally less noisy than dissipation statistics, but I agree the difference between snapshot and time average is pretty big. This is simulation dependent and I'm sure you've thought about all this though. The two should agree in the limit that the averaging window (and output interval) goes to zero? Otherwise there's a bug. I think we have pretty good time averaging tests for NetCDF with analytic solutions (https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_netcdf_output_writer.jl#L476-L570) but we don't explicitly test `NetCDFOutputWriter` + `KernelComputedField` + `AveragedTimeInterval` so there could be a bug. What does a movie of dissipation look like?. I notice the time step is `Δt = 20minutes` while the output interval is `100minutes` so at most a time average will contain 4-5 iterations worth of data. If dissipation changes rapidly (or has a period) then I can see the average being quite different from the snapshot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746:671,Testability,test,test,671,"Very thorough write-up, thank you!. My initial reaction is that maybe something is not wrong. Intuitively I feel that TKE statistics are generally less noisy than dissipation statistics, but I agree the difference between snapshot and time average is pretty big. This is simulation dependent and I'm sure you've thought about all this though. The two should agree in the limit that the averaging window (and output interval) goes to zero? Otherwise there's a bug. I think we have pretty good time averaging tests for NetCDF with analytic solutions (https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_netcdf_output_writer.jl#L476-L570) but we don't explicitly test `NetCDFOutputWriter` + `KernelComputedField` + `AveragedTimeInterval` so there could be a bug. What does a movie of dissipation look like?. I notice the time step is `Δt = 20minutes` while the output interval is `100minutes` so at most a time average will contain 4-5 iterations worth of data. If dissipation changes rapidly (or has a period) then I can see the average being quite different from the snapshot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746:94,Usability,Intuit,Intuitively,94,"Very thorough write-up, thank you!. My initial reaction is that maybe something is not wrong. Intuitively I feel that TKE statistics are generally less noisy than dissipation statistics, but I agree the difference between snapshot and time average is pretty big. This is simulation dependent and I'm sure you've thought about all this though. The two should agree in the limit that the averaging window (and output interval) goes to zero? Otherwise there's a bug. I think we have pretty good time averaging tests for NetCDF with analytic solutions (https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_netcdf_output_writer.jl#L476-L570) but we don't explicitly test `NetCDFOutputWriter` + `KernelComputedField` + `AveragedTimeInterval` so there could be a bug. What does a movie of dissipation look like?. I notice the time step is `Δt = 20minutes` while the output interval is `100minutes` so at most a time average will contain 4-5 iterations worth of data. If dissipation changes rapidly (or has a period) then I can see the average being quite different from the snapshot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809553813:27,Availability,error,error,27,"EDIT: I just found a small error in the results posted in this last comment, so I'll re-post them after I correct it! Sorry",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809553813
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809575458:11,Energy Efficiency,reduce,reduce,11,"> When you reduce the averaging window do differences diminish? What if your averaging window is a dt?. Okay so this is a good test and the results are not at all what I thought they were gonna be. In the figures and videos below the intervals for both the snapshots and time averages are exactly the same as `Δt= 20minutes`. Decreasing the intervals to Δt actually increased the difference between avg and snapshot a bit, but mostly they remain the same. (Note that the results are now exactly two orders of magnitude smaller than before, due to me not including the viscosity in the previous calculations, which is exactly 0.01.). ![Screenshot from 2021-03-29 10-30-17](https://user-images.githubusercontent.com/13205162/112875996-ce35b180-9079-11eb-9239-7300afd4230d.png). > What does a movie of dissipation look like?. That's actually interesting. I had looked at the movie based on the snapshots and it seemed fine, but I made the mistake of not checking the averaged outputs as a movie. I plotted it but it looks weird. Here's a movie of dissipation close to the surface based on the snapshot outputs:. https://user-images.githubusercontent.com/13205162/112876926-f376ef80-907a-11eb-8d8b-412ce466f4fc.mp4. And here's the same movie but based on the avg outputs (which now have `interval=Δt`). (Note that the color ranges are the same). https://user-images.githubusercontent.com/13205162/112876947-fa056700-907a-11eb-9de1-a7fc3ee39253.mp4. To me the snapshot movie looks okay but I definitely did not expect what happens in the avg one. It looks like there's some sort of accumulation which shouldn't be there, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809575458
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809575458:127,Testability,test,test,127,"> When you reduce the averaging window do differences diminish? What if your averaging window is a dt?. Okay so this is a good test and the results are not at all what I thought they were gonna be. In the figures and videos below the intervals for both the snapshots and time averages are exactly the same as `Δt= 20minutes`. Decreasing the intervals to Δt actually increased the difference between avg and snapshot a bit, but mostly they remain the same. (Note that the results are now exactly two orders of magnitude smaller than before, due to me not including the viscosity in the previous calculations, which is exactly 0.01.). ![Screenshot from 2021-03-29 10-30-17](https://user-images.githubusercontent.com/13205162/112875996-ce35b180-9079-11eb-9239-7300afd4230d.png). > What does a movie of dissipation look like?. That's actually interesting. I had looked at the movie based on the snapshots and it seemed fine, but I made the mistake of not checking the averaged outputs as a movie. I plotted it but it looks weird. Here's a movie of dissipation close to the surface based on the snapshot outputs:. https://user-images.githubusercontent.com/13205162/112876926-f376ef80-907a-11eb-8d8b-412ce466f4fc.mp4. And here's the same movie but based on the avg outputs (which now have `interval=Δt`). (Note that the color ranges are the same). https://user-images.githubusercontent.com/13205162/112876947-fa056700-907a-11eb-9de1-a7fc3ee39253.mp4. To me the snapshot movie looks okay but I definitely did not expect what happens in the avg one. It looks like there's some sort of accumulation which shouldn't be there, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809575458
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809585691:248,Testability,test,test,248,"Hmmm, not sure what the issue could be but dissipation field does look well-behaved. I agree that the time average isn't what I would expect based on the movie of the dissipation snapshots. Maybe the best way to approach this is to design a simple test that uses `KernelComputedField` + `TimeAveragedInterval`?. I'll have a look at the code to see if there's anything that stands out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809585691
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809585691:241,Usability,simpl,simple,241,"Hmmm, not sure what the issue could be but dissipation field does look well-behaved. I agree that the time average isn't what I would expect based on the movie of the dissipation snapshots. Maybe the best way to approach this is to design a simple test that uses `KernelComputedField` + `TimeAveragedInterval`?. I'll have a look at the code to see if there's anything that stands out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809585691
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170:2821,Testability,test,tests,2821,"veraged), which indicates that the issue doesn't necessarily have to do with `KernelComputedField`s. https://user-images.githubusercontent.com/13205162/112888062-c03b5d00-9088-11eb-9d70-82ecda21477b.mp4. https://user-images.githubusercontent.com/13205162/112888067-c3364d80-9088-11eb-8eb4-4c5174f45b62.mp4. Here are some line plots comparing dissipation calculated with both `ComputedFields` (cf) and `KernelComputedFields` (kcf) and output with both `TimeInterval` and `AveragedTimeInterval`. (Sorry for the colors being weird, but I wanna be able to see the overlaps.). ![Screenshot from 2021-03-29 12-23-18](https://user-images.githubusercontent.com/13205162/112888734-959dd400-9089-11eb-8423-44dfa0df94ff.png). As you can see the time-averaged results are consistent with each other, but not with the snapshot results. However, if I plot TKE I get somewhat different results:. ![Screenshot from 2021-03-29 12-22-55](https://user-images.githubusercontent.com/13205162/112888917-cbdb5380-9089-11eb-82c7-2de997138b1b.png). Here the snapshot results are consistent with each other, but the time-averaged TKE results computed with `ComputedFields` actually match the snapshots, but not the time-averaged TKE results computed with `KernelComputedFields`!. There's also a difference between the u-velocity using time-averaged results and snapshots:. ![Screenshot from 2021-03-29 12-32-23](https://user-images.githubusercontent.com/13205162/112889703-d8ac7700-908a-11eb-8e03-a5c3b6a70f02.png). I think this last plot provides us with a clue since the averages start at the right value, but the oscillations get dampened as time progresses. This may indicate that the average is being done with a window much bigger than the averaging period for some reason. Although this last one is hard to believe since, as @ali-ramadhan pointed out, there are many tests for `AveragedTimeInterval` and I feel like they'd have caught that. In any case, that's all I got for now! Some feedback is very much appreciated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170:2939,Usability,feedback,feedback,2939,"veraged), which indicates that the issue doesn't necessarily have to do with `KernelComputedField`s. https://user-images.githubusercontent.com/13205162/112888062-c03b5d00-9088-11eb-9d70-82ecda21477b.mp4. https://user-images.githubusercontent.com/13205162/112888067-c3364d80-9088-11eb-8eb4-4c5174f45b62.mp4. Here are some line plots comparing dissipation calculated with both `ComputedFields` (cf) and `KernelComputedFields` (kcf) and output with both `TimeInterval` and `AveragedTimeInterval`. (Sorry for the colors being weird, but I wanna be able to see the overlaps.). ![Screenshot from 2021-03-29 12-23-18](https://user-images.githubusercontent.com/13205162/112888734-959dd400-9089-11eb-8423-44dfa0df94ff.png). As you can see the time-averaged results are consistent with each other, but not with the snapshot results. However, if I plot TKE I get somewhat different results:. ![Screenshot from 2021-03-29 12-22-55](https://user-images.githubusercontent.com/13205162/112888917-cbdb5380-9089-11eb-82c7-2de997138b1b.png). Here the snapshot results are consistent with each other, but the time-averaged TKE results computed with `ComputedFields` actually match the snapshots, but not the time-averaged TKE results computed with `KernelComputedFields`!. There's also a difference between the u-velocity using time-averaged results and snapshots:. ![Screenshot from 2021-03-29 12-32-23](https://user-images.githubusercontent.com/13205162/112889703-d8ac7700-908a-11eb-8e03-a5c3b6a70f02.png). I think this last plot provides us with a clue since the averages start at the right value, but the oscillations get dampened as time progresses. This may indicate that the average is being done with a window much bigger than the averaging period for some reason. Although this last one is hard to believe since, as @ali-ramadhan pointed out, there are many tests for `AveragedTimeInterval` and I feel like they'd have caught that. In any case, that's all I got for now! Some feedback is very much appreciated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809893411:630,Performance,perform,performs,630,"This is worrisome!. What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. It certainly seems that the time-averaged output is incorrect, but only for certain types of output, which is puzzling. One thought is that it seems possible to write a utility / function that calculates time-averages directly from snapshots and compares the result with time-averages generated by `WindowedTimeAverage`. We could even write a function that takes in a field and a simulation, and then constructs the two output writers, runs the simulation, and performs the analysis. The first TKE example should pass, but dissipation should not. Perhaps even time-averaging the velocity field is not correct? We can then experiment with types of output to figure out what ingredient leads to a discrepancy. > Here the snapshot results are consistent with each other, but the time-averaged TKE results computed with ComputedFields actually match the snapshots, but not the time-averaged TKE results computed with KernelComputedFields!. I think I might have missed something --- in the very first example, was TKE computed using a `ComputedField` or `KernelComputedField`? Are the later results in this post consistent with the first posted results?. Is there any way that any of this has to do with time-step alignment?. Lastly, why is the window slightly different from the `TimeInterval`? What happens when the time-interval and averaging window are the same (which appears to be our default?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809893411
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267:1727,Integrability,message,messages,1727,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267:1715,Safety,avoid,avoid,1715,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267:1159,Testability,test,test,1159,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267:249,Usability,clear,clear,249,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153:307,Testability,test,test,307,"Okay, so in summary:. * *Correct*: time-averaging a TKE `ComputedField`; * *Wrong*: time-averaging a TKE `KernelComputedField`; * *Wrong*: time-averaging a dissipation `ComputedField`; * *Wrong*: time-averaging a dissipation `KernelComputedField`. I think probably the next step is to design a quantitative test that currently fails but should pass when this bug is fixed. Designing a minimal test might also help us isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153:393,Testability,test,test,393,"Okay, so in summary:. * *Correct*: time-averaging a TKE `ComputedField`; * *Wrong*: time-averaging a TKE `KernelComputedField`; * *Wrong*: time-averaging a dissipation `ComputedField`; * *Wrong*: time-averaging a dissipation `KernelComputedField`. I think probably the next step is to design a quantitative test that currently fails but should pass when this bug is fixed. Designing a minimal test might also help us isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-813815585:176,Testability,test,test,176,"@tomchor are you suggesting that someone should run your julia and python scripts to see if the plots are the same, or are you suggesting that we work on a different example / test that demonstrates the same issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-813815585
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-814125461:308,Availability,error,error,308,"I guess both would be good. But specifically I meant that it'd be good for someone to run the same scripts I ran and see if they can reproduce the behavior. Who knows, maybe it's something wrong in my setup. (Although I have tried in both my laptop and on the Casper cluster.). I do think it's weird that an error (apparently) this serious isn't being caught by the tests, so it's very possible that I'm making a silly mistake somewhere... having someone investigate this as well would alleviate this concern a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-814125461
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-814125461:366,Testability,test,tests,366,"I guess both would be good. But specifically I meant that it'd be good for someone to run the same scripts I ran and see if they can reproduce the behavior. Who knows, maybe it's something wrong in my setup. (Although I have tried in both my laptop and on the Casper cluster.). I do think it's weird that an error (apparently) this serious isn't being caught by the tests, so it's very possible that I'm making a silly mistake somewhere... having someone investigate this as well would alleviate this concern a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-814125461
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817931493:339,Availability,error,errors,339,"A couple of quick things: . - Has anyone tried to reproduce this result independently so far?; - I'm assuming we're close to releasing a new version. Should we remove this feature for now? Everything so far points to it producing qualitatively wrong results for a functionality that's kinda basic. This could easily introduce pretty major errors in someone's research (and it almost did for me; I was lucky to catch this). Again, that's all assuming this error is real. Which we can't be sure until someone else double-checks me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817931493
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817931493:455,Availability,error,error,455,"A couple of quick things: . - Has anyone tried to reproduce this result independently so far?; - I'm assuming we're close to releasing a new version. Should we remove this feature for now? Everything so far points to it producing qualitatively wrong results for a functionality that's kinda basic. This could easily introduce pretty major errors in someone's research (and it almost did for me; I was lucky to catch this). Again, that's all assuming this error is real. Which we can't be sure until someone else double-checks me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817931493
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659:10,Availability,down,down,10,"I started down that road, but had to install some packages to get the script to run and haven't returned to it yet! I'm confused at how running the exact same code that you ran will uncover an issue. Isn't it more likely that there is a bug in the script, than some issue with computers / software versions?. An efficient path forward might be to write a test that fails due to this error? Then submit a PR that adds the failing test, and we can collaborate on getting the test to pass. We'd have to do this anyways; and writing a test is a good way to come up with a minimal example that we could use to isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659:383,Availability,error,error,383,"I started down that road, but had to install some packages to get the script to run and haven't returned to it yet! I'm confused at how running the exact same code that you ran will uncover an issue. Isn't it more likely that there is a bug in the script, than some issue with computers / software versions?. An efficient path forward might be to write a test that fails due to this error? Then submit a PR that adds the failing test, and we can collaborate on getting the test to pass. We'd have to do this anyways; and writing a test is a good way to come up with a minimal example that we could use to isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659:37,Deployability,install,install,37,"I started down that road, but had to install some packages to get the script to run and haven't returned to it yet! I'm confused at how running the exact same code that you ran will uncover an issue. Isn't it more likely that there is a bug in the script, than some issue with computers / software versions?. An efficient path forward might be to write a test that fails due to this error? Then submit a PR that adds the failing test, and we can collaborate on getting the test to pass. We'd have to do this anyways; and writing a test is a good way to come up with a minimal example that we could use to isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659:312,Energy Efficiency,efficient,efficient,312,"I started down that road, but had to install some packages to get the script to run and haven't returned to it yet! I'm confused at how running the exact same code that you ran will uncover an issue. Isn't it more likely that there is a bug in the script, than some issue with computers / software versions?. An efficient path forward might be to write a test that fails due to this error? Then submit a PR that adds the failing test, and we can collaborate on getting the test to pass. We'd have to do this anyways; and writing a test is a good way to come up with a minimal example that we could use to isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659:355,Testability,test,test,355,"I started down that road, but had to install some packages to get the script to run and haven't returned to it yet! I'm confused at how running the exact same code that you ran will uncover an issue. Isn't it more likely that there is a bug in the script, than some issue with computers / software versions?. An efficient path forward might be to write a test that fails due to this error? Then submit a PR that adds the failing test, and we can collaborate on getting the test to pass. We'd have to do this anyways; and writing a test is a good way to come up with a minimal example that we could use to isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659:429,Testability,test,test,429,"I started down that road, but had to install some packages to get the script to run and haven't returned to it yet! I'm confused at how running the exact same code that you ran will uncover an issue. Isn't it more likely that there is a bug in the script, than some issue with computers / software versions?. An efficient path forward might be to write a test that fails due to this error? Then submit a PR that adds the failing test, and we can collaborate on getting the test to pass. We'd have to do this anyways; and writing a test is a good way to come up with a minimal example that we could use to isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659:473,Testability,test,test,473,"I started down that road, but had to install some packages to get the script to run and haven't returned to it yet! I'm confused at how running the exact same code that you ran will uncover an issue. Isn't it more likely that there is a bug in the script, than some issue with computers / software versions?. An efficient path forward might be to write a test that fails due to this error? Then submit a PR that adds the failing test, and we can collaborate on getting the test to pass. We'd have to do this anyways; and writing a test is a good way to come up with a minimal example that we could use to isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659:531,Testability,test,test,531,"I started down that road, but had to install some packages to get the script to run and haven't returned to it yet! I'm confused at how running the exact same code that you ran will uncover an issue. Isn't it more likely that there is a bug in the script, than some issue with computers / software versions?. An efficient path forward might be to write a test that fails due to this error? Then submit a PR that adds the failing test, and we can collaborate on getting the test to pass. We'd have to do this anyways; and writing a test is a good way to come up with a minimal example that we could use to isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817964604:31,Testability,test,test,31,"How about we work on a minimal test / example? If you can list the essential ingrdients, I can write up a test and submit a PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817964604
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817964604:106,Testability,test,test,106,"How about we work on a minimal test / example? If you can list the essential ingrdients, I can write up a test and submit a PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817964604
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702:310,Safety,predict,predictably,310,"Sure we can do that. But before we start a PR with a new test, shouldn't we first make sure there isn't anything wrong with my script?. That said, I think the basic ingredients are. - A time-average (NetCDF?) output (obviously); - Some diagnostic (preferably a Field, not a ComputedField) that changes in time predictably. The issue with creating a truly _minimal_ MWE is that (like [your comment summed up well](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153)) it's not clear which outputs exhibit the issue and which ones don't. I _think_ we might be able to get away with simply starting a quiescent simulation apart from a uniform u velocity and see if the total momentum is conserved on average. (This should start inertial oscillations.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702:57,Testability,test,test,57,"Sure we can do that. But before we start a PR with a new test, shouldn't we first make sure there isn't anything wrong with my script?. That said, I think the basic ingredients are. - A time-average (NetCDF?) output (obviously); - Some diagnostic (preferably a Field, not a ComputedField) that changes in time predictably. The issue with creating a truly _minimal_ MWE is that (like [your comment summed up well](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153)) it's not clear which outputs exhibit the issue and which ones don't. I _think_ we might be able to get away with simply starting a quiescent simulation apart from a uniform u velocity and see if the total momentum is conserved on average. (This should start inertial oscillations.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702:500,Usability,clear,clear,500,"Sure we can do that. But before we start a PR with a new test, shouldn't we first make sure there isn't anything wrong with my script?. That said, I think the basic ingredients are. - A time-average (NetCDF?) output (obviously); - Some diagnostic (preferably a Field, not a ComputedField) that changes in time predictably. The issue with creating a truly _minimal_ MWE is that (like [your comment summed up well](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153)) it's not clear which outputs exhibit the issue and which ones don't. I _think_ we might be able to get away with simply starting a quiescent simulation apart from a uniform u velocity and see if the total momentum is conserved on average. (This should start inertial oscillations.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702:604,Usability,simpl,simply,604,"Sure we can do that. But before we start a PR with a new test, shouldn't we first make sure there isn't anything wrong with my script?. That said, I think the basic ingredients are. - A time-average (NetCDF?) output (obviously); - Some diagnostic (preferably a Field, not a ComputedField) that changes in time predictably. The issue with creating a truly _minimal_ MWE is that (like [your comment summed up well](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153)) it's not clear which outputs exhibit the issue and which ones don't. I _think_ we might be able to get away with simply starting a quiescent simulation apart from a uniform u velocity and see if the total momentum is conserved on average. (This should start inertial oscillations.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817979922:30,Testability,test,test,30,"I believe setting up a simple test is a quick way to determine whether there is a problem with your script and also improves Oceananigans.jl, making progress towards solving this problem, if there is one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817979922
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817979922:23,Usability,simpl,simple,23,"I believe setting up a simple test is a quick way to determine whether there is a problem with your script and also improves Oceananigans.jl, making progress towards solving this problem, if there is one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817979922
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817981813:10,Testability,test,test,10,We have a test that satisfies those requirements I believe:. https://github.com/CliMA/Oceananigans.jl/blob/39ee546803b05fdf1fdaec2880fede5b5aaebe10/test/test_netcdf_output_writer.jl#L476-L570. In particular it uses a tracer solution that decays exponentially in time at a rate that is different at every grid point. What are the additional ingredients in your script that lead to a bug?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817981813
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817981813:148,Testability,test,test,148,We have a test that satisfies those requirements I believe:. https://github.com/CliMA/Oceananigans.jl/blob/39ee546803b05fdf1fdaec2880fede5b5aaebe10/test/test_netcdf_output_writer.jl#L476-L570. In particular it uses a tracer solution that decays exponentially in time at a rate that is different at every grid point. What are the additional ingredients in your script that lead to a bug?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817981813
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817983202:23,Testability,test,test,23,"Hmm, we could set up a test that uses momentum. I'm not sure the physics of the model matter here, this more seems to be an issue with how time-averaging works (thus a forced tracer is hopefully sufficient --- but we may need to try to average diagnostics / computed fields?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817983202
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388:56,Availability,error,error,56,"Honestly, my thought is that that test should catch the error already. I; can't immediately think of anything else required.; I might implement that test manually on my end and see if the results are; correct. Like I said, there's a possibility that I'm just using; AveragedTimeInterval wrong... On Mon, Apr 12, 2021 at 10:13 AM Gregory L. Wagner ***@***.***>; wrote:. > We have a test that satisfies those requirements I believe:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/39ee546803b05fdf1fdaec2880fede5b5aaebe10/test/test_netcdf_output_writer.jl#L476-L570; >; > In particular it uses a tracer solution that decays exponentially in time; > at a rate that is different at every grid point.; >; > What are the additional ingredients in your script that lead to a bug?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817981813>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KVVXNDWA7HVZ4HYBTTTIMS4HANCNFSM4Z7XXUAQ>; > .; >. -- ; Tomás L. Chor; Postdoctoral researcher; Atmospheric and Oceanic Science department; University of Maryland; https://tomchor.github.io/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388:34,Testability,test,test,34,"Honestly, my thought is that that test should catch the error already. I; can't immediately think of anything else required.; I might implement that test manually on my end and see if the results are; correct. Like I said, there's a possibility that I'm just using; AveragedTimeInterval wrong... On Mon, Apr 12, 2021 at 10:13 AM Gregory L. Wagner ***@***.***>; wrote:. > We have a test that satisfies those requirements I believe:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/39ee546803b05fdf1fdaec2880fede5b5aaebe10/test/test_netcdf_output_writer.jl#L476-L570; >; > In particular it uses a tracer solution that decays exponentially in time; > at a rate that is different at every grid point.; >; > What are the additional ingredients in your script that lead to a bug?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817981813>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KVVXNDWA7HVZ4HYBTTTIMS4HANCNFSM4Z7XXUAQ>; > .; >. -- ; Tomás L. Chor; Postdoctoral researcher; Atmospheric and Oceanic Science department; University of Maryland; https://tomchor.github.io/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388:149,Testability,test,test,149,"Honestly, my thought is that that test should catch the error already. I; can't immediately think of anything else required.; I might implement that test manually on my end and see if the results are; correct. Like I said, there's a possibility that I'm just using; AveragedTimeInterval wrong... On Mon, Apr 12, 2021 at 10:13 AM Gregory L. Wagner ***@***.***>; wrote:. > We have a test that satisfies those requirements I believe:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/39ee546803b05fdf1fdaec2880fede5b5aaebe10/test/test_netcdf_output_writer.jl#L476-L570; >; > In particular it uses a tracer solution that decays exponentially in time; > at a rate that is different at every grid point.; >; > What are the additional ingredients in your script that lead to a bug?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817981813>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KVVXNDWA7HVZ4HYBTTTIMS4HANCNFSM4Z7XXUAQ>; > .; >. -- ; Tomás L. Chor; Postdoctoral researcher; Atmospheric and Oceanic Science department; University of Maryland; https://tomchor.github.io/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388:381,Testability,test,test,381,"Honestly, my thought is that that test should catch the error already. I; can't immediately think of anything else required.; I might implement that test manually on my end and see if the results are; correct. Like I said, there's a possibility that I'm just using; AveragedTimeInterval wrong... On Mon, Apr 12, 2021 at 10:13 AM Gregory L. Wagner ***@***.***>; wrote:. > We have a test that satisfies those requirements I believe:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/39ee546803b05fdf1fdaec2880fede5b5aaebe10/test/test_netcdf_output_writer.jl#L476-L570; >; > In particular it uses a tracer solution that decays exponentially in time; > at a rate that is different at every grid point.; >; > What are the additional ingredients in your script that lead to a bug?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817981813>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KVVXNDWA7HVZ4HYBTTTIMS4HANCNFSM4Z7XXUAQ>; > .; >. -- ; Tomás L. Chor; Postdoctoral researcher; Atmospheric and Oceanic Science department; University of Maryland; https://tomchor.github.io/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388:527,Testability,test,test,527,"Honestly, my thought is that that test should catch the error already. I; can't immediately think of anything else required.; I might implement that test manually on my end and see if the results are; correct. Like I said, there's a possibility that I'm just using; AveragedTimeInterval wrong... On Mon, Apr 12, 2021 at 10:13 AM Gregory L. Wagner ***@***.***>; wrote:. > We have a test that satisfies those requirements I believe:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/39ee546803b05fdf1fdaec2880fede5b5aaebe10/test/test_netcdf_output_writer.jl#L476-L570; >; > In particular it uses a tracer solution that decays exponentially in time; > at a rate that is different at every grid point.; >; > What are the additional ingredients in your script that lead to a bug?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817981813>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KVVXNDWA7HVZ4HYBTTTIMS4HANCNFSM4Z7XXUAQ>; > .; >. -- ; Tomás L. Chor; Postdoctoral researcher; Atmospheric and Oceanic Science department; University of Maryland; https://tomchor.github.io/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817990912:88,Testability,test,test,88,"Doesn't your script use `ComputedField` and `KernelComputedField`?. What if we set up a test with two tracers, and then define a `ComputedField` that's a function of the two. It'd be nice to have tests for time-averaging of `ComputedField` and `KernelComputedField` anyways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817990912
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817990912:196,Testability,test,tests,196,"Doesn't your script use `ComputedField` and `KernelComputedField`?. What if we set up a test with two tracers, and then define a `ComputedField` that's a function of the two. It'd be nice to have tests for time-averaging of `ComputedField` and `KernelComputedField` anyways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817990912
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499:361,Availability,ping,ping,361,"Here's what I posted earlier:. > Correct: time-averaging a TKE ComputedField; Wrong: time-averaging a TKE KernelComputedField; Wrong: time-averaging a dissipation ComputedField; Wrong: time-averaging a dissipation KernelComputedField. From this list I might infer that the two ingredients are 1) `KernelComputedField` OR 2) gradients. Gradients / interpolation ping boundary conditions, which are tricky so there's good reason to test that. Maybe two tests: one for `ComputedField` with interpolation or derivatives, and another with `KernelComputedField` (that's maybe a bit simpler)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499:430,Testability,test,test,430,"Here's what I posted earlier:. > Correct: time-averaging a TKE ComputedField; Wrong: time-averaging a TKE KernelComputedField; Wrong: time-averaging a dissipation ComputedField; Wrong: time-averaging a dissipation KernelComputedField. From this list I might infer that the two ingredients are 1) `KernelComputedField` OR 2) gradients. Gradients / interpolation ping boundary conditions, which are tricky so there's good reason to test that. Maybe two tests: one for `ComputedField` with interpolation or derivatives, and another with `KernelComputedField` (that's maybe a bit simpler)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499:451,Testability,test,tests,451,"Here's what I posted earlier:. > Correct: time-averaging a TKE ComputedField; Wrong: time-averaging a TKE KernelComputedField; Wrong: time-averaging a dissipation ComputedField; Wrong: time-averaging a dissipation KernelComputedField. From this list I might infer that the two ingredients are 1) `KernelComputedField` OR 2) gradients. Gradients / interpolation ping boundary conditions, which are tricky so there's good reason to test that. Maybe two tests: one for `ComputedField` with interpolation or derivatives, and another with `KernelComputedField` (that's maybe a bit simpler)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499:576,Usability,simpl,simpler,576,"Here's what I posted earlier:. > Correct: time-averaging a TKE ComputedField; Wrong: time-averaging a TKE KernelComputedField; Wrong: time-averaging a dissipation ComputedField; Wrong: time-averaging a dissipation KernelComputedField. From this list I might infer that the two ingredients are 1) `KernelComputedField` OR 2) gradients. Gradients / interpolation ping boundary conditions, which are tricky so there's good reason to test that. Maybe two tests: one for `ComputedField` with interpolation or derivatives, and another with `KernelComputedField` (that's maybe a bit simpler)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817993350:143,Testability,test,test,143,"Is that result for `u` obviously incorrect? It looks ok from the plot but maybe I'm not inferring enough detail from the setup. A quantitative test might be better (we can certainly try that). The averaging window is ""behind"" the output time, so you have to be careful about how you interpret the output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817993350
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817998872:28,Energy Efficiency,schedul,schedule,28,"In that example I'm using [`schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1)`](https://pastebin.com/F6ankx4L). So (unless I'm missing something), I expected the time-averaged results to be very close (if not identical) to the snapshot one, since it's only an average over `2Δt`. . From the plot it looks like the average instead is being performed over the interval `[0, t]`, for every `t`. (i.e., a cumulative average starting at the beginning of the simulation)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817998872
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817998872:352,Performance,perform,performed,352,"In that example I'm using [`schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1)`](https://pastebin.com/F6ankx4L). So (unless I'm missing something), I expected the time-averaged results to be very close (if not identical) to the snapshot one, since it's only an average over `2Δt`. . From the plot it looks like the average instead is being performed over the interval `[0, t]`, for every `t`. (i.e., a cumulative average starting at the beginning of the simulation)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817998872
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-818004533:22,Testability,test,test,22,"Hmm, interesting. The test uses. ```julia; window = 6Δt ; stride = 2 ; ```. I wonder if we should try fractional windows like you use. Maybe there's a bug associated with the 1.999. I'll set up something quickly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-818004533
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-818006716:21,Testability,test,test,21,I'll set up a simple test in which both tracers and velocity fields oscillate and see if we can reproduce the bug.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-818006716
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-818006716:14,Usability,simpl,simple,14,I'll set up a simple test in which both tracers and velocity fields oscillate and see if we can reproduce the bug.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-818006716
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872452104:152,Integrability,wrap,wrapping,152,"The code in https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/time_average_outputs.jl is a utility / user-convenience function for wrapping outputs passed to `JLD2OutputWriter` and `NetCDFOutputWriter` in a `WindowedTimeAverage`. It does not involve any averaging. If you can explain why you think it is convoluted, perhaps we can improve it. `WindowedTimeAverage` is defined in this file: https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/windowed_time_average.jl. The key part is `accumulate_result!`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L126-L144. Can you explain why isn't this captured in our tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872452104
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872452104:735,Testability,test,tests,735,"The code in https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/time_average_outputs.jl is a utility / user-convenience function for wrapping outputs passed to `JLD2OutputWriter` and `NetCDFOutputWriter` in a `WindowedTimeAverage`. It does not involve any averaging. If you can explain why you think it is convoluted, perhaps we can improve it. `WindowedTimeAverage` is defined in this file: https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/windowed_time_average.jl. The key part is `accumulate_result!`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L126-L144. Can you explain why isn't this captured in our tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872452104
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599:249,Energy Efficiency,schedul,schedule,249,"To address the first issue, here's the definition of `time_average_outputs`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L11-L16. The arguments are the specified `schedule` (which is an `AveragedTimeInterval` per the API we have designed), the `outputs` (here a `Dict`), `model`, and `field_slicer` (because we support averaging slices of fields). The first line:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L12-L13. converts the `outputs` `Dict` into a `Dict` of `WindowedTimeAverages` by wrapping each member of output in `WindowedTimeAverage`. The second part is to return the `TimeInterval` that corresponds to `AveragedTimeInterval`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L15. It'd be great to improve this functionality if we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599:662,Integrability,wrap,wrapping,662,"To address the first issue, here's the definition of `time_average_outputs`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L11-L16. The arguments are the specified `schedule` (which is an `AveragedTimeInterval` per the API we have designed), the `outputs` (here a `Dict`), `model`, and `field_slicer` (because we support averaging slices of fields). The first line:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L12-L13. converts the `outputs` `Dict` into a `Dict` of `WindowedTimeAverages` by wrapping each member of output in `WindowedTimeAverage`. The second part is to return the `TimeInterval` that corresponds to `AveragedTimeInterval`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L15. It'd be great to improve this functionality if we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141:154,Integrability,wrap,wrapping,154,"> The code in https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/time_average_outputs.jl is a utility / user-convenience function for wrapping outputs passed to JLD2OutputWriter and NetCDFOutputWriter in a WindowedTimeAverage. Yeah, sorry, `windowed_time_average.jl` is what I meant to link to. I guess somewhere these accumulation of the denominator of the mean should be reset to zero when the proper time interval has passed, but I'm not sure where. And thanks for the line-by-line explanation. I understand that part but I really don't see how to fix the issue right now. > Can you explain why isn't this captured in our tests?. I don't know for now. I don't fully understand the `WindowedTimeAveraged` tests to be honest. I think I'd need to run those manually on the REPL but I don't quite have a lot of time on my hands right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141:645,Testability,test,tests,645,"> The code in https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/time_average_outputs.jl is a utility / user-convenience function for wrapping outputs passed to JLD2OutputWriter and NetCDFOutputWriter in a WindowedTimeAverage. Yeah, sorry, `windowed_time_average.jl` is what I meant to link to. I guess somewhere these accumulation of the denominator of the mean should be reset to zero when the proper time interval has passed, but I'm not sure where. And thanks for the line-by-line explanation. I understand that part but I really don't see how to fix the issue right now. > Can you explain why isn't this captured in our tests?. I don't know for now. I don't fully understand the `WindowedTimeAveraged` tests to be honest. I think I'd need to run those manually on the REPL but I don't quite have a lot of time on my hands right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141:727,Testability,test,tests,727,"> The code in https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/time_average_outputs.jl is a utility / user-convenience function for wrapping outputs passed to JLD2OutputWriter and NetCDFOutputWriter in a WindowedTimeAverage. Yeah, sorry, `windowed_time_average.jl` is what I meant to link to. I guess somewhere these accumulation of the denominator of the mean should be reset to zero when the proper time interval has passed, but I'm not sure where. And thanks for the line-by-line explanation. I understand that part but I really don't see how to fix the issue right now. > Can you explain why isn't this captured in our tests?. I don't know for now. I don't fully understand the `WindowedTimeAveraged` tests to be honest. I think I'd need to run those manually on the REPL but I don't quite have a lot of time on my hands right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459502:869,Deployability,update,updated,869,"As for the titular issue, `accumulate_result!` tries to accumulate a time-average of it's `output` whenever it's called. The important line is. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L138. where. * `T_previous` is elapsed model time between the averaging start time and the time at which the average was ""previously"" accumulated; ie `T_previous = wta.previous_collection_time - wta.window_start_time`; * `Δt` is the time-interval between the end of `T_previous` and the current time, ie `Δt = model.clock.time - wta.previous_collection_time`; * `integrand` is the current value of the integrand from `integrand = fetch_output(wta.operand, model, wta.field_slicer)`; * `T_current` is the current time-interval, ie `model.clock.time - wta.window_start_time`. After the average is updated, the new ""previous"" collection time is also updated:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L141",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459502
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459502:921,Deployability,update,updated,921,"As for the titular issue, `accumulate_result!` tries to accumulate a time-average of it's `output` whenever it's called. The important line is. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L138. where. * `T_previous` is elapsed model time between the averaging start time and the time at which the average was ""previously"" accumulated; ie `T_previous = wta.previous_collection_time - wta.window_start_time`; * `Δt` is the time-interval between the end of `T_previous` and the current time, ie `Δt = model.clock.time - wta.previous_collection_time`; * `integrand` is the current value of the integrand from `integrand = fetch_output(wta.operand, model, wta.field_slicer)`; * `T_current` is the current time-interval, ie `model.clock.time - wta.window_start_time`. After the average is updated, the new ""previous"" collection time is also updated:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L141",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459502
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872468918:412,Energy Efficiency,schedul,schedule,412,> Are you getting a warning that output is occurring before the collection period is complete?. Nope. No warning at all. > but perhaps that branch doesn't execute. That's a good guess. Would that mean that this branch isn't executing?:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L180-L185. Since that's the place where `wta.schedule.collecting` goes to `false`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872468918
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872471651:471,Availability,error,error,471,"A warning is emitted if output is requested but `collecting=true`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L201-L203. But if you're not getting a warning then this isn't occurring. Do you have an MWE? If so we can play around. I suspect you might be hitting a flaw / bug in the algorithm that the tests don't hit. To figure out what that flaw is, we need an MWE that produces the error. It probably makes sense to average something that doesn't oscillate around 0 so spurious accumulation is obvious.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872471651
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872471651:388,Testability,test,tests,388,"A warning is emitted if output is requested but `collecting=true`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L201-L203. But if you're not getting a warning then this isn't occurring. Do you have an MWE? If so we can play around. I suspect you might be hitting a flaw / bug in the algorithm that the tests don't hit. To figure out what that flaw is, we need an MWE that produces the error. It probably makes sense to average something that doesn't oscillate around 0 so spurious accumulation is obvious.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872471651
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633:1277,Energy Efficiency,schedul,schedule,1277,"ans; using Oceananigans.Utils; using Oceananigans.Units. grid = RegularRectilinearGrid(size=(4, 4, 4), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0)); coriolis = FPlane(f=1e-4) # [s⁻¹]. model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = coriolis,; tracers = NamedTuple(),; buoyancy = nothing,; closure = nothing,; ); set!(model, u=0.4). using Oceanostics: SingleLineProgressMessenger; Δt = 20minutes; simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days,; progress = SingleLineProgressMessenger()). using Oceananigans.Fields: ComputedField; using Oceanostics: KineticEnergy. u, v, w = model.velocities # unpack velocity `Field`s. # Vertical vorticity [s⁻¹]; tke_k = KineticEnergy(model, u, v, w); tke_c = ComputedField(@at (Center, Center, Center) (u^2+v^2+w^2)/2). outputs = (tke_c=tke_c, u=u,). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(2Δt),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1),; filepath = ""avg.eady.nc"",; mode = ""c""). @info ""Starting run""; run!(simulation); ```. This produces the wrong result for `u`, reproduced below. (Appears to be a cumulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633:1419,Energy Efficiency,schedul,schedule,1419,"coriolis = FPlane(f=1e-4) # [s⁻¹]. model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = coriolis,; tracers = NamedTuple(),; buoyancy = nothing,; closure = nothing,; ); set!(model, u=0.4). using Oceanostics: SingleLineProgressMessenger; Δt = 20minutes; simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days,; progress = SingleLineProgressMessenger()). using Oceananigans.Fields: ComputedField; using Oceanostics: KineticEnergy. u, v, w = model.velocities # unpack velocity `Field`s. # Vertical vorticity [s⁻¹]; tke_k = KineticEnergy(model, u, v, w); tke_c = ComputedField(@at (Center, Center, Center) (u^2+v^2+w^2)/2). outputs = (tke_c=tke_c, u=u,). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(2Δt),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1),; filepath = ""avg.eady.nc"",; mode = ""c""). @info ""Starting run""; run!(simulation); ```. This produces the wrong result for `u`, reproduced below. (Appears to be a cumulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in the list of outputs changes the average result for `u`! Below is a list of what works and doesn't work (for `u`) when setting the list of outp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633:3140,Security,access,accessed,3140,"umulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in the list of outputs changes the average result for `u`! Below is a list of what works and doesn't work (for `u`) when setting the list of outputs:. ```julia; outputs = (tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u,) # Works; outputs = (tke_k=tke_k, tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v, w=w) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v,) # Doesn't work; outputs = (u=u, v=v,) # Doesn't work; outputs = (u=u, w=w,) # Doesn't work; outputs = (u=u,) # Works; ```. Notes: . - I haven't checked the calculation of the other stuff yet; - I created [a branch](https://github.com/CliMA/Oceananigans.jl/tree/tc/fix-time-average) that lets me keep track of when each condition [here](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L146) gets accessed and the number of times it accesses [this condition](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L190) changes based on what's on the output list. Is this expected?; - I've reproduced this in two different machines but I still haven't got confirmation that anyone else reproduced this independently. Could someone please run this? Here's the [Python script to generate this plot](https://pastebin.com/1dSE1hGj)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633:3176,Security,access,accesses,3176,"umulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in the list of outputs changes the average result for `u`! Below is a list of what works and doesn't work (for `u`) when setting the list of outputs:. ```julia; outputs = (tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u,) # Works; outputs = (tke_k=tke_k, tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v, w=w) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v,) # Doesn't work; outputs = (u=u, v=v,) # Doesn't work; outputs = (u=u, w=w,) # Doesn't work; outputs = (u=u,) # Works; ```. Notes: . - I haven't checked the calculation of the other stuff yet; - I created [a branch](https://github.com/CliMA/Oceananigans.jl/tree/tc/fix-time-average) that lets me keep track of when each condition [here](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L146) gets accessed and the number of times it accesses [this condition](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L190) changes based on what's on the output list. Is this expected?; - I've reproduced this in two different machines but I still haven't got confirmation that anyone else reproduced this independently. Could someone please run this? Here's the [Python script to generate this plot](https://pastebin.com/1dSE1hGj)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633:17,Testability,test,tests,17,"Okay, I did some tests and I'm just getting more confused. Here's a more minimal example where I'm creating a simulation with zero everywhere except for a uniform initial condition for `u` and I added Coriolis (to have an inertial oscillation):. ```julia; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Units. grid = RegularRectilinearGrid(size=(4, 4, 4), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0)); coriolis = FPlane(f=1e-4) # [s⁻¹]. model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = coriolis,; tracers = NamedTuple(),; buoyancy = nothing,; closure = nothing,; ); set!(model, u=0.4). using Oceanostics: SingleLineProgressMessenger; Δt = 20minutes; simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days,; progress = SingleLineProgressMessenger()). using Oceananigans.Fields: ComputedField; using Oceanostics: KineticEnergy. u, v, w = model.velocities # unpack velocity `Field`s. # Vertical vorticity [s⁻¹]; tke_k = KineticEnergy(model, u, v, w); tke_c = ComputedField(@at (Center, Center, Center) (u^2+v^2+w^2)/2). outputs = (tke_c=tke_c, u=u,). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(2Δt),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1),; filepath = ""avg.eady.nc"",; mode = ""c""). @info ""Starting run""; run!(simulation); ```. This produces the wrong result for `u`, reproduced below. (Appears to be a cumulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being do",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633:2208,Usability,clear,clear,2208,",; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1),; filepath = ""avg.eady.nc"",; mode = ""c""). @info ""Starting run""; run!(simulation); ```. This produces the wrong result for `u`, reproduced below. (Appears to be a cumulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in the list of outputs changes the average result for `u`! Below is a list of what works and doesn't work (for `u`) when setting the list of outputs:. ```julia; outputs = (tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u,) # Works; outputs = (tke_k=tke_k, tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v, w=w) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v,) # Doesn't work; outputs = (u=u, v=v,) # Doesn't work; outputs = (u=u, w=w,) # Doesn't work; outputs = (u=u,) # Works; ```. Notes: . - I haven't checked the calculation of the other stuff yet; - I created [a branch](https://github.com/CliMA/Oceananigans.jl/tree/tc/fix-time-average) that lets me keep track of when each condition [here](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L146) gets accessed and the number of times it accesses [this condition](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873151733:133,Security,access,accesses,133,"What is the type of `tke_k`? With one exception it seems like there's an issue with two or more fields. > and the number of times it accesses this condition changes based on what's on the output list. Is this expected?. I think it should access that condition `M * N` times, where `M` is the number of outputs being averaged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873151733
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873151733:238,Security,access,access,238,"What is the type of `tke_k`? With one exception it seems like there's an issue with two or more fields. > and the number of times it accesses this condition changes based on what's on the output list. Is this expected?. I think it should access that condition `M * N` times, where `M` is the number of outputs being averaged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873151733
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873153780:57,Testability,test,test,57,"Without much effort we can expand the existing averaging test from one to two outputs by defining a new ""`λ`"". The test now has one lambda defined here:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/test/test_netcdf_output_writer.jl#L481. and used here:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/test/test_netcdf_output_writer.jl#L534. I'm not quite sure why two outputs would cause issues, but this is a good clue that I can dive into. It's also not tested now so it's plausible there's an issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873153780
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873153780:115,Testability,test,test,115,"Without much effort we can expand the existing averaging test from one to two outputs by defining a new ""`λ`"". The test now has one lambda defined here:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/test/test_netcdf_output_writer.jl#L481. and used here:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/test/test_netcdf_output_writer.jl#L534. I'm not quite sure why two outputs would cause issues, but this is a good clue that I can dive into. It's also not tested now so it's plausible there's an issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873153780
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873153780:241,Testability,test,test,241,"Without much effort we can expand the existing averaging test from one to two outputs by defining a new ""`λ`"". The test now has one lambda defined here:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/test/test_netcdf_output_writer.jl#L481. and used here:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/test/test_netcdf_output_writer.jl#L534. I'm not quite sure why two outputs would cause issues, but this is a good clue that I can dive into. It's also not tested now so it's plausible there's an issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873153780
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873153780:384,Testability,test,test,384,"Without much effort we can expand the existing averaging test from one to two outputs by defining a new ""`λ`"". The test now has one lambda defined here:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/test/test_netcdf_output_writer.jl#L481. and used here:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/test/test_netcdf_output_writer.jl#L534. I'm not quite sure why two outputs would cause issues, but this is a good clue that I can dive into. It's also not tested now so it's plausible there's an issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873153780
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873153780:539,Testability,test,tested,539,"Without much effort we can expand the existing averaging test from one to two outputs by defining a new ""`λ`"". The test now has one lambda defined here:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/test/test_netcdf_output_writer.jl#L481. and used here:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/test/test_netcdf_output_writer.jl#L534. I'm not quite sure why two outputs would cause issues, but this is a good clue that I can dive into. It's also not tested now so it's plausible there's an issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873153780
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382:214,Security,access,access,214,"> What is the type of `tke_k`? With one exception it seems like there's an issue with two or more fields. Sorry, should have made it more clear. It's calculated with a `KernelComputedField`.; ; > I think it should access that condition `M * N` times, where `M` is the number of outputs being averaged. Okay, then I guess that part is fine.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382:138,Usability,clear,clear,138,"> What is the type of `tke_k`? With one exception it seems like there's an issue with two or more fields. Sorry, should have made it more clear. It's calculated with a `KernelComputedField`.; ; > I think it should access that condition `M * N` times, where `M` is the number of outputs being averaged. Okay, then I guess that part is fine.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873159691:117,Testability,test,tested,117,"> I'm not quite sure why two outputs would cause issues, but this is a good clue that I can dive into. It's also not tested now so it's plausible there's an issue. I'm not sure if it's just the number of outputs though. When I'm outputting `(tke_k, u)` it works, for example, but `(tke_c, u)` does not. But I guess it's a good start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873159691
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947:172,Availability,failure,failure,172,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947:13,Modifiability,extend,extend,13,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947:40,Testability,test,test,40,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947
https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947:33,Usability,simpl,simple,33,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947
https://github.com/CliMA/Oceananigans.jl/issues/1519#issuecomment-873324849:55,Deployability,install,install,55,I can do this but I think I need repo owner rights (to install the bot)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1519#issuecomment-873324849
https://github.com/CliMA/Oceananigans.jl/pull/1520#issuecomment-810355766:49,Testability,test,tested,49,"Thanks for the effort, @ali-ramadhan, but I just tested this and the results are exactly the same!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1520#issuecomment-810355766
https://github.com/CliMA/Oceananigans.jl/pull/1520#issuecomment-810371371:81,Testability,test,test,81,Ah thanks for trying. I'll close this PR then. We probably need to design a good test to find the bug(s).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1520#issuecomment-810371371
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816284063:221,Energy Efficiency,energy,energy,221,"Some nice surface gravity waves without rotation!. https://user-images.githubusercontent.com/20099589/114105606-0cfa1180-989b-11eb-8650-695d056f7140.mp4. With Coriolis the corner looks like it's complaining (I tried both energy and enstrophy conserving Coriolis)... https://user-images.githubusercontent.com/20099589/114106008-e4bee280-989b-11eb-9a12-7846c21500f4.mp4. @christophernhill had some suggestions for things to double check:. > In the ""flux form"" then it would be good to double check if averaging is barj(bari(u)) and bari(barj(v)) - those are well defined.; > These; > https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html?highlight=circulation#equation-cdscheme-gu; > https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html?highlight=circulation#equation-gu-fv; > show the two forms....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816284063
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816324866:366,Energy Efficiency,energy,energy,366,"Ali,. The non rotating case looks great !; Congrats !. Jean-Michel. On Thu, Apr 08, 2021 at 03:57:28PM -0700, Ali Ramadhan wrote:; > Some nice surface gravity waves without rotation!; > ; > https://user-images.githubusercontent.com/20099589/114105606-0cfa1180-989b-11eb-8650-695d056f7140.mp4; > ; > With Coriolis the corner looks like it's complaining (I tried both energy and enstrophy conserving Coriolis)...; > ; > https://user-images.githubusercontent.com/20099589/114106008-e4bee280-989b-11eb-9a12-7846c21500f4.mp4; > ; > @christophernhill had some suggestions for things to double check:; > ; > > In the ""flux form"" then it would be good to double check if averaging is barj(bari(u)) and bari(barj(v)) - those are well defined.; > > These; > > https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html?highlight=circulation#equation-cdscheme-gu; > > https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html?highlight=circulation#equation-gu-fv; > > show the two forms....; > ; > ; > -- ; > You are receiving this because you were mentioned.; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816284063",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816324866
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:819,Availability,avail,available,819,"TODO list (some we might want to address before merging, some we probably should open issues about):. 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. . 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:403,Deployability,integrat,integrating,403,"TODO list (some we might want to address before merging, some we probably should open issues about):. 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. . 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:1703,Deployability,pipeline,pipeline,1703,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:403,Integrability,integrat,integrating,403,"TODO list (some we might want to address before merging, some we probably should open issues about):. 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. . 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:2202,Performance,perform,performance,2202,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:1663,Security,validat,validation,1663,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:1689,Security,validat,validation,1689,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:1968,Testability,test,tests,1968,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:2169,Testability,test,tests,2169,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:2279,Testability,benchmark,benchmarks,2279,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:2110,Usability,clear,clearer,2110,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:959,Availability,avail,available,959,"e we might want to address before merging, some we probably should open issues about):; > ; > 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. In this PR!. > 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. Soon. > 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer adve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:447,Deployability,integrat,integrating,447,"My two cents:. > TODO list (some we might want to address before merging, some we probably should open issues about):; > ; > 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. In this PR!. > 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. Soon. > 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2103,Deployability,pipeline,pipeline,2103,"1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:447,Integrability,integrat,integrating,447,"My two cents:. > TODO list (some we might want to address before merging, some we probably should open issues about):; > ; > 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. In this PR!. > 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. Soon. > 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2881,Performance,perform,performance,2881,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2063,Security,validat,validation,2063,"1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2089,Security,validat,validation,2089,"1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2560,Testability,test,tests,2560,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2809,Testability,test,tests,2809,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2817,Testability,Test,Tests,2817,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2958,Testability,benchmark,benchmarks,2958,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2702,Usability,clear,clearer,2702,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2792,Usability,clear,clear,2792,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-819174689:0,Testability,Test,Tests,0,Tests are on track to pass so I think this PR is finally ready to be reviewed/merged (with a regrettable amount of technical debt). It's unfortunately too large to be effectively reviewed but I'm happy to make changes if needed (or go over the code on Zoom if anyone would like to do so).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-819174689
https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-819603798:185,Performance,perform,performance,185,Thanks for taking a look @glwagner! I'll open a PR to make sure we're working with `PrescribedVelocityFields` correctly. And I'll also open a second PR to start looking at cubed sphere performance + getting it working on the GPU.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-819603798
https://github.com/CliMA/Oceananigans.jl/pull/1524#issuecomment-811477318:25,Deployability,update,update,25,We probably just have to update this line https://github.com/CliMA/Oceananigans.jl/blob/c7c9a3b41452a7f3934ba2903faa7df149c5d794/src/Architectures.jl#L60,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1524#issuecomment-811477318
https://github.com/CliMA/Oceananigans.jl/pull/1524#issuecomment-811480162:40,Integrability,depend,dependency,40,You will need to add `CUDAKernels` as a dependency,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1524#issuecomment-811480162
https://github.com/CliMA/Oceananigans.jl/pull/1526#issuecomment-810679001:11,Modifiability,extend,extended,11,@tomchor I extended both JLD2 and NetCDF tests to include a StepRange index specification. All that's potentially left is to spruce up the docstring if we have the motivation here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1526#issuecomment-810679001
https://github.com/CliMA/Oceananigans.jl/pull/1526#issuecomment-810679001:41,Testability,test,tests,41,@tomchor I extended both JLD2 and NetCDF tests to include a StepRange index specification. All that's potentially left is to spruce up the docstring if we have the motivation here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1526#issuecomment-810679001
https://github.com/CliMA/Oceananigans.jl/pull/1528#issuecomment-811116295:286,Usability,learn,learned,286,"> Nice catch haha. Seems that ~30 other commits made it into this PR though?. Yes, sadly, I didn't start off on `master` and do a git pull. In retrospect, I should have trashed the branch and started again but oh well. All those are basically to restore to master. Sorry. I hope that I learned my lesson.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1528#issuecomment-811116295
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173:80,Availability,avail,available,80,Ah it was just a try. `\bm` comes from the `bm` LaTeX package which I guess was available with KaTeX. For MathJax we might have to define the `\bm` command at the top of the pages that use it?. [Equation numbering still doesn't work](https://clima.github.io/OceananigansDocumentation/previews/PR1530/numerical_implementation/time_stepping/) but apparently it's because MathJax3 doesn't enable it by default: http://docs.mathjax.org/en/latest/input/tex/eqnumbers.html. Looks like we can configure it by passing a dict to the `MathJax3` constructor though: https://juliadocs.github.io/Documenter.jl/stable/lib/internals/writers/#Documenter.Writers.HTMLWriter.MathJax3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173:486,Modifiability,config,configure,486,Ah it was just a try. `\bm` comes from the `bm` LaTeX package which I guess was available with KaTeX. For MathJax we might have to define the `\bm` command at the top of the pages that use it?. [Equation numbering still doesn't work](https://clima.github.io/OceananigansDocumentation/previews/PR1530/numerical_implementation/time_stepping/) but apparently it's because MathJax3 doesn't enable it by default: http://docs.mathjax.org/en/latest/input/tex/eqnumbers.html. Looks like we can configure it by passing a dict to the `MathJax3` constructor though: https://juliadocs.github.io/Documenter.jl/stable/lib/internals/writers/#Documenter.Writers.HTMLWriter.MathJax3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289:253,Availability,down,download,253,"hm... I merged master and the unit tests seem to fail saying. ```julia. [2021/04/09 19:34:17.876] WARN Checksum did not match -@-> /storage7/buildkite-agent/.julia-1983/packages/DataDeps/ooWXe/src/verification.jl:24; --;   | Do you wish to Abort, Retry download or Ignore;   | [a/r/i]; ```. Apparently buildkite is not answering so tests stop at that point indefinitely... https://buildkite.com/clima/oceananigans/builds/1983#a259cdda-aa8b-40f1-861f-e198c1e7c7f2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289:240,Safety,Abort,Abort,240,"hm... I merged master and the unit tests seem to fail saying. ```julia. [2021/04/09 19:34:17.876] WARN Checksum did not match -@-> /storage7/buildkite-agent/.julia-1983/packages/DataDeps/ooWXe/src/verification.jl:24; --;   | Do you wish to Abort, Retry download or Ignore;   | [a/r/i]; ```. Apparently buildkite is not answering so tests stop at that point indefinitely... https://buildkite.com/clima/oceananigans/builds/1983#a259cdda-aa8b-40f1-861f-e198c1e7c7f2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289:103,Security,Checksum,Checksum,103,"hm... I merged master and the unit tests seem to fail saying. ```julia. [2021/04/09 19:34:17.876] WARN Checksum did not match -@-> /storage7/buildkite-agent/.julia-1983/packages/DataDeps/ooWXe/src/verification.jl:24; --;   | Do you wish to Abort, Retry download or Ignore;   | [a/r/i]; ```. Apparently buildkite is not answering so tests stop at that point indefinitely... https://buildkite.com/clima/oceananigans/builds/1983#a259cdda-aa8b-40f1-861f-e198c1e7c7f2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289:35,Testability,test,tests,35,"hm... I merged master and the unit tests seem to fail saying. ```julia. [2021/04/09 19:34:17.876] WARN Checksum did not match -@-> /storage7/buildkite-agent/.julia-1983/packages/DataDeps/ooWXe/src/verification.jl:24; --;   | Do you wish to Abort, Retry download or Ignore;   | [a/r/i]; ```. Apparently buildkite is not answering so tests stop at that point indefinitely... https://buildkite.com/clima/oceananigans/builds/1983#a259cdda-aa8b-40f1-861f-e198c1e7c7f2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289:332,Testability,test,tests,332,"hm... I merged master and the unit tests seem to fail saying. ```julia. [2021/04/09 19:34:17.876] WARN Checksum did not match -@-> /storage7/buildkite-agent/.julia-1983/packages/DataDeps/ooWXe/src/verification.jl:24; --;   | Do you wish to Abort, Retry download or Ignore;   | [a/r/i]; ```. Apparently buildkite is not answering so tests stop at that point indefinitely... https://buildkite.com/clima/oceananigans/builds/1983#a259cdda-aa8b-40f1-861f-e198c1e7c7f2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817873104:29,Availability,error,error,29,"@navidcy Ah sorry about that error, it was fixed in PR #1552. I merged `master` into this branch which should fix the unit tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817873104
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817873104:123,Testability,test,tests,123,"@navidcy Ah sorry about that error, it was fixed in PR #1552. I merged `master` into this branch which should fix the unit tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817873104
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-818242327:6,Testability,test,tests,6,hm... tests pass here after 3-4 days!; weird.; seems like just something made the code extremely slow?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-818242327
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-818309942:60,Deployability,pipeline,pipeline,60,"None of the individual test runs took very long, but our CI pipeline is clogged up due to this hanging issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-818309942
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-818309942:23,Testability,test,test,23,"None of the individual test runs took very long, but our CI pipeline is clogged up due to this hanging issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-818309942
https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-819116119:19,Deployability,upgrade,upgrades,19,Looks like this PR upgrades to Julia 1.6 as well now?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-819116119
https://github.com/CliMA/Oceananigans.jl/pull/1540#issuecomment-816815511:20,Testability,test,tests,20,Merging because all tests pass (it's just docs that don't build).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1540#issuecomment-816815511
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813396548:569,Integrability,depend,depends,569,"> The changes look good to me but I admit that I am a bit confuses as to when we have superscripts a vs c or f. The superscript `a` refers to ""Any"" location. For example, the difference operator `δxᶜᵃᵃ` is _independent_ of the `y` and `z` directions:. https://github.com/CliMA/Oceananigans.jl/blob/6bfc1551c57403268138b85620d88dba8114a4c0/src/Operators/difference_operators.jl#L7. Thus this operator is valid if `y` and `z` are respectively `Center` or `Face`. When this is not true (for example, on a horizontally-curvilinear grid, the grid spacing in the x-direction depends on both `x` and `y` location), we need to explicitly specify the location of the operator / object.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813396548
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813710848:35,Testability,test,tests,35,One question: Should we modify the tests so that they would be able to catch the bug? Or is that too much?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813710848
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813816344:37,Testability,test,tests,37,"> One question: Should we modify the tests so that they would be able to catch the bug? Or is that too much?. We need to add a _new_ test. I already changed the test that demonstrates the Poisson equation is solved correctly (with the correct Laplace operator as a diagnostic). However, something missing is a straightforward test that mass is conserved when using this solver on a stretched grid (not a regular grid, where this issue doesn't crop up). I'm working on that now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813816344
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813816344:133,Testability,test,test,133,"> One question: Should we modify the tests so that they would be able to catch the bug? Or is that too much?. We need to add a _new_ test. I already changed the test that demonstrates the Poisson equation is solved correctly (with the correct Laplace operator as a diagnostic). However, something missing is a straightforward test that mass is conserved when using this solver on a stretched grid (not a regular grid, where this issue doesn't crop up). I'm working on that now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813816344
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813816344:161,Testability,test,test,161,"> One question: Should we modify the tests so that they would be able to catch the bug? Or is that too much?. We need to add a _new_ test. I already changed the test that demonstrates the Poisson equation is solved correctly (with the correct Laplace operator as a diagnostic). However, something missing is a straightforward test that mass is conserved when using this solver on a stretched grid (not a regular grid, where this issue doesn't crop up). I'm working on that now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813816344
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813816344:326,Testability,test,test,326,"> One question: Should we modify the tests so that they would be able to catch the bug? Or is that too much?. We need to add a _new_ test. I already changed the test that demonstrates the Poisson equation is solved correctly (with the correct Laplace operator as a diagnostic). However, something missing is a straightforward test that mass is conserved when using this solver on a stretched grid (not a regular grid, where this issue doesn't crop up). I'm working on that now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813816344
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474:558,Availability,error,error,558,"@ali-ramadhan @christophernhill it looks like the incompressible-in-time tests are failing for a hyperbolically `VerticallyStretchedRectilinearGrid`. However, a curious aspect of the test is that we compare `maximum(|δ|)` to 0, where `δ` is the divergence. Models that use `VerticallyStretchedRectilinearGrid` fail this test because `maximum(|δ|)` is greater than 5e-8 (its around 1e-4 for AdamsBashforth, and 3e-5 for RK3). . However, it looks like `sum(δ)` is smaller than machine precision; thus mass does not accumulate in time. . The larger-than-normal error only shows up when the grid is stretched; when the coordinate spacing in `VerticallyStretchedRectilinearGrid` is constant, the tests pass. Should we modify this test? What do we want to test for and what do we expect? Presumably both non-accumulation of mass and a small divergence are both important...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474:73,Testability,test,tests,73,"@ali-ramadhan @christophernhill it looks like the incompressible-in-time tests are failing for a hyperbolically `VerticallyStretchedRectilinearGrid`. However, a curious aspect of the test is that we compare `maximum(|δ|)` to 0, where `δ` is the divergence. Models that use `VerticallyStretchedRectilinearGrid` fail this test because `maximum(|δ|)` is greater than 5e-8 (its around 1e-4 for AdamsBashforth, and 3e-5 for RK3). . However, it looks like `sum(δ)` is smaller than machine precision; thus mass does not accumulate in time. . The larger-than-normal error only shows up when the grid is stretched; when the coordinate spacing in `VerticallyStretchedRectilinearGrid` is constant, the tests pass. Should we modify this test? What do we want to test for and what do we expect? Presumably both non-accumulation of mass and a small divergence are both important...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474:183,Testability,test,test,183,"@ali-ramadhan @christophernhill it looks like the incompressible-in-time tests are failing for a hyperbolically `VerticallyStretchedRectilinearGrid`. However, a curious aspect of the test is that we compare `maximum(|δ|)` to 0, where `δ` is the divergence. Models that use `VerticallyStretchedRectilinearGrid` fail this test because `maximum(|δ|)` is greater than 5e-8 (its around 1e-4 for AdamsBashforth, and 3e-5 for RK3). . However, it looks like `sum(δ)` is smaller than machine precision; thus mass does not accumulate in time. . The larger-than-normal error only shows up when the grid is stretched; when the coordinate spacing in `VerticallyStretchedRectilinearGrid` is constant, the tests pass. Should we modify this test? What do we want to test for and what do we expect? Presumably both non-accumulation of mass and a small divergence are both important...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474:320,Testability,test,test,320,"@ali-ramadhan @christophernhill it looks like the incompressible-in-time tests are failing for a hyperbolically `VerticallyStretchedRectilinearGrid`. However, a curious aspect of the test is that we compare `maximum(|δ|)` to 0, where `δ` is the divergence. Models that use `VerticallyStretchedRectilinearGrid` fail this test because `maximum(|δ|)` is greater than 5e-8 (its around 1e-4 for AdamsBashforth, and 3e-5 for RK3). . However, it looks like `sum(δ)` is smaller than machine precision; thus mass does not accumulate in time. . The larger-than-normal error only shows up when the grid is stretched; when the coordinate spacing in `VerticallyStretchedRectilinearGrid` is constant, the tests pass. Should we modify this test? What do we want to test for and what do we expect? Presumably both non-accumulation of mass and a small divergence are both important...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474:691,Testability,test,tests,691,"@ali-ramadhan @christophernhill it looks like the incompressible-in-time tests are failing for a hyperbolically `VerticallyStretchedRectilinearGrid`. However, a curious aspect of the test is that we compare `maximum(|δ|)` to 0, where `δ` is the divergence. Models that use `VerticallyStretchedRectilinearGrid` fail this test because `maximum(|δ|)` is greater than 5e-8 (its around 1e-4 for AdamsBashforth, and 3e-5 for RK3). . However, it looks like `sum(δ)` is smaller than machine precision; thus mass does not accumulate in time. . The larger-than-normal error only shows up when the grid is stretched; when the coordinate spacing in `VerticallyStretchedRectilinearGrid` is constant, the tests pass. Should we modify this test? What do we want to test for and what do we expect? Presumably both non-accumulation of mass and a small divergence are both important...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474:725,Testability,test,test,725,"@ali-ramadhan @christophernhill it looks like the incompressible-in-time tests are failing for a hyperbolically `VerticallyStretchedRectilinearGrid`. However, a curious aspect of the test is that we compare `maximum(|δ|)` to 0, where `δ` is the divergence. Models that use `VerticallyStretchedRectilinearGrid` fail this test because `maximum(|δ|)` is greater than 5e-8 (its around 1e-4 for AdamsBashforth, and 3e-5 for RK3). . However, it looks like `sum(δ)` is smaller than machine precision; thus mass does not accumulate in time. . The larger-than-normal error only shows up when the grid is stretched; when the coordinate spacing in `VerticallyStretchedRectilinearGrid` is constant, the tests pass. Should we modify this test? What do we want to test for and what do we expect? Presumably both non-accumulation of mass and a small divergence are both important...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474:750,Testability,test,test,750,"@ali-ramadhan @christophernhill it looks like the incompressible-in-time tests are failing for a hyperbolically `VerticallyStretchedRectilinearGrid`. However, a curious aspect of the test is that we compare `maximum(|δ|)` to 0, where `δ` is the divergence. Models that use `VerticallyStretchedRectilinearGrid` fail this test because `maximum(|δ|)` is greater than 5e-8 (its around 1e-4 for AdamsBashforth, and 3e-5 for RK3). . However, it looks like `sum(δ)` is smaller than machine precision; thus mass does not accumulate in time. . The larger-than-normal error only shows up when the grid is stretched; when the coordinate spacing in `VerticallyStretchedRectilinearGrid` is constant, the tests pass. Should we modify this test? What do we want to test for and what do we expect? Presumably both non-accumulation of mass and a small divergence are both important...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474
https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814488403:125,Testability,test,tests,125,@ali-ramadhan @christophernhill disregard this previous comment. I found a 3rd bug in the divergence operator. I believe the tests pass now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814488403
https://github.com/CliMA/Oceananigans.jl/issues/1542#issuecomment-819463975:70,Usability,Guid,Guide,70,"@ali-ramadhan, should we change the instructions in the Contributor's Guide to reflect the way the docs are build post #1573?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1542#issuecomment-819463975
https://github.com/CliMA/Oceananigans.jl/issues/1542#issuecomment-819466377:107,Modifiability,variab,variable,107,Ah yes! Seems like we were probably not doing it exactly right before... We could also add the environment variable `JULIA_DEBUG=Documenter` if people think it's helpful to get an idea of which example is currently being built (for when you build docs + examples locally).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1542#issuecomment-819466377
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-813527300:170,Availability,error,error,170,> Docs should show up at https://clima.github.io/OceananigansDocumentation/previews/PR1543/ once a commit has been made after the PR has been opened. This gives me a 404 error!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-813527300
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-813713965:179,Availability,error,error,179,"> > Docs should show up at https://clima.github.io/OceananigansDocumentation/previews/PR1543/ once a commit has been made after the PR has been opened.; > ; > This gives me a 404 error!. I believe you have to open the PR (not have it as ""Draft"") and then it'll push the preview....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-813713965
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032:310,Energy Efficiency,adapt,adapt,310,"I finished the first draft (of the topics I know about at least). I haven't written the very last subsection though, which is about viewing/using arrays in GPU runs because honestly I don't know enough to write about it. I know there's a function called `view()` that helps with slicing, and you can also use `adapt` to view CUDA Arrays in REPL for investigating, but I feel like I don't know enough of this aspect of the code to write this. There are two options here:. - Someone helps me out and writes that last section; - Or I can merge the PR without it for now (there are many other important things there for the user) and we worry about that last part in a future PR. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032:310,Modifiability,adapt,adapt,310,"I finished the first draft (of the topics I know about at least). I haven't written the very last subsection though, which is about viewing/using arrays in GPU runs because honestly I don't know enough to write about it. I know there's a function called `view()` that helps with slicing, and you can also use `adapt` to view CUDA Arrays in REPL for investigating, but I feel like I don't know enough of this aspect of the code to write this. There are two options here:. - Someone helps me out and writes that last section; - Or I can merge the PR without it for now (there are many other important things there for the user) and we worry about that last part in a future PR. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711:218,Availability,error,errors,218,"I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. There's a few other things that are required to get things working on GPUs --- for example, Oceananigans must be _built_ (not just run) with a GPU / CUDA installation available; this is a common pitfall on clusters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711:393,Availability,avail,available,393,"I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. There's a few other things that are required to get things working on GPUs --- for example, Oceananigans must be _built_ (not just run) with a GPU / CUDA installation available; this is a common pitfall on clusters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711:380,Deployability,install,installation,380,"I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. There's a few other things that are required to get things working on GPUs --- for example, Oceananigans must be _built_ (not just run) with a GPU / CUDA installation available; this is a common pitfall on clusters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711:114,Performance,perform,performance,114,"I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. There's a few other things that are required to get things working on GPUs --- for example, Oceananigans must be _built_ (not just run) with a GPU / CUDA installation available; this is a common pitfall on clusters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711:126,Performance,optimiz,optimizations,126,"I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. There's a few other things that are required to get things working on GPUs --- for example, Oceananigans must be _built_ (not just run) with a GPU / CUDA installation available; this is a common pitfall on clusters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275:220,Availability,error,errors,220,"> I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275:116,Performance,perform,performance,116,"> I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275:128,Performance,optimiz,optimizations,128,"> I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275:275,Safety,avoid,avoid,275,"> I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200:222,Availability,error,errors,222,"> > I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors.; > ; > That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed. 🤦 there's already Using GPUs of course, silly me...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200:118,Performance,perform,performance,118,"> > I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors.; > ; > That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed. 🤦 there's already Using GPUs of course, silly me...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200:130,Performance,optimiz,optimizations,130,"> > I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors.; > ; > That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed. 🤦 there's already Using GPUs of course, silly me...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200:284,Safety,avoid,avoid,284,"> > I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors.; > ; > That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed. 🤦 there's already Using GPUs of course, silly me...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819536777:12,Testability,test,tests,12,"I think GPU tests randomly crapped out (not important for this PR) but docs are still building so as long as the PR docs preview looks good, then this should be good to merge!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819536777
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819553284:51,Performance,load,load,51,"@ali-ramadhan currently waiting for the preview to load so that I can merge, but I don't think it'll do that with the GPU test failing. How do we fix that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819553284
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819553284:122,Testability,test,test,122,"@ali-ramadhan currently waiting for the preview to load so that I can merge, but I don't think it'll do that with the GPU test failing. How do we fix that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819553284
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819560412:104,Deployability,deploy,deployed,104,@tomchor Ah are you okay with committing my suggestion before merging? . I think docs did get built and deployed:; https://buildkite.com/clima/oceananigans/builds/2048#0d49a5b8-1dec-4f7b-b82a-cf6f8809e234/40-574; https://clima.github.io/OceananigansDocumentation/previews/PR1543/simulation_tips/. Working on getting you guys access to Buildkite so you can control it as well. I'm not a Buildkite admin so I have to ask one to invite other people...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819560412
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819560412:325,Security,access,access,325,@tomchor Ah are you okay with committing my suggestion before merging? . I think docs did get built and deployed:; https://buildkite.com/clima/oceananigans/builds/2048#0d49a5b8-1dec-4f7b-b82a-cf6f8809e234/40-574; https://clima.github.io/OceananigansDocumentation/previews/PR1543/simulation_tips/. Working on getting you guys access to Buildkite so you can control it as well. I'm not a Buildkite admin so I have to ask one to invite other people...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819560412
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819606114:319,Availability,avail,available,319,"Thanks, everyone. I'll merge this for now and we can improve on it later based on feedback from users. @glwagner I'm thinking of opening another PR soon to address your [comment about using GPUs](https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711). Like I mentioned, some of this info is already available in the ""Using GPUs"" page, but maybe it's useful to expand a bit on it and link this newly created page there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819606114
https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819606114:82,Usability,feedback,feedback,82,"Thanks, everyone. I'll merge this for now and we can improve on it later based on feedback from users. @glwagner I'm thinking of opening another PR soon to address your [comment about using GPUs](https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711). Like I mentioned, some of this info is already available in the ""Using GPUs"" page, but maybe it's useful to expand a bit on it and link this newly created page there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819606114
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813428624:143,Integrability,interface,interface,143,Sorry but I don't quite understand the changes. Could you please post explain a little more? Maybe posting a couple of snipets showing how the interface changed is enough!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813428624
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443:1021,Availability,redundant,redundant,1021,"> I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work. Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :). > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that. Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443:175,Energy Efficiency,efficient,efficient,175,"> I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work. Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :). > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that. Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443:1021,Safety,redund,redundant,1021,"> I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work. Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :). > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that. Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443:161,Usability,intuit,intuitive,161,"> I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work. Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :). > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that. Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822:1063,Availability,redundant,redundant,1063,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822:1396,Availability,down,down,1396,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822:184,Energy Efficiency,efficient,efficient,184,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822:1063,Safety,redund,redundant,1063,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822:1208,Testability,test,tests,1208,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822:170,Usability,intuit,intuitive,170,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813457987:552,Availability,down,down,552,"> > ; > > ; > > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > > ```julia; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > > ```; > ; > But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function. Okay, thanks for the clarification! So you're proposing something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. But in my opinion something closer to the previous alternative is already good enough, no? Since you can infer `z=(0, Lz)` from `z_stretch=function_or_array`:. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); ```. One can envision a general form of this where the following alternatives are all valid and the rest is inferred from the constructor:. ```julia; z_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); y_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), z=(0, 1), y_stretch=collect(0:Δz:Lz)); x_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), y=(0, 1), z=(0, 1), x_stretch=collect(0:Δz:Lz)); ```. In my opinion this is better since it's a little cleaner (although it may require some more programming on the background). Also, I think `z_stretch` is less clear than `zF`, no? At least to me it's not clear what I'm supposed to provide as the `z_stretch` argument.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813457987
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813457987:1803,Usability,clear,clear,1803,"> > ; > > ; > > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > > ```julia; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > > ```; > ; > But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function. Okay, thanks for the clarification! So you're proposing something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. But in my opinion something closer to the previous alternative is already good enough, no? Since you can infer `z=(0, Lz)` from `z_stretch=function_or_array`:. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); ```. One can envision a general form of this where the following alternatives are all valid and the rest is inferred from the constructor:. ```julia; z_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); y_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), z=(0, 1), y_stretch=collect(0:Δz:Lz)); x_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), y=(0, 1), z=(0, 1), x_stretch=collect(0:Δz:Lz)); ```. In my opinion this is better since it's a little cleaner (although it may require some more programming on the background). Also, I think `z_stretch` is less clear than `zF`, no? At least to me it's not clear what I'm supposed to provide as the `z_stretch` argument.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813457987
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813457987:1848,Usability,clear,clear,1848,"> > ; > > ; > > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > > ```julia; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > > ```; > ; > But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function. Okay, thanks for the clarification! So you're proposing something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. But in my opinion something closer to the previous alternative is already good enough, no? Since you can infer `z=(0, Lz)` from `z_stretch=function_or_array`:. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); ```. One can envision a general form of this where the following alternatives are all valid and the rest is inferred from the constructor:. ```julia; z_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); y_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), z=(0, 1), y_stretch=collect(0:Δz:Lz)); x_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), y=(0, 1), z=(0, 1), x_stretch=collect(0:Δz:Lz)); ```. In my opinion this is better since it's a little cleaner (although it may require some more programming on the background). Also, I think `z_stretch` is less clear than `zF`, no? At least to me it's not clear what I'm supposed to provide as the `z_stretch` argument.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813457987
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813465259:1722,Usability,intuit,intuitive,1722,"es, I am suggesting this syntax; ```; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```; or the following where `stretch_function` is an `@inline function`; ```; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=stretch_function); ```; Both will work. There are pluses and minuses in the different approaches. Below are a few thoughts. - You are correct that if you pass an array you know the end points so there is no real need to have `z=(0,Lz)`. ; - However, if you want to pass an inline function, then you don't need to specify the bounds at all, and these then serve a purpose.; - As I mentioned before, I think that specifying the domain is more similar to what's done in other grids. I do think that normzlizing the grids so that they follow a similar framework is advantageous. Both to be able to switch from one to the other, but also to the user who sees that this function is only different that we add another argument. ; - There could and should be a check added it to make sure that the first element and lasta elements of the grid are equal to z. What you suggest is also possible but then when you want to have stretching in 2 or 3 dimenions, you can still do it but then you need to have `xF`, `yF`, `zF` and you no longer have `x,y,z`. In terms of the coding, it seems easy to write up and run code that would specify the domain in all three directions and then stretches in whatever directions the user wants to stretch, with checks. I choose the name `z_stretch` to denote the stretched grid in the `z` direction. I supposed we could use `z_stretched` or something else. `zF` is not intuitive to me, someone who never used the stretched grid before, since it just suggests the faces. In some code I have seen `zF_generator`, which is better than `zF` but generator is maybe not as explicit as stretched or something else. Maybe we can come up with a better name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813465259
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813479254:80,Usability,simpl,simpler,80,"Thanks for the explanation. I agree there are pros and cons. I still prefer the simpler approach, but I can see why this one might be desirable. I'm still a bit unclear on what `z_stretch` should be, though. If it's an array or a function, it should provide the location of the faces, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813479254
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813490794:673,Usability,clear,clear,673,"Just trying to understand the conversation so far and I have a couple of questions:. 1. Is it correct to think of this PR as being a precursor to PR #1532 (I guess this PR should be merged first)?; 2. Am I right in thinking that the current discussion is around whether we want to specify `z=(-Lz, 0), z_stretch=something` vs. just `z_stretch=something` (and infering `z=(-Lz, 0)` from `z_stretch`)?. I think it would be awesome if users never had to think about the staggered grid but in this case it might be unavoidable? I guess `z_stretch` (`zF` in the main branch) specifies the location of the faces (of which there are Nz+1 if z is `Bounded`) so this should be made clear (could be in the docstring I suppose). I'm also not a fan of `zF`. I think `z_stretch` is better. What if we allowed the `z` kwarg to be either a function, an array, or a 2-tuple (inferred to be regularly spaced)? And we clearly explain in the docstring and docs that arrays and functions specify the location of the faces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813490794
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813490794:900,Usability,clear,clearly,900,"Just trying to understand the conversation so far and I have a couple of questions:. 1. Is it correct to think of this PR as being a precursor to PR #1532 (I guess this PR should be merged first)?; 2. Am I right in thinking that the current discussion is around whether we want to specify `z=(-Lz, 0), z_stretch=something` vs. just `z_stretch=something` (and infering `z=(-Lz, 0)` from `z_stretch`)?. I think it would be awesome if users never had to think about the staggered grid but in this case it might be unavoidable? I guess `z_stretch` (`zF` in the main branch) specifies the location of the faces (of which there are Nz+1 if z is `Bounded`) so this should be made clear (could be in the docstring I suppose). I'm also not a fan of `zF`. I think `z_stretch` is better. What if we allowed the `z` kwarg to be either a function, an array, or a 2-tuple (inferred to be regularly spaced)? And we clearly explain in the docstring and docs that arrays and functions specify the location of the faces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813490794
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813508041:123,Usability,clear,clearly,123,"> What if we allowed the z kwarg to be either a function, an array, or a 2-tuple (inferred to be regularly spaced)? And we clearly explain in the docstring and docs that arrays and functions specify the location of the faces. I like this option!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813508041
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543:394,Integrability,depend,depends,394,"To answer @tomchor's question, yes, the grid is formed at the faces and that's easy enough to do when building the grid. For @ali-ramadhan questions. 1. @glwagner suggested that I try doing this in `VerticallyStretchedGrid` to see what it looks like and then we can discuss it. I'm happy to say that was very successful and now we are talking about it. I guess whether this PR is merged or not depends on how we want to proceed.; 2. Yes, I guess the question is what is the best design for the average user. Whatever we do, not everyone is going to like it but we should strive for something that is ""easy`, since that's in the description of Oceananigans. As a user I think I would simply want to specify the domain and then say I want a tighter grid around a particular point, say the left boundary, or any other point for that matter. I don't think the average user is going to care whether it's quadratic, cubic or hyperbolic, as long as you get better resolution around the point of interest. Is this something we agree on? If yes I would ideally want to user to specify the domain, where they want the clustering and then boom it happens. . @glwagner also suggeted in #1532, that it would be nice for us to put together some functions that the user can use to define grids. Specifying the array is not too difficult but I think we can make it easier by having functions to do most of the work for the user. I like @ali-ramadhan 's suggestion of having options in terms of what the input is and I will certainly need some help doing this, after we decide what we want the input to be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543:683,Usability,simpl,simply,683,"To answer @tomchor's question, yes, the grid is formed at the faces and that's easy enough to do when building the grid. For @ali-ramadhan questions. 1. @glwagner suggested that I try doing this in `VerticallyStretchedGrid` to see what it looks like and then we can discuss it. I'm happy to say that was very successful and now we are talking about it. I guess whether this PR is merged or not depends on how we want to proceed.; 2. Yes, I guess the question is what is the best design for the average user. Whatever we do, not everyone is going to like it but we should strive for something that is ""easy`, since that's in the description of Oceananigans. As a user I think I would simply want to specify the domain and then say I want a tighter grid around a particular point, say the left boundary, or any other point for that matter. I don't think the average user is going to care whether it's quadratic, cubic or hyperbolic, as long as you get better resolution around the point of interest. Is this something we agree on? If yes I would ideally want to user to specify the domain, where they want the clustering and then boom it happens. . @glwagner also suggeted in #1532, that it would be nice for us to put together some functions that the user can use to define grids. Specifying the array is not too difficult but I think we can make it easier by having functions to do most of the work for the user. I like @ali-ramadhan 's suggestion of having options in terms of what the input is and I will certainly need some help doing this, after we decide what we want the input to be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166:100,Integrability,interface,interface,100,"Thanks for all the clarifications, @francispoulin. Just a few thoughts:. I think regardless of what interface we end up using (allowing `x` to be a constructor, or creating a separate keyword such as `z_strecthed`) it needs to be absolutely clear what each option is gonna do. For example the name `z_stretched` doesn't tell us in any way that that corresponds to face locations. As a last option we can specify this clearly in the docstring, but ideally the keyword itself should be somewhat self-explanatory. About your comment about users not caring about what kind of stretching is used: regardless of creating convenience functions or not for stretched directions, we should always allow arbitrary stretching from the user part. That's because it's not just a matter of at which depth to make the grid tighter. Take free convection for example. Some users like to define a grid that is the finest close to the boundary and monotonically stretch from there (which I guess is what you have in mind). However, many people (and I know @glwagner is one of those) prefer simulating the whole boundary layer with one uniform resolution and only stretch the grid in the thermocline, for example. This has technical advantages such as aliasing reduction, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166:241,Usability,clear,clear,241,"Thanks for all the clarifications, @francispoulin. Just a few thoughts:. I think regardless of what interface we end up using (allowing `x` to be a constructor, or creating a separate keyword such as `z_strecthed`) it needs to be absolutely clear what each option is gonna do. For example the name `z_stretched` doesn't tell us in any way that that corresponds to face locations. As a last option we can specify this clearly in the docstring, but ideally the keyword itself should be somewhat self-explanatory. About your comment about users not caring about what kind of stretching is used: regardless of creating convenience functions or not for stretched directions, we should always allow arbitrary stretching from the user part. That's because it's not just a matter of at which depth to make the grid tighter. Take free convection for example. Some users like to define a grid that is the finest close to the boundary and monotonically stretch from there (which I guess is what you have in mind). However, many people (and I know @glwagner is one of those) prefer simulating the whole boundary layer with one uniform resolution and only stretch the grid in the thermocline, for example. This has technical advantages such as aliasing reduction, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166:417,Usability,clear,clearly,417,"Thanks for all the clarifications, @francispoulin. Just a few thoughts:. I think regardless of what interface we end up using (allowing `x` to be a constructor, or creating a separate keyword such as `z_strecthed`) it needs to be absolutely clear what each option is gonna do. For example the name `z_stretched` doesn't tell us in any way that that corresponds to face locations. As a last option we can specify this clearly in the docstring, but ideally the keyword itself should be somewhat self-explanatory. About your comment about users not caring about what kind of stretching is used: regardless of creating convenience functions or not for stretched directions, we should always allow arbitrary stretching from the user part. That's because it's not just a matter of at which depth to make the grid tighter. Take free convection for example. Some users like to define a grid that is the finest close to the boundary and monotonically stretch from there (which I guess is what you have in mind). However, many people (and I know @glwagner is one of those) prefer simulating the whole boundary layer with one uniform resolution and only stretch the grid in the thermocline, for example. This has technical advantages such as aliasing reduction, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145:1229,Availability,avail,available,1229,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145:201,Modifiability,variab,variable,201,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145:25,Usability,feedback,feedback,25,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145:126,Usability,clear,clear,126,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145:225,Usability,intuit,intuitive,225,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145:684,Usability,clear,clearly,684,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145:1617,Usability,clear,clearer,1617,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775:56,Deployability,continuous,continuous,56,"It might be possible to design an interface that uses a continuous map from a regular to stretched coordinate, rather than a generator function that specifies the location of cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775:34,Integrability,interface,interface,34,"It might be possible to design an interface that uses a continuous map from a regular to stretched coordinate, rather than a generator function that specifies the location of cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775:180,Integrability,interface,interfaces,180,"It might be possible to design an interface that uses a continuous map from a regular to stretched coordinate, rather than a generator function that specifies the location of cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518:917,Energy Efficiency,adapt,adapt,917,"This PR was created yesterday to start a discussion about how we might want to change the input arguments for `VerticallyStetchedRectilinearGrid`. After some disucssion there is no concensus that a chance should be made so I'm going to close this PR. . I think it's better that users get to play with stretched grids in any or all dimensions sooner rather than later. Hence, I'm going to return to #1532 and change the arguments to be inline with what `VerticallyStretchedRectilinearGrid`. . One change that I would like to make is instead of having `zF` as input, I would prefer to have `zFs` or even `zFaces`, to emphasize that all the faces are specified. Usually, when I see `zF` I think of a face, and that's not the case here. @tomchor , what do you think about this?. When users have played with grid stretching we will be better able to asses from experience what is good for the user, and we will be able to adapt to that in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518:917,Modifiability,adapt,adapt,917,"This PR was created yesterday to start a discussion about how we might want to change the input arguments for `VerticallyStetchedRectilinearGrid`. After some disucssion there is no concensus that a chance should be made so I'm going to close this PR. . I think it's better that users get to play with stretched grids in any or all dimensions sooner rather than later. Hence, I'm going to return to #1532 and change the arguments to be inline with what `VerticallyStretchedRectilinearGrid`. . One change that I would like to make is instead of having `zF` as input, I would prefer to have `zFs` or even `zFaces`, to emphasize that all the faces are specified. Usually, when I see `zF` I think of a face, and that's not the case here. @tomchor , what do you think about this?. When users have played with grid stretching we will be better able to asses from experience what is good for the user, and we will be able to adapt to that in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814119908:94,Usability,feedback,feedback,94,"Thanks for the effort in this PR @francispoulin. And it's a good point that without much user feedback it's hard to anticipate what will be best for them. > One change that I would like to make is instead of having zF as input, I would prefer to have zFs or even zFaces, to emphasize that all the faces are specified. Usually, when I see zF I think of a face, and that's not the case here. @tomchor , what do you think about this?. I agree that `zFaces` is better than `zF` and `z_stretched`. Way more intuitive. To be inline with the Oceananigans/Julia naming conventions it might be best to use `z_faces` or `ZFaces` though. But that's up to you. I have no personal preference here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814119908
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814119908:502,Usability,intuit,intuitive,502,"Thanks for the effort in this PR @francispoulin. And it's a good point that without much user feedback it's hard to anticipate what will be best for them. > One change that I would like to make is instead of having zF as input, I would prefer to have zFs or even zFaces, to emphasize that all the faces are specified. Usually, when I see zF I think of a face, and that's not the case here. @tomchor , what do you think about this?. I agree that `zFaces` is better than `zF` and `z_stretched`. Way more intuitive. To be inline with the Oceananigans/Julia naming conventions it might be best to use `z_faces` or `ZFaces` though. But that's up to you. I have no personal preference here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814119908
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814124178:35,Usability,learn,learning,35,"Thanks @tomchor . Sadly, I'm still learning the naming conventions, but did you mean to suggest `z_Faces`? If yes I'm happy to use that, or `z_faces`, if that is more inline with convention.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814124178
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814143240:141,Modifiability,variab,variables,141,"I honesntly don't have a personal preference here. I'm just myself off of [Julia naming conventions](https://docs.julialang.org/en/v1/manual/variables/#Stylistic-Conventions) for variables and [general identified styles](https://en.wikipedia.org/wiki/Naming_convention_(programming)#Examples_of_multiple-word_identifier_formats). `ZFaces`, `z_faces` or `z_Faces` work for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814143240
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814143240:179,Modifiability,variab,variables,179,"I honesntly don't have a personal preference here. I'm just myself off of [Julia naming conventions](https://docs.julialang.org/en/v1/manual/variables/#Stylistic-Conventions) for variables and [general identified styles](https://en.wikipedia.org/wiki/Naming_convention_(programming)#Examples_of_multiple-word_identifier_formats). `ZFaces`, `z_faces` or `z_Faces` work for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814143240
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814216312:35,Integrability,interface,interfaces,35,Should we open an issue to discuss interfaces to stretched grids?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814216312
https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814262579:44,Integrability,interface,interface,44,I think an issue is a good place to discuss interface design. I can open one if you want!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814262579
https://github.com/CliMA/Oceananigans.jl/pull/1545#issuecomment-1104643713:212,Availability,checkpoint,checkpoint,212,"This is a great feature, though I think it should be implemented as optional functionality rather than hard coded. We can also make it default if we like. > when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs). I don't think this PR will solve this issue, because when the time-limit is up the job abruptly ends whether or not `run!` has completed. I don't know if there is a SLURM option to send a signal to your job with some waiting time before quitting (ie, giving you time to Checkpoint before the job ends).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545#issuecomment-1104643713
https://github.com/CliMA/Oceananigans.jl/pull/1545#issuecomment-1104643713:602,Availability,Checkpoint,Checkpoint,602,"This is a great feature, though I think it should be implemented as optional functionality rather than hard coded. We can also make it default if we like. > when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs). I don't think this PR will solve this issue, because when the time-limit is up the job abruptly ends whether or not `run!` has completed. I don't know if there is a SLURM option to send a signal to your job with some waiting time before quitting (ie, giving you time to Checkpoint before the job ends).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545#issuecomment-1104643713
https://github.com/CliMA/Oceananigans.jl/pull/1545#issuecomment-1104643713:276,Safety,avoid,avoid,276,"This is a great feature, though I think it should be implemented as optional functionality rather than hard coded. We can also make it default if we like. > when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs). I don't think this PR will solve this issue, because when the time-limit is up the job abruptly ends whether or not `run!` has completed. I don't know if there is a SLURM option to send a signal to your job with some waiting time before quitting (ie, giving you time to Checkpoint before the job ends).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545#issuecomment-1104643713
https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813538771:295,Integrability,depend,depends,295,"Thanks for sharing this @tomchor . . Do I take that to mean that if we try and run Oceananigan on an AMD GPU then very likely the code will fail because KerelAbstractions.jl (and possibily others) will fail? . It would be great to be able to run the library on any GPU but I guess a lot of this depends on KerenAbstractions, and other libraries. Do people know what other libraries we depend on that would not necessary run on AMD GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813538771
https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813538771:385,Integrability,depend,depend,385,"Thanks for sharing this @tomchor . . Do I take that to mean that if we try and run Oceananigan on an AMD GPU then very likely the code will fail because KerelAbstractions.jl (and possibily others) will fail? . It would be great to be able to run the library on any GPU but I guess a lot of this depends on KerenAbstractions, and other libraries. Do people know what other libraries we depend on that would not necessary run on AMD GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813538771
https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813560368:79,Usability,clear,clearer,79,"I don't know a lot about this (@ali-ramadhan and @glwagner can give you a much clearer picture) but I think up until last week KernelAbstractions.jl straight up didn't support AMD. It relied on defining CUDAKernels which are specific to Nvidia GPUs. Now I believe they also added ROCKernels, that are meant to take care of the AMD case. However I think we still need some work on our end since Oceananigans imports CUDA and uses some CUDA-specific functions in lots of places. I think something needs to be done in these instances.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813560368
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-813710211:72,Safety,risk,risk,72,"#1514 is failing so at this point you are using Julia v1.6 ""at your own risk"" :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-813710211
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-813816963:59,Availability,Checkpoint,Checkpointer,59,"To clarify, the run appears to hang at the point that the `Checkpointer` attempts to write something to disk (rather than the simulation running normally, but with no output created)? We should also check whether `JLD2OutputWriter` works or hangs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-813816963
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-814122854:180,Availability,checkpoint,checkpointer,180,"Yes! It's hard for me to say exactly _where_ it's getting stuck in the case. But it hangs before even running a single step of the simulation. Everything that happens up until the checkpointer seem to be fine. That is, model and simulations are created fine, and I see files created for all my NetCDF outputs, but I never see a file created for the checkpointer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-814122854
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-814122854:349,Availability,checkpoint,checkpointer,349,"Yes! It's hard for me to say exactly _where_ it's getting stuck in the case. But it hangs before even running a single step of the simulation. Everything that happens up until the checkpointer seem to be fine. That is, model and simulations are created fine, and I see files created for all my NetCDF outputs, but I never see a file created for the checkpointer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-814122854
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-814257048:20,Testability,test,test,20,Hmm... I'm going to test whether JLD2 works with 1.6...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-814257048
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:105,Availability,error,error,105,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:219,Availability,checkpoint,checkpointer,219,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:2614,Availability,Checkpoint,Checkpointer,2614,"517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able to create a MWE this time:. ```julia; using Printf; using Oceananigans; using Oceananigans: Utils, Units; using Oceananigans.OutputWriters; using Oceanostics: SingleLineProgressMessenger. grid = RegularRectilinearGrid(size=(4, 4, 4), extent=(1,1,1)); model = IncompressibleModel(architecture = CPU(), grid = grid). start_time = 1e-9*time_ns(); simulation = Simulation(model, Δt=1, stop_time=50, iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; ); println(""\n"", simulation,""\n"",). @info ""Setting up chk writer""; simulation.output_writers[:chk_writer] = Checkpointer(model; dir=""."",; prefix = ""chk.test"",; schedule = TimeInterval(5),; force = true, cleanup = true,; ); ; println(""\n"", simulation,""\n"",) . @printf(""---> Starting run!\n""); run!(simulation, pickup=true); ```. This results in the following output:. ```julia. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Ne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:4120,Availability,Checkpoint,Checkpointer,4120,"n_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with 1 entry:; │ └── chk_writer => Checkpointer. ---> Starting run!; ```. And then the REPL just hangs there and nothing happens. I also see no checkpoint file created. I checked `checkpointer.jl` and the only packge that it seems to use that's different from the rest of Oceananigans is `Glob`, which wasn't even updated. So I'm not really sure what's causing this. Here's `versioninfo()` and `]st` for completeness. Let me know if something else is needed:. ```julia; julia> versioninfo(); Julia Version 1.5.3; Commit 788b2c77c1 (2020-11-09 13:37 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Gold 6240 CPU @ 2.60GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake). (ISI_jet) pkg> st; Status `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ArgParse v1.1.4; [63c18a36] KernelAbstractions v0.5.5; [9e8cae18] Oceananigans v0.54.0; [d0ccf422] Oceanostics v0.3.0; [5fb14364] OhMyREPL v0.5.10; [d96e819e] Parameters v0.12.2; [91a5bcdd] Plots v1.11.2; [2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:4229,Availability,checkpoint,checkpoint,4229,"ulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with 1 entry:; │ └── chk_writer => Checkpointer. ---> Starting run!; ```. And then the REPL just hangs there and nothing happens. I also see no checkpoint file created. I checked `checkpointer.jl` and the only packge that it seems to use that's different from the rest of Oceananigans is `Glob`, which wasn't even updated. So I'm not really sure what's causing this. Here's `versioninfo()` and `]st` for completeness. Let me know if something else is needed:. ```julia; julia> versioninfo(); Julia Version 1.5.3; Commit 788b2c77c1 (2020-11-09 13:37 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Gold 6240 CPU @ 2.60GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake). (ISI_jet) pkg> st; Status `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ArgParse v1.1.4; [63c18a36] KernelAbstractions v0.5.5; [9e8cae18] Oceananigans v0.54.0; [d0ccf422] Oceanostics v0.3.0; [5fb14364] OhMyREPL v0.5.10; [d96e819e] Parameters v0.12.2; [91a5bcdd] Plots v1.11.2; [276daf66] SpecialFunctions v1.3.0; [de0858da] Printf; [10745b16] Statistics; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:4265,Availability,checkpoint,checkpointer,4265,"ulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with 1 entry:; │ └── chk_writer => Checkpointer. ---> Starting run!; ```. And then the REPL just hangs there and nothing happens. I also see no checkpoint file created. I checked `checkpointer.jl` and the only packge that it seems to use that's different from the rest of Oceananigans is `Glob`, which wasn't even updated. So I'm not really sure what's causing this. Here's `versioninfo()` and `]st` for completeness. Let me know if something else is needed:. ```julia; julia> versioninfo(); Julia Version 1.5.3; Commit 788b2c77c1 (2020-11-09 13:37 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Gold 6240 CPU @ 2.60GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake). (ISI_jet) pkg> st; Status `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ArgParse v1.1.4; [63c18a36] KernelAbstractions v0.5.5; [9e8cae18] Oceananigans v0.54.0; [d0ccf422] Oceanostics v0.3.0; [5fb14364] OhMyREPL v0.5.10; [d96e819e] Parameters v0.12.2; [91a5bcdd] Plots v1.11.2; [276daf66] SpecialFunctions v1.3.0; [de0858da] Printf; [10745b16] Statistics; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:147,Deployability,upgrade,upgrade,147,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:207,Deployability,upgrade,upgrade,207,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:266,Deployability,upgrade,upgrade,266,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:414,Deployability,Install,Installed,414,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:446,Deployability,Install,Installed,446,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:478,Deployability,Install,Installed,478,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:510,Deployability,Install,Installed,510,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:543,Deployability,Install,Installed,543,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:575,Deployability,Install,Installed,575,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:4399,Deployability,update,updated,4399,"ulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with 1 entry:; │ └── chk_writer => Checkpointer. ---> Starting run!; ```. And then the REPL just hangs there and nothing happens. I also see no checkpoint file created. I checked `checkpointer.jl` and the only packge that it seems to use that's different from the rest of Oceananigans is `Glob`, which wasn't even updated. So I'm not really sure what's causing this. Here's `versioninfo()` and `]st` for completeness. Let me know if something else is needed:. ```julia; julia> versioninfo(); Julia Version 1.5.3; Commit 788b2c77c1 (2020-11-09 13:37 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Gold 6240 CPU @ 2.60GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake). (ISI_jet) pkg> st; Status `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ArgParse v1.1.4; [63c18a36] KernelAbstractions v0.5.5; [9e8cae18] Oceananigans v0.54.0; [d0ccf422] Oceanostics v0.3.0; [5fb14364] OhMyREPL v0.5.10; [d96e819e] Parameters v0.12.2; [91a5bcdd] Plots v1.11.2; [276daf66] SpecialFunctions v1.3.0; [de0858da] Printf; [10745b16] Statistics; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:903,Energy Efficiency,Adapt,Adapt,903,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:2666,Energy Efficiency,schedul,schedule,2666,"e v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able to create a MWE this time:. ```julia; using Printf; using Oceananigans; using Oceananigans: Utils, Units; using Oceananigans.OutputWriters; using Oceanostics: SingleLineProgressMessenger. grid = RegularRectilinearGrid(size=(4, 4, 4), extent=(1,1,1)); model = IncompressibleModel(architecture = CPU(), grid = grid). start_time = 1e-9*time_ns(); simulation = Simulation(model, Δt=1, stop_time=50, iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; ); println(""\n"", simulation,""\n"",). @info ""Setting up chk writer""; simulation.output_writers[:chk_writer] = Checkpointer(model; dir=""."",; prefix = ""chk.test"",; schedule = TimeInterval(5),; force = true, cleanup = true,; ); ; println(""\n"", simulation,""\n"",) . @printf(""---> Starting run!\n""); run!(simulation, pickup=true); ```. This results in the following output:. ```julia. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:903,Modifiability,Adapt,Adapt,903,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:2658,Testability,test,test,2658,"e v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able to create a MWE this time:. ```julia; using Printf; using Oceananigans; using Oceananigans: Utils, Units; using Oceananigans.OutputWriters; using Oceanostics: SingleLineProgressMessenger. grid = RegularRectilinearGrid(size=(4, 4, 4), extent=(1,1,1)); model = IncompressibleModel(architecture = CPU(), grid = grid). start_time = 1e-9*time_ns(); simulation = Simulation(model, Δt=1, stop_time=50, iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; ); println(""\n"", simulation,""\n"",). @info ""Setting up chk writer""; simulation.output_writers[:chk_writer] = Checkpointer(model; dir=""."",; prefix = ""chk.test"",; schedule = TimeInterval(5),; force = true, cleanup = true,; ); ; println(""\n"", simulation,""\n"",) . @printf(""---> Starting run!\n""); run!(simulation, pickup=true); ```. This results in the following output:. ```julia. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:129,Usability,clear,clear,129,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493:526,Availability,mask,mask,526,"I think the next step is a fully-fledged implementation that supports `Flux` boundary conditions (and possibly others). We are almost there with the latest `TurbulenceClosures` refactor. If `correct_immersed_tendencies!` is copy/pasted for tracers then all tracers will be set to zero inside a boundary; this might not be exactly what users want. I think we also sometimes want free-slip rather than no-slip boundary conditions on momentum. The algorithm I am thinking of would have the following components:. 1. Implement a ""mask"" that replaces `correct_immersed_tendencies!` that forcibly overwrites immersed regions to specified values in `update_state!` (this is effectively what `correct_immersed_tendencies!` does now); 2. Extend `calculate_boundary_tendency_terms!` to adjust tendencies in cells adjacent to immersed boundaries. This involves a) subtracting out the ""spurious"" component associated with a diffusive flux across an immersed boundary and b) adding in the ""true"" boundary flux that's either specified by the user, or implied by a `Value` / `Gradient` boundary condition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493
https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493:177,Modifiability,refactor,refactor,177,"I think the next step is a fully-fledged implementation that supports `Flux` boundary conditions (and possibly others). We are almost there with the latest `TurbulenceClosures` refactor. If `correct_immersed_tendencies!` is copy/pasted for tracers then all tracers will be set to zero inside a boundary; this might not be exactly what users want. I think we also sometimes want free-slip rather than no-slip boundary conditions on momentum. The algorithm I am thinking of would have the following components:. 1. Implement a ""mask"" that replaces `correct_immersed_tendencies!` that forcibly overwrites immersed regions to specified values in `update_state!` (this is effectively what `correct_immersed_tendencies!` does now); 2. Extend `calculate_boundary_tendency_terms!` to adjust tendencies in cells adjacent to immersed boundaries. This involves a) subtracting out the ""spurious"" component associated with a diffusive flux across an immersed boundary and b) adding in the ""true"" boundary flux that's either specified by the user, or implied by a `Value` / `Gradient` boundary condition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493
https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493:729,Modifiability,Extend,Extend,729,"I think the next step is a fully-fledged implementation that supports `Flux` boundary conditions (and possibly others). We are almost there with the latest `TurbulenceClosures` refactor. If `correct_immersed_tendencies!` is copy/pasted for tracers then all tracers will be set to zero inside a boundary; this might not be exactly what users want. I think we also sometimes want free-slip rather than no-slip boundary conditions on momentum. The algorithm I am thinking of would have the following components:. 1. Implement a ""mask"" that replaces `correct_immersed_tendencies!` that forcibly overwrites immersed regions to specified values in `update_state!` (this is effectively what `correct_immersed_tendencies!` does now); 2. Extend `calculate_boundary_tendency_terms!` to adjust tendencies in cells adjacent to immersed boundaries. This involves a) subtracting out the ""spurious"" component associated with a diffusive flux across an immersed boundary and b) adding in the ""true"" boundary flux that's either specified by the user, or implied by a `Value` / `Gradient` boundary condition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629:1206,Deployability,update,update,1206,"@francispoulin thanks for starting this discussion!. Broadly speaking I think we would like to implement an arbitrary Lagrangian-Eulerian vertical coordinate in the long run. As far as I understand, implementing an ALE scheme would require more changes than just a new `AbstractGrid`. We need to modify the time-stepping to include a regridding / interpolation stage, and I believe we also need to change the equations being solved (the tendency kernels). . My preliminary thought on software design is that this might be a new model property, something like `HydrostaticFreeSurfaceModel.vertical_coordinate`. Then one needs to interpret the z-coordinate in the chosen `HydrostaticFreeSurfaceModel.grid` in light of the choice of `HydrostaticFreeSurfaceModel.vertical_coordinate`. Other design ideas are certainly welcome!. Something less clear is what happens if we design a terrain following coordinate. Perhaps you are write @francispoulin that terrain following coordinates can be implemented purely by introducing a new type of grid (because the grid is not moving... ?) I think terrain-following, curvilinear grid would require three-dimensionally curvilinear operators, correct? So we would have to update the implementation of the `HydrostaticFreeSurfaceModel` operators as well. As for a horizontal grid for `ShallowWaterModel`, since we have horizontally-curvilinear operators I think you might be able to do `boundary_following` in the horizontal once you refactor `ShallowWaterModel` to use horizontally-curvilinear operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629:1467,Modifiability,refactor,refactor,1467,"@francispoulin thanks for starting this discussion!. Broadly speaking I think we would like to implement an arbitrary Lagrangian-Eulerian vertical coordinate in the long run. As far as I understand, implementing an ALE scheme would require more changes than just a new `AbstractGrid`. We need to modify the time-stepping to include a regridding / interpolation stage, and I believe we also need to change the equations being solved (the tendency kernels). . My preliminary thought on software design is that this might be a new model property, something like `HydrostaticFreeSurfaceModel.vertical_coordinate`. Then one needs to interpret the z-coordinate in the chosen `HydrostaticFreeSurfaceModel.grid` in light of the choice of `HydrostaticFreeSurfaceModel.vertical_coordinate`. Other design ideas are certainly welcome!. Something less clear is what happens if we design a terrain following coordinate. Perhaps you are write @francispoulin that terrain following coordinates can be implemented purely by introducing a new type of grid (because the grid is not moving... ?) I think terrain-following, curvilinear grid would require three-dimensionally curvilinear operators, correct? So we would have to update the implementation of the `HydrostaticFreeSurfaceModel` operators as well. As for a horizontal grid for `ShallowWaterModel`, since we have horizontally-curvilinear operators I think you might be able to do `boundary_following` in the horizontal once you refactor `ShallowWaterModel` to use horizontally-curvilinear operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629:839,Usability,clear,clear,839,"@francispoulin thanks for starting this discussion!. Broadly speaking I think we would like to implement an arbitrary Lagrangian-Eulerian vertical coordinate in the long run. As far as I understand, implementing an ALE scheme would require more changes than just a new `AbstractGrid`. We need to modify the time-stepping to include a regridding / interpolation stage, and I believe we also need to change the equations being solved (the tendency kernels). . My preliminary thought on software design is that this might be a new model property, something like `HydrostaticFreeSurfaceModel.vertical_coordinate`. Then one needs to interpret the z-coordinate in the chosen `HydrostaticFreeSurfaceModel.grid` in light of the choice of `HydrostaticFreeSurfaceModel.vertical_coordinate`. Other design ideas are certainly welcome!. Something less clear is what happens if we design a terrain following coordinate. Perhaps you are write @francispoulin that terrain following coordinates can be implemented purely by introducing a new type of grid (because the grid is not moving... ?) I think terrain-following, curvilinear grid would require three-dimensionally curvilinear operators, correct? So we would have to update the implementation of the `HydrostaticFreeSurfaceModel` operators as well. As for a horizontal grid for `ShallowWaterModel`, since we have horizontally-curvilinear operators I think you might be able to do `boundary_following` in the horizontal once you refactor `ShallowWaterModel` to use horizontally-curvilinear operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133:973,Energy Efficiency,charge,charge,973,"Thanks @glwagner for the quickly and in depth rely!. I don't know the details of AEL but sounds interesting, and complicated. I think what I am suggesting is much simpler, but certainly related. Maybe this could be a first step in that bigger problem? . Starting simple, `ShallowWaterModel` would be the place to start as it only has horizontal coordiantes and so there would not need to be any need (I don't think) to create any new operators. The steps to do this could include the following:. - [ ] Create a dispatch between `ConservationForm` and `VectorInvariantForm` (similar to `HydrostaticModel` I presume); - [ ] Define a new grid, maybe called `BoundaryFollowingGrid`; - [ ] Merge the two together. Could it be that easy? If @glwagner could help with the dispactching between the two forms, then I think I could borrow heavily from `HydrostaticModel` to put together the right equations. As a bonus, this would also allow us to do `SphericalShallowWater` free of charge. . As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in `xz` space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. Actually Allistair had some great news of a class he taught at MIT on the MITgcm, that explaines it very well. I know as that's where I learned it from. . But as per usual, maybe I will suggest doing shallow water first as it's easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133:163,Usability,simpl,simpler,163,"Thanks @glwagner for the quickly and in depth rely!. I don't know the details of AEL but sounds interesting, and complicated. I think what I am suggesting is much simpler, but certainly related. Maybe this could be a first step in that bigger problem? . Starting simple, `ShallowWaterModel` would be the place to start as it only has horizontal coordiantes and so there would not need to be any need (I don't think) to create any new operators. The steps to do this could include the following:. - [ ] Create a dispatch between `ConservationForm` and `VectorInvariantForm` (similar to `HydrostaticModel` I presume); - [ ] Define a new grid, maybe called `BoundaryFollowingGrid`; - [ ] Merge the two together. Could it be that easy? If @glwagner could help with the dispactching between the two forms, then I think I could borrow heavily from `HydrostaticModel` to put together the right equations. As a bonus, this would also allow us to do `SphericalShallowWater` free of charge. . As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in `xz` space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. Actually Allistair had some great news of a class he taught at MIT on the MITgcm, that explaines it very well. I know as that's where I learned it from. . But as per usual, maybe I will suggest doing shallow water first as it's easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133:263,Usability,simpl,simple,263,"Thanks @glwagner for the quickly and in depth rely!. I don't know the details of AEL but sounds interesting, and complicated. I think what I am suggesting is much simpler, but certainly related. Maybe this could be a first step in that bigger problem? . Starting simple, `ShallowWaterModel` would be the place to start as it only has horizontal coordiantes and so there would not need to be any need (I don't think) to create any new operators. The steps to do this could include the following:. - [ ] Create a dispatch between `ConservationForm` and `VectorInvariantForm` (similar to `HydrostaticModel` I presume); - [ ] Define a new grid, maybe called `BoundaryFollowingGrid`; - [ ] Merge the two together. Could it be that easy? If @glwagner could help with the dispactching between the two forms, then I think I could borrow heavily from `HydrostaticModel` to put together the right equations. As a bonus, this would also allow us to do `SphericalShallowWater` free of charge. . As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in `xz` space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. Actually Allistair had some great news of a class he taught at MIT on the MITgcm, that explaines it very well. I know as that's where I learned it from. . But as per usual, maybe I will suggest doing shallow water first as it's easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133:1685,Usability,learn,learned,1685,"Thanks @glwagner for the quickly and in depth rely!. I don't know the details of AEL but sounds interesting, and complicated. I think what I am suggesting is much simpler, but certainly related. Maybe this could be a first step in that bigger problem? . Starting simple, `ShallowWaterModel` would be the place to start as it only has horizontal coordiantes and so there would not need to be any need (I don't think) to create any new operators. The steps to do this could include the following:. - [ ] Create a dispatch between `ConservationForm` and `VectorInvariantForm` (similar to `HydrostaticModel` I presume); - [ ] Define a new grid, maybe called `BoundaryFollowingGrid`; - [ ] Merge the two together. Could it be that easy? If @glwagner could help with the dispactching between the two forms, then I think I could borrow heavily from `HydrostaticModel` to put together the right equations. As a bonus, this would also allow us to do `SphericalShallowWater` free of charge. . As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in `xz` space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. Actually Allistair had some great news of a class he taught at MIT on the MITgcm, that explaines it very well. I know as that's where I learned it from. . But as per usual, maybe I will suggest doing shallow water first as it's easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814261781:884,Energy Efficiency,adapt,adapt,884,"> As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in xz space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. References would help! We are currently curvilinear only in xy... so 2D curvilinearity in xz is the same thing as 3D curvilinearity. But maybe I am misunderstanding what you're saying. > Create a dispatch between ConservationForm and VectorInvariantForm (similar to HydrostaticModel I presume). Alternatively, you can adapt the existing ""flux form"" momentum advection operators to work on curvilinear grids. This is something we plan to do eventually (so we can use WENO advection schemes on a lat-lon grid, for example), but haven't gotten to it yet. There is already a `VectorInvariant` type. You just need to move around some of the code and ensure that the vector invariant advection scheme generalizes / can be generalized to a shallow water system. > Define a new grid, maybe called BoundaryFollowingGrid. I think you could build something more generic like `HorizontallyWarpedGrid` with a warping function that maps from the rectangle / square to whatever geometry you're trying to use?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814261781
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814261781:884,Modifiability,adapt,adapt,884,"> As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in xz space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. References would help! We are currently curvilinear only in xy... so 2D curvilinearity in xz is the same thing as 3D curvilinearity. But maybe I am misunderstanding what you're saying. > Create a dispatch between ConservationForm and VectorInvariantForm (similar to HydrostaticModel I presume). Alternatively, you can adapt the existing ""flux form"" momentum advection operators to work on curvilinear grids. This is something we plan to do eventually (so we can use WENO advection schemes on a lat-lon grid, for example), but haven't gotten to it yet. There is already a `VectorInvariant` type. You just need to move around some of the code and ensure that the vector invariant advection scheme generalizes / can be generalized to a shallow water system. > Define a new grid, maybe called BoundaryFollowingGrid. I think you could build something more generic like `HorizontallyWarpedGrid` with a warping function that maps from the rectangle / square to whatever geometry you're trying to use?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814261781
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814271048:83,Usability,Clear,Clearly,83,"Here is a PDF from Allistar and section 1.2 is what describes what I'm suggesting. Clearly not my original idea. [main_ch10.pdf](https://github.com/CliMA/Oceananigans.jl/files/6266259/main_ch10.pdf). Sorry if I am not being clear. We agree that shallow water would be curvlinear in two dimesions, those dimensions are x and y. Consider the stratified of a 2D vertical slice, where the only dimensions are x,z. Clearly this problem is curvlinear in 2D as that's all there is. If we add on a y direction, that is regular, then it's still only 2D curvlinear. I guess the analogue wold be that the hydrostatic model is 3D but only curvlinear in the horizontal. This is the same thing but with a 90 degree rotation. I realize this is not what exists but I don't think there is any new methods here, it's a matter of relabeling. If this isn't clear than maybe we can chat sometime?. The ""flux_form"" operations sounds interesting, but I don't think I know what those are. . Sure, there must be a better name than what I suggested and will keep that in mind.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814271048
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814271048:224,Usability,clear,clear,224,"Here is a PDF from Allistar and section 1.2 is what describes what I'm suggesting. Clearly not my original idea. [main_ch10.pdf](https://github.com/CliMA/Oceananigans.jl/files/6266259/main_ch10.pdf). Sorry if I am not being clear. We agree that shallow water would be curvlinear in two dimesions, those dimensions are x and y. Consider the stratified of a 2D vertical slice, where the only dimensions are x,z. Clearly this problem is curvlinear in 2D as that's all there is. If we add on a y direction, that is regular, then it's still only 2D curvlinear. I guess the analogue wold be that the hydrostatic model is 3D but only curvlinear in the horizontal. This is the same thing but with a 90 degree rotation. I realize this is not what exists but I don't think there is any new methods here, it's a matter of relabeling. If this isn't clear than maybe we can chat sometime?. The ""flux_form"" operations sounds interesting, but I don't think I know what those are. . Sure, there must be a better name than what I suggested and will keep that in mind.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814271048
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814271048:410,Usability,Clear,Clearly,410,"Here is a PDF from Allistar and section 1.2 is what describes what I'm suggesting. Clearly not my original idea. [main_ch10.pdf](https://github.com/CliMA/Oceananigans.jl/files/6266259/main_ch10.pdf). Sorry if I am not being clear. We agree that shallow water would be curvlinear in two dimesions, those dimensions are x and y. Consider the stratified of a 2D vertical slice, where the only dimensions are x,z. Clearly this problem is curvlinear in 2D as that's all there is. If we add on a y direction, that is regular, then it's still only 2D curvlinear. I guess the analogue wold be that the hydrostatic model is 3D but only curvlinear in the horizontal. This is the same thing but with a 90 degree rotation. I realize this is not what exists but I don't think there is any new methods here, it's a matter of relabeling. If this isn't clear than maybe we can chat sometime?. The ""flux_form"" operations sounds interesting, but I don't think I know what those are. . Sure, there must be a better name than what I suggested and will keep that in mind.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814271048
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814271048:837,Usability,clear,clear,837,"Here is a PDF from Allistar and section 1.2 is what describes what I'm suggesting. Clearly not my original idea. [main_ch10.pdf](https://github.com/CliMA/Oceananigans.jl/files/6266259/main_ch10.pdf). Sorry if I am not being clear. We agree that shallow water would be curvlinear in two dimesions, those dimensions are x and y. Consider the stratified of a 2D vertical slice, where the only dimensions are x,z. Clearly this problem is curvlinear in 2D as that's all there is. If we add on a y direction, that is regular, then it's still only 2D curvlinear. I guess the analogue wold be that the hydrostatic model is 3D but only curvlinear in the horizontal. This is the same thing but with a 90 degree rotation. I realize this is not what exists but I don't think there is any new methods here, it's a matter of relabeling. If this isn't clear than maybe we can chat sometime?. The ""flux_form"" operations sounds interesting, but I don't think I know what those are. . Sure, there must be a better name than what I suggested and will keep that in mind.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814271048
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814273115:26,Usability,clear,clear,26,"> Sorry if I am not being clear. We agree that shallow water would be curvlinear in two dimesions, those dimensions are x and y. Consider the stratified of a 2D vertical slice, where the only dimensions are x,z. Clearly this problem is curvlinear in 2D as that's all there is. If we add on a y direction, that is regular, then it's still only 2D curvlinear. I guess the analogue wold be that the hydrostatic model is 3D but only curvlinear in the horizontal. This is the same thing but with a 90 degree rotation. I realize this is not what exists but I don't think there is any new methods here, it's a matter of relabeling. If this isn't clear than maybe we can chat sometime?. I think to implement this problem we should generalize our operators to be curvilinear in all three directions (thus permitting 2D curvilinearity in x-z), rather than attempting some rotation of the model / physics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814273115
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814273115:212,Usability,Clear,Clearly,212,"> Sorry if I am not being clear. We agree that shallow water would be curvlinear in two dimesions, those dimensions are x and y. Consider the stratified of a 2D vertical slice, where the only dimensions are x,z. Clearly this problem is curvlinear in 2D as that's all there is. If we add on a y direction, that is regular, then it's still only 2D curvlinear. I guess the analogue wold be that the hydrostatic model is 3D but only curvlinear in the horizontal. This is the same thing but with a 90 degree rotation. I realize this is not what exists but I don't think there is any new methods here, it's a matter of relabeling. If this isn't clear than maybe we can chat sometime?. I think to implement this problem we should generalize our operators to be curvilinear in all three directions (thus permitting 2D curvilinearity in x-z), rather than attempting some rotation of the model / physics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814273115
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814273115:639,Usability,clear,clear,639,"> Sorry if I am not being clear. We agree that shallow water would be curvlinear in two dimesions, those dimensions are x and y. Consider the stratified of a 2D vertical slice, where the only dimensions are x,z. Clearly this problem is curvlinear in 2D as that's all there is. If we add on a y direction, that is regular, then it's still only 2D curvlinear. I guess the analogue wold be that the hydrostatic model is 3D but only curvlinear in the horizontal. This is the same thing but with a 90 degree rotation. I realize this is not what exists but I don't think there is any new methods here, it's a matter of relabeling. If this isn't clear than maybe we can chat sometime?. I think to implement this problem we should generalize our operators to be curvilinear in all three directions (thus permitting 2D curvilinearity in x-z), rather than attempting some rotation of the model / physics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814273115
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839672324:110,Integrability,wrap,wrapped,110,"Maybe the following papers might interest you. We implemented an ALE type of grid but where the regridding is wrapped into the definition of the ""vertical"" velocity (actually velocity relative to the moving grid). In this way it is very ""easy"" to keep conservation valid and if desired be close to isopycnal calculations (keeping w small). https://orbi.uliege.be/handle/2268/4295; https://orbi.uliege.be/handle/2268/8322; https://orbi.uliege.be/handle/2268/92087",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839672324
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:109,Security,access,access,109,Thank you @jmbeckers for sharing these papers. I noticed that some of these links you shared have restricted access so I'm copying direct links to the PDFs below. . Since I started this issue I have done some reading and read that two major approaches are what some call the POM and ROMS approaches for sigma coordinates. Can you briefly comment on how your approach compares with those two classical methods?. [Paper1](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500300X00145/1-s2.0-S1463500302000604/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJHMEUCIQCPbl7iqBAsyZ8sRzkx1Ceu9AQF170J9roBR55QCqWu6QIgK1YF%2FMKz5kEEN%2BLSAk3uM7vp0bn20LDC1tDAUsMe7o0qvQMIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwNTkwMDM1NDY4NjUiDBDmAWV%2FECe9JTdEPSqRA1h5EvlG9Mou%2F5LQtQ0qTo%2FotTV4Mmai4N7yubrFwotN1oRsCBH1DZYOsmuP%2FAULR6gQ8CmbG4TzyH3e0%2BlVyMQkrFvRWGyE9GDITVa%2FFzxZqmqgiVJvtFdsn0j8XK40BBhk3FlIfr%2FDW5oJjMrU0maDIFvF7fRZiBQupzw7svkvuouMdvyV%2Fj0Z%2BUlp0TRBPY9%2FOE8BfqKD3kVkxTXQFQSrMhixOFlUm3uEEHqKCgIG6XB%2FJJYjcL5%2Fu4wT391kDRgJfhIG%2BUpPibFTPs5XdD6rx7NCxdbO33aqPGJLnhpdsgpQ7J0dMzh%2B0iM0JHyfaae34JX7O%2F6raZWlUFcDpKy6AqGGcJM4hscgDTR%2BdkWGFd9lPUVfluYnaSxZVeLsZ9zDPf%2FQzqVH5PWsdW4aoIhfEM0nf6lw3dm85x8iqPx5vddC2BXvu0oNc1nsGQEWYeEP4XCWVGEBdjyaXJGJ2v4YOpbKjCQfB92tIAHIIAVidzZV%2FYq4a6KghC5deRwUhOn%2BBM4aAgz73gLggs7fGC%2BFMK7w7oQGOusBckSxfT%2Bl68Te6I8GKmj1FFQnX6W1kR1PmETsZjRti47ImhxN8A1Vm3f%2BDT9bl1FSb9B%2FQe0jCAjAtHKJgoaSBVB4Y%2BvzcdjxOkgQjwibNbSbHXhyPCkFAM03hQIneH0DdLRRwIRsBpeJbiXRNqNKpQ0fBOZmXFKG%2BxOqnt9B6qAlxteNnbwa920K8rasugPsuPCIjXXxJQdIgw%2BqM9MK%2FURkc13nU2HizMkm6v4lmAcMifIO1mpx0gDDrMy1cxwaACh%2FJwSd7S3utRdNLQq%2Fa%2B9X8DgBQUR6k6ufGqN2nwyNXPNbX31RXQk78Q%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124636Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY5M2JQLUK%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=313b4ff70d811d309b5a8892417798d52cf3e72b5e40f11c3892298d6d57c9fa&hash=d9162dcc50830a9e18fb569db6253e564f0ae5a415,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:528,Security,Secur,Security-Token,528, those two classical methods?. [Paper1](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500300X00145/1-s2.0-S1463500302000604/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJHMEUCIQCPbl7iqBAsyZ8sRzkx1Ceu9AQF170J9roBR55QCqWu6QIgK1YF%2FMKz5kEEN%2BLSAk3uM7vp0bn20LDC1tDAUsMe7o0qvQMIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwNTkwMDM1NDY4NjUiDBDmAWV%2FECe9JTdEPSqRA1h5EvlG9Mou%2F5LQtQ0qTo%2FotTV4Mmai4N7yubrFwotN1oRsCBH1DZYOsmuP%2FAULR6gQ8CmbG4TzyH3e0%2BlVyMQkrFvRWGyE9GDITVa%2FFzxZqmqgiVJvtFdsn0j8XK40BBhk3FlIfr%2FDW5oJjMrU0maDIFvF7fRZiBQupzw7svkvuouMdvyV%2Fj0Z%2BUlp0TRBPY9%2FOE8BfqKD3kVkxTXQFQSrMhixOFlUm3uEEHqKCgIG6XB%2FJJYjcL5%2Fu4wT391kDRgJfhIG%2BUpPibFTPs5XdD6rx7NCxdbO33aqPGJLnhpdsgpQ7J0dMzh%2B0iM0JHyfaae34JX7O%2F6raZWlUFcDpKy6AqGGcJM4hscgDTR%2BdkWGFd9lPUVfluYnaSxZVeLsZ9zDPf%2FQzqVH5PWsdW4aoIhfEM0nf6lw3dm85x8iqPx5vddC2BXvu0oNc1nsGQEWYeEP4XCWVGEBdjyaXJGJ2v4YOpbKjCQfB92tIAHIIAVidzZV%2FYq4a6KghC5deRwUhOn%2BBM4aAgz73gLggs7fGC%2BFMK7w7oQGOusBckSxfT%2Bl68Te6I8GKmj1FFQnX6W1kR1PmETsZjRti47ImhxN8A1Vm3f%2BDT9bl1FSb9B%2FQe0jCAjAtHKJgoaSBVB4Y%2BvzcdjxOkgQjwibNbSbHXhyPCkFAM03hQIneH0DdLRRwIRsBpeJbiXRNqNKpQ0fBOZmXFKG%2BxOqnt9B6qAlxteNnbwa920K8rasugPsuPCIjXXxJQdIgw%2BqM9MK%2FURkc13nU2HizMkm6v4lmAcMifIO1mpx0gDDrMy1cxwaACh%2FJwSd7S3utRdNLQq%2Fa%2B9X8DgBQUR6k6ufGqN2nwyNXPNbX31RXQk78Q%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124636Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY5M2JQLUK%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=313b4ff70d811d309b5a8892417798d52cf3e72b5e40f11c3892298d6d57c9fa&hash=d9162dcc50830a9e18fb569db6253e564f0ae5a415cf4ec09165130e634648ef&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500302000604&tid=spdf-7940fbcd-96cc-4ec2-bbf0-16d073dd8922&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper2](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500310X00038/1-s2.0-S1463500309002248/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWV,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:1954,Security,hash,hash,1954, those two classical methods?. [Paper1](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500300X00145/1-s2.0-S1463500302000604/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJHMEUCIQCPbl7iqBAsyZ8sRzkx1Ceu9AQF170J9roBR55QCqWu6QIgK1YF%2FMKz5kEEN%2BLSAk3uM7vp0bn20LDC1tDAUsMe7o0qvQMIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwNTkwMDM1NDY4NjUiDBDmAWV%2FECe9JTdEPSqRA1h5EvlG9Mou%2F5LQtQ0qTo%2FotTV4Mmai4N7yubrFwotN1oRsCBH1DZYOsmuP%2FAULR6gQ8CmbG4TzyH3e0%2BlVyMQkrFvRWGyE9GDITVa%2FFzxZqmqgiVJvtFdsn0j8XK40BBhk3FlIfr%2FDW5oJjMrU0maDIFvF7fRZiBQupzw7svkvuouMdvyV%2Fj0Z%2BUlp0TRBPY9%2FOE8BfqKD3kVkxTXQFQSrMhixOFlUm3uEEHqKCgIG6XB%2FJJYjcL5%2Fu4wT391kDRgJfhIG%2BUpPibFTPs5XdD6rx7NCxdbO33aqPGJLnhpdsgpQ7J0dMzh%2B0iM0JHyfaae34JX7O%2F6raZWlUFcDpKy6AqGGcJM4hscgDTR%2BdkWGFd9lPUVfluYnaSxZVeLsZ9zDPf%2FQzqVH5PWsdW4aoIhfEM0nf6lw3dm85x8iqPx5vddC2BXvu0oNc1nsGQEWYeEP4XCWVGEBdjyaXJGJ2v4YOpbKjCQfB92tIAHIIAVidzZV%2FYq4a6KghC5deRwUhOn%2BBM4aAgz73gLggs7fGC%2BFMK7w7oQGOusBckSxfT%2Bl68Te6I8GKmj1FFQnX6W1kR1PmETsZjRti47ImhxN8A1Vm3f%2BDT9bl1FSb9B%2FQe0jCAjAtHKJgoaSBVB4Y%2BvzcdjxOkgQjwibNbSbHXhyPCkFAM03hQIneH0DdLRRwIRsBpeJbiXRNqNKpQ0fBOZmXFKG%2BxOqnt9B6qAlxteNnbwa920K8rasugPsuPCIjXXxJQdIgw%2BqM9MK%2FURkc13nU2HizMkm6v4lmAcMifIO1mpx0gDDrMy1cxwaACh%2FJwSd7S3utRdNLQq%2Fa%2B9X8DgBQUR6k6ufGqN2nwyNXPNbX31RXQk78Q%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124636Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY5M2JQLUK%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=313b4ff70d811d309b5a8892417798d52cf3e72b5e40f11c3892298d6d57c9fa&hash=d9162dcc50830a9e18fb569db6253e564f0ae5a415cf4ec09165130e634648ef&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500302000604&tid=spdf-7940fbcd-96cc-4ec2-bbf0-16d073dd8922&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper2](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500310X00038/1-s2.0-S1463500309002248/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWV,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:2339,Security,Secur,Security-Token,2339,8424519d9831bbc1028c2b5gxrqa&type=client); [Paper2](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500310X00038/1-s2.0-S1463500309002248/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJHMEUCIFOWdyS3a22deEBXjBCSg9JkqHU7kKI82ao5VmOhVBCJAiEAkMrWigQVK4lU%2BXCC27bRmvm32M0zTk4bVzllPXcV16cqvQMIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwNTkwMDM1NDY4NjUiDFW%2FMJYjQWUkPx9JGCqRA%2B2gfPEHupvIbgmLh8Ea3HcYZNAkacD7N0Bj1%2By4O8SRtGO1gVirrSZbMJOEuywRDXWbUVHyy7mqKd5c4noCV127vH97IoV6GNMzLS04SZzrHaxNf87iMHuvQSac1ryMPdyiRVXjGVKD%2FK9WUOD9pCuwkbJ1Xq9fIFUBDpIpf6YsziUbag80uMnrgLDdI4bi0Od%2BycFCl8l135%2BiBSJ1nXr2i1d0KoM%2FwxqRhZe3eJnFkqIjBKZMTnaYXcNkBQ4OnVMdp6iNwqDluofhE86ze0DxkmKmwDIlOY6BmAZldUxJNOtojkAkoK%2BggRqDF9RpNh7eUBfmpajcmW%2Fs93jRxiBwxtkolmdDmsSYNOZyJxHn1l9VX0PpWFmhvYuzxVIxKWwhDu2jq1JUO9HWjCSOb5cu4iXr%2FY6UtLVk0zBA%2FUhBFJvYBpTFKCB%2FTZ2nm1VQ05HIq0CdMWngU2%2BPGtb8boOqEZYSJuxcW9liUpegyLYEDrFuQ5zD1PokanBmvQb4nbl3JIfRff6RQTs7I39ruWFvMO3w7oQGOusBq4rh3NlN%2BL771IAdhwa5OXPw6Dtu1rnK8mq15ILN7oUZoGlSoGGHmC9iCauDZZ0S7JRYJvBBlp3zMbH5gPzKtgbHOcfreLqawi%2FXQsNSwLrv8kMK7xtgAtq9KwZNCba%2BezOii00IhPulhEgoRpf32NORW2hf9xvSrh6O7J%2BpFl13%2BgZGv2C9YWQFtiowI1giCVrkqvdAzLIQTemllWlG4BocEdlXsIPbMTqVRy%2BPJeOoDFCEJfa3GEulzYOD7wBM8Mzcs8oPGrs32RGTKanWlrNurlGoWt9LD1yRpHRBW0W3KGW77dYPRa9WMw%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124707Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYU4SXGKKT%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=61ac35b7b8d6de69c863c18a7ac278cfcfcba8c8e333851a5dc0b0fb1a0fec5d&hash=40f925060e5aa979f6c2f65ee083626803b350750f9d24f55b22337096ac841d&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500309002248&tid=spdf-c9770d3b-56ff-4583-8351-378cc6cbd0d1&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper3](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500311X00082/1-s2.0-S1463500311000801/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJGMEQ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:3741,Security,hash,hash,3741,8424519d9831bbc1028c2b5gxrqa&type=client); [Paper2](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500310X00038/1-s2.0-S1463500309002248/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJHMEUCIFOWdyS3a22deEBXjBCSg9JkqHU7kKI82ao5VmOhVBCJAiEAkMrWigQVK4lU%2BXCC27bRmvm32M0zTk4bVzllPXcV16cqvQMIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwNTkwMDM1NDY4NjUiDFW%2FMJYjQWUkPx9JGCqRA%2B2gfPEHupvIbgmLh8Ea3HcYZNAkacD7N0Bj1%2By4O8SRtGO1gVirrSZbMJOEuywRDXWbUVHyy7mqKd5c4noCV127vH97IoV6GNMzLS04SZzrHaxNf87iMHuvQSac1ryMPdyiRVXjGVKD%2FK9WUOD9pCuwkbJ1Xq9fIFUBDpIpf6YsziUbag80uMnrgLDdI4bi0Od%2BycFCl8l135%2BiBSJ1nXr2i1d0KoM%2FwxqRhZe3eJnFkqIjBKZMTnaYXcNkBQ4OnVMdp6iNwqDluofhE86ze0DxkmKmwDIlOY6BmAZldUxJNOtojkAkoK%2BggRqDF9RpNh7eUBfmpajcmW%2Fs93jRxiBwxtkolmdDmsSYNOZyJxHn1l9VX0PpWFmhvYuzxVIxKWwhDu2jq1JUO9HWjCSOb5cu4iXr%2FY6UtLVk0zBA%2FUhBFJvYBpTFKCB%2FTZ2nm1VQ05HIq0CdMWngU2%2BPGtb8boOqEZYSJuxcW9liUpegyLYEDrFuQ5zD1PokanBmvQb4nbl3JIfRff6RQTs7I39ruWFvMO3w7oQGOusBq4rh3NlN%2BL771IAdhwa5OXPw6Dtu1rnK8mq15ILN7oUZoGlSoGGHmC9iCauDZZ0S7JRYJvBBlp3zMbH5gPzKtgbHOcfreLqawi%2FXQsNSwLrv8kMK7xtgAtq9KwZNCba%2BezOii00IhPulhEgoRpf32NORW2hf9xvSrh6O7J%2BpFl13%2BgZGv2C9YWQFtiowI1giCVrkqvdAzLIQTemllWlG4BocEdlXsIPbMTqVRy%2BPJeOoDFCEJfa3GEulzYOD7wBM8Mzcs8oPGrs32RGTKanWlrNurlGoWt9LD1yRpHRBW0W3KGW77dYPRa9WMw%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124707Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYU4SXGKKT%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=61ac35b7b8d6de69c863c18a7ac278cfcfcba8c8e333851a5dc0b0fb1a0fec5d&hash=40f925060e5aa979f6c2f65ee083626803b350750f9d24f55b22337096ac841d&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500309002248&tid=spdf-c9770d3b-56ff-4583-8351-378cc6cbd0d1&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper3](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500311X00082/1-s2.0-S1463500311000801/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJGMEQ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:4126,Security,Secur,Security-Token,4126,841d&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500309002248&tid=spdf-c9770d3b-56ff-4583-8351-378cc6cbd0d1&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper3](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500311X00082/1-s2.0-S1463500311000801/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJGMEQCIEQMBR002B0LthnumUbBVDoR4U3VR1%2BG2xH%2FbIDI1AFoAiAuoSQfiKqWKf3m%2FVE%2FTNJYYLsXkWY1mN6C20bNTWXrbyq9Awi9%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAMaDDA1OTAwMzU0Njg2NSIMv%2BDAm8ISlbHKF3xLKpED2bpaqVDlCq%2FGp3Dc9u5Zu5HLtx2oVIXcHmg%2FTY8WZmZ9N7cEwhcNyX8qTIQqVETB6a7wofc0JLX%2BnIscRSocQijV63Kn3N%2BIoojUYHSNuwuOBcx2J5subwAr8fzzOXkoFYw9nrd6y%2Bjx8t8ZkxhpAFa4WTZf0z8CWCNi059xlb20ESLxmGI2lGxglJK%2BDwLQub5TqE0fNqGjBUg6d2A7Uw9SgLQyhQGkB0DhCAGSbcskYQD2nlQcrJGiDFzXDDU6Z8u%2FeZiBvZFKr59%2F2l%2BZWAcaToBhjSNPbwZSKPJu0Il7192olWKVgcN%2FPV%2Ff69n9WRzSxUjzcTPeQeWHBcL6CqQSs74smvUq4Pps9wGacAXCYIITEJvNgLWJ3a8IPMogAr9T32a0v432lo4jKqxWoLaFN9utt9yTc9z05QEh6mh%2FUWs%2BWHNvxajljyqICd5vRgW9kfQ4rOGocjXbDJGWbvKsmEWC2cO42BTOOkAoTuZZHG61V2GBXmuuYprD%2FEENCU4yv0omCCorRGVj9fOwnLAwuvbuhAY67AFEMpZuxL1UHoFniFEKR%2B3JadvLhS03QquHGbY4m2mwchN96GFOgyaaISUwmAv8dSlX0eAKHqbAli90Bt%2BI761m0NTUUKF%2BxcPqtcNcaZr7nOZgUr8OjNP55mXnURmklGmB1NgYkgrYwe37IsYt1H5t4ii1ZmYHStJUGpL5nzv3OwLdsQsVit5xTsBGdGraNgsk%2F6fxNyUX8ZAO96BOnMEr4KfFLtXxOd3Cqd5rwf9%2FsUSRYUgEbMET2MFZE7LtoPrv9Y4YbnZZPuROvaePIFOVQL1lzBFEqwOL%2BAlsbBIO%2FTUEl4nkFuLft3wUJg%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124741Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYWCZJM4U7%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=78f17eb8a6139a663a8bce25fad0a2e3ce9da7be82563c990973904a96e0e4ea&hash=9376e9734a2dea82bcc8fb808ef803104cf448fd971c2d8d0c5c6776c8c920c1&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500311000801&tid=spdf-f5035413-aea3-427f-a9ac-13d0a85a5ca6&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:5540,Security,hash,hash,5540,841d&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500309002248&tid=spdf-c9770d3b-56ff-4583-8351-378cc6cbd0d1&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper3](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500311X00082/1-s2.0-S1463500311000801/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJGMEQCIEQMBR002B0LthnumUbBVDoR4U3VR1%2BG2xH%2FbIDI1AFoAiAuoSQfiKqWKf3m%2FVE%2FTNJYYLsXkWY1mN6C20bNTWXrbyq9Awi9%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAMaDDA1OTAwMzU0Njg2NSIMv%2BDAm8ISlbHKF3xLKpED2bpaqVDlCq%2FGp3Dc9u5Zu5HLtx2oVIXcHmg%2FTY8WZmZ9N7cEwhcNyX8qTIQqVETB6a7wofc0JLX%2BnIscRSocQijV63Kn3N%2BIoojUYHSNuwuOBcx2J5subwAr8fzzOXkoFYw9nrd6y%2Bjx8t8ZkxhpAFa4WTZf0z8CWCNi059xlb20ESLxmGI2lGxglJK%2BDwLQub5TqE0fNqGjBUg6d2A7Uw9SgLQyhQGkB0DhCAGSbcskYQD2nlQcrJGiDFzXDDU6Z8u%2FeZiBvZFKr59%2F2l%2BZWAcaToBhjSNPbwZSKPJu0Il7192olWKVgcN%2FPV%2Ff69n9WRzSxUjzcTPeQeWHBcL6CqQSs74smvUq4Pps9wGacAXCYIITEJvNgLWJ3a8IPMogAr9T32a0v432lo4jKqxWoLaFN9utt9yTc9z05QEh6mh%2FUWs%2BWHNvxajljyqICd5vRgW9kfQ4rOGocjXbDJGWbvKsmEWC2cO42BTOOkAoTuZZHG61V2GBXmuuYprD%2FEENCU4yv0omCCorRGVj9fOwnLAwuvbuhAY67AFEMpZuxL1UHoFniFEKR%2B3JadvLhS03QquHGbY4m2mwchN96GFOgyaaISUwmAv8dSlX0eAKHqbAli90Bt%2BI761m0NTUUKF%2BxcPqtcNcaZr7nOZgUr8OjNP55mXnURmklGmB1NgYkgrYwe37IsYt1H5t4ii1ZmYHStJUGpL5nzv3OwLdsQsVit5xTsBGdGraNgsk%2F6fxNyUX8ZAO96BOnMEr4KfFLtXxOd3Cqd5rwf9%2FsUSRYUgEbMET2MFZE7LtoPrv9Y4YbnZZPuROvaePIFOVQL1lzBFEqwOL%2BAlsbBIO%2FTUEl4nkFuLft3wUJg%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124741Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYWCZJM4U7%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=78f17eb8a6139a663a8bce25fad0a2e3ce9da7be82563c990973904a96e0e4ea&hash=9376e9734a2dea82bcc8fb808ef803104cf448fd971c2d8d0c5c6776c8c920c1&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500311000801&tid=spdf-f5035413-aea3-427f-a9ac-13d0a85a5ca6&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947:448,Availability,down,down,448,"I'm not sure of the latest approaches/versions of POM and ROMS with the sigma coordinates, but the approach in our paper is similar in the sense that it is based on a general vertical coordinate change. But where ROMS and POM have a fixed distribution of points on a vertical (except for the effect of surface movement which moves points but not their relative position on the vertical), our approach allowed to move the points at any moment up or down depending on local features for example to increase resolution near the moving thermocline and differently for different horizontal positions. .As a special case you can of course have the original POM or ROMS version.; Hope it makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947
https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947:453,Integrability,depend,depending,453,"I'm not sure of the latest approaches/versions of POM and ROMS with the sigma coordinates, but the approach in our paper is similar in the sense that it is based on a general vertical coordinate change. But where ROMS and POM have a fixed distribution of points on a vertical (except for the effect of surface movement which moves points but not their relative position on the vertical), our approach allowed to move the points at any moment up or down depending on local features for example to increase resolution near the moving thermocline and differently for different horizontal positions. .As a special case you can of course have the original POM or ROMS version.; Hope it makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814466232:75,Integrability,interface,interface,75,"For completeness I think the same grid could be generated with the current interface using. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; zF = k -> cos(π * (2k - 1) / 2Nz)); ```. I suppose the main difference is that the syntax with `z_stretching` makes the bounds of the domain explicit, whereas when using `zF` a code-reader has to compute the domain bounds by plugging `k = 1` and `k = Nz + 1` into the generating function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814466232
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072:91,Integrability,interface,interfaces,91,"Another important point is that this discussion is not about ""deciding"" on a _single_ user interfaces, but rather deciding what interfaces we want to put into the code. We can and perhaps should have multiple ways of specifying stretched grids. We have already agreed that specifying cell interface locations with an array (loaded from file, for example) is an important pattern to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072:128,Integrability,interface,interfaces,128,"Another important point is that this discussion is not about ""deciding"" on a _single_ user interfaces, but rather deciding what interfaces we want to put into the code. We can and perhaps should have multiple ways of specifying stretched grids. We have already agreed that specifying cell interface locations with an array (loaded from file, for example) is an important pattern to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072:289,Integrability,interface,interface,289,"Another important point is that this discussion is not about ""deciding"" on a _single_ user interfaces, but rather deciding what interfaces we want to put into the code. We can and perhaps should have multiple ways of specifying stretched grids. We have already agreed that specifying cell interface locations with an array (loaded from file, for example) is an important pattern to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072:324,Performance,load,loaded,324,"Another important point is that this discussion is not about ""deciding"" on a _single_ user interfaces, but rather deciding what interfaces we want to put into the code. We can and perhaps should have multiple ways of specifying stretched grids. We have already agreed that specifying cell interface locations with an array (loaded from file, for example) is an important pattern to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814950782:124,Usability,clear,clearer,124,"`z_faces` sounds good to me. As a newish user who will be reading examples and trying to figure things out, I think this is clearer than `zF`. Certainly people can learn to use either without much difficulty. Also, I thought that `zF` is mostly used for a face, wheres we want multiple, so plural. I suppose even `zFs` would be better in my mind.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814950782
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814950782:164,Usability,learn,learn,164,"`z_faces` sounds good to me. As a newish user who will be reading examples and trying to figure things out, I think this is clearer than `zF`. Certainly people can learn to use either without much difficulty. Also, I thought that `zF` is mostly used for a face, wheres we want multiple, so plural. I suppose even `zFs` would be better in my mind.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814950782
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:423,Availability,redundant,redundant,423,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:762,Deployability,continuous,continuous,762,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:864,Deployability,continuous,continuous,864,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:241,Integrability,depend,depends,241,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:673,Integrability,interface,interface,673,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:774,Integrability,interface,interface,774,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:876,Integrability,interface,interface,876,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:423,Safety,redund,redundant,423,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:26,Usability,clear,clearer,26,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815163245:540,Usability,clear,clearly,540,"I agree that to define the grid with `z_faces` we need to know the number of grid points, but that can be done internally. I don't believe we need that in the arguments. In the example you showed previously, with a `cheb` grid, you specified it in terms of a function of `z`. I can imagine the user specifying `z=(0, Lz)`, `Nz` and some `f(z)`, and then we compute what the grid is. I guess if `f(z)=z`, then we get a linear or uniform grid. . I imagine some people might prefer to be more hands on and specify it in terms fo indices. Both clearly can work. What your suggesting sounds very general, which is nice, but also a bit complicated. I wonder if we might want to start with something simple, one of the two, and then as we get to use it then decide how we want to change it. I'm perfectly fine with specifying the index form, since that is consistent with what we are currently doing, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815163245
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815163245:693,Usability,simpl,simple,693,"I agree that to define the grid with `z_faces` we need to know the number of grid points, but that can be done internally. I don't believe we need that in the arguments. In the example you showed previously, with a `cheb` grid, you specified it in terms of a function of `z`. I can imagine the user specifying `z=(0, Lz)`, `Nz` and some `f(z)`, and then we compute what the grid is. I guess if `f(z)=z`, then we get a linear or uniform grid. . I imagine some people might prefer to be more hands on and specify it in terms fo indices. Both clearly can work. What your suggesting sounds very general, which is nice, but also a bit complicated. I wonder if we might want to start with something simple, one of the two, and then as we get to use it then decide how we want to change it. I'm perfectly fine with specifying the index form, since that is consistent with what we are currently doing, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815163245
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815385216:108,Testability,test,test,108,"Sure. . This [code ](https://github.com/CliMA/Oceananigans.jl/blob/78f1e2910355ca4213241b23525b717c73d77900/test/test_stretched_grid.jl#L5) shows different functions that I have defined, similar to your `cheb` example above. Passing the function, which in this context I've called `stretched` but agree we should change it, [here](https://github.com/CliMA/Oceananigans.jl/blob/78f1e2910355ca4213241b23525b717c73d77900/src/Grids/stretched_rectilinear_grid.jl#L54) you will see that the function is evaluated to define the grid. It's nothing fancy, but it does the trick. . Sorry if I misunderstood your suggestion?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815385216
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:26,Integrability,interface,interface,26,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:239,Integrability,interface,interface,239,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:283,Integrability,interface,interface,283,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:525,Integrability,interface,interfaces,525,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:839,Integrability,interface,interface,839,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:897,Integrability,interface,interface,897,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:1565,Integrability,interface,interface,1565,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:643,Performance,perform,performing,643,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:136,Usability,clear,clear,136,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:618,Usability,simpl,simplify,618,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071:271,Integrability,interface,interfaces,271,"It seems natural to me to have a function of 3 arguments, `x, L, N`, as those are all needed to define the grid. There are other ways of doing it I'm sure, and I am open to other options. I agree with you that given the current setup using `zF`, we do need the number of interfaces. This other option would not as we are passing functions instead. I very much like the examples you set up and think that would be very attractive from the user perspective. . Another option that I think should be included in these functions, like the two you have above, is an argument saying where the center (or something else) is in the stretched grid. It could be the left boundary, right boundary, center or anywhere else. The physics should be the guide on where to concenrate the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071:737,Usability,guid,guide,737,"It seems natural to me to have a function of 3 arguments, `x, L, N`, as those are all needed to define the grid. There are other ways of doing it I'm sure, and I am open to other options. I agree with you that given the current setup using `zF`, we do need the number of interfaces. This other option would not as we are passing functions instead. I very much like the examples you set up and think that would be very attractive from the user perspective. . Another option that I think should be included in these functions, like the two you have above, is an argument saying where the center (or something else) is in the stretched grid. It could be the left boundary, right boundary, center or anywhere else. The physics should be the guide on where to concenrate the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071
https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815961732:77,Integrability,interface,interface,77,"A possible implementation of `QuadraticallyStretchedFaces` with the ""z faces interface"" might allow syntax like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z_faces = QuadraticallyStretchedFaces()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815961732
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815005247:203,Testability,test,tests,203,"I can imagine others benefiting from the Poisson solvers and wanting to use those without necessarily using Oceananigans, so I think this could work well. . I do have a question though. We have a lot of tests in Oceananigans now and that is a concern. If we had the solvers in a different package, what would be the savings? I guess we wouldn't have the solvers part of the test as that would be separate? From what I understand that's a small portion of all the tests, but I could be wrong. @ali-ramadhan 's point is well taken, that it would need a champion to get this started.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815005247
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815005247:374,Testability,test,test,374,"I can imagine others benefiting from the Poisson solvers and wanting to use those without necessarily using Oceananigans, so I think this could work well. . I do have a question though. We have a lot of tests in Oceananigans now and that is a concern. If we had the solvers in a different package, what would be the savings? I guess we wouldn't have the solvers part of the test as that would be separate? From what I understand that's a small portion of all the tests, but I could be wrong. @ali-ramadhan 's point is well taken, that it would need a champion to get this started.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815005247
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815005247:463,Testability,test,tests,463,"I can imagine others benefiting from the Poisson solvers and wanting to use those without necessarily using Oceananigans, so I think this could work well. . I do have a question though. We have a lot of tests in Oceananigans now and that is a concern. If we had the solvers in a different package, what would be the savings? I guess we wouldn't have the solvers part of the test as that would be separate? From what I understand that's a small portion of all the tests, but I could be wrong. @ali-ramadhan 's point is well taken, that it would need a champion to get this started.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815005247
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149:17,Availability,down,downside,17,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149:83,Deployability,pipeline,pipelines,83,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149:356,Integrability,depend,dependencies,356,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149:135,Usability,clear,clear,135,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079:340,Deployability,release,releases,340,I guess from a refactoring point of view it might also make sense to wait until we're closer to Oceananigans v1.0 before splitting off into multiple smaller packages. If we have to refactor code that involves deep changes (still likely) right now it might be easier to refactor 1 package rather than refactor across multiple packages + tag releases etc.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079:15,Modifiability,refactor,refactoring,15,I guess from a refactoring point of view it might also make sense to wait until we're closer to Oceananigans v1.0 before splitting off into multiple smaller packages. If we have to refactor code that involves deep changes (still likely) right now it might be easier to refactor 1 package rather than refactor across multiple packages + tag releases etc.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079:181,Modifiability,refactor,refactor,181,I guess from a refactoring point of view it might also make sense to wait until we're closer to Oceananigans v1.0 before splitting off into multiple smaller packages. If we have to refactor code that involves deep changes (still likely) right now it might be easier to refactor 1 package rather than refactor across multiple packages + tag releases etc.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079:269,Modifiability,refactor,refactor,269,I guess from a refactoring point of view it might also make sense to wait until we're closer to Oceananigans v1.0 before splitting off into multiple smaller packages. If we have to refactor code that involves deep changes (still likely) right now it might be easier to refactor 1 package rather than refactor across multiple packages + tag releases etc.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079:300,Modifiability,refactor,refactor,300,I guess from a refactoring point of view it might also make sense to wait until we're closer to Oceananigans v1.0 before splitting off into multiple smaller packages. If we have to refactor code that involves deep changes (still likely) right now it might be easier to refactor 1 package rather than refactor across multiple packages + tag releases etc.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815114009:128,Availability,down,downside,128,"Waiting until closer to v1.0 sounds like a good plan. Although I have no idea how close we are to that goal. > I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. My idea about separating the Poisson solvers specifically was mainly motivated by my perception that that part of code the changes very rarely compared to the other parts. Thus the extra level of maintenance would be low. Although I might be wrong in my impression! . I also like the idea of separating other aspects of the code like @glwagner proposed. Although I don't have much of a feel of the work needed for those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815114009
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815114009:416,Availability,mainten,maintenance,416,"Waiting until closer to v1.0 sounds like a good plan. Although I have no idea how close we are to that goal. > I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. My idea about separating the Poisson solvers specifically was mainly motivated by my perception that that part of code the changes very rarely compared to the other parts. Thus the extra level of maintenance would be low. Although I might be wrong in my impression! . I also like the idea of separating other aspects of the code like @glwagner proposed. Although I don't have much of a feel of the work needed for those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815114009
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815114009:194,Deployability,pipeline,pipelines,194,"Waiting until closer to v1.0 sounds like a good plan. Although I have no idea how close we are to that goal. > I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. My idea about separating the Poisson solvers specifically was mainly motivated by my perception that that part of code the changes very rarely compared to the other parts. Thus the extra level of maintenance would be low. Although I might be wrong in my impression! . I also like the idea of separating other aspects of the code like @glwagner proposed. Although I don't have much of a feel of the work needed for those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815114009
https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815164667:333,Deployability,pipeline,pipelines,333,"> Although I don't have much of a feel of the work needed for those. The _typing_ is mostly copy/paste directories in `Oceananigans.jl/src` to another directory, defining what gets `export`ed, and then changing `import` and `using` statements in `Oceananigans` correspondingly. The more annoying part is setting up new repos with CI pipelines, docs, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815164667
https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815045759:124,Modifiability,variab,variable,124,"> In line 39, where I define the background buoyancy of the jet, I can't use coriolis.f because CUDA seems to need a global variable and this doesn't cut it. This isn't a GPU issue I don't think because initialization is done on the CPU. I don't see a `coriolis` object defined in your script. You may need to write `model.coriolis.f`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815045759
https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237:60,Availability,error,error,60,@francispoulin I think it's always helpful to post the full error and stacktrace. From your original post. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!; ```. suggests that the error could be happening since `b̄` is being used in a `ComputedField`'s `compute!`: https://github.com/CliMA/Oceananigans.jl/blob/9eca5780658bb8f5c0debd34146a0ad5cb73c872/examples/inertially_unstable_jet.jl#L51,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237
https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237:112,Availability,ERROR,ERROR,112,@francispoulin I think it's always helpful to post the full error and stacktrace. From your original post. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!; ```. suggests that the error could be happening since `b̄` is being used in a `ComputedField`'s `compute!`: https://github.com/CliMA/Oceananigans.jl/blob/9eca5780658bb8f5c0debd34146a0ad5cb73c872/examples/inertially_unstable_jet.jl#L51,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237
https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237:201,Availability,error,error,201,@francispoulin I think it's always helpful to post the full error and stacktrace. From your original post. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!; ```. suggests that the error could be happening since `b̄` is being used in a `ComputedField`'s `compute!`: https://github.com/CliMA/Oceananigans.jl/blob/9eca5780658bb8f5c0debd34146a0ad5cb73c872/examples/inertially_unstable_jet.jl#L51,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237
https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237:119,Performance,Load,LoadError,119,@francispoulin I think it's always helpful to post the full error and stacktrace. From your original post. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!; ```. suggests that the error could be happening since `b̄` is being used in a `ComputedField`'s `compute!`: https://github.com/CliMA/Oceananigans.jl/blob/9eca5780658bb8f5c0debd34146a0ad5cb73c872/examples/inertially_unstable_jet.jl#L51,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237
https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815061162:473,Availability,down,downside,473,"Oh nice, the first use I've seen that mixes a function with a concrete `Field` in an `AbstractOperation`! Sweet! I'm not sure it would work but you can try `const coriolis = Coriolis(f=f)`. Alternatively you can build the `FunctionField` manually with something like. ```julia; b̄(x, y, z, f=coriolis.f) = # definition; b̄_field = FunctionField{Center, Center, Center}(b̄, grid, parameters=coriolis.f). b̃ = ComputedField(b - b̄_field) ; ```. But there's not too much of a downside in writing `const f = # whatever` right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815061162
https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807:187,Availability,error,error,187,"Thansk for the quick feedback. 1. I should say this is not as much of a concern as I found a work around. In my definition of b\tilde, I changed `f` to `model.coriolis.f` and received an error. Below is the beginning and it's huge so can't copy the whole thing. I will stick to my simple solution for the moment but want to point this out, in case there was a concern. ```; include(""inertially_unstable_jet.jl""); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 64, 64)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 64)},KernelAbstractions.NDIteration.StaticSize{(1, 64, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Center,Center,Center,Nothing,Nothing,typeof(b̄),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [2] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [3] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807
https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807:413,Availability,ERROR,ERROR,413,"Thansk for the quick feedback. 1. I should say this is not as much of a concern as I found a work around. In my definition of b\tilde, I changed `f` to `model.coriolis.f` and received an error. Below is the beginning and it's huge so can't copy the whole thing. I will stick to my simple solution for the moment but want to point this out, in case there was a concern. ```; include(""inertially_unstable_jet.jl""); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 64, 64)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 64)},KernelAbstractions.NDIteration.StaticSize{(1, 64, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Center,Center,Center,Nothing,Nothing,typeof(b̄),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [2] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [3] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807
https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807:420,Performance,Load,LoadError,420,"Thansk for the quick feedback. 1. I should say this is not as much of a concern as I found a work around. In my definition of b\tilde, I changed `f` to `model.coriolis.f` and received an error. Below is the beginning and it's huge so can't copy the whole thing. I will stick to my simple solution for the moment but want to point this out, in case there was a concern. ```; include(""inertially_unstable_jet.jl""); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 64, 64)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 64)},KernelAbstractions.NDIteration.StaticSize{(1, 64, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Center,Center,Center,Nothing,Nothing,typeof(b̄),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [2] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [3] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807
https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807:5401,Performance,optimiz,optimize,5401,"orted dynamic function invocation (call to getproperty); Stacktrace:; [1] call at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:456; [2] fallback at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:454; [3] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:279; [4] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [5] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [6] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:63; [7] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:6; [8] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:59; [9] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:11; [10] getindex at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:34; [11] macro expansion at /home/fpoulin/software/Oceananigans.jl/src/Fields/computed_field.jl:114; [12] gpu__compute! at /home/fpoulin/.julia/packages/KernelAbstractions/mKsXc/src/macros.jl:80; [13] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/validation.jl:123; [2] macro expansion at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:239 [inlined]; [3] macro expansion at /home/fpoulin/.julia/packages/TimerOutputs/4QAIk/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:237; [5] compile(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807
https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807:5624,Performance,optimiz,optimize,5624,"orted dynamic function invocation (call to getproperty); Stacktrace:; [1] call at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:456; [2] fallback at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:454; [3] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:279; [4] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [5] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [6] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:63; [7] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:6; [8] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:59; [9] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:11; [10] getindex at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:34; [11] macro expansion at /home/fpoulin/software/Oceananigans.jl/src/Fields/computed_field.jl:114; [12] gpu__compute! at /home/fpoulin/.julia/packages/KernelAbstractions/mKsXc/src/macros.jl:80; [13] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/validation.jl:123; [2] macro expansion at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:239 [inlined]; [3] macro expansion at /home/fpoulin/.julia/packages/TimerOutputs/4QAIk/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:237; [5] compile(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807
