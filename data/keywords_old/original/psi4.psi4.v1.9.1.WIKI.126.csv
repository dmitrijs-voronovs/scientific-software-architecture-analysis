id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110776,Modifiability,variab,variable,110776,"or('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPO",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:110870,Modifiability,variab,variable,110870,"util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in prope",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:111070,Modifiability,variab,variables,111070,"se, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:111121,Modifiability,variab,variables,111121,"ified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Comp",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:111557,Modifiability,config,configuration,111557," dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Compute; if name in ['mcscf', 'rasscf', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_pro",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:123446,Modifiability,variab,variables,123446,"tion_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_pr",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:123495,Modifiability,variab,variables,123495,"f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Star",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131042,Modifiability,variab,variables,131042,"# wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131091,Modifiability,variab,variables,131091,"OOT n OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131271,Modifiability,config,configuration,131271,"ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROH",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:134464,Modifiability,variab,variables,134464,", 'WFN', 'DETCI'); core.set_local_option('DETCI', 'FCI', 'TRUE'); elif name == 'cisd':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 2); elif name == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:134511,Modifiability,variab,variables,134511,"option('DETCI', 'FCI', 'TRUE'); elif name == 'cisd':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 2); elif name == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1}",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:134712,Modifiability,variab,variable,134712,"ETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENE",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:134747,Modifiability,variab,variable,134747,", 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORREL",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135310,Modifiability,variab,variable,135310,"files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwarg",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135596,Modifiability,variab,variable,135596,"iwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.mol",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135644,Modifiability,variab,variable,135644,"print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135742,Modifiability,variab,variable,135742,"NERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135790,Modifiability,variab,variable,135790," good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn)",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:136916,Modifiability,variab,variable,136916,"odule calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137014,Modifiability,variab,variable,137014,"SIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137127,Modifiability,variab,variable,137127,"t_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the w",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137221,Modifiability,variab,variable,137221,"). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137266,Modifiability,variab,variables,137266,"tion is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:137317,Modifiability,variab,variables,137317,"'ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:139180,Modifiability,extend,extend,139180,"le(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add IP info; ip_info = np.unique(irrep_map[ip_map], return_counts=True); for irrep, cnt in zip(*ip_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep] - cnt, nalphapi[irrep])). # Add EA info; ea_info = np.unique(irrep_map[ea_map], return_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:139381,Modifiability,extend,extend,139381,". # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add IP info; ip_info = np.unique(irrep_map[ip_map], return_counts=True); for irrep, cnt in zip(*ip_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep] - cnt, nalphapi[irrep])). # Add EA info; ea_info = np.unique(irrep_map[ea_map], return_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sor",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:140778,Modifiability,variab,variable,140778,"rtree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPN",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142500,Modifiability,variab,variable,142500,"""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142604,Modifiability,variab,variable,142604,"); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); o",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142729,Modifiability,variab,variable,142729,"ymbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). ret",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142829,Modifiability,variab,variable,142829,"""""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142874,Modifiability,variab,variables,142874,"if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:142928,Modifiability,variab,variables,142928," != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG'",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:143651,Modifiability,variab,variables,143651," dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:143701,Modifiability,variab,variables,143701,"ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Sh",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:144354,Modifiability,variab,variables,144354,"wargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variab",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:144404,Modifiability,variab,variables,144404," written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:144711,Modifiability,variab,variables,144711,"ariable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:144764,Modifiability,variab,variables,144764,"un_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = k",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:145316,Modifiability,variab,variables,145316,"tore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); mono",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:145369,Modifiability,variab,variables,145369," space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); monomerB_basis = core.BasisSet.build(mono",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:147722,Modifiability,variab,variable,147722,"al_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=mo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:148365,Modifiability,variab,variable,148365,"SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:148911,Modifiability,variab,variable,148911," and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if name in ['sapt0', 'ssapt0']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif name == 'sapt2':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif name in ['sapt2+', 'sapt2+dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(3)', 'sapt2+(3)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152285,Modifiability,variab,variable,152285,"ASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Wa",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152435,Modifiability,variab,variable,152435,"tion(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_uti",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:152539,Modifiability,variab,variable,152539,"sis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('mono",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:157293,Modifiability,variab,variable,157293,"t_local_option('SAPT', 'DO_CCD_DISP', True). core.print_out('\n'). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis); if core.get_global_option(""DF_BASIS_ELST"") == """":; dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:157660,Modifiability,variab,variable,157660,"x_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_chang",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:161459,Modifiability,variab,variable,161459,"; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; from .proc_data import mrcc_methods. # level is a dictionary of settings to be passed to core.mrcc; try:; level = mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:;",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:161864,Modifiability,variab,variables,161864,"ef_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; from .proc_data import mrcc_methods. # level is a dictionary of settings to be passed to core.mrcc; try:; level = mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level); ref_wfn.set_module(""mrcc""). # Load the fort.56 f",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164994,Modifiability,variab,variable,164994,"rror(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do no",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165197,Modifiability,variab,variable,165197,"; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165246,Modifiability,variab,variable,165246,"elds = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165450,Modifiability,variab,variable,165450,"ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165501,Modifiability,variab,variable,165501,"RRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:166325,Modifiability,variab,variables,166325,"ef_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC'",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:166374,Modifiability,variab,variables,166374,"ON ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; co",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:170062,Modifiability,variab,variables,170062,"onError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). if name in [""mp3"", ""fno-mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:170113,Modifiability,variab,variables,170113,"of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). if name in [""mp3"", ""fno-mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). director = {; # Note ""nat_orbs",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174657,Modifiability,variab,variable,174657,"Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174762,Modifiability,variab,variable,174762,"PE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_le",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174886,Modifiability,variab,variable,174886," ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174933,Modifiability,variab,variable,174933,"DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc""",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:174978,Modifiability,variab,variables,174978,"('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:175029,Modifiability,variab,variables,175029,").has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": False,},; ""fn",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:179271,Modifiability,variab,variables,179271,"sure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if no",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:179322,Modifiability,variab,variables,179322,"oc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SC",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:182528,Modifiability,variab,variable,182528,"_TYPE') == 'AO':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:182573,Modifiability,variab,variables,182573,"SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efp",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:182620,Modifiability,variab,variables,182620,"n('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:1237,Performance,optimiz,optimize,1237,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import sol",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:2549,Performance,perform,performance,2549," import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:3400,Performance,perform,performance,3400,"y.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zap",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:5299,Performance,perform,performance,5299,"= 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zapt2')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""); elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""F",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:6336,Performance,perform,performance,6336," specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE').",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:7100,Performance,perform,performance,7100,"r([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:7873,Performance,perform,performance,7873," ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'U",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:8595,Performance,perform,performance,8595,"unc = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC'",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:9243,Performance,perform,performance,9243,"e in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:9887,Performance,perform,performance,9887,"RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:10533,Performance,perform,performance,10533,", 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; fun",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:11163,Performance,perform,performance,11163,"'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:12646,Performance,perform,performance,12646," = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP3 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:13623,Performance,perform,performance,13623," the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:14396,Performance,perform,performance,14396,"Error([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:15108,Performance,perform,performance,15108,"aise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') =",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:15860,Performance,perform,performance,15860,"me__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; i",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:16652,Performance,perform,performance,16652," if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:17429,Performance,perform,performance,17429," module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:18139,Performance,perform,performance,18139," func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algori",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:19153,Performance,perform,performance,19153,"y call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:19943,Performance,perform,performance,19943,"name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_M",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:20718,Performance,perform,performance,20718,"or([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:21435,Performance,perform,performance,21435,"func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD t",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:22177,Performance,perform,performance,22177,"unc is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD through CCENERGY for (RHF|ROHF) not enabled here since not advertised. It does run, though, see #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:23873,Performance,perform,performance,23873," == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in ["""", ""OCC""]:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:24878,Performance,perform,performance,24878,"SD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:25626,Performance,perform,performance,25626,"ne:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == 'ROHF':; if mtd_ty",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:27041,Performance,perform,performance,27041,"_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['OCC']: # SOON """",; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a a-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; if name.lo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:27938,Performance,perform,performance,27938,", **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['OCC']: # SOON """",; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a a-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)"", ""ccsd(t)_l""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:29402,Performance,perform,performance,29402,"nc = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif mtd_type == ""CD"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == ""ROHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:30136,Performance,perform,performance,30136,"run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_r",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:31205,Performance,perform,performance,31205,"lt modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:31942,Performance,perform,performance,31942,"""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_opti",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:32833,Performance,perform,performance,32833,"; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_t",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:33653,Performance,perform,performance,33653,"ence, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROH",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:35078,Performance,perform,performance,35078,"C2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CC2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] Both UHF and ROHF gradients run in ccenergy but ROHF is slightly off (1.e-5); # and UHF is more off (1.e-4). Moreover, manual only claims RHF are working, so restricting here.; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc3(name, **kwargs):; """"""Function selectin",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:36097,Performance,perform,performance,36097,"directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] Both UHF and ROHF gradients run in ccenergy but ROHF is slightly off (1.e-5); # and UHF is more off (1.e-4). Moreover, manual only claims RHF are working, so restricting here.; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc3(name, **kwargs):; """"""Function selecting the algorithm for a CC3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:62111,Performance,optimiz,optimized,62111,"wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in core.OEProp.valid_methods or ""MULTIPOLE("" in prop:; oe.add(prop); oe.compute(); dct_wfn.oeprop = oe. for k, v in dct_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC. Se",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:66211,Performance,optimiz,optimized,66211,"("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # CC_LAMBDA keyword was being set TRUE sporadically, but that's covered c-side. director = {; ""mp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:70030,Performance,optimiz,optimized,70030,"ut("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:2713,Safety,avoid,avoids,2713,"les as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:72138,Safety,risk,risks,72138,"per(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98786,Safety,sanity check,sanity checks,98786,"AL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TD",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:32353,Security,access,access,32353,"pe(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:33244,Security,access,access,33244,"nt_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and whi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:64600,Testability,log,logic,64600," ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""a-ccsd(t)"": {""wfn_type"": ""DF-CCSD(AT)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC energy""). # throw exception for CONV (approximately). run reference defaulting logic; set_cholesky_from(method_algorithm_type(name).now). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", s",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:124782,Testability,assert,assert,124782," # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Mller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gaug",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168387,Testability,log,logic,168387,"roc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basis",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:57393,Usability,simpl,simplefilter,57393,"; scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:100410,Usability,simpl,simple,100410,"f_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:113141,Usability,clear,clear,113141,"f', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_prop:; oe.add(prop.upper()). # Compute ""the"" CI density; oe.compute(); ciwfn.oeprop = oe. # If we have more than one root, compute all data; if nroots > 1:; core.print_out(""\n ===> %s properties for all CI roots <=== \n\n"" % name.upper()); for root in states:; oe.set_title(""%s ROOT %d"" % (name.upper(), root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(root, root, ""B"", True)); oe.compute(). # Transition density matrices; if (nroots > 1) and len(ci_trans):; oe.clear(); for tprop in ci_trans:; oe.add(tprop.upper()). core.print_out(""\n ===> %s properties for all CI transition density matrices <=== \n\n"" % name.upper()); for root in states[1:]:; oe.set_title(""%s ROOT %d -> ROOT %d"" % (name.upper(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). _clean_detci(); optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:125264,Usability,simpl,simplefilter,125264,"lternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Mller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gauge_short = ""VEL""; elif gauge == ""length"":; gauge_short = ""LEN""; else:; raise ValidationError(f""Gauge {gauge} not recognised for ADC calculations.""). computed = []; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; props = {}; if any(prop in properties for prop in (""TRANSITION_DIPOLE"", ""OSCILLATOR_STRENGTH"")):; data = excitation.transition_dipole_moment; props[""Transition dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:2455,Availability,error,error,2455,"List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):; """"""Initialize Molecule object from LibmintsMolecule""""""; super(Molecule, self).__init__(). if molinit is not None or geom is not None:; if isinstance(molinit, dict):; molrec = molinit. elif isinstance(molinit, str):; compound_molrec = qcel.molparse.from_string(; molstr=molinit,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); molrec = compound_molrec['qm']. elif molinit",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5109,Availability,avail,available,5109,"str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilen",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5178,Availability,avail,available,5178,"self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5860,Availability,avail,available,5860,"t_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5929,Availability,avail,available,5929," def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3}",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:37753,Availability,error,error,37753,"turn geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=e",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40542,Availability,error,error,40542,"om']) < 5**(-(prec))] = 0. smol = qcel.molparse.to_string(; molrec,; dtype=dtype,; units=units,; atom_format=atom_format,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs] def run_dftd3(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43130,Availability,error,error,43130,"oat(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:58448,Availability,fault,faulty,58448,"al; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.f",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:67796,Deployability,update,updated,67796,"; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.7; . PSI4. Module code; psi4.driver.qcdb.molecule.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:1591,Energy Efficiency,charge,charge,1591,"lic License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):;",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5223,Energy Efficiency,charge,charge,5223," += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NO",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5974,Energy Efficiency,charge,charge,5974,"alse, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7230,Energy Efficiency,charge,charge,7230," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7258,Energy Efficiency,charge,chargem,7258," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7322,Energy Efficiency,charge,chargem,7322," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7346,Energy Efficiency,charge,chargem,7346," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:7431,Energy Efficiency,charge,charge,7431," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:13760,Energy Efficiency,charge,charge,13760," be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True. return text, options. def format_molecule_for_psi4_xyz(self):; """"""not much examined. """"""; text = """"; if self.nallatom():. factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; # append units and any other non-default molecule keywords; text += ""units Angstrom\n""; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += ""no_com\n""; if self.PYfix_orientation:; text += ""no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s%s%d %d\n"" % ("""" if Pfr == 0 else ""--\n"", ""#"" if self.fragment_types[fr] == 'Ghost'; or self.fragment_types[fr] == 'Absent' else """", self.fragment_charges[fr],; self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent' or self.fsymbol(at) == ""X"":; pass; else:; if self.fZ(at):; text += ""%-8s"" % (self.flabel(at)); else:; text += ""%-8s"" % (""Gh("" + self.flabel(at) + "")""); [x, y, z] = self.full_atoms[at].compute(); text += '%17.12f %17.12f %17.12f\n' % \; (x * factor, y * factor, z * factor); text += ""\n"". wtext = 'molecule mol {\n'; for line in text.splitlines():; wtext += ' ' + line + '\n'; wtext += '}\n'; return wtext. def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2a",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:22622,Energy Efficiency,charge,charge,22622,"format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variabl",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:32331,Energy Efficiency,charge,charge,32331," 1.0e-6 else 0.0; ]. # Determine degeneracy of rotational constants.; degen = 0; for i in range(2):; for j in range(i + 1, 3):; if degen >= 2:; continue; rabs = math.fabs(rot_const[i] - rot_const[j]); tmp = rot_const[i] if rot_const[i] > rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:32548,Energy Efficiency,charge,charge,32548,"rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_n(); elif pg in ['Dn', 'Dnd', 'Dnh']:; sigma = 2 * self.full_pg_n(); elif pg == 'Sn':; sigma = self.full_pg_n() / 2; else:; raise ValidationError(""Can't ID full symmetry group: "" + pg). return sigma. def axis_representation(self, zero=1e",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:32714,Energy Efficiency,charge,charge,32714,"Degeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_n(); elif pg in ['Dn', 'Dnd', 'Dnh']:; sigma = 2 * self.full_pg_n(); elif pg == 'Sn':; sigma = self.full_pg_n() / 2; else:; raise ValidationError(""Can't ID full symmetry group: "" + pg). return sigma. def axis_representation(self, zero=1e-8):; """"""Molecule vs. laboratory frame representation (e.g., IR or IIIL). Parameters; ----------; zero : float, optional; S",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40629,Energy Efficiency,energy,energy-only,40629,"ormat,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs] def run_dftd3(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40681,Energy Efficiency,efficient,efficient,40681,"ormat,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs] def run_dftd3(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40777,Energy Efficiency,energy,energy,40777,"ional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40811,Energy Efficiency,energy,energy,40811,"ional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40899,Energy Efficiency,energy,energy,40899,"ion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40980,Energy Efficiency,energy,energy,40980,"--; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43217,Energy Efficiency,energy,energy-only,43217,"']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43269,Energy Efficiency,efficient,efficient,43269,"']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43365,Energy Efficiency,energy,energy,43365,"l[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43399,Energy Efficiency,energy,energy,43399,"l[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43480,Energy Efficiency,energy,energy,43480,"; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras'][",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43554,Energy Efficiency,energy,energy,43554,"; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras'][",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:45574,Energy Efficiency,energy,energy,45574,"from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both ene",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:45643,Energy Efficiency,energy,energy,45643,"from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both ene",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46268,Energy Efficiency,energy,energy-only,46268,"rogram. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_na",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46320,Energy Efficiency,efficient,efficient,46320,"rogram. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_na",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46435,Energy Efficiency,energy,energy,46435,"correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3)",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46469,Energy Efficiency,energy,energy,46469,"correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3)",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46550,Energy Efficiency,energy,energy,46550,"nt; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (l",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:46624,Energy Efficiency,energy,energy,46624,"nt; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (l",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:55304,Energy Efficiency,charge,charge,55304,"ovenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.set_geometry_variable(var[0], var[1]). else:; geom = np.array(molrec['geom']).reshape((-1, 3)); nat = geom.shape[0]; unsettled = False. for iat in range(nat):; x, y, z = geom[iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_atom(Z, x, y, z, molrec['elem'][iat], molrec['mass'][iat], Z, label, molrec['elea'][iat]); # TODO charge and 2nd elez site; # TODO real back to type Ghost?. # apparently py- and c- sides settled on a diff convention of 2nd of pair in fragments_; fragment_separators = np.array(molrec['fragment_separators'], dtype=int); fragment_separators = np.insert(fragment_separators, 0, 0); fragment_separators = np.append(fragment_separators, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragment_charges']],; molrec['fragment_multiplicities']). self.set_molecular_charge(int(molrec['molecular_charge'])); self.set_multiplicity(molrec['molecular_multiplicity']). self.fix_com(molrec['fix_com']); self.fix_orientation(molrec['fix_orientation']); if 'fix_symmetry' in molrec:; # Save the user-specified symmetry, but don't set it as the point group; # That step occurs in update_geometry, after the atoms are added; self.PYsymmetry_from_i",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:58153,Energy Efficiency,charge,charge,58153,"ays.; return_molecules; If True, also return fragments as list of Molecules.; return_molecule; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:58694,Energy Efficiency,adapt,adapted,58694,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:62502,Energy Efficiency,charge,charge,62502," = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `ref_mol`; from mirror image of `concern_mol`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple, qcdb.Molecule or psi4.core.Molecule; First item is RMSD [A] between `ref_mol` and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `concern_mol` and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by `concern_mol` type. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); cgeom, cmass, celem, celez, cuniq = concern_mol.to_arrays(). rmsd, solution = qcel.molutil.B787(; cgeom=cgeom,; rgeom=rgeom,; cuniq=cuniq,; runiq=runiq,; do_plot=do_plot,; verbose=verbose,; atoms_map=atoms_map,; run_resorting=run_resorting,; mols_align=mols_align,; run_to_completion=run_to_completion,; run_mirror=run_mirror,; uno_cutoff=uno_cutoff). ageom, amass, aelem, aelez, auniq = solution.align_system(cgeom, cmass, celem, celez, cuniq, reverse=False); adict = qcel.molparse.from_arrays(; geom=ageom,; mass=amass,; elem=aelem,; elez=aelez,; units='Bohr',; molecular_charge=concern_mol.molecular_charge(),; molecular_multiplicity=concern_mol.multiplicity(),; fix_com=True,; fix_orientation=True); if isinstance(concern_mol, Molecule):; amol = Molecule.from_dict(adict); else:; from psi4 import core; amol = core.Molecule.fr",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:37939,Integrability,wrap,wrapper,37939,"orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43625,Integrability,wrap,wraps,43625,"BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43664,Integrability,wrap,wraps,43664,"BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:45942,Integrability,interface,interface,45942,"erint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:48107,Integrability,wrap,wrapper,48107,"resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']),; jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~qcdb.Molecule.from_arrays`. Parameters; ----------; molschema : dict; Dictionary form of Molecule following known schema.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate.; verbose : int, optional; Amount of printing. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """""". molrec = qcel.molparse.from_schema(molschema, verbose=verbose). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). [docs] def to_schema(self, dtype, units='Bohr'):; """"""Serializes instance into dictionary according to schema `dtype`."""""". molrec = self.to_dict(np_out=True); schmol = qcel.molparse.to_schema(molrec, dtype=dtype, units=units); return schmol. [docs] def to_dict(self, force_c1=False, force_units=False, np_out=True):; """"""Serializes instance into Molecule dictionary."""""". self.update_geometry(); molrec = {}.",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:1806,Modifiability,extend,extends,1806,". See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):; """"""Initialize Molecule object from LibmintsMolecule""""""; super(Molecule, self).__init__(). if molinit is not None or geom is not None:; if isinstance(molinit, dict):; molrec = molinit. elif isinstance(molinit, str):; compound_molrec = qcel.molparse.from_",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:4374,Modifiability,variab,variable,4374,"me,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilena",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:4701,Modifiability,variab,variable,4701,"icity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def in",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:21791,Modifiability,variab,variables,21791,"{:>17.12f}\n"""""".format(x * factor, y * factor, z * factor); # >>>; # any general finishing notation here <<<; text += '$end\n\n'; # >>>. # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; if (not self.PYmove_to_com) or self.PYfix_orientation:; options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True; options['QCHEM']['QCHEM_SYM_IGNORE']['clobber'] = True. return text, options. def format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; #",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:21868,Modifiability,variab,variables,21868,"{:>17.12f}\n"""""".format(x * factor, y * factor, z * factor); # >>>; # any general finishing notation here <<<; text += '$end\n\n'; # >>>. # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; if (not self.PYmove_to_com) or self.PYfix_orientation:; options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True; options['QCHEM']['QCHEM_SYM_IGNORE']['clobber'] = True. return text, options. def format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; #",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:23554,Modifiability,variab,variables,23554,"ent\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(),",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:37922,Modifiability,variab,variables,37922,"olstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_c",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43835,Modifiability,extend,extending,43835,"me of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:45894,Modifiability,extend,extended,45894,"erint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:54894,Modifiability,variab,variables,54894,"rn mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.set_geometry_variable(var[0], var[1]). else:; geom = np.array(molrec['geom']).reshape((-1, 3)); nat = geom.shape[0]; unsettled = False. for iat in range(nat):; x, y, z = geom[iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_atom(Z, x, y, z, molrec['elem'][iat], molrec['mass'][iat], Z, label, molrec['elea'][iat]); # TODO charge and 2nd elez site; # TODO real back to type Ghost?. # apparently py- and c- sides settled on a diff convention of 2nd of pair in fragments_; fragment_separators = np.array(molrec['fragment_separators'], dtype=int); fragment_separators = np.insert(fragment_separators, 0, 0); fragment_separators = np.append(fragment_separators, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragment",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:58694,Modifiability,adapt,adapted,58694,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:51067,Performance,perform,performed,51067," # moldict['zmat'] = self.zmat; # TODO zmat, geometry_variables. nat = self.natom(); geom = np.array(self.geometry()) # [a0]; if molrec['units'] == 'Angstrom':; geom *= qcel.constants.bohr2angstroms #self.input_units_to_au(); molrec['geom'] = geom.reshape((-1)). molrec['elea'] = np.array([self.mass_number(at) for at in range(nat)]); molrec['elez'] = np.array([qcel.periodictable.to_Z(self.symbol(at)) for at in range(nat)]); molrec['elem'] = np.array([self.symbol(at).capitalize() for at in range(nat)]); molrec['mass'] = np.array([self.mass(at) for at in range(nat)]); molrec['real'] = np.array([bool(self.Z(at)) for at in range(nat)]); molrec['elbl'] = np.array([self.label(at)[len(self.symbol(at)):].lower() for at in range(nat)]). fragments = [x[:] for x in self.get_fragments()]; fragment_charges = [float(f) for f in self.get_fragment_charges()]; fragment_multiplicities = [m for m in self.get_fragment_multiplicities()]. # do trimming not performed in Molecule class b/c fragment_* member data never directly exposed; for ifr, fr in reversed(list(enumerate(self.get_fragment_types()))):; if fr == 'Ghost':; fragment_charges[ifr] = 0.; fragment_multiplicities[ifr] = 1; elif fr == 'Absent':; del fragment_charges[ifr]; del fragment_multiplicities[ifr]; # readjust atom indices for subsequent fragments; renum = fragments[ifr][0]; for iffr, ffr in enumerate(fragments):; if iffr <= ifr:; continue; lenfr = ffr[1] - ffr[0]; fragments[iffr] = [renum, renum + lenfr]; renum += lenfr; del fragments[ifr]. molrec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the diffe",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5058,Safety,detect,detected,5058," comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to tur",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:5809,Safety,detect,detected,5809,"dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.r",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:57382,Safety,detect,detected,57382,"etry termination upon no atoms; #if nat == 0:; # self.set_lock_frame(True). if not unsettled:; self.update_geometry(). [docs] def BFS(self,; seed_atoms: List = None,; bond_threshold: float = 1.20,; return_arrays: bool = False,; return_molecules: bool = False,; return_molecule: bool = False):; """"""Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters; ----------; self : qcdb.Molecule or psi4.core.Molecule; seed_atoms; List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: `[[1, 0], [2]]`; bond_threshold; Factor beyond average of covalent radii to determine bond cutoff.; return_arrays; If `True`, also return fragments as list of arrays.; return_molecules; If True, also return fragments as list of Molecules.; return_molecule; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:1128,Security,hash,hashlib,1128,".molecule; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:4641,Security,access,accessing,4641,"icity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def in",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:35118,Security,hash,hash,35118,"'; elif np.array_equal(Iidx, np.asarray([0, 1, 2])):; ar = 'IIIR'; elif np.array_equal(Iidx, np.asarray([2, 1, 0])):; ar = 'IL'; elif np.array_equal(Iidx, np.asarray([0, 2, 1])):; ar = 'IIL'; elif np.array_equal(Iidx, np.asarray([1, 0, 2])):; ar = 'IIIL'. # if inertial tensor has non-zero off-diagonals, this whole classification is iffy; if np.count_nonzero(it - np.diag(np.diagonal(it))):; ar = '~' + ar. return ar. [docs] def to_arrays(self, dummy: bool = False, ghost_as_dummy: bool = False) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:; """"""Exports coordinate info into NumPy arrays. Parameters; ----------; dummy; Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy; Whether or not to treat ghost atoms as dummies. Returns; -------; geom, mass, elem, elez, uniq : numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geome",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:35937,Security,hash,hashlib,35937,"ez, uniq : numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom()); ]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:36429,Security,hash,hashlib,36429,"l qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom()); ]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:51137,Security,expose,exposed,51137," # moldict['zmat'] = self.zmat; # TODO zmat, geometry_variables. nat = self.natom(); geom = np.array(self.geometry()) # [a0]; if molrec['units'] == 'Angstrom':; geom *= qcel.constants.bohr2angstroms #self.input_units_to_au(); molrec['geom'] = geom.reshape((-1)). molrec['elea'] = np.array([self.mass_number(at) for at in range(nat)]); molrec['elez'] = np.array([qcel.periodictable.to_Z(self.symbol(at)) for at in range(nat)]); molrec['elem'] = np.array([self.symbol(at).capitalize() for at in range(nat)]); molrec['mass'] = np.array([self.mass(at) for at in range(nat)]); molrec['real'] = np.array([bool(self.Z(at)) for at in range(nat)]); molrec['elbl'] = np.array([self.label(at)[len(self.symbol(at)):].lower() for at in range(nat)]). fragments = [x[:] for x in self.get_fragments()]; fragment_charges = [float(f) for f in self.get_fragment_charges()]; fragment_multiplicities = [m for m in self.get_fragment_multiplicities()]. # do trimming not performed in Molecule class b/c fragment_* member data never directly exposed; for ifr, fr in reversed(list(enumerate(self.get_fragment_types()))):; if fr == 'Ghost':; fragment_charges[ifr] = 0.; fragment_multiplicities[ifr] = 1; elif fr == 'Absent':; del fragment_charges[ifr]; del fragment_multiplicities[ifr]; # readjust atom indices for subsequent fragments; renum = fragments[ifr][0]; for iffr, ffr in enumerate(fragments):; if iffr <= ifr:; continue; lenfr = ffr[1] - ffr[0]; fragments[iffr] = [renum, renum + lenfr]; renum += lenfr; del fragments[ifr]. molrec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the diffe",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:53935,Security,validat,validated,53935,"t_molecular_change` or `set_multiplicity`. Such alterations are an expert feature. Specifying in the original molecule string is preferred. Nonphysical masses may also trigger the warning.""""""; ); molrec['fragment_charges'] = [None] * len(fragments); molrec['fragment_multiplicities'] = [None] * len(fragments); validated_molrec = qcel.molparse.from_arrays(speclabel=False, nonphysical=True, verbose=0, domain='qm', **molrec); forgive.append('fragment_charges'); forgive.append('fragment_multiplicities'); compare_molrecs(validated_molrec, molrec, 'to_dict', atol=1.e-6, forgive=forgive, verbose=0). # from_arrays overwrites provenance; validated_molrec['provenance'] = copy.deepcopy(molrec['provenance']). if not np_out:; validated_molrec = qcel.util.unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, molrec, verbose=1):. mol = cls(); mol._internal_from_dict(molrec=molrec, verbose=verbose); return mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.s",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:1345,Testability,test,testing,1345,"corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_retur",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:61811,Testability,test,test,61811,"; aligns with `ref_mol`. Wraps :py:func:`qcelemental.molutil.B787` for :py:class:`psi4.driver.qcdb.Molecule` or; :py:class:`psi4.core.Molecule`. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters; ----------; concern_mol; Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with `ref_mol`.; ref_mol; Molecule to match.; atoms_map; Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc.; If true, specifying `True` can save much time.; mols_align; Whether `ref_mol` and `concern_mol` have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `ref_mol`; from mirror image of `concern_mol`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple, qcdb.Molecule or psi4.core.Molecule; First item is RMSD [A] between `ref_mol` and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `concern_mol` and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by `concern_mol` type. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); cgeom, cmass, celem, celez, cuniq = concern_mol.to_arrays(). rmsd, solution = qcel.molutil.B787(; cgeom=cgeom,",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:65651,Testability,test,test,65651,"_shift; Whether to generate a random atom shift on interval [-3, 3) in each; dimension (`True`) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate; Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort; Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`).; To specify shuffle, supply a nat-element list of indices.; deflection; If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror; Whether to construct the mirror image structure by inverting y-axis.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; By construction, scrambled systems are fully alignable (final RMSD=0).; Even so, `True` turns off the mechanism to stop when RMSD reaches zero; and instead proceed to worst possible time.; run_resorting; Even if atoms not shuffled, test the resorting machinery.; verbose; Print level. Returns; -------; None. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); nat = rgeom.shape[0]. perturbation = qcel.molutil.compute_scramble(; rgeom.shape[0],; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_c",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:1380,Availability,toler,tolerance,1380," file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Toleranc",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:1889,Availability,toler,tolerance,1889," FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:2096,Availability,toler,tolerance,2096,". import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:2136,Availability,error,error,2136,"ols; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:2278,Availability,failure,failure,2278,"elemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; che",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:2513,Availability,toler,tolerance,2513,"mega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:; if asp not in computed and asp in forgive:; continue. if toldict is not None and",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:10925,Availability,toler,tolerance,10925,"s in diff (xyz) arrangements); idx_sort_wi_degen = np.lexsort(; (idx_max_elem_each_normco[istart:istart + degree], max_elem_each_normco[istart:istart + degree])); idx_vib_reordering[istart:istart + degree] = np.arange(istart, istart + degree)[idx_sort_wi_degen]. arr2 = arr[:, idx_vib_reordering]. reorderings = ['{}-->{}'.format(i, v) for i, v in enumerate(idx_vib_reordering) if (i != v)]; if reorderings and verbose >= 2:; print('Degenerate modes reordered:', ', '.join(reorderings)). return arr2. def _phase_cols_to_max_element(arr, tol=1.e-2, verbose=1):; """"""Returns copy of 2D `arr` scaled such that, within cols, max(fabs); element is positive. If max(fabs) is pos/neg pair, scales so first; element (within `tol`) is positive. """"""; arr2 = np.copy(arr). rephasing = []; for v in range(arr.shape[1]):; vextreme = 0.0; iextreme = None. # find most extreme value; for varr in arr[:, v]:; vextreme = max(np.absolute(varr), vextreme). # find the first index whose fabs equals that value, w/i tolerance; for iarr, varr in enumerate(arr[:, v]):; if (vextreme - np.absolute(varr)) < tol:; iextreme = iarr; break. sign = np.sign(arr[iextreme, v]); if sign == -1.:; rephasing.append(str(v)); arr2[:, v] *= sign. if rephasing and verbose >= 2:; print('Negative modes rephased:', ', '.join(rephasing)). return arr2. [docs]def harmonic_analysis(hess: np.ndarray, geom: np.ndarray, mass: np.ndarray, basisset: psi4.core.BasisSet, irrep_labels: List[str], dipder: np.ndarray = None, project_trans: bool = True, project_rot: bool = True) -> Tuple[Dict[str, Datum], str]:; """"""Extract frequencies, normal modes and other properties from electronic Hessian. Like so much other Psi4 goodness, originally by @andysim. Parameters; ----------; hess; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; geom; (nat, 3) geometry [a0] at which Hessian computed.; mass; (nat,) atomic masses [u].; basisset; Basis set object (can be dummy, e.g., STO-3G) for SALCs.; irrep_labels; Irreducible representat",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:18997,Availability,down,downhill,18997,"(qcel.constants.na * qcel.constants.hartree2J * 1.0e19) /; (2 * np.pi * qcel.constants.c * qcel.constants.bohr2angstroms)); pre_frequency_cm_1 = np.lib.scimath.sqrt(pre_force_constant_au) * uconv_cm_1. pre_lowfreq = np.where(np.real(pre_frequency_cm_1) < 100.0)[0]; pre_lowfreq = np.append(pre_lowfreq, np.arange(nrt_expected)) # catch at least nrt modes; for lf in set(pre_lowfreq):; vlf = pre_frequency_cm_1[lf]; if vlf.imag > vlf.real:; text.append(' pre-proj low-frequency mode: {:9.4f}i [cm^-1]'.format(vlf.real, vlf.imag)); else:; text.append(' pre-proj low-frequency mode: {:9.4f} [cm^-1]'.format(vlf.real, '')); text.append(' pre-proj all modes:' + str(_format_omega(pre_frequency_cm_1, 4))). # project & solve; mwhess_proj = np.dot(P.T, mwhess).dot(P); text.append(mat_symm_info(mwhess_proj, lbl='projected mass-weighted Hessian') + f' ({nrt})'). #print('projhess = ', np.array_repr(mwhess_proj)); force_constant_au, qL = np.linalg.eigh(mwhess_proj). # expected order for vibrations is steepest downhill to steepest uphill; idx = np.argsort(force_constant_au); force_constant_au = force_constant_au[idx]; qL = qL[:, idx]; qL = _phase_cols_to_max_element(qL); vibinfo['q'] = Datum('normal mode', 'a0 u^1/2', qL, comment='normalized mass-weighted'). # frequency, LAB II.17; frequency_cm_1 = np.lib.scimath.sqrt(force_constant_au) * uconv_cm_1; vibinfo['omega'] = Datum('frequency', 'cm^-1', frequency_cm_1). # degeneracies; ufreq, uinv, ucts = np.unique(np.around(frequency_cm_1, 1), return_inverse=True, return_counts=True); vibinfo['degeneracy'] = Datum('degeneracy', '', ucts[uinv]). # look among the symmetry subspaces h for one to which the normco; # of vib does *not* add an extra dof to the vector space; active = []; irrep_classification = []; for idx, vib in enumerate(frequency_cm_1):. if vec_in_space(qL[:, idx], TRspace, 1.0e-4):; active.append('TR'); irrep_classification.append(None). else:; active.append('V'). for h in Uh.keys():; if vec_in_space(qL[:, idx], Uh[h], 1.0e-4):; ir",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:42777,Deployability,update,updated,42777,"p.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return TRindep. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.7; . PSI4. Module code; psi4.driver.qcdb.vib.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:14211,Energy Efficiency,reduce,reduced,14211," +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | x | normal mode, normalized un-mass-weighted | a0 | ndarray(ndof, ndof) float |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | degeneracy | degree of degeneracy | | ndarray(ndof) int |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | TRV | translation/rotation/vibration | | ndarray(ndof) str 'TR' or 'V' or '-' for partial |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | gamma | irreducible representation | | ndarray(ndof) str irrep or None if unclassifiable |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | mu | reduced mass | u | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | k | force constant | mDyne/A | ndarray(ndof) float (+/-) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | DQ0 | RMS deviation v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Qtp0 | Turning point v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(n",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:15637,Energy Efficiency,energy,energy,15637," | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Qtp0 | Turning point v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | IR_intensity | infrared intensity | km/mol | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+. Examples; --------; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). """"""; if (mass.shape[0] == geom.shape[0] == (hess.shape[0] // 3) == (hess.shape[1] // 3)) and (geom.shape[1] == 3):; pass; else:; raise ValidationError(; f""""""Dimension mismatch among mass ({mass.shape}), geometry ({geom.shape}), and Hessian ({hess.shape})""""""). def mat_symm_info(a, atol=1e-14, lbl='array', stol=None):; symm = np.allclose(a, a.T, atol=atol); herm = np.allclose(a, a.conj().T, atol=atol); ivrt = a.shape[0] - np.linalg.matrix_rank(a, tol=stol); return """""" {:32} Symmetric? {} Hermitian? {} Lin Dep Dim? {:2}"""""".format(lbl + ':', symm, herm, ivrt). def vec_in_space(vec, space, tol=1.0e-4):; merged = np.vstack((space, vec)); u, s, v = np.linalg.svd(merged); return (s[-1] < tol). vibinfo = {}; text = []. nat = len(mass); text.append(""""""\n\n ==> Harmonic Vibrational Analysis <==\n""""""). if nat == 1:; nrt_expected = 3; elif np.li",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:21431,Energy Efficiency,reduce,reduced,21431,"cted)) # catch at least nrt modes; for lf in set(lowfreq):; vlf = frequency_cm_1[lf]; if vlf.imag > vlf.real:; text.append(' post-proj low-frequency mode: {:9.4f}i [cm^-1] ({})'.format(vlf.imag, active[lf])); else:; text.append(' post-proj low-frequency mode: {:9.4f} [cm^-1] ({})'.format(vlf.real, active[lf])); text.append(' post-proj all modes:' + str(_format_omega(frequency_cm_1, 4)) + '\n'); if project_trans and not project_rot:; text.append(f' Note that ""Vibration""s include {nrt_expected - 3} un-projected rotation-like modes.'); elif not project_trans and not project_rot:; text.append(; f' Note that ""Vibration""s include {nrt_expected} un-projected rotation-like and translation-like modes.'). # general conversion factors, LAB II.11; uconv_K = (qcel.constants.h * qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intens",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:21670,Energy Efficiency,reduce,reduced,21670,"post-proj low-frequency mode: {:9.4f} [cm^-1] ({})'.format(vlf.real, active[lf])); text.append(' post-proj all modes:' + str(_format_omega(frequency_cm_1, 4)) + '\n'); if project_trans and not project_rot:; text.append(f' Note that ""Vibration""s include {nrt_expected - 3} un-projected rotation-like modes.'); elif not project_trans and not project_rot:; text.append(; f' Note that ""Vibration""s include {nrt_expected} un-projected rotation-like and translation-like modes.'). # general conversion factors, LAB II.11; uconv_K = (qcel.constants.h * qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infr",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:22206,Energy Efficiency,meter,meter,22206,"qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infrared intensity', '(D/AA)^2/u', ir_intens_D2A2u); ir_intensity_kmmol = ir_intensity * uconv_kmmol; vibinfo['IR_intensity'] = Datum('infrared intensity', 'km/mol', ir_intensity_kmmol). # force constants, LAB II.16 (real compensates for earlier sqrt); uconv_mdyne_a = (0.1 * (2 * np.pi * qcel.constants.c)**2) / qcel.constants.na; force_constant_mdyne_a = reduced_mass_u * (frequency_cm_1 * frequency_cm_1).real * uconv_mdyne_a; vibinfo['k'] = Datum('force constant', 'mDyne/A', force_constant_mdyne_a). force_constant_cm_1_bb = reduced_mass_u * (f",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:25360,Energy Efficiency,reduce,reduced,25360,"ts.c / qcel.constants.kb; vib_temperature_K = frequency_cm_1.real * uconv_K; vibinfo['theta_vib'] = Datum('char temp', 'K', vib_temperature_K). return vibinfo, '\n'.join(text). def _br(string):; return '[' + string + ']'. def _format_omega(omega, decimals):; """"""Return complex frequencies in `omega` into strings showing only real or imag (""i""-labeled); to `decimals` precision. """"""; freqs = []; for fr in omega:; if fr.imag > fr.real:; freqs.append(""""""{:.{prec}f}i"""""".format(fr.imag, prec=decimals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). [docs]def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requeste",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:25840,Energy Efficiency,reduce,reduced,25840,"cimals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). [docs]def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requested normal coordinates not among allowed q/w/x: """""" + normco). nat = int(len(vibinfo['q'].data[:, 0]) / 3); if atom_lbl is None:; atom_lbl = [''] * nat. active = [idx for idx, trv in enumerate(vibinfo['TRV'].data) if trv == 'V']. presp = 2; colsp = 2; if shortlong:; groupby = groupby if groupby else 3; ncprec = ncprec if ncprec else 2; width = (ncprec + 4) * 3; prewidth = 24; else:; groupby = groupby if groupby else 6; ncprec = ncprec if ncprec else 4; width = ncprec + 8; prewidth = 24; if",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:30898,Energy Efficiency,energy,energy,30898,"[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. [docs]def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datu",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:33633,Energy Efficiency,reduce,reduced,33633,"const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['ele",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37156,Energy Efficiency,energy,energy,37156,"e2kcalmol, qcel.constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37206,Energy Efficiency,energy,energy,37206,"e2kcalmol, qcel.constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gi",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37293,Energy Efficiency,energy,energy,37293,""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); tex",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37594,Energy Efficiency,energy,energy,37594,"t = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:37843,Energy Efficiency,energy,energy,37843,"format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:38192,Energy Efficiency,energy,energy,38192,"at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvibs",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:2142,Integrability,message,messages,2142,"ols; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:40125,Integrability,depend,dependencies,40125," remove=[i for i, d in enumerate(allvibs['gamma'].data) if d != 'A1']). """"""; work = {}; if remove is None:; remove = [idx for idx, dat in enumerate(vibinfo['TRV'].data) if dat != 'V']; for asp, oasp in vibinfo.items():; if asp in ['q', 'w', 'x']:; axis = 1; else:; axis = 0; work[asp] = Datum(oasp.label, oasp.units, np.delete(oasp.data, remove, axis=axis), comment=oasp.comment, numeric=False). return work. [docs]def filter_omega_to_real(omega: np.ndarray) -> np.ndarray:; """"""Returns ndarray (float) of `omega` (complex) where imaginary entries are converted to negative reals.""""""; freqs = []; for fr in omega:; if fr.imag > fr.real:; freqs.append(-1 * fr.imag); else:; freqs.append(fr.real); return np.asarray(freqs). def _get_TR_space(m: np.ndarray, geom: np.ndarray, space: str = 'TR', tol: float = None, verbose: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); as",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:3285,Modifiability,extend,extend,3285,"red; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:; if asp not in computed and asp in forgive:; continue. if toldict is not None and asp in toldict:; ktol = toldict[asp]; else:; ktol = tol. if asp in 'qwx':; ccnc = _phase_cols_to_max_element(computed[asp].data); eenc = _phase_cols_to_max_element(expected[asp].data); ccnc = _check_degen_modes(ccnc, computed['omega'].data); eenc = _check_degen_modes(eenc, expected['omega'].data); same = np.allclose(eenc, ccnc, atol=ktol); print_stuff(asp=asp, same=same, ref=eenc, val=ccnc, space='\n'); same = _check_rank_degen_modes(ccnc, computed[""omega""].data, eenc, difftol=ktol, svdtol=svdtol). elif asp in ['gamma', 'TRV']:; same = all([computed[asp].data[idx] == val for idx, val in enumerate(expected[asp].data)]); print_stuff(asp=asp, same=same, ref=expected[asp].data, val=computed[asp].data). elif isinstance(expected[asp].data, float):; same = abs(expected[asp].data - computed[asp].data) < ktol; ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:5713,Testability,test,tested,5713,"metrize(hess: np.ndarray, mol: psi4.core.Molecule) -> np.ndarray:; """"""Apply Abelian symmetry of `mol` to Hessian `hess`. Parameters; ----------; hess; (3 * nat, 3 * nat) Hessian array perhaps with jitter unbecoming a symmetric molecule.; mol; Molecule at which Hessian computed. Returns; -------; numpy.ndarray; (3 * nat, 3 * nat) symmetrized Hessian array. """"""; ct = mol.point_group().char_table(). # Obtain atom mapping of atom * symm op to atom; atom_map = compute_atom_map(mol). syms = []; smap = []; for g in range(ct.order()):; syms.append(np.asarray(ct.symm_operation(g).d)); smap.append([atom_map[at][g] for at in range(mol.natom())]). np.set_printoptions(formatter={'float': '{: 16.12f}'.format}); b_hess = blockwise_expand(hess, (3, 3), False). bDG = []; nat = b_hess.shape[0]; for iat in range(nat):; for jat in range(nat):; for sym in range(len(syms)):; bDG.append(np.zeros_like(b_hess)); bDG[sym][iat, jat] = syms[sym].dot(b_hess[iat, jat].dot(syms[sym])); # Note that tested syms all diagonal, so above may be off by some transposes. for sym in range(len(syms)):; bDG[sym] = bDG[sym][:, smap[sym]]; bDG[sym] = bDG[sym][smap[sym], :]; tot = np.sum(bDG, axis=0); tot = np.divide(tot, len(syms)). print('symmetrization diff:', np.linalg.norm(tot - b_hess)); m_tot = blockwise_contract(tot); return m_tot. [docs]def print_molden_vibs(vibinfo: Dict[str, Datum], atom_symbol: Union[np.ndarray, List[str]], geom: Union[np.ndarray, List[List[float]]], standalone: bool = True) -> str:; """"""Format vibrational analysis for Molden. Parameters; ----------; vibinfo; Holds results of vibrational analysis.; atom_symbol; (nat,) element symbols for geometry of vibrational analysis.; geom; (nat, 3) geometry of vibrational analysis [a0].; standalone; Whether returned string prefixed ""[Molden Format]"" for standalone rather than append. Returns; -------; str; `vibinfo` formatted for Molden, including FREQ, FR-COORD, & FR-NORM-COORD fields. Notes; -----; Molden format spec from http://www.cmbi.ru.nl",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:32042,Testability,log,log,32042,"ty of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[(",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:32294,Testability,log,log,32294,"RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibon",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:32650,Testability,log,log,32650,"minfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lo",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:32948,Testability,log,log,32948,"y; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')]",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:33909,Testability,log,log,33909,"; sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['elec', 'trans', 'rot', 'vib']:; # terms above are unitless (S, Cv, Cp) or in units of temperature (ZPE, E, H, G) as expressions are divided by R.; # R [Eh/K], computed as below, slightly diff in 7th sigfig from 3.1668114e-6 (k_B in [Eh/K]); # value listed https://en.wikipedia.org/wiki/Boltzmann_constant; uco",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:34185,Testability,assert,assert,34185,"a(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['elec', 'trans', 'rot', 'vib']:; # terms above are unitless (S, Cv, Cp) or in units of temperature (ZPE, E, H, G) as expressions are divided by R.; # R [Eh/K], computed as below, slightly diff in 7th sigfig from 3.1668114e-6 (k_B in [Eh/K]); # value listed https://en.wikipedia.org/wiki/Boltzmann_constant; uconv_R_EhK = qcel.constants.R / qcel.constants.hartree2kJmol; for piece in ['S', 'Cv', 'Cp']:; sm[(piece, term)] *= uconv_R_EhK # [mEh/K] <-- []; for piece in ['ZPE', 'E', 'H', 'G']:; sm[(piece, term)] *= uconv_R_EhK * 0.001 # [Eh] <-- [K]. # sum corrections and totals; for piece in ['S', 'Cv', ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:40936,Testability,assert,assert,40936,"e: str = 'TR', tol: float = None, verbose: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in sp",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:40984,Testability,assert,assert,40984,"se: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41031,Testability,assert,assert,41031,"zed translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if ",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41078,Testability,assert,assert,41078,"geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it run",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41126,Testability,assert,assert,41126,"encies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]).",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41173,Testability,assert,assert,41173,"toms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41221,Testability,assert,assert,41221,") otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=Fals",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html:41353,Testability,assert,assert,41353,"ray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps",MatchSource.WIKI,psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.AngularMomentumInt.html:527,Deployability,update,updated,527,". AngularMomentumInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; AngularMomentumInt. AngularMomentumInt. class psi4.core.AngularMomentumInt; Bases: OneBodyAOInt; Computes angular momentum integrals. table of contents. AngularMomentumInt; AngularMomentumInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; AngularMomentumInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.AngularMomentumInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.AngularMomentumInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.AOShellCombinationsIterator.html:1393,Deployability,update,updated,1393,". AOShellCombinationsIterator. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; AOShellCombinationsIterator. AOShellCombinationsIterator. class psi4.core.AOShellCombinationsIterator; Bases: pybind11_object; Attributes Summary. p; Returns current P index. q; Returns current Q index. r; Returns current R index. s; Returns current S index. Methods Summary. first(self); docstring. is_done(self); docstring. next(self); docstring. Attributes Documentation. p; Returns current P index. q; Returns current Q index. r; Returns current R index. s; Returns current S index. Methods Documentation. first(self: psi4.core.AOShellCombinationsIterator)  None; docstring. is_done(self: psi4.core.AOShellCombinationsIterator)  bool; docstring. next(self: psi4.core.AOShellCombinationsIterator)  None; docstring. table of contents. AOShellCombinationsIterator; AOShellCombinationsIterator; AOShellCombinationsIterator.p; AOShellCombinationsIterator.q; AOShellCombinationsIterator.r; AOShellCombinationsIterator.s; AOShellCombinationsIterator.first(); AOShellCombinationsIterator.is_done(); AOShellCombinationsIterator.next(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; AOShellCombinationsIterator.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.AOShellCombinationsIterator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.AOShellCombinationsIterator.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variable.html:547,Deployability,update,updated,547,". array_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; array_variable. array_variable. psi4.core.array_variable(key: str)  psi4.core.Matrix; Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). table of contents. array_variable; array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; array_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variable.html:281,Modifiability,variab,variable,281,". array_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; array_variable. array_variable. psi4.core.array_variable(key: str)  psi4.core.Matrix; Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). table of contents. array_variable; array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; array_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variables.html:542,Deployability,update,updated,542,". array_variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; array_variables. array_variables. psi4.core.array_variables()  Dict[str, psi4.core.Matrix]; Returns dictionary of all Matrix QCVariables; prefer variables(). table of contents. array_variables; array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; array_variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variables.html:272,Modifiability,variab,variables,272,". array_variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; array_variables. array_variables. psi4.core.array_variables()  Dict[str, psi4.core.Matrix]; Returns dictionary of all Matrix QCVariables; prefer variables(). table of contents. array_variables; array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; array_variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.array_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisExtents.html:1092,Deployability,update,updated,1092,". BasisExtents. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BasisExtents. BasisExtents. class psi4.core.BasisExtents; Bases: pybind11_object; docstring; Methods Summary. basis(self); docstring. delta(self); docstring. maxR(self); docstring. set_delta(self,arg0); docstring. shell_extents(self); docstring. Methods Documentation. basis(self: psi4.core.BasisExtents)  psi4.core.BasisSet; docstring. delta(self: psi4.core.BasisExtents)  float; docstring. maxR(self: psi4.core.BasisExtents)  float; docstring. set_delta(self: psi4.core.BasisExtents, arg0: float)  None; docstring. shell_extents(self: psi4.core.BasisExtents)  psi4.core.Vector; docstring. table of contents. BasisExtents; BasisExtents; BasisExtents.basis(); BasisExtents.delta(); BasisExtents.maxR(); BasisExtents.set_delta(); BasisExtents.shell_extents(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BasisExtents.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisExtents.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisExtents.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisFunctions.html:1333,Deployability,update,updated,1333,". BasisFunctions. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BasisFunctions. BasisFunctions. class psi4.core.BasisFunctions; Bases: pybind11_object; docstring; Methods Summary. basis_values(self); docstring. compute_functions(self,arg0); docstring. deriv(self); docstring. max_functions(self); docstring. max_points(self); docstring. set_deriv(self,arg0); docstring. Methods Documentation. basis_values(self: psi4.core.BasisFunctions)  Dict[str, psi4.core.Matrix]; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi4.core.BlockOPoints)  None; docstring. deriv(self: psi4.core.BasisFunctions)  int; docstring. max_functions(self: psi4.core.BasisFunctions)  int; docstring. max_points(self: psi4.core.BasisFunctions)  int; docstring. set_deriv(self: psi4.core.BasisFunctions, arg0: int)  None; docstring. table of contents. BasisFunctions; BasisFunctions; BasisFunctions.basis_values(); BasisFunctions.compute_functions(); BasisFunctions.deriv(); BasisFunctions.max_functions(); BasisFunctions.max_points(); BasisFunctions.set_deriv(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BasisFunctions.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisFunctions.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:3883,Availability,avail,available,3883,"oes it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from key in global options. If; a user-defined-basis callable is available at string target, target; value will be set to it. In practice, setting this argument to a; PSI4 keyword (e.g., core.get_option(""SCF"", ""DF_BASIS_SCF"") or; core.get_global_option(""BASIS"")) works to handle both simple and; user-defined bases.; fitrole (str)  {ORBITAL, JKFIT, RIFIT, DECON}; Role for which to build basis. Only used when key indicates auxiliary; (i.e., is not ""BASIS"") and auxiliary spec from processing target; cant complete the mol. Then, primary spec from other can be used; to complete the auxiliary basis by looking up suitable default basis; according to fitrole.; other (Union[str, Callable, None])  Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like target.; puream (int)  Whether to override the native spherical/cartesian-ness of target for; returned basis? Value 1 forces spherical, value 0 forces; Cartesian, value -1 (default) uses native puream. Note that; explicitly setting PUREAM trumps both native; pur",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:10270,Deployability,update,updated,10270,"int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int)  int; Return the atomic center for the ith shell. static zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. table of contents. BasisSet; BasisSet; BasisSet.ao_to_shell(); BasisSet.blend(); BasisSet.build(); BasisSet.compute_phi(); BasisSet.construct_from_pydict(); BasisSet.ecp_shell(); BasisSet.ecp_shell_on_center(); BasisSet.function_to_center(); BasisSet.function_to_shell(); BasisSet.genbas(); BasisSet.has_ECP(); BasisSet.has_puream(); BasisSet.make_filename(); BasisSet.max_am(); BasisSet.max_function_per_shell(); BasisSet.max_nprimitive(); BasisSet.molecule(); BasisSet.move_atom(); BasisSet.n_ecp_core(); BasisSet.n_ecp_shell_on_center(); BasisSet.n_frozen_core(); BasisSet.name(); BasisSet.nao(); BasisSet.nbf(); BasisSet.nprimitive(); BasisSet.nshell(); BasisSet.nshell_on_center(); BasisSet.print_detail_out(); BasisSet.print_out(); BasisSet.shell(); BasisSet.shell_on_center(); BasisSet.shell_to_ao_function(); BasisSet.shell_to_basis_function(); BasisSet.shell_to_center(); BasisSet.zero_ao_basis_set(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BasisSet.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:1927,Integrability,depend,depending,1927,"respond to. genbas(self); Returns basis set per atom in CFOUR format. has_ECP(self); Whether this basis set object has an ECP associated with it. has_puream(self); Spherical harmonics?. make_filename(arg0); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self); Returns maximum angular momentum used. max_function_per_shell(self); The max number of basis functions in a shell. max_nprimitive(self); The max number of primitives in a shell. molecule(self); Molecule object. move_atom(self,arg0,arg1); Translate a given atom by a given amount. n_ecp_core(*args,**kwargs); Overloaded function. n_ecp_shell_on_center(self,i); Return the number of ECP shells on a given center. n_frozen_core(self[,local,molecule]); Returns the number of orbital (non-ECP) frozen core electrons. name(self); Callback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it corr",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:2013,Integrability,contract,contractions,2013,"Whether this basis set object has an ECP associated with it. has_puream(self); Spherical harmonics?. make_filename(arg0); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self); Returns maximum angular momentum used. max_function_per_shell(self); The max number of basis functions in a shell. max_nprimitive(self); The max number of primitives in a shell. molecule(self); Molecule object. move_atom(self,arg0,arg1); Translate a given atom by a given amount. n_ecp_core(*args,**kwargs); Overloaded function. n_ecp_shell_on_center(self,i); Return the number of ECP shells on a given center. n_frozen_core(self[,local,molecule]); Returns the number of orbital (non-ECP) frozen core electrons. name(self); Callback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisna",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:2746,Integrability,contract,contraction,2746,"llback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely fr",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:7793,Integrability,depend,depending,7793,"oes not affect the underlying molecule object. n_ecp_core(*args, **kwargs); Overloaded function. n_ecp_core(self: psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_ecp_shell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of ECP shells on a given center. n_frozen_core(self: psi4.core.BasisSet, local: str = '', molecule: psi4.core.Molecule = None)  int; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet)  None; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith she",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:7906,Integrability,contract,contractions,7906,"psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_ecp_shell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of ECP shells on a given center. n_frozen_core(self: psi4.core.BasisSet, local: str = '', molecule: psi4.core.Molecule = None)  int; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet)  None; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:9144,Integrability,contract,contraction,9144,"ts detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int)  int; Return the atomic center for the ith shell. static zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. table of contents. BasisSet; BasisSet; BasisSet.ao_to_shell(); BasisSet.blend(); BasisSet.build(); BasisSet.compute_phi(); BasisSet.construct_from_pydict(); BasisSet.ecp_shell(); BasisSet.ecp_shell_on_center(); BasisSet.function_to_center(); BasisSet.function_to_shell(); BasisSet.genbas(); BasisSet.has_ECP(); BasisSet.has_puream(); BasisSet.make_filename(); BasisSet.max_am(); BasisSet.max_function_per_shell(); BasisSet.max_nprimitive(); BasisSet.molecule(); BasisSet.move_atom(); BasisSet.n_ecp_core(); BasisSet.n_ecp_shell_on_center(); BasisSet.n_frozen_core(); BasisSet.name(); BasisSet.nao(); BasisSet.nbf(); BasisSet.nprimitive(); BasisSet.nshell(); BasisSet.nshell_on_center(); BasisSet.print_detail_out(); BasisSet.print_out(); BasisSet.shell(); BasisSet.shell_on_center(); BasisSet.shell_to_ao_function(); BasisSet.shell_to_basis_function(); BasisSet.shell_to_center(); BasisSet.zero_ao_basis_set(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html:4102,Usability,simpl,simple,4102,"omlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from key in global options. If; a user-defined-basis callable is available at string target, target; value will be set to it. In practice, setting this argument to a; PSI4 keyword (e.g., core.get_option(""SCF"", ""DF_BASIS_SCF"") or; core.get_global_option(""BASIS"")) works to handle both simple and; user-defined bases.; fitrole (str)  {ORBITAL, JKFIT, RIFIT, DECON}; Role for which to build basis. Only used when key indicates auxiliary; (i.e., is not ""BASIS"") and auxiliary spec from processing target; cant complete the mol. Then, primary spec from other can be used; to complete the auxiliary basis by looking up suitable default basis; according to fitrole.; other (Union[str, Callable, None])  Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like target.; puream (int)  Whether to override the native spherical/cartesian-ness of target for; returned basis? Value 1 forces spherical, value 0 forces; Cartesian, value -1 (default) uses native puream. Note that; explicitly setting PUREAM trumps both native; puream and this puream argument.; return_atomlist (bool)  Build one-atom basis sets (e.g., for SAD) rather than one whole-mol; basis set.; quiet (bool)  When True, do not print to the output file. Ret",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html:592,Deployability,update,updated,592,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html:262,Integrability,rout,routines,262,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html:300,Integrability,rout,routine,300,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html:233,Testability,benchmark,benchmark,233,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html:592,Deployability,update,updated,592,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html:262,Integrability,rout,routines,262,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html:300,Integrability,rout,routine,300,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html:233,Testability,benchmark,benchmark,233,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html:621,Deployability,update,updated,621,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html:280,Integrability,rout,routines,280,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html:318,Integrability,rout,routine,318,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html:251,Testability,benchmark,benchmark,251,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html:582,Deployability,update,updated,582,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html:293,Integrability,rout,routine,293,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html:252,Performance,perform,performance,252,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html:229,Testability,benchmark,benchmark,229,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html:687,Deployability,update,updated,687,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html:248,Testability,benchmark,benchmark,248,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html:591,Deployability,update,updated,591,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html:302,Integrability,rout,routine,302,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html:215,Testability,benchmark,benchmark,215,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.be_quiet.html:523,Deployability,update,updated,523,". be_quiet. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; be_quiet. be_quiet. psi4.core.be_quiet()  None; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). Doesnt work with Windows. table of contents. be_quiet; be_quiet(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; be_quiet.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.be_quiet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.be_quiet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BlockOPoints.html:1747,Deployability,update,updated,1747,". BlockOPoints. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BlockOPoints. BlockOPoints. class psi4.core.BlockOPoints; Bases: pybind11_object; docstring; Methods Summary. functions_local_to_global(self); docstring. npoints(self); docstring. parent_atom(self); Returns the atom number this BlockOfPoints belongs to. print_out(self[,out_fname,print]); docstring. refresh(self); docstring. shells_local_to_global(self); docstring. w(self). x(self). y(self). z(self). Methods Documentation. functions_local_to_global(self: psi4.core.BlockOPoints)  List[int]; docstring. npoints(self: psi4.core.BlockOPoints)  int; docstring. parent_atom(self: psi4.core.BlockOPoints)  int; Returns the atom number this BlockOfPoints belongs to. print_out(self: psi4.core.BlockOPoints, out_fname: str = 'outfile', print: int = 2)  None; docstring. refresh(self: psi4.core.BlockOPoints)  None; docstring. shells_local_to_global(self: psi4.core.BlockOPoints)  List[int]; docstring. w(self: psi4.core.BlockOPoints)  psi4.core.Vector. x(self: psi4.core.BlockOPoints)  psi4.core.Vector. y(self: psi4.core.BlockOPoints)  psi4.core.Vector. z(self: psi4.core.BlockOPoints)  psi4.core.Vector. table of contents. BlockOPoints; BlockOPoints; BlockOPoints.functions_local_to_global(); BlockOPoints.npoints(); BlockOPoints.parent_atom(); BlockOPoints.print_out(); BlockOPoints.refresh(); BlockOPoints.shells_local_to_global(); BlockOPoints.w(); BlockOPoints.x(); BlockOPoints.y(); BlockOPoints.z(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BlockOPoints.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BlockOPoints.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BlockOPoints.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BoysLocalizer.html:488,Deployability,update,updated,488,". BoysLocalizer. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer. BoysLocalizer. class psi4.core.BoysLocalizer; Bases: Localizer; Performs Boys orbital localization. table of contents. BoysLocalizer; BoysLocalizer. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BoysLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BoysLocalizer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1694,Availability,error,error,1694,"i4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:2058,Deployability,update,updated,2058,"i4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:346,Modifiability,extend,extend,346,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:883,Modifiability,extend,extend,883,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:930,Modifiability,extend,extend,930,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1071,Modifiability,extend,extend,1071,"I4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1811,Modifiability,extend,extend,1811,"i4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:247,Usability,clear,clear,247,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:694,Usability,clear,clear,694,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1781,Usability,clear,clear,1781,"i4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccdensity.html:504,Deployability,update,updated,504,". ccdensity. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ccdensity. ccdensity. psi4.core.ccdensity(ref_wfn: psi4.core.CCWavefunction)  float; Runs the code to compute coupled cluster density matrices. table of contents. ccdensity; ccdensity(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ccdensity.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ccdensity.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccdensity.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccenergy.html:491,Deployability,update,updated,491,". ccenergy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ccenergy. ccenergy. psi4.core.ccenergy(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster energy code. table of contents. ccenergy; ccenergy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ccenergy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccenergy.html:242,Energy Efficiency,energy,energy,242,". ccenergy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ccenergy. ccenergy. psi4.core.ccenergy(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster energy code. table of contents. ccenergy; ccenergy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ccenergy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cceom.html:486,Deployability,update,updated,486,". cceom. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cceom. cceom. psi4.core.cceom(ref_wfn: psi4.core.CCWavefunction)  float; Runs the equation of motion coupled cluster code for excited states. table of contents. cceom; cceom(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cceom.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cceom.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cceom.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cchbar.html:487,Deployability,update,updated,487,". cchbar. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cchbar. cchbar. psi4.core.cchbar(ref_wfn: psi4.core.Wavefunction)  None; Runs the code to generate the similarity transformed Hamiltonian. table of contents. cchbar; cchbar(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cchbar.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cchbar.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cchbar.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cclambda.html:501,Deployability,update,updated,501,". cclambda. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cclambda. cclambda. psi4.core.cclambda(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster lambda equations code. table of contents. cclambda; cclambda(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cclambda.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cclambda.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cclambda.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccresponse.html:497,Deployability,update,updated,497,". ccresponse. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ccresponse. ccresponse. psi4.core.ccresponse(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster response theory code. table of contents. ccresponse; ccresponse(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ccresponse.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ccresponse.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ccresponse.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctransort.html:542,Deployability,update,updated,542,". cctransort. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cctransort. cctransort. psi4.core.cctransort(ref_wfn: psi4.core.Wavefunction)  None; Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. table of contents. cctransort; cctransort(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cctransort.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cctransort.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctransort.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctriples.html:485,Deployability,update,updated,485,". cctriples. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cctriples. cctriples. psi4.core.cctriples(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster (T) energy code. table of contents. cctriples; cctriples(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cctriples.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctriples.html:233,Energy Efficiency,energy,energy,233,". cctriples. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cctriples. cctriples. psi4.core.cctriples(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster (T) energy code. table of contents. cctriples; cctriples(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cctriples.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:1440,Availability,error,error,1440," 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:1991,Deployability,update,updated,1991," 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:432,Energy Efficiency,energy,energy-sorted,432,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:1144,Energy Efficiency,energy,energy,1144," 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:1639,Energy Efficiency,energy,energy-sorted,1639," 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:878,Integrability,depend,depending,878,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html:1339,Modifiability,variab,variable,1339," 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalc.html:1041,Deployability,update,updated,1041,". CdSalc. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CdSalc. CdSalc. class psi4.core.CdSalc; Bases: pybind11_object; Cartesian displacement SALC; Methods Summary. irrep(self); Return the irrep bit representation. irrep_index(self); Return the irrep index. print_out(self); Print the irrep index and the coordinates of the SALC of Cartesian displacements. Methods Documentation. irrep(self: psi4.core.CdSalc)  str; Return the irrep bit representation. irrep_index(self: psi4.core.CdSalc)  int; Return the irrep index. print_out(self: psi4.core.CdSalc)  None; Print the irrep index and the coordinates of the SALC of Cartesian displacements. Irrep index is 0-indexed and Cotton ordered. table of contents. CdSalc; CdSalc; CdSalc.irrep(); CdSalc.irrep_index(); CdSalc.print_out(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CdSalc.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CdSalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html:2025,Deployability,update,updated,2025,"++ and Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  List[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html:227,Energy Efficiency,adapt,adapted,227,". CdSalcList. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  List[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyright 2007-2023, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html:227,Modifiability,adapt,adapted,227,". CdSalcList. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  List[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyright 2007-2023, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CharacterTable.html:1203,Deployability,update,updated,1203,". CharacterTable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CharacterTable. CharacterTable. class psi4.core.CharacterTable; Bases: pybind11_object; Contains the character table of the point group; Methods Summary. gamma(self,arg0); Returns the irrep with the given index in the character table. order(self); Return the order of the point group. symm_operation(self,arg0); Return the i'th symmetry operation. Methods Documentation. gamma(self: psi4.core.CharacterTable, arg0: int)  psi4.core.IrreducibleRepresentation; Returns the irrep with the given index in the character table. order(self: psi4.core.CharacterTable)  int; Return the order of the point group. symm_operation(self: psi4.core.CharacterTable, arg0: int)  psi4.core.SymmetryOperation; Return the ith symmetry operation. 0-indexed. table of contents. CharacterTable; CharacterTable; CharacterTable.gamma(); CharacterTable.order(); CharacterTable.symm_operation(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CharacterTable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CharacterTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CharacterTable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIVector.html:2961,Deployability,update,updated,2961,"loat, arg1: psi4.core.CIVector, arg2: int, arg3: int)  None; docstring. close_io_files(self: psi4.core.CIVector, arg0: int)  None; docstring. copy(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int)  None; docstring. dcalc(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int)  float; docstring. divide(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: float, arg2: int, arg3: int)  None; docstring. init_io_files(self: psi4.core.CIVector, arg0: bool)  None; docstring. norm(self: psi4.core.CIVector, arg0: int)  float; docstring. read(self: psi4.core.CIVector, arg0: int, arg1: int)  int; docstring. scale(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. set_nvec(self: psi4.core.CIVector, arg0: int)  None; docstring. shift(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. symnormalize(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. vdot(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int)  float; docstring. vector_multiply(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: psi4.core.CIVector, arg3: int, arg4: int, arg5: int)  None; docstring. write(self: psi4.core.CIVector, arg0: int, arg1: int)  int; docstring. zero(self: psi4.core.CIVector)  None; docstring. table of contents. CIVector; CIVector; CIVector.np; CIVector.axpy(); CIVector.close_io_files(); CIVector.copy(); CIVector.dcalc(); CIVector.divide(); CIVector.init_io_files(); CIVector.norm(); CIVector.read(); CIVector.scale(); CIVector.set_nvec(); CIVector.shift(); CIVector.symnormalize(); CIVector.vdot(); CIVector.vector_multiply(); CIVector.write(); CIVector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CIVector.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CIVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIVector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIWavefunction.html:7641,Deployability,update,updated,7641,"(*args, **kwargs); Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. tpdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int)  List[psi4.core.Matrix]; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction)  None; Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool)  None; docstring. table of contents. CIWavefunction; CIWavefunction; CIWavefunction.D_vector(); CIWavefunction.Hd_vector(); CIWavefunction.ci_nat_orbs(); CIWavefunction.cleanup_ci(); CIWavefunction.cleanup_dpd(); CIWavefunction.compute_state_transfer(); CIWavefunction.diag_h(); CIWavefunction.form_opdm(); CIWavefunction.form_tpdm(); CIWavefunction.get_dimension(); CIWavefunction.get_opdm(); CIWavefunction.get_orbitals(); CIWavefunction.get_tpdm(); CIWavefunction.hamiltonian(); CIWavefunction.mcscf_object(); CIWavefunction.ndet(); CIWavefunction.new_civector(); CIWavefunction.opdm(); CIWavefunction.pitzer_to_ci_order_onel(); CIWavefunction.pitzer_to_ci_order_twoel(); CIWavefunction.print_vector(); CIWavefunction.reset_ci_H0block(); CIWavefunction.rotate_mcscf_integrals(); CIWavefunction.semicanonical_orbs(); CIWavefunction.set_ci_guess(); CIWavefunction.set_orbitals(); CIWavefunction.sigma(); CIWavefunction.tpdm(); CIWavefunction.transform_ci_integrals(); CIWavefunction.transform_mcscf_integrals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CIWavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CIWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIWavefunction.html:4039,Integrability,contract,contract,4039,"ulations.; Jroot (int)  The index of the root in the ket. Select -1 for the same as Iroot.; Always use -1 for single-state calculations.; spin (str)  {A, B, SUM}; Return the alpha density matrix, the beta density matrix, or their sum?; full_space (bool)  Return a density matrix in the space of all orbitals (true) or the active orbitals (false)?. Returns:; The selected one-particle density/transition matrix with Pitzer-ordered orbitals.; Irrep h of the matrix corresponds to orbitals of irrep h.; Element pq is <|a^p a_q|>. Return type:; Matrix. get_orbitals(self: psi4.core.CIWavefunction, arg0: str)  psi4.core.Matrix; docstring. get_tpdm(self: psi4.core.CIWavefunction, spin: str, symmetrize: bool)  psi4.core.Matrix; Returns the two-particle density matrix. Parameters:. spin (str)  {AA, AB, BB, SUM}; Which spin-block of the TPDM should be returned? SUM sums over all possible spin cases.; symmetrize (bool)  Return a genuine TPDM element (false) or an average of TPDM elements that contract with the same integral (true)?; Only working for SUM. Returns:; The two-particle density matrix with Pitzer-ordered orbitals, restricted to the active space.; If symmetrize is false, element pqrs is <|a^p a^r a_s a_q|>.; If symmetrize is true, element pqrs is obtained by summing over all flips of p/s, q/r, and multiplying by 0.5. Return type:; Matrix. hamiltonian(self: psi4.core.CIWavefunction, arg0: int)  psi4.core.Matrix; docstring. mcscf_object(self: psi4.core.CIWavefunction)  psi4.core.SOMCSCF; docstring. ndet(self: psi4.core.CIWavefunction)  int; docstring. new_civector(self: psi4.core.CIWavefunction, arg0: int, arg1: int, arg2: bool, arg3: bool)  psi4.core.CIVector; docstring. opdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int)  List[psi4.core.Matrix]; docstring. pitzer_to_ci_order_onel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector)  None; docstri",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CIWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CIWavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean.html:436,Deployability,update,updated,436,". clean. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; clean. clean. psi4.core.clean()  None; Remove scratch files. Call between independent jobs. table of contents. clean; clean(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; clean.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.clean.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_options.html:469,Deployability,update,updated,469,". clean_options. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; clean_options. clean_options. psi4.core.clean_options()  None; Reset options to clean state. table of contents. clean_options; clean_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; clean_options.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.clean_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_options.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_timers.html:544,Deployability,update,updated,544,". clean_timers. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; clean_timers. clean_timers. psi4.core.clean_timers()  None; Reinitialize timers for independent timer.dat entries. Vital when earlier independent calc finished improperly. table of contents. clean_timers; clean_timers(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; clean_timers.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.clean_timers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_timers.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_variables.html:532,Deployability,update,updated,532,". clean_variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; clean_variables. clean_variables. psi4.core.clean_variables()  None; Empties all double and Matrix QCVariables that have been set in global memory. table of contents. clean_variables; clean_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; clean_variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.clean_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.clean_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.close_outfile.html:463,Deployability,update,updated,463,". close_outfile. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; close_outfile. close_outfile. psi4.core.close_outfile()  None; Closes the output file. table of contents. close_outfile; close_outfile(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; close_outfile.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.close_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.close_outfile.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CompositeJK.html:819,Deployability,update,updated,819,". CompositeJK. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CompositeJK. CompositeJK. class psi4.core.CompositeJK; Bases: JK; docstring; Methods Summary. clear_D_prev(self); Clear previous D matrices. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. clear_D_prev(self: psi4.core.CompositeJK)  None; Clear previous D matrices. do_incfock_iter(self: psi4.core.CompositeJK)  bool; Was the last Fock build incremental?. table of contents. CompositeJK; CompositeJK; CompositeJK.clear_D_prev(); CompositeJK.do_incfock_iter(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CompositeJK.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CompositeJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CompositeJK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationFactor.html:772,Deployability,update,updated,772,". CorrelationFactor. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CorrelationFactor. CorrelationFactor. class psi4.core.CorrelationFactor; Bases: pybind11_object; docstring; Methods Summary. set_params(self,coeff,exponent); Set coefficient and exponent. Methods Documentation. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector)  None; Set coefficient and exponent. table of contents. CorrelationFactor; CorrelationFactor; CorrelationFactor.set_params(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CorrelationFactor.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CorrelationFactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationFactor.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html:2120,Deployability,update,updated,2120,"ses: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html:571,Energy Efficiency,reduce,reduced,571,". CorrelationTable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable. CorrelationTable. class psi4.core.CorrelationTable; Bases: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html:1373,Energy Efficiency,reduce,reduced,1373,"ses: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html:1793,Deployability,update,updated,1793,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html:533,Integrability,wrap,wrapper,533,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html:1183,Integrability,wrap,wrapper,1183,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.CUHF.html:1272,Deployability,update,updated,1272,". CUHF. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CUHF. CUHF. class psi4.core.CUHF; Bases: HF; docstring; Methods Summary. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock,...); docstring. diis(self,arg0); docstring. mintshelper(self); The MintsHelper object. Methods Documentation. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet)  psi4.core.CUHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, max_diis_vectors); docstring. Return type:; float. Parameters:. save_fock (bool)  ; max_diis_vectors (int)  . diis(self: psi4.core.HF, arg0: float)  bool; docstring. mintshelper(self: psi4.core.CUHF)  psi4.core.MintsHelper; The MintsHelper object. table of contents. CUHF; CUHF; CUHF.c1_deep_copy(); CUHF.compute_orbital_gradient(); CUHF.diis(); CUHF.mintshelper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; CUHF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.CUHF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.CUHF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DASUM.html:445,Deployability,update,updated,445,". DASUM. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DASUM. DASUM. psi4.core.DASUM(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  float; docstring. table of contents. DASUM; DASUM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DASUM.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DASUM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DASUM.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DAXPY.html:487,Deployability,update,updated,487,". DAXPY. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DAXPY. DAXPY. psi4.core.DAXPY(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int, arg5: psi::Vector, arg6: int)  None; docstring. table of contents. DAXPY; DAXPY(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DAXPY.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DAXPY.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DAXPY.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DCOPY.html:474,Deployability,update,updated,474,". DCOPY. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DCOPY. DCOPY. psi4.core.DCOPY(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  None; docstring. table of contents. DCOPY; DCOPY(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DCOPY.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DCOPY.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DCOPY.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dct.html:470,Deployability,update,updated,470,". dct. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dct. dct. psi4.core.dct(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density cumulant (functional) theory code. table of contents. dct; dct(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dct.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dct.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dct.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DDOT.html:468,Deployability,update,updated,468,". DDOT. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DDOT. DDOT. psi4.core.DDOT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  float; docstring. table of contents. DDOT; DDOT(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DDOT.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DDOT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DDOT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_array_variable.html:559,Deployability,update,updated,559,". del_array_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; del_array_variable. del_array_variable. psi4.core.del_array_variable(key: str)  None; Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). table of contents. del_array_variable; del_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; del_array_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.del_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_scalar_variable.html:566,Deployability,update,updated,566,". del_scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; del_scalar_variable. del_scalar_variable. psi4.core.del_scalar_variable(key: str)  None; Removes the double QCVariable key (case-insensitive); prefer del_variable(). table of contents. del_scalar_variable; del_scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; del_scalar_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.del_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_scalar_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_variable.html:607,Deployability,update,updated,607,". del_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; del_variable. del_variable. psi4.core.del_variable(key); Removes scalar or array QCVariable key; from global memory if present. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Return type:; None. table of contents. del_variable; del_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; del_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.del_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.del_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Deriv.html:1698,Deployability,update,updated,1698,". Deriv. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Deriv. Deriv. class psi4.core.Deriv; Bases: pybind11_object; Computes gradients of wavefunctions; Methods Summary. compute(self,deriv_calc_type); Compute the gradient. compute_df(self,arg0,arg1); Compute the density-fitted gradient. set_deriv_density_backtransformed(self[,val]); Is the deriv_density already backtransformed? Default is False. set_ignore_reference(self[,val]); Ignore reference contributions to the gradient? Default is False. set_tpdm_presorted(self[,val]); Is the TPDM already presorted? Default is False. Methods Documentation. compute(self: psi4.core.Deriv, deriv_calc_type: psi4.core.DerivCalcType = <DerivCalcType.Default: 0>)  psi4.core.Matrix; Compute the gradient. compute_df(self: psi4.core.Deriv, arg0: str, arg1: str)  psi4.core.Matrix; Compute the density-fitted gradient. set_deriv_density_backtransformed(self: psi4.core.Deriv, val: bool = False)  None; Is the deriv_density already backtransformed? Default is False. set_ignore_reference(self: psi4.core.Deriv, val: bool = False)  None; Ignore reference contributions to the gradient? Default is False. set_tpdm_presorted(self: psi4.core.Deriv, val: bool = False)  None; Is the TPDM already presorted? Default is False. table of contents. Deriv; Deriv; Deriv.compute(); Deriv.compute_df(); Deriv.set_deriv_density_backtransformed(); Deriv.set_ignore_reference(); Deriv.set_tpdm_presorted(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Deriv.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Deriv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Deriv.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DerivCalcType.html:841,Deployability,update,updated,841,". DerivCalcType. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. DerivCalcType. class psi4.core.DerivCalcType; Bases: pybind11_object; Members:; Default : Use internal logic.; Correlated : Correlated methods that write RDMs and Lagrangian to disk.; Attributes Summary. Correlated. Default. name. value. Attributes Documentation. Correlated = <DerivCalcType.Correlated: 1>. Default = <DerivCalcType.Default: 0>. name. value. table of contents. DerivCalcType; DerivCalcType; DerivCalcType.Correlated; DerivCalcType.Default; DerivCalcType.name; DerivCalcType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DerivCalcType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DerivCalcType.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DerivCalcType.html:242,Testability,log,logic,242,". DerivCalcType. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. DerivCalcType. class psi4.core.DerivCalcType; Bases: pybind11_object; Members:; Default : Use internal logic.; Correlated : Correlated methods that write RDMs and Lagrangian to disk.; Attributes Summary. Correlated. Default. name. value. Attributes Documentation. Correlated = <DerivCalcType.Correlated: 1>. Default = <DerivCalcType.Default: 0>. name. value. table of contents. DerivCalcType; DerivCalcType; DerivCalcType.Correlated; DerivCalcType.Default; DerivCalcType.name; DerivCalcType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DerivCalcType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DerivCalcType.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html:232,Deployability,configurat,configuration,232,". detci. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html:491,Deployability,update,updated,491,". detci. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html:232,Modifiability,config,configuration,232,". detci. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html:866,Deployability,update,updated,866,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]])  List[List[Tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html:357,Energy Efficiency,energy,energy,357,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]])  List[List[Tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html:545,Energy Efficiency,energy,energy,545,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]])  List[List[Tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFHelper.html:3477,Deployability,update,updated,3477,"verloaded function. get_tensor(self: psi4.core.DFHelper, arg0: str) -> psi4.core.Matrix; get_tensor(self: psi4.core.DFHelper, arg0: str, arg1: List[int], arg2: List[int], arg3: List[int]) -> psi4.core.Matrix. get_tensor_shape(self: psi4.core.DFHelper, arg0: str)  Tuple[int, int, int]. get_tensor_size(self: psi4.core.DFHelper, arg0: str)  int. hold_met(self: psi4.core.DFHelper, arg0: bool)  None. initialize(self: psi4.core.DFHelper)  None. print_header(self: psi4.core.DFHelper)  None. set_AO_core(self: psi4.core.DFHelper, arg0: bool)  None. set_MO_core(self: psi4.core.DFHelper, arg0: bool)  None. set_memory(self: psi4.core.DFHelper, arg0: int)  None. set_method(self: psi4.core.DFHelper, arg0: str)  None. set_nthreads(self: psi4.core.DFHelper, arg0: int)  None. set_schwarz_cutoff(self: psi4.core.DFHelper, arg0: float)  None. set_subalgo(self: psi4.core.DFHelper, arg0: str)  None. transform(self: psi4.core.DFHelper)  None. transpose(self: psi4.core.DFHelper, arg0: str, arg1: Tuple[int, int, int])  None. table of contents. DFHelper; DFHelper; DFHelper.add_space(); DFHelper.add_transformation(); DFHelper.clear_all(); DFHelper.clear_spaces(); DFHelper.get_AO_core(); DFHelper.get_AO_size(); DFHelper.get_MO_core(); DFHelper.get_memory(); DFHelper.get_method(); DFHelper.get_schwarz_cutoff(); DFHelper.get_space_size(); DFHelper.get_tensor(); DFHelper.get_tensor_shape(); DFHelper.get_tensor_size(); DFHelper.hold_met(); DFHelper.initialize(); DFHelper.print_header(); DFHelper.set_AO_core(); DFHelper.set_MO_core(); DFHelper.set_memory(); DFHelper.set_method(); DFHelper.set_nthreads(); DFHelper.set_schwarz_cutoff(); DFHelper.set_subalgo(); DFHelper.transform(); DFHelper.transpose(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFHelper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfmp2.html:454,Deployability,update,updated,454,". dfmp2. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dfmp2. dfmp2. psi4.core.dfmp2(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the DF-MP2 code. table of contents. dfmp2; dfmp2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dfmp2.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dfmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfmp2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfocc.html:484,Deployability,update,updated,484,". dfocc. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dfocc. dfocc. psi4.core.dfocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density-fitted orbital optimized CC codes. table of contents. dfocc; dfocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dfocc.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfocc.html:237,Performance,optimiz,optimized,237,". dfocc. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dfocc. dfocc. psi4.core.dfocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density-fitted orbital optimized CC codes. table of contents. dfocc; dfocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dfocc.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFSOMCSCF.html:433,Deployability,update,updated,433,". DFSOMCSCF. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFSOMCSCF. DFSOMCSCF. class psi4.core.DFSOMCSCF; Bases: SOMCSCF; docstring. table of contents. DFSOMCSCF; DFSOMCSCF. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFSOMCSCF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFSOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFSOMCSCF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFTensor.html:1180,Deployability,update,updated,1180,". DFTensor. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFTensor. DFTensor. class psi4.core.DFTensor; Bases: pybind11_object; docstring; Methods Summary. Idfmo(self); doctsring. Imo(self); doctsring. Qmo(self); doctsring. Qoo(self); doctsring. Qov(self); doctsring. Qso(self); doctsring. Qvv(self); doctsring. Methods Documentation. Idfmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Imo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qoo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qov(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qso(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qvv(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. table of contents. DFTensor; DFTensor; DFTensor.Idfmo(); DFTensor.Imo(); DFTensor.Qmo(); DFTensor.Qoo(); DFTensor.Qov(); DFTensor.Qso(); DFTensor.Qvv(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFTensor.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFTensor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFTensor.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFTGrid.html:784,Deployability,update,updated,784,". DFTGrid. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFTGrid. DFTGrid. class psi4.core.DFTGrid; Bases: MolecularGrid; docstring; Methods Summary. build(*args,**kwargs); Overloaded function. Methods Documentation. static build(*args, **kwargs); Overloaded function. build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet) -> psi4.core.DFTGrid; build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet, arg2: Dict[str, int], arg3: Dict[str, str]) -> psi4.core.DFTGrid. table of contents. DFTGrid; DFTGrid; DFTGrid.build(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DFTGrid.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DFTGrid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DFTGrid.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGBMV.html:578,Deployability,update,updated,578,". DGBMV. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGBMV. DGBMV. psi4.core.DGBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int, arg11: float, arg12: psi::Vector, arg13: int)  None; docstring. table of contents. DGBMV; DGBMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGBMV.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGBMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEEV.html:597,Deployability,update,updated,597,". DGEEV. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGEEV. DGEEV. psi4.core.DGEEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int, arg12: psi::Vector, arg13: int)  int; docstring. table of contents. DGEEV; DGEEV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGEEV.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGEEV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEEV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEMM.html:578,Deployability,update,updated,578,". DGEMM. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGEMM. DGEMM. psi4.core.DGEMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Matrix, arg10: int, arg11: float, arg12: psi::Matrix, arg13: int)  None; docstring. table of contents. DGEMM; DGEMM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGEMM.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGEMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEMM.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEMV.html:554,Deployability,update,updated,554,". DGEMV. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGEMV. DGEMV. psi4.core.DGEMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int)  None; docstring. table of contents. DGEMV; DGEMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGEMV.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGEMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGEMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGER.html:521,Deployability,update,updated,521,". DGER. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGER. DGER. psi4.core.DGER(arg0: int, arg1: int, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int)  None; docstring. table of contents. DGER; DGER(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGER.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGER.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGER.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRF.html:483,Deployability,update,updated,483,". DGETRF. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGETRF. DGETRF. psi4.core.DGETRF(arg0: int, arg1: int, arg2: int, arg3: psi::Matrix, arg4: int, arg5: psi::IntVector)  int; docstring. table of contents. DGETRF; DGETRF(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGETRF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGETRF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRI.html:502,Deployability,update,updated,502,". DGETRI. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGETRI. DGETRI. psi4.core.DGETRI(arg0: int, arg1: int, arg2: psi::Matrix, arg3: int, arg4: psi::IntVector, arg5: psi::Vector, arg6: int)  int; docstring. table of contents. DGETRI; DGETRI(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGETRI.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGETRI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRI.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRS.html:524,Deployability,update,updated,524,". DGETRS. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGETRS. DGETRS. psi4.core.DGETRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int)  int; docstring. table of contents. DGETRS; DGETRS(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DGETRS.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DGETRS.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DGETRS.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DiagonalizeOrder.html:862,Deployability,update,updated,862,". DiagonalizeOrder. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DiagonalizeOrder. DiagonalizeOrder. class psi4.core.DiagonalizeOrder; Bases: pybind11_object; Defines ordering of eigenvalues after diagonalization; Members:. Ascending; Descending. Attributes Summary. Ascending. Descending. name. value. Attributes Documentation. Ascending = <DiagonalizeOrder.Ascending: 1>. Descending = <DiagonalizeOrder.Descending: 3>. name. value. table of contents. DiagonalizeOrder; DiagonalizeOrder; DiagonalizeOrder.Ascending; DiagonalizeOrder.Descending; DiagonalizeOrder.name; DiagonalizeOrder.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DiagonalizeOrder.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DiagonalizeOrder.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DiagonalizeOrder.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Dimension.html:2705,Deployability,update,updated,2705,"ibutes Documentation. name; The name of the dimension. Used in printing. Methods Documentation. fill(self: psi4.core.Dimension, val: int)  None; Fill all elements with given value. classmethod from_list(dims, name='New Dimension'); Builds a Dimension object from a Python list or tuple. If a; Dimension object is passed, a copy will be returned. Parameters:. dims (Union[Tuple[int], List[int], ndarray, Dimension])  Iterable of integers defining irrep dimensions.; name  Name for new instance. Return type:; Dimension. init(self: psi4.core.Dimension, arg0: int, arg1: str)  None; Re-initializes the dimension object. max(*args, **kwargs); Overloaded function. max(self: psi4.core.Dimension) -> int. Gets the maximum value from the dimension object. max(self: psi4.core.Dimension) -> int. Return the maximum element. n(self: psi4.core.Dimension)  int; The order of the dimension. print_out(self: psi4.core.Dimension)  None; Print out the dimension object to the output file. sum(*args, **kwargs); Overloaded function. sum(self: psi4.core.Dimension) -> int. Gets the sum of the values in the dimension object. sum(self: psi4.core.Dimension) -> int. Return the sum of constituent dimensions. to_tuple(); Serializes Dimension to a tuple. Return type:; Tuple[int]. Parameters:; self (Dimension)  . zero(*args, **kwargs); Overloaded function. zero(self: psi4.core.Dimension) -> None. Zeros all values in the dimension object. zero(self: psi4.core.Dimension) -> None. Zero all elements. table of contents. Dimension; Dimension; Dimension.name; Dimension.fill(); Dimension.from_list(); Dimension.init(); Dimension.max(); Dimension.n(); Dimension.print_out(); Dimension.sum(); Dimension.to_tuple(); Dimension.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Dimension.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Dimension.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Dimension.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DipoleInt.html:454,Deployability,update,updated,454,". DipoleInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DipoleInt. DipoleInt. class psi4.core.DipoleInt; Bases: OneBodyAOInt; Computes dipole integrals. table of contents. DipoleInt; DipoleInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DipoleInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DipoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DipoleInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DirectJK.html:639,Deployability,update,updated,639,". DirectJK. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DirectJK. DirectJK. class psi4.core.DirectJK; Bases: JK; docstring; Methods Summary. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. do_incfock_iter(self: psi4.core.DirectJK)  bool; Was the last Fock build incremental?. table of contents. DirectJK; DirectJK; DirectJK.do_incfock_iter(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DirectJK.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DirectJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DirectJK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DiskSOMCSCF.html:447,Deployability,update,updated,447,". DiskSOMCSCF. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DiskSOMCSCF. DiskSOMCSCF. class psi4.core.DiskSOMCSCF; Bases: SOMCSCF; docstring. table of contents. DiskSOMCSCF; DiskSOMCSCF. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DiskSOMCSCF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DiskSOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DiskSOMCSCF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Dispersion.html:3509,Deployability,update,updated,3509," compute_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  psi4.core.Matrix; docstring. compute_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  psi4.core.Matrix; docstring. d(self: psi4.core.Dispersion)  float; docstring. description(self: psi4.core.Dispersion)  str; docstring. name(self: psi4.core.Dispersion)  str; docstring. print_energy(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_out(self: psi4.core.Dispersion)  None; docstring. s6(self: psi4.core.Dispersion)  float; docstring. s8(self: psi4.core.Dispersion)  float; docstring. set_bibtex(self: psi4.core.Dispersion, arg0: str)  None; Set the BibTeX key for the literature reference. set_citation(self: psi4.core.Dispersion, arg0: str)  None; docstring. set_description(self: psi4.core.Dispersion, arg0: str)  None; docstring. set_name(self: psi4.core.Dispersion, arg0: str)  None; docstring. sr6(self: psi4.core.Dispersion)  float; docstring. table of contents. Dispersion; Dispersion; Dispersion.a1(); Dispersion.a2(); Dispersion.bibtex(); Dispersion.build(); Dispersion.citation(); Dispersion.compute_energy(); Dispersion.compute_gradient(); Dispersion.compute_hessian(); Dispersion.d(); Dispersion.description(); Dispersion.name(); Dispersion.print_energy(); Dispersion.print_gradient(); Dispersion.print_hessian(); Dispersion.print_out(); Dispersion.s6(); Dispersion.s8(); Dispersion.set_bibtex(); Dispersion.set_citation(); Dispersion.set_description(); Dispersion.set_name(); Dispersion.sr6(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Dispersion.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Dispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dlpno.html:451,Deployability,update,updated,451,". dlpno. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dlpno. dlpno. psi4.core.dlpno(arg0: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the DLPNO codes. table of contents. dlpno; dlpno(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dlpno.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dlpno.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dlpno.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dmrg.html:446,Deployability,update,updated,446,". dmrg. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dmrg. dmrg. psi4.core.dmrg(ref_wfn: psi4.core.Wavefunction)  float; Runs the CheMPS2 interface DMRG code. table of contents. dmrg; dmrg(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dmrg.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dmrg.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dmrg.html:201,Integrability,interface,interface,201,". dmrg. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dmrg. dmrg. psi4.core.dmrg(ref_wfn: psi4.core.Wavefunction)  float; Runs the CheMPS2 interface DMRG code. table of contents. dmrg; dmrg(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dmrg.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dmrg.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DNRM2.html:445,Deployability,update,updated,445,". DNRM2. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DNRM2. DNRM2. psi4.core.DNRM2(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  float; docstring. table of contents. DNRM2; DNRM2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DNRM2.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DNRM2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DNRM2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.doublet.html:588,Deployability,update,updated,588,". doublet. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; doublet. doublet. psi4.core.doublet(A: psi4.core.Matrix, B: psi4.core.Matrix, transA: bool = False, transB: bool = False)  psi4.core.Matrix; Returns the multiplication of two matrices A and B, with options to transpose each beforehand. table of contents. doublet; doublet(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; doublet.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.doublet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.doublet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dpdbuf4.html:1121,Deployability,update,updated,1121,". dpdbuf4. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dpdbuf4. dpdbuf4. class psi4.core.dpdbuf4; Bases: pybind11_object; docstring; Methods Summary. axpy_matrix(self,arg0,arg1); Add 'a' times a Matrix to this. coldim(self); Return the dimensions of the column index. rowdim(self); Return the dimensions of the row index. zero(self); Fill all with entries. Methods Documentation. axpy_matrix(self: psi4.core.dpdbuf4, arg0: psi4.core.Matrix, arg1: float)  int; Add a times a Matrix to this. coldim(self: psi4.core.dpdbuf4)  psi4.core.Dimension; Return the dimensions of the column index. rowdim(self: psi4.core.dpdbuf4)  psi4.core.Dimension; Return the dimensions of the row index. zero(self: psi4.core.dpdbuf4)  int; Fill all with entries. table of contents. dpdbuf4; dpdbuf4; dpdbuf4.axpy_matrix(); dpdbuf4.coldim(); dpdbuf4.rowdim(); dpdbuf4.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dpdbuf4.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dpdbuf4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dpdbuf4.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.dpdfile2.html:1150,Deployability,update,updated,1150,". dpdfile2. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dpdfile2. dpdfile2. class psi4.core.dpdfile2; Bases: pybind11_object; docstring; Methods Summary. axpy_matrix(self,arg0,arg1); Add 'a' times a Matrix to this. coldim(self); Return the dimensions of the column index. rowdim(self); Return the dimensions of the row index. zero(self); Fill all entries with zeroes. Methods Documentation. axpy_matrix(self: psi4.core.dpdfile2, arg0: psi4.core.Matrix, arg1: float)  int; Add a times a Matrix to this. coldim(self: psi4.core.dpdfile2)  psi4.core.Dimension; Return the dimensions of the column index. rowdim(self: psi4.core.dpdfile2)  psi4.core.Dimension; Return the dimensions of the row index. zero(self: psi4.core.dpdfile2)  int; Fill all entries with zeroes. table of contents. dpdfile2; dpdfile2; dpdfile2.axpy_matrix(); dpdfile2.coldim(); dpdfile2.rowdim(); dpdfile2.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dpdfile2.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.dpdfile2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.dpdfile2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRF.html:461,Deployability,update,updated,461,". DPOTRF. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DPOTRF. DPOTRF. psi4.core.DPOTRF(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int)  int; docstring. table of contents. DPOTRF; DPOTRF(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DPOTRF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DPOTRF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRI.html:461,Deployability,update,updated,461,". DPOTRI. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DPOTRI. DPOTRI. psi4.core.DPOTRI(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int)  int; docstring. table of contents. DPOTRI; DPOTRI(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DPOTRI.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DPOTRI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRI.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRS.html:502,Deployability,update,updated,502,". DPOTRS. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DPOTRS. DPOTRS. psi4.core.DPOTRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Matrix, arg7: int)  int; docstring. table of contents. DPOTRS; DPOTRS(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DPOTRS.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DPOTRS.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DPOTRS.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DROT.html:493,Deployability,update,updated,493,". DROT. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DROT. DROT. psi4.core.DROT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int, arg6: float, arg7: float)  None; docstring. table of contents. DROT; DROT(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DROT.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DROT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DROT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSBMV.html:554,Deployability,update,updated,554,". DSBMV. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSBMV. DSBMV. psi4.core.DSBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int)  None; docstring. table of contents. DSBMV; DSBMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSBMV.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSBMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSCAL.html:457,Deployability,update,updated,457,". DSCAL. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSCAL. DSCAL. psi4.core.DSCAL(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int)  None; docstring. table of contents. DSCAL; DSCAL(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSCAL.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSCAL.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSCAL.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSWAP.html:474,Deployability,update,updated,474,". DSWAP. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSWAP. DSWAP. psi4.core.DSWAP(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  None; docstring. table of contents. DSWAP; DSWAP(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSWAP.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSWAP.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSWAP.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYEV.html:514,Deployability,update,updated,514,". DSYEV. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYEV. DSYEV. psi4.core.DSYEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: int)  int; docstring. table of contents. DSYEV; DSYEV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYEV.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYEV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYEV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYMM.html:566,Deployability,update,updated,566,". DSYMM. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYMM. DSYMM. psi4.core.DSYMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int)  None; docstring. table of contents. DSYMM; DSYMM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYMM.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYMM.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYMV.html:542,Deployability,update,updated,542,". DSYMV. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYMV. DSYMV. psi4.core.DSYMV(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: int, arg8: float, arg9: psi::Vector, arg10: int)  None; docstring. table of contents. DSYMV; DSYMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYMV.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR.html:491,Deployability,update,updated,491,". DSYR. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYR. DSYR. psi4.core.DSYR(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Matrix, arg7: int)  None; docstring. table of contents. DSYR; DSYR(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYR.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYR.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR2.html:528,Deployability,update,updated,528,". DSYR2. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYR2. DSYR2. psi4.core.DSYR2(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int)  None; docstring. table of contents. DSYR2; DSYR2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYR2.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYR2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR2.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR2K.html:573,Deployability,update,updated,573,". DSYR2K. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYR2K. DSYR2K. psi4.core.DSYR2K(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int)  None; docstring. table of contents. DSYR2K; DSYR2K(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYR2K.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYR2K.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYR2K.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYRK.html:534,Deployability,update,updated,534,". DSYRK. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYRK. DSYRK. psi4.core.DSYRK(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: float, arg9: psi::Matrix, arg10: int)  None; docstring. table of contents. DSYRK; DSYRK(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYRK.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYRK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYRK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYSV.html:548,Deployability,update,updated,548,". DSYSV. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYSV. DSYSV. psi4.core.DSYSV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int)  int; docstring. table of contents. DSYSV; DSYSV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DSYSV.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DSYSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DSYSV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTBMV.html:518,Deployability,update,updated,518,". DTBMV. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTBMV. DTBMV. psi4.core.DTBMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int)  None; docstring. table of contents. DTBMV; DTBMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTBMV.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTBMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTBSV.html:518,Deployability,update,updated,518,". DTBSV. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTBSV. DTBSV. psi4.core.DTBSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int)  None; docstring. table of contents. DTBSV; DTBSV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTBSV.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTBSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTBSV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRMM.html:544,Deployability,update,updated,544,". DTRMM. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTRMM. DTRMM. psi4.core.DTRMM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int)  None; docstring. table of contents. DTRMM; DTRMM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTRMM.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTRMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRMM.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRMV.html:507,Deployability,update,updated,507,". DTRMV. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTRMV. DTRMV. psi4.core.DTRMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int)  None; docstring. table of contents. DTRMV; DTRMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTRMV.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTRMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRMV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRSM.html:544,Deployability,update,updated,544,". DTRSM. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTRSM. DTRSM. psi4.core.DTRSM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int)  None; docstring. table of contents. DTRSM; DTRSM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTRSM.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTRSM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRSM.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRSV.html:507,Deployability,update,updated,507,". DTRSV. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTRSV. DTRSV. psi4.core.DTRSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int)  None; docstring. table of contents. DTRSV; DTRSV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; DTRSV.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.DTRSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.DTRSV.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ElectricFieldInt.html:511,Deployability,update,updated,511,". ElectricFieldInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ElectricFieldInt. ElectricFieldInt. class psi4.core.ElectricFieldInt; Bases: OneBodyAOInt; Computes electric field integrals. table of contents. ElectricFieldInt; ElectricFieldInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ElectricFieldInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ElectricFieldInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ElectricFieldInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ElectrostaticInt.html:510,Deployability,update,updated,510,". ElectrostaticInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ElectrostaticInt. ElectrostaticInt. class psi4.core.ElectrostaticInt; Bases: OneBodyAOInt; Computes electrostatic integrals. table of contents. ElectrostaticInt; ElectrostaticInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ElectrostaticInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ElectrostaticInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ElectrostaticInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ERI.html:435,Deployability,update,updated,435,". ERI. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ERI. ERI. class psi4.core.ERI; Bases: TwoBodyAOInt; Computes normal two electron repulsion integrals. table of contents. ERI; ERI. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ERI.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ERI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ERI.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ERISieve.html:1619,Deployability,update,updated,1619,". ERISieve. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ERISieve. ERISieve. class psi4.core.ERISieve; Bases: pybind11_object; docstring; Methods Summary. build(orbital_basis[,cutoff,do_csam]); Constructs a Psi4 ERISieve object from an input basis set, with an optional cutoff threshold for ERI screening and an optional input to enable CSAM screening (over Schwarz screening). shell_significant(self,arg0,arg1,arg2,arg3). Methods Documentation. static build(orbital_basis, cutoff=0.0, do_csam=False); Constructs a Psi4 ERISieve object from an input basis set, with an optional cutoff threshold for; ERI screening and an optional input to enable CSAM screening (over Schwarz screening). Parameters:. orbital_basis (BasisSet)  Basis set to use in the ERISieve object.; cutoff (float)  Integral cutoff threshold to use for Schwarz/CSAM screening. Defaults to 0.0, disabling screening entirely.; do_csam (bool)  Use CSAM screening? If True, CSAM screening is used; else, Schwarz screening is used. By default,; Schwarz screening is utilized. Returns:; Initialized ERISieve object. Return type:; ERISieve. Example; >>> sieve = psi4.core.ERISieve.build(bas, cutoff, csam). shell_significant(self: psi4.core.ERISieve, arg0: int, arg1: int, arg2: int, arg3: int)  bool. table of contents. ERISieve; ERISieve; ERISieve.build(); ERISieve.shell_significant(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ERISieve.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ERISieve.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ERISieve.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html:1163,Deployability,update,updated,1163,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html:218,Integrability,rout,routines,218,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html:208,Security,access,access,208,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:3110,Deployability,update,updated,3110,"fs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:435,Energy Efficiency,charge,charge,435,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:502,Energy Efficiency,charge,charge,502,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:816,Energy Efficiency,energy,energy,816,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:982,Energy Efficiency,charge,charge,982,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:1379,Energy Efficiency,charge,charge,1379," of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.Exte",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:1524,Energy Efficiency,charge,charge,1524,"of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. tabl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:2000,Energy Efficiency,energy,energy,2000,"f charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:2307,Energy Efficiency,charge,charge,2307,"fs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:548,Usability,clear,clear,548,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:1570,Usability,clear,clear,1570,"o zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasi",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:2667,Usability,clear,clear,2667,"fs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FCHKWriter.html:1104,Deployability,update,updated,1104,". FCHKWriter. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; FCHKWriter. FCHKWriter. class psi4.core.FCHKWriter; Bases: pybind11_object; Extracts information from a wavefunction object, and writes it to an FCHK file; Methods Summary. SCF_Dtot(self). set_postscf_density_label(self,label); Set base label for post-SCF density, e.g. ' CC Density'. write(self,filename); Write wavefunction information to file. Methods Documentation. SCF_Dtot(self: psi4.core.FCHKWriter)  psi4.core.Matrix. set_postscf_density_label(self: psi4.core.FCHKWriter, label: str)  None; Set base label for post-SCF density, e.g.  CC Density. write(self: psi4.core.FCHKWriter, filename: str)  None; Write wavefunction information to file. table of contents. FCHKWriter; FCHKWriter; FCHKWriter.SCF_Dtot(); FCHKWriter.set_postscf_density_label(); FCHKWriter.write(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; FCHKWriter.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FCHKWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FCHKWriter.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.fcidump_tei_helper.html:619,Deployability,update,updated,619,". fcidump_tei_helper. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump_tei_helper. fcidump_tei_helper. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str = 'INTDUMP')  None; Write integrals to file in FCIDUMP format. table of contents. fcidump_tei_helper; fcidump_tei_helper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump_tei_helper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.fcidump_tei_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.fcidump_tei_helper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FDDS_Dispersion.html:2856,Deployability,update,updated,2856,"y AO to auxiliary AO space. Methods Documentation. R_A(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains (R^t)^-1 for monomer A. R_B(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains (R^t)^-1 for monomer B. aux_overlap(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS aux_overlap. form_aux_matrices(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float)  Dict[str, psi4.core.Matrix]; Forms the uncoupled amplitudes and other matrices for either monomer. form_unc_amplitude(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float)  psi4.core.Matrix; Forms the uncoupled amplitudes for either monomer. get_tensor_pqQ(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: Tuple[int, int, int])  psi4.core.Matrix; Debug only: fetches 3-index intermediate from disk and return as matrix. metric(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS metric. metric_inv(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS metric_inv. print_tensor_pqQ(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: str, arg2: Tuple[int, int, int])  None; Debug only: prints formatted 3-index intermediate to file. project_densities(self: psi4.core.FDDS_Dispersion, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; Projects a density from the primary AO to auxiliary AO space. table of contents. FDDS_Dispersion; FDDS_Dispersion; FDDS_Dispersion.R_A(); FDDS_Dispersion.R_B(); FDDS_Dispersion.aux_overlap(); FDDS_Dispersion.form_aux_matrices(); FDDS_Dispersion.form_unc_amplitude(); FDDS_Dispersion.get_tensor_pqQ(); FDDS_Dispersion.metric(); FDDS_Dispersion.metric_inv(); FDDS_Dispersion.print_tensor_pqQ(); FDDS_Dispersion.project_densities(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; FDDS_Dispersion.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FDDS_Dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FDDS_Dispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.finalize.html:459,Deployability,update,updated,459,". finalize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; finalize. finalize. psi4.core.finalize()  None; Called upon psi4 module exit to closes timers and I/O. table of contents. finalize; finalize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; finalize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.finalize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.finalize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:5432,Deployability,update,updated,5432,"ion energies. overlap(self: psi4.core.FISAPT)  None; Build the overlap integrals S. partition(self: psi4.core.FISAPT)  None; Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self: psi4.core.FISAPT)  None; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT)  None; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str)  None; Plot some analysis files. scalars(self: psi4.core.FISAPT)  Dict[str, float]; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT)  None; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT)  None; Produce unified matrices for A, B, and C. unify_part2(self: psi4.core.FISAPT)  None; Finish producing unified matrices for A, B, and C. vectors(self: psi4.core.FISAPT)  Dict[str, psi4.core.Vector]; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.compute_energy(); FISAPT.coulomb(); FISAPT.dHF(); FISAPT.disp(); FISAPT.do_cubes(); FISAPT.elst(); FISAPT.exch(); FISAPT.fdisp(); FISAPT.fdrop(); FISAPT.felst(); FISAPT.fexch(); FISAPT.find(); FISAPT.flocalize(); FISAPT.freeze_core(); FISAPT.ind(); FISAPT.kinetic(); FISAPT.localize(); FISAPT.matrices(); FISAPT.molecule(); FISAPT.nuclear(); FISAPT.overlap(); FISAPT.partition(); FISAPT.plot(); FISAPT.print_header(); FISAPT.print_trailer(); FISAPT.raw_plot(); FISAPT.scalars(); FISAPT.scf(); FISAPT.sinf_disp(); FISAPT.unify(); FISAPT.unify_part2(); FISAPT.vectors(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; FISAPT.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:286,Energy Efficiency,energy,energy,286,". FISAPT. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; FISAPT. FISAPT. class psi4.core.FISAPT; Bases: pybind11_object; A Fragment-SAPT Wavefunction; Methods Summary. compute_energy([external_potentials]); Computes the FSAPT energy. coulomb(self); Build the J/K potentials for C, D, and E. dHF(self); SAPT0 delta HF. disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self); Prepare cube files for orbital/density pictures. elst(self); SAPT0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. fdrop([external_potentials]); Drop output files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT ene",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:456,Energy Efficiency,energy,energy,456,". FISAPT. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; FISAPT. FISAPT. class psi4.core.FISAPT; Bases: pybind11_object; A Fragment-SAPT Wavefunction; Methods Summary. compute_energy([external_potentials]); Computes the FSAPT energy. coulomb(self); Build the J/K potentials for C, D, and E. dHF(self); SAPT0 delta HF. disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self); Prepare cube files for orbital/density pictures. elst(self); SAPT0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. fdrop([external_potentials]); Drop output files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT ene",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:1695,Energy Efficiency,energy,energy,1695,"put files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT)  None; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT)  None; SAPT0 electrostatics. exch(self: psi4.core.FISAPT)  None; SAPT0 exchange. fdisp(self: psi4.core.FISAPT)  None; F-SAPT0 dispersion. fdrop(external_potentials=None); Drop output files from ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:1998,Energy Efficiency,energy,energy,1998,"ize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT)  None; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT)  None; SAPT0 electrostatics. exch(self: psi4.core.FISAPT)  None; SAPT0 exchange. fdisp(self: psi4.core.FISAPT)  None; F-SAPT0 dispersion. fdrop(external_potentials=None); Drop output files from FSAPT calculation. FISAPT::fdrop. felst(self: psi4.core.FISAPT)  None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT)  None; F-SAPT0 exchange. find(self: psi4.core.FISAPT)  None; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT)  None; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:2334,Energy Efficiency,energy,energy,2334,". plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT)  None; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT)  None; SAPT0 electrostatics. exch(self: psi4.core.FISAPT)  None; SAPT0 exchange. fdisp(self: psi4.core.FISAPT)  None; F-SAPT0 dispersion. fdrop(external_potentials=None); Drop output files from FSAPT calculation. FISAPT::fdrop. felst(self: psi4.core.FISAPT)  None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT)  None; F-SAPT0 exchange. find(self: psi4.core.FISAPT)  None; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT)  None; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)  None; Freeze the core orbitals. ind(self: psi4.core.FISAPT)  None; SAPT0 induction. kinetic(self: psi4.core.FISAPT)  None; Build the kinetic integrals T. localize(self: psi4.core.FISAPT)  None; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT)  Dict[str, psi4.core.Matrix]; Return the i",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:4309,Energy Efficiency,energy,energy,4309,"trix]; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT)  psi4.core.Molecule; Returns the FISAPTs molecule. nuclear(self: psi4.core.FISAPT)  None; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT)  None; Build the overlap integrals S. partition(self: psi4.core.FISAPT)  None; Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self: psi4.core.FISAPT)  None; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT)  None; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str)  None; Plot some analysis files. scalars(self: psi4.core.FISAPT)  Dict[str, float]; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT)  None; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT)  None; Produce unified matrices for A, B, and C. unify_part2(self: psi4.core.FISAPT)  None; Finish producing unified matrices for A, B, and C. vectors(self: psi4.core.FISAPT)  Dict[str, psi4.core.Vector]; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.compute_energy(); FISAPT.coulomb(); FISAPT.dHF(); FISAPT.disp(); FISAPT.do_cubes(); FISAPT.elst(); FISAPT.exch(); FISAPT.fdisp(); FISAPT.fdrop(); FISAPT.felst(); FISAPT.fexch(); FISAPT.find(); FISAPT.flocalize(); FISAPT.freeze_core(); FISAPT.ind(); FISAPT.kinetic(); FISAPT.localize(); FISAPT.matrices(); FISAPT.molecule(); FISAPT.nuclear(); FISAPT.overlap(); FISAPT.partition(); FISAPT.plot(); FISAPT.print_header(); FISAPT.print_trailer(); FISAPT.raw_plot(); FISAPT.scalars(); FISAPT.scf(); FISAPT.sinf_disp(); FISAPT.unify(); FISAPT.unify_part2(); FISAPT.vectors(). ; hide menu. menu; sidebar; ; . Navigat",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:1319,Integrability,wrap,wrapper,1319,"K potentials for C, D, and E. dHF(self); SAPT0 delta HF. disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self); Prepare cube files for orbital/density pictures. elst(self); SAPT0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. fdrop([external_potentials]); Drop output files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and E",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html:3696,Integrability,wrap,wrapper,3696,"elst(self: psi4.core.FISAPT)  None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT)  None; F-SAPT0 exchange. find(self: psi4.core.FISAPT)  None; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT)  None; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)  None; Freeze the core orbitals. ind(self: psi4.core.FISAPT)  None; SAPT0 induction. kinetic(self: psi4.core.FISAPT)  None; Build the kinetic integrals T. localize(self: psi4.core.FISAPT)  None; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT)  Dict[str, psi4.core.Matrix]; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT)  psi4.core.Molecule; Returns the FISAPTs molecule. nuclear(self: psi4.core.FISAPT)  None; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT)  None; Build the overlap integrals S. partition(self: psi4.core.FISAPT)  None; Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self: psi4.core.FISAPT)  None; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT)  None; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str)  None; Plot some analysis files. scalars(self: psi4.core.FISAPT)  Dict[str, float]; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT)  None; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT)  None; Produce unified matrices for A, B, and C. unify_part2(self: psi4.core.FISAPT)  None; Finish producing unified matrices for A, B, and C. vectors(self: psi4.core.FISAPT)  Dict[str, psi4.core.Vector]; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.compute_energy(); FISAPT.cou",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FittedSlaterCorrelationFactor.html:747,Deployability,update,updated,747,". FittedSlaterCorrelationFactor. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; FittedSlaterCorrelationFactor. FittedSlaterCorrelationFactor. class psi4.core.FittedSlaterCorrelationFactor; Bases: CorrelationFactor; docstring; Methods Summary. exponent(self). Methods Documentation. exponent(self: psi4.core.FittedSlaterCorrelationFactor)  float. table of contents. FittedSlaterCorrelationFactor; FittedSlaterCorrelationFactor; FittedSlaterCorrelationFactor.exponent(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; FittedSlaterCorrelationFactor.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FittedSlaterCorrelationFactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FittedSlaterCorrelationFactor.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FittingMetric.html:2047,Deployability,update,updated,2047,"ingMetric. FittingMetric. class psi4.core.FittingMetric; Bases: pybind11_object; docstring; Methods Summary. form_QR_inverse(self,arg0); docstring. form_cholesky_inverse(self); docstring. form_eig_inverse(self,arg0); docstring. form_fitting_metric(self); docstring. form_full_inverse(self); docstring. get_algorithm(self); docstring. get_metric(self); docstring. get_pivots(self); docstring. get_reverse_pivots(self); docstring. is_inverted(self); docstring. is_poisson(self); docstring. Methods Documentation. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric)  None; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_fitting_metric(self: psi4.core.FittingMetric)  None; docstring. form_full_inverse(self: psi4.core.FittingMetric)  None; docstring. get_algorithm(self: psi4.core.FittingMetric)  str; docstring. get_metric(self: psi4.core.FittingMetric)  psi4.core.Matrix; docstring. get_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. get_reverse_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. is_inverted(self: psi4.core.FittingMetric)  bool; docstring. is_poisson(self: psi4.core.FittingMetric)  bool; docstring. table of contents. FittingMetric; FittingMetric; FittingMetric.form_QR_inverse(); FittingMetric.form_cholesky_inverse(); FittingMetric.form_eig_inverse(); FittingMetric.form_fitting_metric(); FittingMetric.form_full_inverse(); FittingMetric.get_algorithm(); FittingMetric.get_metric(); FittingMetric.get_pivots(); FittingMetric.get_reverse_pivots(); FittingMetric.is_inverted(); FittingMetric.is_poisson(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; FittingMetric.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FittingMetric.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FittingMetric.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.flush_outfile.html:464,Deployability,update,updated,464,". flush_outfile. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; flush_outfile. flush_outfile. psi4.core.flush_outfile()  None; Flushes the output file. table of contents. flush_outfile; flush_outfile(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; flush_outfile.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.flush_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.flush_outfile.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.fnocc.html:484,Deployability,update,updated,484,". fnocc. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fnocc. fnocc. psi4.core.fnocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. table of contents. fnocc; fnocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fnocc.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.fnocc.html:244,Energy Efficiency,energy,energy,244,". fnocc. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fnocc. fnocc. psi4.core.fnocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. table of contents. fnocc; fnocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fnocc.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.FragmentType.html:806,Deployability,update,updated,806,". FragmentType. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; FragmentType. FragmentType. class psi4.core.FragmentType; Bases: pybind11_object; Fragment activation status; Members:. Absent; Real; Ghost. Attributes Summary. Absent. Ghost. Real. name. value. Attributes Documentation. Absent = <FragmentType.Absent: 0>. Ghost = <FragmentType.Ghost: 2>. Real = <FragmentType.Real: 1>. name. value. table of contents. FragmentType; FragmentType; FragmentType.Absent; FragmentType.Ghost; FragmentType.Real; FragmentType.name; FragmentType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; FragmentType.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.FragmentType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.FragmentType.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Functional.html:3805,Deployability,update,updated,3805,"ional)  str; docstring. omega(self: psi4.core.Functional)  float; docstring. print_detail(self: psi4.core.Functional, arg0: int)  None; docstring. print_out(self: psi4.core.Functional)  None; docstring. set_alpha(self: psi4.core.Functional, arg0: float)  None; docstring. set_citation(self: psi4.core.Functional, arg0: str)  None; docstring. set_density_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_description(self: psi4.core.Functional, arg0: str)  None; docstring. set_gga(self: psi4.core.Functional, arg0: bool)  None; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_meta(self: psi4.core.Functional, arg0: bool)  None; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_name(self: psi4.core.Functional, arg0: str)  None; docstring. set_omega(self: psi4.core.Functional, arg0: float)  None; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float)  None; docstring. table of contents. Functional; Functional; Functional.alpha(); Functional.build_base(); Functional.citation(); Functional.compute_functional(); Functional.density_cutoff(); Functional.description(); Functional.is_gga(); Functional.is_lrc(); Functional.is_meta(); Functional.lsda_cutoff(); Functional.meta_cutoff(); Functional.name(); Functional.omega(); Functional.print_detail(); Functional.print_out(); Functional.set_alpha(); Functional.set_citation(); Functional.set_density_cutoff(); Functional.set_description(); Functional.set_gga(); Functional.set_lsda_cutoff(); Functional.set_meta(); Functional.set_meta_cutoff(); Functional.set_name(); Functional.set_omega(); Functional.set_parameter(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Functional.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Functional.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:3043,Deployability,update,updated,3043,"ical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:359,Integrability,contract,contraction,359,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:410,Integrability,contract,contraction,410,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:490,Integrability,contract,contraction,490,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:1028,Integrability,contract,contraction,1028,"vigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.Gaus",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:1089,Integrability,contract,contraction,1089,"PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the giv",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:1338,Integrability,contract,contraction,1338,"character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical ha",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:1390,Integrability,contract,contraction,1390,"The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:1471,Integrability,contract,contraction,1471,"er symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primiti",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:2170,Integrability,contract,contraction,2170,"ical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html:2264,Integrability,contract,contraction,2264,"ical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianType.html:794,Deployability,update,updated,794,". GaussianType. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; GaussianType. GaussianType. class psi4.core.GaussianType; Bases: pybind11_object; 0 if Cartesian, 1 if Pure; Members:. Cartesian : (n+1)(n+2)/2 functions; Pure : 2n+1 functions. Attributes Summary. Cartesian. Pure. name. value. Attributes Documentation. Cartesian = <GaussianType.Cartesian: 0>. Pure = <GaussianType.Pure: 1>. name. value. table of contents. GaussianType; GaussianType; GaussianType.Cartesian; GaussianType.Pure; GaussianType.name; GaussianType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; GaussianType.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GaussianType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GaussianType.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.GeometryUnits.html:772,Deployability,update,updated,772,". GeometryUnits. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; GeometryUnits. GeometryUnits. class psi4.core.GeometryUnits; Bases: pybind11_object; The units used to define the geometry; Members:. Angstrom; Bohr. Attributes Summary. Angstrom. Bohr. name. value. Attributes Documentation. Angstrom = <GeometryUnits.Angstrom: 0>. Bohr = <GeometryUnits.Bohr: 1>. name. value. table of contents. GeometryUnits; GeometryUnits; GeometryUnits.Angstrom; GeometryUnits.Bohr; GeometryUnits.name; GeometryUnits.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; GeometryUnits.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.GeometryUnits.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.GeometryUnits.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_active_molecule.html:541,Deployability,update,updated,541,". get_active_molecule. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_active_molecule. get_active_molecule. psi4.core.get_active_molecule()  psi4.core.Molecule; Returns the currently active molecule object. table of contents. get_active_molecule; get_active_molecule(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_active_molecule.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_active_molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_active_molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variable.html:534,Deployability,update,updated,534,". get_array_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. get_array_variable. psi4.core.get_array_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. table of contents. get_array_variable; get_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variable.html:248,Modifiability,variab,variable,248,". get_array_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. get_array_variable. psi4.core.get_array_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. table of contents. get_array_variable; get_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variables.html:539,Deployability,update,updated,539,". get_array_variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. get_array_variables. psi4.core.get_array_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. table of contents. get_array_variables; get_array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variables.html:249,Modifiability,variab,variables,249,". get_array_variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. get_array_variables. psi4.core.get_array_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. table of contents. get_array_variables; get_array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_datadir.html:479,Deployability,update,updated,479,". get_datadir. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_datadir. get_datadir. psi4.core.get_datadir()  str; Returns the path to shared text resources, PSIDATADIR. table of contents. get_datadir; get_datadir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_datadir.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_datadir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_datadir.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option.html:394,Availability,error,error,394,". get_global_option. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_global_option. get_global_option. psi4.core.get_global_option(key: str)  object; Return keyword key value at global (all-module) scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized. table of contents. get_global_option; get_global_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_global_option.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option.html:689,Deployability,update,updated,689,". get_global_option. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_global_option. get_global_option. psi4.core.get_global_option(key: str)  object; Return keyword key value at global (all-module) scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized. table of contents. get_global_option; get_global_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_global_option.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option_list.html:545,Deployability,update,updated,545,". get_global_option_list. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_global_option_list. get_global_option_list. psi4.core.get_global_option_list()  List[str]; Returns a list of all global options. table of contents. get_global_option_list; get_global_option_list(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_global_option_list.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_global_option_list.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_global_option_list.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_local_option.html:390,Availability,error,error,390,". get_local_option. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_local_option. get_local_option. psi4.core.get_local_option(module: str, key: str)  object; Return keyword key value at module scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized for the module. table of contents. get_local_option; get_local_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_local_option.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_local_option.html:697,Deployability,update,updated,697,". get_local_option. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_local_option. get_local_option. psi4.core.get_local_option(module: str, key: str)  object; Return keyword key value at module scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized for the module. table of contents. get_local_option; get_local_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_local_option.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_memory.html:204,Availability,avail,available,204,". get_memory. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_memory. get_memory. psi4.core.get_memory()  int; Returns the amount of memory available to Psi (in bytes). table of contents. get_memory; get_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_memory.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_memory.html:475,Deployability,update,updated,475,". get_memory. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_memory. get_memory. psi4.core.get_memory()  int; Returns the amount of memory available to Psi (in bytes). table of contents. get_memory; get_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_memory.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_num_threads.html:519,Deployability,update,updated,519,". get_num_threads. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_num_threads. get_num_threads. psi4.core.get_num_threads()  int; Returns the number of threads to use in SMP parallel computations. table of contents. get_num_threads; get_num_threads(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_num_threads.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_num_threads.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_option.html:388,Availability,error,error,388,". get_option. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_option. get_option. psi4.core.get_option(module: str, key: str)  object; Return keyword key value used by module. Returns the local value associated with the keyword if its been set, else the global value if its been set, else the local default value. Returns error if key is not recognized globally or if key is not recognized for the module. table of contents. get_option; get_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_option.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_option.html:714,Deployability,update,updated,714,". get_option. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_option. get_option. psi4.core.get_option(module: str, key: str)  object; Return keyword key value used by module. Returns the local value associated with the keyword if its been set, else the global value if its been set, else the local default value. Returns error if key is not recognized globally or if key is not recognized for the module. table of contents. get_option; get_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_option.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_options.html:451,Deployability,update,updated,451,". get_options. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_options. get_options. psi4.core.get_options()  psi4.core.Options; Get options. table of contents. get_options; get_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_options.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_options.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_output_file.html:518,Deployability,update,updated,518,". get_output_file. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_output_file. get_output_file. psi4.core.get_output_file()  str; Returns output file name (stem + suffix, no directory). stdout. table of contents. get_output_file; get_output_file(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_output_file.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_output_file.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_output_file.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variable.html:492,Deployability,update,updated,492,". get_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_variable. get_variable. psi4.core.get_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. table of contents. get_variable; get_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variable.html:224,Modifiability,variab,variable,224,". get_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_variable. get_variable. psi4.core.get_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. table of contents. get_variable; get_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variables.html:497,Deployability,update,updated,497,". get_variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_variables. get_variables. psi4.core.get_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. table of contents. get_variables; get_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variables.html:225,Modifiability,variab,variables,225,". get_variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_variables. get_variables. psi4.core.get_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. table of contents. get_variables; get_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_writer_file_prefix.html:586,Deployability,update,updated,586,". get_writer_file_prefix. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_writer_file_prefix. get_writer_file_prefix. psi4.core.get_writer_file_prefix(molecule_name: str)  str; Returns the prefix to use for writing files for external programs. table of contents. get_writer_file_prefix; get_writer_file_prefix(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_writer_file_prefix.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.get_writer_file_prefix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.get_writer_file_prefix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.git_version.html:455,Deployability,update,updated,455,". git_version. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; git_version. git_version. psi4.core.git_version()  None. Deprecated since version 1.4. table of contents. git_version; git_version(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; git_version.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.git_version.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.git_version.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_array_variable.html:558,Deployability,update,updated,558,". has_array_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_array_variable. has_array_variable. psi4.core.has_array_variable(key: str)  bool; Is the Matrix QCVariable key (case-insensitive) set? Prefer has_variable(). table of contents. has_array_variable; has_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_array_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_global_option_changed.html:807,Deployability,update,updated,807,". has_global_option_changed. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_global_option_changed. has_global_option_changed. psi4.core.has_global_option_changed(key: str)  bool; Whether keyword key value has been touched at global (all-module) scope. Has it been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. table of contents. has_global_option_changed; has_global_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_global_option_changed.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_global_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_global_option_changed.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_local_option_changed.html:815,Deployability,update,updated,815,". has_local_option_changed. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_local_option_changed. has_local_option_changed. psi4.core.has_local_option_changed(module: str, key: str)  bool; Whether keyword key value has been touched at module scope. Has it been touched in the scope of the specified module by either user or code.Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user. table of contents. has_local_option_changed; has_local_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_local_option_changed.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_local_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_local_option_changed.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_option_changed.html:767,Deployability,update,updated,767,". has_option_changed. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_option_changed. has_option_changed. psi4.core.has_option_changed(module: str, key: str)  bool; Whether keyword key value has been touched or is default. Has it been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. table of contents. has_option_changed; has_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_option_changed.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_option_changed.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_scalar_variable.html:565,Deployability,update,updated,565,". has_scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_scalar_variable. has_scalar_variable. psi4.core.has_scalar_variable(key: str)  bool; Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). table of contents. has_scalar_variable; has_scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_scalar_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_scalar_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_variable.html:607,Deployability,update,updated,607,". has_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_variable. has_variable. psi4.core.has_variable(key); Whether scalar or array QCVariable key; has been set in global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Return type:; bool. table of contents. has_variable; has_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; has_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.has_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.has_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:4327,Deployability,update,update,4327,"nergies(). print_header(self); docstring. print_orbitals(self); docstring. print_preiterations([small]). print_stability_analysis(self,arg0); docstring. push_back_external_potential(self,V); Add an external potential to the private external_potentials list. reset_occupation(self); docstring. rotate_orbitals(self,arg0,arg1); docstring. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self,arg0,arg1); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:10893,Deployability,update,update,10893,"ensity_and_energy(self: psi4.core.HF)  None; docstring. scf_type(self: psi4.core.HF)  str; Return the value of scf_type used in the SCF computation. semicanonicalize(self: psi4.core.HF)  None; Semicanonicalizes the orbitals for ROHF. set_energies(self: psi4.core.HF, arg0: str, arg1: float)  None; docstring. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix])  None; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK)  None; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int)  int; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF)  bool; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str)  List[psi4.core.Matrix]; Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError  If any of DIIS options dont play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbital_gradient(); HF.comput",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:13080,Deployability,update,updated,13080,"; Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError  If any of DIIS options dont play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbital_gradient(); HF.compute_spin_contamination(); HF.cphf_Hx(); HF.cphf_converged(); HF.cphf_solve(); HF.damping_update(); HF.diis(); HF.finalize(); HF.finalize_energy(); HF.find_occupation(); HF.form_C(); HF.form_D(); HF.form_F(); HF.form_FDSmSDF(); HF.form_G(); HF.form_H(); HF.form_Shalf(); HF.form_V(); HF.form_initial_C(); HF.form_initial_F(); HF.frac_renormalize(); HF.functional(); HF.get_energies(); HF.guess(); HF.guess_Ca(); HF.guess_Cb(); HF.initialize(); HF.initialize_gtfock_jk(); HF.initialize_jk(); HF.iterations(); HF.jk(); HF.occupation_a(); HF.occupation_b(); HF.onel_Hx(); HF.print_energies(); HF.print_header(); HF.print_orbitals(); HF.print_preiterations(); HF.print_stability_analysis(); HF.push_back_external_potential(); HF.reset_occupation(); HF.rotate_orbitals(); HF.save_density_and_energy(); HF.scf_type(); HF.semicanonicalize(); HF.set_energies(); HF.set_external_cpscf_perturbation(); HF.set_jk(); HF.set_sad_basissets(); HF.set_sad_fitting_basissets(); HF.soscf_update(); HF.stability_analysis(); HF.twoel_Hx(); HF.validate_diis(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; HF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:1900,Energy Efficiency,energy,energy,1900,"); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self,arg0,arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. functional(self); Returns the internal DFT Superfunctional. get_energies(self,arg0); docstring. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self,arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self,arg0); Sets the guess Beta Orbital Matrix. ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:6010,Energy Efficiency,energy,energy,6010,"he number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and call",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:7072,Energy Efficiency,energy,energy,7072,"puted by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF)  None; docstring. form_C(self: psi4.core.HF, shift: float = 0.0)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF)  None; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Forms the residual of SCF theory. form_G(self: psi4.core.HF)  None; Forms the G matrix. form_H(self: psi4.core.HF)  None; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF)  None; Forms the S^1/2 matrix. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF)  None; Forms the in",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:7140,Energy Efficiency,energy,energy,7140,"elf: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF)  None; docstring. form_C(self: psi4.core.HF, shift: float = 0.0)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF)  None; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Forms the residual of SCF theory. form_G(self: psi4.core.HF)  None; Forms the G matrix. form_H(self: psi4.core.HF)  None; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF)  None; Forms the S^1/2 matrix. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF)  None; Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self: psi4.core.HF)  None; Forms the initial F matri",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:5928,Integrability,wrap,wrapper,5928,"on_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions te",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:260,Performance,perform,performed,260,". HF. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; HF. HF. class psi4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:470,Performance,perform,performed,470,". HF. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; HF. HF. class psi4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:4628,Performance,perform,performed,4628,"ng. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self,arg0,arg1); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:4843,Performance,perform,performed,4843,"); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. comput",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:5919,Usability,simpl,simply,5919,"on_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions te",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IDAMAX.html:450,Deployability,update,updated,450,". IDAMAX. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; IDAMAX. IDAMAX. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  int; docstring. table of contents. IDAMAX; IDAMAX(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; IDAMAX.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IDAMAX.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IDAMAX.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.initialize.html:504,Deployability,update,updated,504,". initialize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; initialize. initialize. psi4.core.initialize()  bool; Called upon psi4 module import to initialize timers, singletons, and I/O. Idempotent. table of contents. initialize; initialize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; initialize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.initialize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.initialize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntegralFactory.html:9205,Deployability,update,updated,9205,")  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO nabla integral. so_overlap(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO overlap integrals. so_potential(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO nuclear attraction integral. so_quadrupole(self: psi4.core.IntegralFactory)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes SO the quadrupole integral. so_traceless_quadrupole(self: psi4.core.IntegralFactory)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the traceless SO quadrupole integral. table of contents. IntegralFactory; IntegralFactory; IntegralFactory.ao_angular_momentum(); IntegralFactory.ao_dipole(); IntegralFactory.ao_kinetic(); IntegralFactory.ao_multipole_potential(); IntegralFactory.ao_multipoles(); IntegralFactory.ao_nabla(); IntegralFactory.ao_overlap(); IntegralFactory.ao_potential(); IntegralFactory.ao_quadrupole(); IntegralFactory.ao_traceless_quadrupole(); IntegralFactory.electric_field(); IntegralFactory.electrostatic(); IntegralFactory.erf_complement_eri(); IntegralFactory.erf_eri(); IntegralFactory.eri(); IntegralFactory.f12(); IntegralFactory.f12_double_commutator(); IntegralFactory.f12_squared(); IntegralFactory.f12g12(); IntegralFactory.overlap_3c(); IntegralFactory.shells_iterator(); IntegralFactory.so_angular_momentum(); IntegralFactory.so_dipole(); IntegralFactory.so_kinetic(); IntegralFactory.so_multipoles(); IntegralFactory.so_nabla(); IntegralFactory.so_overlap(); IntegralFactory.so_potential(); IntegralFactory.so_quadrupole(); IntegralFactory.so_traceless_quadrupole(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; IntegralFactory.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IntegralFactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntegralFactory.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntegralTransform.html:7187,Deployability,update,updated,7187,"grals. update_orbitals(self: psi4.core.IntegralTransform)  None; docstring. table of contents. IntegralTransform; IntegralTransform; IntegralTransform.DPD_ID(); IntegralTransform.alpha_corr_to_pitzer(); IntegralTransform.backtransform_density(); IntegralTransform.backtransform_tpdm_restricted(); IntegralTransform.backtransform_tpdm_unrestricted(); IntegralTransform.beta_corr_to_pitzer(); IntegralTransform.compute_fock_like_matrices(); IntegralTransform.get_dpd_id(); IntegralTransform.get_frozen_core_energy(); IntegralTransform.get_keep_dpd_so_ints(); IntegralTransform.get_keep_ht_ints(); IntegralTransform.get_keep_iwl_so_ints(); IntegralTransform.get_memory(); IntegralTransform.get_print(); IntegralTransform.get_psio(); IntegralTransform.get_tei_already_presorted(); IntegralTransform.initialize(); IntegralTransform.nirrep(); IntegralTransform.presort_so_tei(); IntegralTransform.print_dpd_lookup(); IntegralTransform.reset_so_int(); IntegralTransform.set_aa_int_name(); IntegralTransform.set_ab_int_name(); IntegralTransform.set_bb_int_name(); IntegralTransform.set_dpd_id(); IntegralTransform.set_dpd_int_file(); IntegralTransform.set_keep_dpd_so_ints(); IntegralTransform.set_keep_ht_ints(); IntegralTransform.set_keep_iwl_so_ints(); IntegralTransform.set_memory(); IntegralTransform.set_orbitals(); IntegralTransform.set_print(); IntegralTransform.set_psio(); IntegralTransform.set_so_tei_file(); IntegralTransform.set_tei_already_presorted(); IntegralTransform.set_tpdm_already_presorted(); IntegralTransform.set_write_dpd_so_tpdm(); IntegralTransform.transform_tei(); IntegralTransform.transform_tei_first_half(); IntegralTransform.transform_tei_second_half(); IntegralTransform.update_orbitals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; IntegralTransform.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IntegralTransform.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntegralTransform.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntVector.html:3309,Deployability,update,updated,3309,": psi4.core.ProtoIntVector)  None; Copy another vector into this. dim(self: psi4.core.IntVector, h: int = 0)  int; Returns the number of dimensions per irrep h. dimpi(self: psi4.core.IntVector)  psi4.core.Dimension; Returns the Dimension object. get(*args, **kwargs); Overloaded function. get(self: psi4.core.IntVector, m: int) -> int. Returns a single element value located at m. get(self: psi4.core.IntVector, h: int, m: int) -> int. Returns a single element value located at m in irrep h. get_block(self: psi4.core.IntVector, slice: psi4.core.Slice)  psi4.core.IntVector; Get a vector block. init(self: psi4.core.IntVector, arg0: psi4.core.Dimension)  None; Reallocate the data of the Vector. Consider making a new object. static iota(arg0: psi4.core.Dimension)  psi4.core.IntVector. nirrep(self: psi4.core.IntVector)  int; Returns the number of irreps. print_out(self: psi4.core.IntVector)  None; Prints the vector to the output file. set(*args, **kwargs); Overloaded function. set(self: psi4.core.IntVector, m: int, val: int) -> None. Sets a single element value located at m. set(self: psi4.core.IntVector, h: int, m: int, val: int) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.IntVector, slice: psi4.core.Slice, block: psi4.core.ProtoIntVector)  None; Set a vector block. zero(self: psi4.core.IntVector)  None; Zeros the vector. table of contents. IntVector; IntVector; IntVector.name; IntVector.add(); IntVector.clone(); IntVector.copy(); IntVector.dim(); IntVector.dimpi(); IntVector.get(); IntVector.get_block(); IntVector.init(); IntVector.iota(); IntVector.nirrep(); IntVector.print_out(); IntVector.set(); IntVector.set_block(); IntVector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; IntVector.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IntVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IntVector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IO.html:3662,Deployability,update,updated,3662,"str; Lookup process id. open(self: psi4.core.IO, unit: int, status: int)  None; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int)  int; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int)  None; Sync up the object to the file on disk by closing and opening the file, if necessary. static set_default_namespace(ns: str)  None; Set the current namespace (for PREFIX.NAMESPACE.UNIT file numbering). set_pid(self: psi4.core.IO, pid: str)  None; Set process id. static shared_object()  psi4.core.IO; Return the global shared object. state(self: psi4.core.IO)  int; Return 1 if PSIO library is activated. tocclean(self: psi4.core.IO, unit: int, key: str)  None; Delete all TOC entries after the given key. If a blank key is given, the entire TOC will be wiped. tocentry_exists(self: psi4.core.IO, arg0: int, arg1: str)  bool; Checks the TOC to see if a particular keyword exists there or not. tocprint(self: psi4.core.IO, arg0: int)  None; Print the table of contents for the given unit. tocscan(self: psi4.core.IO, arg0: int, arg1: str)  psi4.core.psio_entry; Seek string in binary file. This export is only good for catching None, as returned success object not exported. tocwrite(self: psi4.core.IO, arg0: int)  None; Write the table of contents for passed file number. table of contents. IO; IO; IO.change_file_namespace(); IO.close(); IO.exists(); IO.get_default_namespace(); IO.getpid(); IO.open(); IO.open_check(); IO.rehash(); IO.set_default_namespace(); IO.set_pid(); IO.shared_object(); IO.state(); IO.tocclean(); IO.tocentry_exists(); IO.tocprint(); IO.tocscan(); IO.tocwrite(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; IO.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IO.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IO.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html:3208,Deployability,update,updated,3208,"4.core.IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str)  None; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str)  None; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool)  None; Set the specific file number to be retained. static shared_object()  psi4.core.IOManager; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str)  None; Write a string to a temporary file. The scratch file is opened and closed by this function. table of contents. IOManager; IOManager; IOManager.crashclean(); IOManager.get_default_path(); IOManager.get_file_path(); IOManager.mark_file_for_retention(); IOManager.print_out(); IOManager.psiclean(); IOManager.set_default_path(); IOManager.set_specific_path(); IOManager.set_specific_retention(); IOManager.shared_object(); IOManager.write_scratch_file(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; IOManager.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html:745,Integrability,protocol,protocol,745,". IOManager. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; IOManager. IOManager. class psi4.core.IOManager; Bases: pybind11_object; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation; Methods Summary. crashclean(self); Clean from disk-mirrored image after crash. get_default_path(self); Return the default path. get_file_path(self,fileno); Get the path for a specific file number. mark_file_for_retention(self,full_path,retain); Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self); Print the current status of PSI4 files. psiclean(self); Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self,path); Set the default path for files to be stored. set_specific_path(self,fileno,path); Set the path for specific file numbers. set_specific_retention(self,fileno,retain); Set the specific file number to be retained. shared_object(); The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self,full_path,text); Write a string to a temporary file. Methods Documentation. crashclean(self: psi4.core.IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. se",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html:1915,Integrability,protocol,protocol,1915,"path); Set the path for specific file numbers. set_specific_retention(self,fileno,retain); Set the specific file number to be retained. shared_object(); The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self,full_path,text); Write a string to a temporary file. Methods Documentation. crashclean(self: psi4.core.IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str)  None; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str)  None; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool)  None; Set the specific file number to be retained. static shared_object()  psi4.core.IOManager; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str)  None; Write a string to a temporary file. The scratch file is opened and closed by this function. table of contents. IOManager; IOManager; IOManager.crashclean(); IOManager.get_default_path(); IOManager.get_file_path(); IOManager.mark_file_for_retention(); IOManager.print_out(); IOManager.psiclean(); IOManager.set_default_path(); IOManager.set_specific_path(); IOManager.set_speci",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.IrreducibleRepresentation.html:1087,Deployability,update,updated,1087,". IrreducibleRepresentation. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; IrreducibleRepresentation. IrreducibleRepresentation. class psi4.core.IrreducibleRepresentation; Bases: pybind11_object; An irreducible representation of the point group; Methods Summary. character(self,arg0); Return the character of the i'th symmetry operation for the irrep. symbol(self); Return the symbol for the irrep. Methods Documentation. character(self: psi4.core.IrreducibleRepresentation, arg0: int)  float; Return the character of the ith symmetry operation for the irrep. 0-indexed. symbol(self: psi4.core.IrreducibleRepresentation)  str; Return the symbol for the irrep. table of contents. IrreducibleRepresentation; IrreducibleRepresentation; IrreducibleRepresentation.character(); IrreducibleRepresentation.symbol(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; IrreducibleRepresentation.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.IrreducibleRepresentation.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.IrreducibleRepresentation.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.JK.html:6134,Deployability,update,updated,6134,": psi4.core.JK)  None. memory_estimate(self: psi4.core.JK)  int. name(self: psi4.core.JK)  str. print_header(self: psi4.core.JK)  None; docstring. set_cutoff(self: psi4.core.JK, arg0: float)  None. set_do_J(self: psi4.core.JK, arg0: bool)  None. set_do_K(self: psi4.core.JK, arg0: bool)  None. set_do_wK(self: psi4.core.JK, arg0: bool)  None. set_early_screening(self: psi4.core.JK, early_screening: bool)  None; Use severe screening techniques? Useful in early SCF iterations. set_memory(self: psi4.core.JK, arg0: int)  None. set_omega(self: psi4.core.JK, omega: float)  None; Dampening term for range separated DFT. set_omega_alpha(self: psi4.core.JK, alpha: float)  None; Weight for HF exchange term in range-separated DFT. set_omega_beta(self: psi4.core.JK, beta: float)  None; Weight for dampened exchange term in range-separated DFT. set_omp_nthread(self: psi4.core.JK, arg0: int)  None. set_print(self: psi4.core.JK, arg0: int)  None. set_wcombine(self: psi4.core.JK, wcombine: bool)  None; Are Exchange terms in one Matrix. wK(self: psi4.core.JK)  List[psi4.core.Matrix]. table of contents. JK; JK; JK.C_add(); JK.C_clear(); JK.C_left_add(); JK.C_right_add(); JK.D(); JK.J(); JK.K(); JK.basisset(); JK.build(); JK.build_JK(); JK.compute(); JK.computed_shells_per_iter(); JK.finalize(); JK.get_early_screening(); JK.get_omega(); JK.get_omega_alpha(); JK.get_omega_beta(); JK.get_wcombine(); JK.initialize(); JK.memory_estimate(); JK.name(); JK.print_header(); JK.set_cutoff(); JK.set_do_J(); JK.set_do_K(); JK.set_do_wK(); JK.set_early_screening(); JK.set_memory(); JK.set_omega(); JK.set_omega_alpha(); JK.set_omega_beta(); JK.set_omp_nthread(); JK.set_print(); JK.set_wcombine(); JK.wK(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; JK.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.JK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.JK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.KineticInt.html:462,Deployability,update,updated,462,". KineticInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; KineticInt. KineticInt. class psi4.core.KineticInt; Bases: OneBodyAOInt; Computes kinetic integrals. table of contents. KineticInt; KineticInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; KineticInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.KineticInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.KineticInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html:1317,Deployability,update,updated,1317,". LaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. LaplaceDenominator. class psi4.core.LaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). table of contents. LaplaceDenominator; LaplaceDenominator; LaplaceDenominator.denominator_occ(); LaplaceDenominator.denominator_vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html:290,Energy Efficiency,energy,energy,290,". LaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. LaplaceDenominator. class psi4.core.LaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). table of contents. LaplaceDenominator; LaplaceDenominator; LaplaceDenominator.denominator_occ(); LaplaceDenominator.denominator_vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.LaplaceDenominator.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.LibXCFunctional.html:2014,Deployability,update,updated,2014,"4 API: Linking C++ and Python; LibXCFunctional. LibXCFunctional. class psi4.core.LibXCFunctional; Bases: Functional; docstring; Methods Summary. density_cutoff(self); docstring. get_mix_data(self); docstring. query_libxc(self,arg0); query libxc regarding functional parameters. set_density_cutoff(self,arg0); docstring. set_omega(self,arg0); docstring. set_tweak(*args,**kwargs); Overloaded function. xclib_description(); query libxc for version and citation. Methods Documentation. density_cutoff(self: psi4.core.LibXCFunctional)  float; docstring. get_mix_data(self: psi4.core.LibXCFunctional)  List[Tuple[str, int, float]]; docstring. query_libxc(self: psi4.core.LibXCFunctional, arg0: str)  Dict[str, float]; query libxc regarding functional parameters. set_density_cutoff(self: psi4.core.LibXCFunctional, arg0: float)  None; docstring. set_omega(self: psi4.core.LibXCFunctional, arg0: float)  None; docstring. set_tweak(*args, **kwargs); Overloaded function. set_tweak(self: psi4.core.LibXCFunctional, tweaks: List[float], quiet: bool = False) -> None. Set all tweaks on a LibXC functional through a list. Deprecated in v1.4. set_tweak(self: psi4.core.LibXCFunctional, tweaks: Dict[str, float], quiet: bool = False) -> None. Set all tweaks on a LibXC functional through a dictionary of names (usually underscore prepended) and values. New in v1.4. xclib_description()  str; query libxc for version and citation. table of contents. LibXCFunctional; LibXCFunctional; LibXCFunctional.density_cutoff(); LibXCFunctional.get_mix_data(); LibXCFunctional.query_libxc(); LibXCFunctional.set_density_cutoff(); LibXCFunctional.set_omega(); LibXCFunctional.set_tweak(); LibXCFunctional.xclib_description(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; LibXCFunctional.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.LibXCFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.LibXCFunctional.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Localizer.html:1207,Deployability,update,updated,1207,". Localizer. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Localizer. Localizer. class psi4.core.Localizer; Bases: pybind11_object; Class containing orbital localization procedures; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build(arg0,arg1,arg2); Build the localization scheme. localize(self); Perform the localization procedure. Attributes Documentation. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Documentation. static build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; Build the localization scheme. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. table of contents. Localizer; Localizer; Localizer.L; Localizer.U; Localizer.converged; Localizer.build(); Localizer.localize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Localizer.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Localizer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:19724,Deployability,update,updated,19724,"; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix)  None; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix)  None; Zero the lower triangle. zero_upper(self: psi4.core.Matrix)  None; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Matrix.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:3297,Energy Efficiency,power,power,3297,"rix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,bl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:3357,Energy Efficiency,power,power,3357,"rix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,bl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:13009,Energy Efficiency,power,power,13009,"ucted.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12)  psi4.core.Dimension; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile')  None; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix)  None; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int)  psi4.core.Matrix; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix)  None; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix)  float; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float)  None; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; Returns the rows per irrep array. row",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:13130,Energy Efficiency,power,power,13130,"turn type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12)  psi4.core.Dimension; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile')  None; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix)  None; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int)  psi4.core.Matrix; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix)  None; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix)  float; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float)  None; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; Returns the rows per irrep array. rows(self: psi4.core.Matrix, h: int = 0)  int; Returns the rows in irrep h. save(*args, **kwargs); Overloa",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:18894,Energy Efficiency,power,power,18894,"; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix)  None; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix)  None; Zero the lower triangle. zero_upper(self: psi4.core.Matrix)  None; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Matrix.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:16418,Integrability,depend,depending,16418,"ce, cols: psi4.core.Slice, block: psi4.core.Matrix)  None; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix)  float; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix)  psi4.core.Matrix; Creates a new matrix that is the tran",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:2740,Performance,load,load,2740,"im1,dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. gemm(self,transa,transb,alpha,a,b,beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoa",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:2996,Performance,load,load,2996,"); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*ar",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11109,Performance,load,load,11109,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return typ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11154,Performance,load,load,11154,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_w",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11278,Performance,load,load,11278,"nsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return th",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11446,Performance,load,load,11446,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11954,Performance,load,load,11954,"x)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:18768,Performance,load,load,18768,"lf: psi4.core.Matrix)  None; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix)  None; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix)  None; Zero the lower triangle. zero_upper(self: psi4.core.Matrix)  None; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Matrix.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Crea",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:4789,Security,access,accessor,4789,"ix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,block); Set a matrix block. subtract(self,arg0); Substract a matrix from this matrix. sum_of_squares(self); Returns the sum of the squares of this matrix. symmetrize_gradient(self,mol); Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self); Returns the overall symmetry of the matrix. to_array([copy,dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self); Returns the trace of the matrix. transform(*args,**kwargs); Overloaded function. transpose(self); Creates a new matrix that is the transpose of this matrix. transpose_this(self); Transpose the matrix in-place. triplet(A,B,C,transA,transB,transC); Multiply three matrices together. vector_dot(self,rhs); Returns the vector dot product of this with rhs. zero(self); Zero all elements of the matrix. zero_diagonal(self); Zero the diagonal of the matrix. zero_lower(self); Zero the lower triangle. zero_upper(self); Zero the upper triangle. Attributes Documentation. name; The name of the Matrix. Used in printing. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix)  float; Returns the absolute maximum value. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; Multiplies two arguments and adds the result to this ma",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:16713,Security,access,accessor,16713,": psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix)  psi4.core.Matrix; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix)  None; Transpose the matrix in-place. static triplet(A, B, C, transA, transB, transC); Multiply three matrices together. Deprecated since version 1.4: Use psi4.core.triplet() instead. vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix)  float; Returns th",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11252,Testability,test,tests,11252,"rix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompres",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:16035,Usability,simpl,simply,16035,"ne. Sets every element of a matrix to val. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix)  None; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix)  float; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*a",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MatrixFactory.html:920,Deployability,update,updated,920,". MatrixFactory. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MatrixFactory. MatrixFactory. class psi4.core.MatrixFactory; Bases: pybind11_object; Creates Matrix objects; Methods Summary. create_matrix(*args,**kwargs); Overloaded function. Methods Documentation. create_matrix(*args, **kwargs); Overloaded function. create_matrix(self: psi4.core.MatrixFactory) -> psi4.core.Matrix. Returns a new matrix object with default dimensions. create_matrix(self: psi4.core.MatrixFactory, arg0: str) -> psi4.core.Matrix. Returns a new Matrix object named name with default dimensions. table of contents. MatrixFactory; MatrixFactory; MatrixFactory.create_matrix(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MatrixFactory.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MatrixFactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MatrixFactory.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.mcscf.html:494,Deployability,update,updated,494,". mcscf. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mcscf. mcscf. psi4.core.mcscf(arg0: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the MCSCF code, (N.B. restricted to certain active spaces). table of contents. mcscf; mcscf(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mcscf.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.mcscf.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MemDFJK.html:588,Deployability,update,updated,588,". MemDFJK. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MemDFJK. MemDFJK. class psi4.core.MemDFJK; Bases: JK; docstring; Methods Summary. dfh(self); Return the DFHelper object. Methods Documentation. dfh(self: psi4.core.MemDFJK)  psi4.core.DFHelper; Return the DFHelper object. table of contents. MemDFJK; MemDFJK; MemDFJK.dfh(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MemDFJK.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MemDFJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MemDFJK.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:21511,Deployability,update,updated,21511,"tsHelper.ao_oei_deriv1(); MintsHelper.ao_oei_deriv2(); MintsHelper.ao_overlap(); MintsHelper.ao_overlap_half_deriv1(); MintsHelper.ao_potential(); MintsHelper.ao_pvp(); MintsHelper.ao_quadrupole(); MintsHelper.ao_tei_deriv1(); MintsHelper.ao_tei_deriv2(); MintsHelper.ao_traceless_quadrupole(); MintsHelper.basisset(); MintsHelper.cdsalcs(); MintsHelper.core_hamiltonian_grad(); MintsHelper.dipole_grad(); MintsHelper.electric_field(); MintsHelper.electric_field_value(); MintsHelper.electrostatic_potential_value(); MintsHelper.f12_cgtg(); MintsHelper.factory(); MintsHelper.induction_operator(); MintsHelper.integral(); MintsHelper.integrals(); MintsHelper.integrals_erf(); MintsHelper.integrals_erfc(); MintsHelper.kinetic_grad(); MintsHelper.mo_elec_dip_deriv1(); MintsHelper.mo_erf_eri(); MintsHelper.mo_eri(); MintsHelper.mo_f12(); MintsHelper.mo_f12_double_commutator(); MintsHelper.mo_f12_squared(); MintsHelper.mo_f12g12(); MintsHelper.mo_oei_deriv1(); MintsHelper.mo_oei_deriv2(); MintsHelper.mo_overlap_half_deriv1(); MintsHelper.mo_spin_eri(); MintsHelper.mo_tei_deriv1(); MintsHelper.mo_tei_deriv2(); MintsHelper.mo_transform(); MintsHelper.multipole_grad(); MintsHelper.nbf(); MintsHelper.one_electron_integrals(); MintsHelper.overlap_grad(); MintsHelper.perturb_grad(); MintsHelper.petite_list(); MintsHelper.petite_list1(); MintsHelper.play(); MintsHelper.potential_grad(); MintsHelper.set_basisset(); MintsHelper.set_print(); MintsHelper.so_angular_momentum(); MintsHelper.so_dipole(); MintsHelper.so_dkh(); MintsHelper.so_kinetic(); MintsHelper.so_nabla(); MintsHelper.so_overlap(); MintsHelper.so_potential(); MintsHelper.so_quadrupole(); MintsHelper.so_traceless_quadrupole(); MintsHelper.sobasisset(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MintsHelper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:2738,Energy Efficiency,charge,charges,2738,"ion. ao_overlap_half_deriv1(self,side,atom); Half-derivative of AO basis overlap integrals: returns (3 * natoms) matrices. ao_potential(*args,**kwargs); Overloaded function. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self,atom[,omega,factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...);",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:2815,Energy Efficiency,charge,charge,2815,"ap integrals: returns (3 * natoms) matrices. ao_potential(*args,**kwargs); Overloaded function. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self,atom[,omega,factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...); MO F12 double commutator integrals. mo_f12_squared(self,corr,C1,C2,C3,C4);",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:12213,Energy Efficiency,charge,charges,12213,"2 matrices. ao_traceless_quadrupole(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; Vector AO traceless quadrupole integrals. basisset(self: psi4.core.MintsHelper)  psi4.core.BasisSet; Returns the basis set being used. cdsalcs(self: psi4.core.MintsHelper, arg0: int, arg1: bool, arg2: bool)  psi4.core.CdSalcList; Returns a CdSalcList object. core_hamiltonian_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative T + V + Perturb integrals. dipole_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0)  List[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  List[Tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  Non",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:12370,Energy Efficiency,charge,charge,12370,"self: psi4.core.MintsHelper)  psi4.core.BasisSet; Returns the basis set being used. cdsalcs(self: psi4.core.MintsHelper, arg0: int, arg1: bool, arg2: bool)  psi4.core.CdSalcList; Returns a CdSalcList object. core_hamiltonian_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative T + V + Perturb integrals. dipole_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0)  List[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  List[Tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERFC integrals. kinetic_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative kinetic int",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:3048,Integrability,contract,contracting,3048,"s: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...); MO F12 double commutator integrals. mo_f12_squared(self,corr,C1,C2,C3,C4); MO F12 squared integrals. mo_f12g12(self,corr,C1,C2,C3,C4); MO F12G12 integrals. mo_oei_deriv1(self,oei_type,atom,C1,C2); Gradient of MO basis OEI integrals: returns (3 * natoms) matrices. mo_oei_deriv2(self,oei_type,atom1,atom2,...); Hessian of ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html:12795,Integrability,contract,contracting,12795," dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0)  List[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  List[Tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERFC integrals. kinetic_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self: psi4.core.MintsHelper, atom: int, C1: psi4.core.Matrix, C2: psi4.core.Matrix)  List[psi4.core.Matrix]; Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self: psi4.core.MintsHelper, omega: float, C1: psi4.core.Matrix, C2: psi4.core.Matrix, C3: psi4.core.Matrix, C4: psi4.core.Matrix)  psi4.core.Matrix; MO ERFC Omega Integrals. mo_eri(self: psi4.core.MintsHelper, C1: psi4.core.Matrix, C2: psi",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MoldenWriter.html:926,Deployability,update,updated,926,". MoldenWriter. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MoldenWriter. MoldenWriter. class psi4.core.MoldenWriter; Bases: pybind11_object; Writes wavefunction information in molden format; Methods Summary. write(self,filename,Ca,Cb,Ea,Eb,OccA,...); Writes wavefunction information in molden format. Methods Documentation. write(self: psi4.core.MoldenWriter, filename: str, Ca: psi4.core.Matrix, Cb: psi4.core.Matrix, Ea: psi4.core.Vector, Eb: psi4.core.Vector, OccA: psi4.core.Vector, OccB: psi4.core.Vector, dovirtual: bool)  None; Writes wavefunction information in molden format. table of contents. MoldenWriter; MoldenWriter; MoldenWriter.write(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MoldenWriter.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MoldenWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MoldenWriter.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MolecularGrid.html:1984,Deployability,update,updated,1984,". ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MolecularGrid. MolecularGrid. class psi4.core.MolecularGrid; Bases: pybind11_object; docstring; Methods Summary. atomic_blocks(self); Returns a list of blocks. blocks(self); Returns a list of blocks. collocation_size(self); Returns the total collocation size of all blocks. max_functions(self); Returns the maximum number of functions in a block. max_points(self); Returns the maximum number of points in a block. npoints(self); Returns the number of grid points. orientation(self); Returns the orientation of the grid. print(self,arg0,arg1); Prints grid information. Methods Documentation. atomic_blocks(self: psi4.core.MolecularGrid)  List[List[psi4.core.BlockOPoints]]; Returns a list of blocks. blocks(self: psi4.core.MolecularGrid)  List[psi4.core.BlockOPoints]; Returns a list of blocks. collocation_size(self: psi4.core.MolecularGrid)  int; Returns the total collocation size of all blocks. max_functions(self: psi4.core.MolecularGrid)  int; Returns the maximum number of functions in a block. max_points(self: psi4.core.MolecularGrid)  int; Returns the maximum number of points in a block. npoints(self: psi4.core.MolecularGrid)  int; Returns the number of grid points. orientation(self: psi4.core.MolecularGrid)  psi4.core.Matrix; Returns the orientation of the grid. print(self: psi4.core.MolecularGrid, arg0: str, arg1: int)  None; Prints grid information. table of contents. MolecularGrid; MolecularGrid; MolecularGrid.atomic_blocks(); MolecularGrid.blocks(); MolecularGrid.collocation_size(); MolecularGrid.max_functions(); MolecularGrid.max_points(); MolecularGrid.npoints(); MolecularGrid.orientation(); MolecularGrid.print(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MolecularGrid.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MolecularGrid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MolecularGrid.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:2061,Availability,toler,tolerance,2061,"a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:2158,Availability,toler,tolerance,2158,"f,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string(molstr[,dtype,name,fix_com,...]). fsymbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-in",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:10087,Availability,toler,tolerance,10087,"g0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self,arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self,i); Return the Vector3 for atom i (0-indexed without dummies). y(self,arg0);",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:15276,Availability,fault,faulty,15276,"ts of ndarray, optional)  geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional)  List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol:",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:18828,Availability,toler,tolerance,18828,"ts(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Writte",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:18982,Availability,toler,tolerance,18982,"ract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='An",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:20287,Availability,error,error,20287,"ride this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Mo",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28617,Availability,error,error,28617,"al_symmetry_number(self: psi4.core.Molecule)  int; Returns number of unique orientations of the rigid molecule that only interchange identical atoms. rotor_type(self: psi4.core.Molecule)  str; Returns rotor type, e.g. RT_ATOM or RT_SYMMETRIC_TOP. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:29908,Availability,error,error,29908,"ertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geom",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:37312,Availability,toler,tolerance,37312,"elf: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[so",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:43220,Deployability,update,updated,43220,"nergy_deriv1(); Molecule.nuclear_repulsion_energy_deriv2(); Molecule.orientation_fixed(); Molecule.point_group(); Molecule.print_bond_angles(); Molecule.print_cluster(); Molecule.print_distances(); Molecule.print_in_input_format(); Molecule.print_out(); Molecule.print_out_in_angstrom(); Molecule.print_out_in_bohr(); Molecule.print_out_of_planes(); Molecule.print_rotational_constants(); Molecule.provenance(); Molecule.reinterpret_coordentry(); Molecule.reset_point_group(); Molecule.rotational_constants(); Molecule.rotational_symmetry_number(); Molecule.rotor_type(); Molecule.run_dftd3(); Molecule.run_dftd4(); Molecule.run_gcp(); Molecule.save_string_xyz(); Molecule.save_string_xyz_file(); Molecule.save_xyz_file(); Molecule.schoenflies_symbol(); Molecule.scramble(); Molecule.set_active_fragment(); Molecule.set_active_fragments(); Molecule.set_basis_all_atoms(); Molecule.set_basis_by_label(); Molecule.set_basis_by_number(); Molecule.set_basis_by_symbol(); Molecule.set_comment(); Molecule.set_connectivity(); Molecule.set_full_geometry(); Molecule.set_geometry(); Molecule.set_ghost_fragment(); Molecule.set_ghost_fragments(); Molecule.set_input_units_to_au(); Molecule.set_mass(); Molecule.set_molecular_charge(); Molecule.set_multiplicity(); Molecule.set_name(); Molecule.set_nuclear_charge(); Molecule.set_point_group(); Molecule.set_provenance(); Molecule.set_units(); Molecule.set_variable(); Molecule.symbol(); Molecule.symmetrize(); Molecule.symmetry_from_input(); Molecule.to_arrays(); Molecule.to_dict(); Molecule.to_schema(); Molecule.to_string(); Molecule.translate(); Molecule.true_atomic_number(); Molecule.units(); Molecule.update_geometry(); Molecule.x(); Molecule.xyz(); Molecule.y(); Molecule.z(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Molecule.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:266,Energy Efficiency,charge,charge,266,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:611,Energy Efficiency,charge,charge,611,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:904,Energy Efficiency,charge,charge,904,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:1188,Energy Efficiency,charge,charge,1188,"rdinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:1213,Energy Efficiency,charge,charge,1213,"rdinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:1627,Energy Efficiency,charge,charges,1627,"0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:1906,Energy Efficiency,charge,charge,1906,"ed atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:1983,Energy Efficiency,charge,charge,1983,"rloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_sc",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:3912,Energy Efficiency,charge,charge,3912,"es. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string(molstr[,dtype,name,fix_com,...]). fsymbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:5141,Energy Efficiency,charge,charge,5141,"gments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separato",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:5574,Energy Efficiency,energy,energy,5574,"s molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:5674,Energy Efficiency,energy,energy,5674,"nit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to output file. print_r",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:5791,Energy Efficiency,energy,energy,5791,"els. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to output file. print_rotational_constants(self); Print the rotational constants to output file. provenance(self); Gets molecule",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:9282,Energy Efficiency,charge,charge,9282,"arg2); Sets basis set arg1 to all atoms with label (e.g., H4) arg0. set_basis_by_number(self,arg0,arg1,arg2); Sets basis set arg1 to all atoms with number arg0. set_basis_by_symbol(self,arg0,arg1,arg2); Sets basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self,arg0); Sets molecule comment. set_connectivity(self,arg0); Sets molecule connectivity. set_full_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); E",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:9461,Energy Efficiency,charge,charge,9461,"basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self,arg0); Sets molecule comment. set_connectivity(self,arg0); Sets molecule connectivity. set_full_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema d",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:13152,Energy Efficiency,charge,charge,13152,"ed final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; do_plot (bool)  Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool)  Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst-case timings.; run_resorting (bool)  Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float)  TODO; run_mirror (bool)  Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection.; verbose (int)  . Returns:; First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:; float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)[source]; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:. self (qcdb.Molecule or psi4.core.Molecule)  ; seed_atoms (List)  List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float)  Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool)  If True, also return fragments as list of arrays.; return_molecules (bool)  If True, also return fragments as list of Molecules.; return_molecule (bool)  If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map (list of ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:14995,Energy Efficiency,charge,charge,14995,"rays.; return_molecules (bool)  If True, also return fragments as list of Molecules.; return_molecule (bool)  If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map (list of lists)  Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional)  geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional)  List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:15474,Energy Efficiency,charge,charge,15474,"ch built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: in",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:15731,Energy Efficiency,charge,charge,15731,"cule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: ps",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:15893,Energy Efficiency,charge,charge,15893,"cule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: ps",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:16682,Energy Efficiency,charge,charge,16682,"oat, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule)  bool; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule)  str; Gets molecule comment. connectivity(self: psi4.core.Molecule)  List[Tuple[int, int, float]]; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Mole",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:16741,Energy Efficiency,charge,charge,16741,", label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule)  bool; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule)  str; Gets molecule comment. connectivity(self: psi4.core.Molecule)  List[Tuple[int, int, float]]; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.M",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:17331,Energy Efficiency,charge,charges,17331," tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule)  bool; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule)  str; Gets molecule comment. connectivity(self: psi4.core.Molecule)  List[Tuple[int, int, float]]; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: p",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:18620,Energy Efficiency,charge,charge,18620,"wargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:18731,Energy Efficiency,charge,charge,18731,"si4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by cal",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:22852,Energy Efficiency,charge,charge,22852," C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self: psi4.core.Molecule)  int; Gets n in Cnv, etc.; If there is no n (e.g. Td) its the highest-order rotation axis. fx(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg0 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg0 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule)  List[int]; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule)  List[int]; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule)  List[str]; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:24568,Energy Efficiency,charge,charge,24568,"str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  float; Computes nuclear repulsion energy. nuclear_r",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:25536,Energy Efficiency,energy,energy,25536,": psi4.core.Molecule)  int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  float; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  psi4.core.Matrix; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule)  psi4.core.Matrix; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule)  bool; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule)  psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule)  None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule)  None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule)  None; Prints the molecul",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:25717,Energy Efficiency,energy,energy,25717,"Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  float; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  psi4.core.Matrix; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule)  psi4.core.Matrix; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule)  bool; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule)  psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule)  None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule)  None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule)  None; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:25874,Energy Efficiency,energy,energy,25874,"molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  float; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  psi4.core.Matrix; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule)  psi4.core.Matrix; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule)  bool; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule)  psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule)  None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule)  None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule)  None; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self: psi4.core.Molecule)  None; Prints the m",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28729,Energy Efficiency,energy,energy-only,28729,"ical atoms. rotor_type(self: psi4.core.Molecule)  str; Returns rotor type, e.g. RT_ATOM or RT_SYMMETRIC_TOP. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28781,Energy Efficiency,efficient,efficient,28781,"ical atoms. rotor_type(self: psi4.core.Molecule)  str; Returns rotor type, e.g. RT_ATOM or RT_SYMMETRIC_TOP. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28876,Energy Efficiency,energy,energy,28876,"dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parame",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28909,Energy Efficiency,energy,energy,28909,"dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parame",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:28996,Energy Efficiency,energy,energy,28996,":. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecule",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:29076,Energy Efficiency,energy,energy,29076,"& disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficien",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30020,Energy Efficiency,energy,energy-only,30020,"y.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30072,Energy Efficiency,efficient,efficient,30072,"y.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30167,Energy Efficiency,energy,energy,30167,"se=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently comp",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30200,Energy Efficiency,energy,energy,30200,"se=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently comp",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30280,Energy Efficiency,energy,energy,30280," disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended b",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30353,Energy Efficiency,energy,energy,30353," disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended b",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31034,Energy Efficiency,energy,energy,31034,"nfluences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31099,Energy Efficiency,energy,energy,31099,"nfluences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both e",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31731,Energy Efficiency,energy,energy-only,31731,"rogram.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31783,Energy Efficiency,efficient,efficient,31783,"rogram.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31897,Energy Efficiency,energy,energy,31897,"ion to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31930,Energy Efficiency,energy,energy,31930,"ion to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:32010,Energy Efficiency,energy,energy,32010,"; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:32083,Energy Efficiency,energy,energy,32083,"; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:35959,Energy Efficiency,charge,charge,35959,"y(self: psi4.core.Molecule, arg0: List[Tuple[int, int, float]])  None; Sets molecule connectivity. set_full_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int])  None; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float)  None; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float)  None; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:36366,Energy Efficiency,charge,charge,36366," set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int])  None; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float)  None; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float)  None; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:39880,Energy Efficiency,charge,charge,39880,"ine the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int)  psi4.core.Vector3; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int)  float; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int)  float; z position [Bohr] of atom arg0 (0-indexed without dummies). table of contents. Molecule; Molecule; Molecule.B787(); Molecule.BFS(); Molecule.Z(); Molecule.activate_all_fragments(); Molecule.add_atom(); Molecule.atom_at_position(); Molecule.basis_on_atom(); Molecule.center_of_mass(); Molecule.charge(); Molecule.clone(); Molecule.com_fixed(); Molecule.comment(); Molecule.connectivity(); Molecule.create_psi4_string_from_molecule(); Molecule.deactivate_all_fragments(); Molecule.distance_matrix(); Molecule.extract_subsets(); Molecule.fZ(); Molecule.fcharge(); Molecule.find_highest_point_group(); Molecule.find_point_group(); Molecule.fix_com(); Molecule.fix_orientation(); Molecule.flabel(); Molecule.fmass(); Molecule.form_symmetry_information(); Molecule.format_molecule_for_mol(); Molecule.from_arrays(); Molecule.from_dict(); Molecule.from_schema(); Molecule.from_string(); Molecule.fsymbol(); Molecule.ftrue_atomic_number(); Molecule.full_geometry(); Molecule.full_pg_n(); Molecule.fx(); Molecule.fy(); Molecule.fz(); Molecule.geometry(); Molecule.get_fragment_charges(); Molecule.get_fragment_multiplicities(); Molecule.get_fragment_types(); Molecule.get_fragments(); Molecule.get_full_point_group(); Molecule.get_full_point_group_with_n(); Molecule.get_variable(); Molecule.has_zmatrix(); Molec",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:20465,Integrability,wrap,wrapper,20465,"). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict)  Dictionary representation of instance.; Only provided if return_dict is True. classm",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:21006,Integrability,wrap,wrapper,21006,"o_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict)  Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1). fsymbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed including d",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30417,Integrability,wrap,wraps,30417," Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30456,Integrability,wrap,wraps,30456," Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31374,Integrability,interface,interface,31374,"3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:912,Modifiability,extend,extended,912,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:2898,Modifiability,variab,variables,2898,"ion. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string(molstr[,dtype,name,fix_com,...]). fsymbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:4450,Modifiability,variab,variable,4450,"; Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nucle",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:4482,Modifiability,variab,variables,4482,"; Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nucle",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:4808,Modifiability,variab,variable,4808,"as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (nato",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:4843,Modifiability,variab,variables,4843,"as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (nato",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:9817,Modifiability,variab,variable,9817,"x arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Re",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:9856,Modifiability,variab,variables,9856,"x arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Re",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:10863,Modifiability,variab,variable,10863,"e variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self,arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self,i); Return the Vector3 for atom i (0-indexed without dummies). y(self,arg0); y position [Bohr] of atom arg0 (0-indexed without dummies). z(self,arg0); z position [Bohr] of atom arg0 (0-indexed without dummies). Methods Documentation. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)[source]; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcelemental.molutil.B787() for psi4.driver.qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:. concern_mol (Union[Molecule, Molecule])  Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with re",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:15901,Modifiability,extend,extended,15901,"cule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: ps",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:20447,Modifiability,variab,variables,20447,"; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molec",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:23589,Modifiability,variab,variable,23589,"on of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule)  List[int]; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule)  List[int]; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule)  List[str]; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:23621,Modifiability,variab,variables,23621,"on of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule)  List[int]; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule)  List[int]; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule)  List[str]; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:24110,Modifiability,variab,variable,24110,"ent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:24145,Modifiability,variab,variables,24145,"ent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:30612,Modifiability,extend,extending,30612,"correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:31326,Modifiability,extend,extended,31326,"3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:36975,Modifiability,variab,variable,36975,"nitial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:37014,Modifiability,variab,variables,37014,"nitial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:39023,Modifiability,variab,variable,39023,"ment symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule)  str; Returns units used to define the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int)  psi4.core.Vector3; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int)  float; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int)  float; z position [Bohr] of atom arg0 (0-indexed without dummies). table of contents. Molecule; Molecule; Molecule.B787(); Molecule.BFS(); Molecule.Z(); Molecule.activate_all_fragments(); Molecule.add_atom(); Molecule.atom_at_position(); Molecule.basis_on_atom(); Molecule.center_of_mass(); Molecule.charge(); Molecule.clone(); Molecule.com_fixed(); Molecule.comment(); Molecule.connectivity(); Molecule.create_psi4_string_from_molecule(",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:14235,Safety,detect,detected,14235," aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:; float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)[source]; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:. self (qcdb.Molecule or psi4.core.Molecule)  ; seed_atoms (List)  List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float)  Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool)  If True, also return fragments as list of arrays.; return_molecules (bool)  If True, also return fragments as list of Molecules.; return_molecule (bool)  If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map (list of lists)  Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional)  geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional)  List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped b",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:21277,Security,validat,validation,21277,"e, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict)  Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1). fsymbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self: psi4.core.Molecule)  int; Gets n in Cnv, etc.; If there is no n (e.g. ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:38006,Security,hash,hash,38006,"iables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule)  str; Returns units used to define the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with cur",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:12486,Testability,test,test,12486," qcelemental.molutil.B787() for psi4.driver.qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:. concern_mol (Union[Molecule, Molecule])  Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref_mol.; ref_mol (Union[Molecule, Molecule])  Molecule to match.; atoms_map (bool)  Whether atom1 of ref_mol corresponds to atom1 of concern_mol, etc.; If true, specifying True can save much time.; mols_align (bool)  Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; do_plot (bool)  Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool)  Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst-case timings.; run_resorting (bool)  Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float)  TODO; run_mirror (bool)  Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection.; verbose (int)  . Returns:; First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:; float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)[source]; Detect fragment",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:33972,Testability,test,test,33972,"on (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate (Union[bool, ndarray, List[List]])  Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort (Union[bool, List])  Whether to shuffle atoms (True) or leave 1st atom 1st, etc. (False).; To specify shuffle, supply a nat-element list of indices.; deflection (float)  If do_rotate, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror (bool)  Whether to construct the mirror image structure by inverting y-axis.; do_plot (bool)  Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool)  By construction, scrambled systems are fully alignable (final RMSD=0).; Even so, True turns off the mechanism to stop when RMSD reaches zero; and instead proceed to worst possible time.; run_resorting (bool)  Even if atoms not shuffled, test the resorting machinery.; verbose (int)  Print level. Return type:; None. set_active_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg0 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: List[int])  None; Sets the specified list arg0 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str)  None; Sets basis set arg0 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg1 to all atoms with label (e.g., H4) arg0. set_basis_by_number(self: psi4.core.Molecule, arg0: int, arg1: str, arg2: str)  None; Sets basis set arg1 to all atoms with number arg0. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self: psi4.core.Molecule, arg0: str)  None; Sets molecule comment. set_connectivity(self: psi4.core.Molecule,",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:39072,Usability,clear,clearing,39072,"rmation is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule)  str; Returns units used to define the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int)  psi4.core.Vector3; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int)  float; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int)  float; z position [Bohr] of atom arg0 (0-indexed without dummies). table of contents. Molecule; Molecule; Molecule.B787(); Molecule.BFS(); Molecule.Z(); Molecule.activate_all_fragments(); Molecule.add_atom(); Molecule.atom_at_position(); Molecule.basis_on_atom(); Molecule.center_of_mass(); Molecule.charge(); Molecule.clone(); Molecule.com_fixed(); Molecule.comment(); Molecule.connectivity(); Molecule.create_psi4_string_from_molecule(); Molecule.deactivate_all_fragments(); Molecule.distance_matrix(); Molecu",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MOSpace.html:1614,Deployability,update,updated,1614,". MOSpace. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MOSpace. MOSpace. class psi4.core.MOSpace; Bases: pybind11_object; Defines orbital spaces in which to transform integrals; Methods Summary. aIndex(self); Get the alpha orbital indexing array. aOrbs(self); Get the alpha orbitals. all(). bIndex(self); Get the beta orbital indexing array. bOrbs(self); Get the beta orbitals. dum(). fzc(). fzv(). label(self); Get the unique identifier for this space. nil(). occ(). vir(). Methods Documentation. aIndex(self: psi4.core.MOSpace)  List[int]; Get the alpha orbital indexing array. aOrbs(self: psi4.core.MOSpace)  List[int]; Get the alpha orbitals. static all()  psi4.core.MOSpace. bIndex(self: psi4.core.MOSpace)  List[int]; Get the beta orbital indexing array. bOrbs(self: psi4.core.MOSpace)  List[int]; Get the beta orbitals. static dum()  psi4.core.MOSpace. static fzc()  psi4.core.MOSpace. static fzv()  psi4.core.MOSpace. label(self: psi4.core.MOSpace)  str; Get the unique identifier for this space. static nil()  psi4.core.MOSpace. static occ()  psi4.core.MOSpace. static vir()  psi4.core.MOSpace. table of contents. MOSpace; MOSpace; MOSpace.aIndex(); MOSpace.aOrbs(); MOSpace.all(); MOSpace.bIndex(); MOSpace.bOrbs(); MOSpace.dum(); MOSpace.fzc(); MOSpace.fzv(); MOSpace.label(); MOSpace.nil(); MOSpace.occ(); MOSpace.vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MOSpace.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MOSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MOSpace.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MOWriter.html:581,Deployability,update,updated,581,". MOWriter. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MOWriter. MOWriter. class psi4.core.MOWriter; Bases: pybind11_object; Writes the MOs; Methods Summary. write(self); Write the MOs. Methods Documentation. write(self: psi4.core.MOWriter)  None; Write the MOs. table of contents. MOWriter; MOWriter; MOWriter.write(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MOWriter.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MOWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MOWriter.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.mrcc_generate_input.html:583,Deployability,update,updated,583,". mrcc_generate_input. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mrcc_generate_input. mrcc_generate_input. psi4.core.mrcc_generate_input(arg0: psi4.core.Wavefunction, arg1: dict)  psi4.core.PsiReturnType; Generates an input for Kallays MRCC code. table of contents. mrcc_generate_input; mrcc_generate_input(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mrcc_generate_input.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.mrcc_generate_input.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.mrcc_generate_input.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.mrcc_load_densities.html:595,Deployability,update,updated,595,". mrcc_load_densities. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mrcc_load_densities. mrcc_load_densities. psi4.core.mrcc_load_densities(arg0: psi4.core.Wavefunction, arg1: dict)  psi4.core.PsiReturnType; Reads in the density matrices from Kallays MRCC code. table of contents. mrcc_load_densities; mrcc_load_densities(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mrcc_load_densities.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.mrcc_load_densities.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.mrcc_load_densities.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MultipoleInt.html:494,Deployability,update,updated,494,". MultipoleInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MultipoleInt. MultipoleInt. class psi4.core.MultipoleInt; Bases: OneBodyAOInt; Computes arbitrary-order multipole integrals. table of contents. MultipoleInt; MultipoleInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MultipoleInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MultipoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MultipoleInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.MultipoleSymmetry.html:714,Deployability,update,updated,714,". MultipoleSymmetry. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MultipoleSymmetry. MultipoleSymmetry. class psi4.core.MultipoleSymmetry; Bases: pybind11_object; docstring; Methods Summary. create_matrices(self,arg0); docstring. Methods Documentation. create_matrices(self: psi4.core.MultipoleSymmetry, arg0: str)  List[psi4.core.Matrix]; docstring. table of contents. MultipoleSymmetry; MultipoleSymmetry; MultipoleSymmetry.create_matrices(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MultipoleSymmetry.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.MultipoleSymmetry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.MultipoleSymmetry.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.NablaInt.html:446,Deployability,update,updated,446,". NablaInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; NablaInt. NablaInt. class psi4.core.NablaInt; Bases: OneBodyAOInt; Computes nabla integrals. table of contents. NablaInt; NablaInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; NablaInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.NablaInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.NablaInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html:668,Deployability,integrat,integration,668,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. P",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html:982,Deployability,integrat,integration,982,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. P",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html:1313,Deployability,integrat,integration,1313,"lper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html:1675,Deployability,integrat,integration,1675,"lper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html:2095,Deployability,update,updated,2095,"lper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html:668,Integrability,integrat,integration,668,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. P",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html:982,Integrability,integrat,integration,982,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. P",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html:1313,Integrability,integrat,integration,1313,"lper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html:1675,Integrability,integrat,integration,1675,"lper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.occ.html:455,Deployability,update,updated,455,". occ. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; occ. occ. psi4.core.occ(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the orbital optimized CC codes. table of contents. occ; occ(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; occ.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.occ.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.occ.html:214,Performance,optimiz,optimized,214,". occ. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; occ. occ. psi4.core.occ(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the orbital optimized CC codes. table of contents. occ; occ(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; occ.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.occ.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html:3518,Deployability,update,updated,3518," List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OEProp.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html:975,Modifiability,variab,variables,975,". OEProp. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp. class psi4.core.OEProp; Bases: pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self,arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self,Da[,symmetry]); docstring. set_Da_mo(self,arg0); docstring. set_Da_so(self,arg0); docstring. set_Db_ao(self,Db[,symmetry]); docstring. set_Db_mo(self,arg0); docstring. set_Db_so(self,arg0); docstring. set_names(self,arg0); Instruct OEProp to save variables under all specified names. set_title(self,title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  Non",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html:2614,Modifiability,variab,variables,2614," List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OEProp.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html:2883,Modifiability,variab,variables,2883," List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OEProp.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html:611,Usability,clear,clear,611,". OEProp. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp. class psi4.core.OEProp; Bases: pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self,arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self,Da[,symmetry]); docstring. set_Da_mo(self,arg0); docstring. set_Da_so(self,arg0); docstring. set_Db_ao(self,Db[,symmetry]); docstring. set_Db_mo(self,arg0); docstring. set_Db_so(self,arg0); docstring. set_names(self,arg0); Instruct OEProp to save variables under all specified names. set_title(self,title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  Non",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html:1884,Usability,clear,clear,1884,". set_Db_so(self,arg0); docstring. set_names(self,arg0); Instruct OEProp to save variables under all specified names. set_title(self,title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html:3138,Usability,clear,clear,3138," List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OEProp.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OneBodyAOInt.html:1586,Deployability,update,updated,1586,". OneBodyAOInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OneBodyAOInt. OneBodyAOInt. class psi4.core.OneBodyAOInt; Bases: pybind11_object; Basis class for all one-electron integrals; Attributes Summary. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. origin; The origin about which the one body ints are being computed. Methods Summary. compute(self,arg0); Compute all integrals over both basis sets, and store them in the provided matrix. compute_shell(self,arg0,arg1); Compute integrals between basis functions in the given shell pair. Attributes Documentation. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. origin; The origin about which the one body ints are being computed. Methods Documentation. compute(self: psi4.core.OneBodyAOInt, arg0: List[psi4.core.Matrix])  None; Compute all integrals over both basis sets, and store them in the provided matrix. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; Compute integrals between basis functions in the given shell pair. table of contents. OneBodyAOInt; OneBodyAOInt; OneBodyAOInt.basis; OneBodyAOInt.basis1; OneBodyAOInt.basis2; OneBodyAOInt.origin; OneBodyAOInt.compute(); OneBodyAOInt.compute_shell(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OneBodyAOInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OneBodyAOInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OneBodyAOInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OneBodySOInt.html:782,Deployability,update,updated,782,". OneBodySOInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OneBodySOInt. OneBodySOInt. class psi4.core.OneBodySOInt; Bases: pybind11_object; Attributes Summary. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. Attributes Documentation. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. table of contents. OneBodySOInt; OneBodySOInt; OneBodySOInt.basis; OneBodySOInt.basis1; OneBodySOInt.basis2. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OneBodySOInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OneBodySOInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OneBodySOInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Options.html:4247,Deployability,update,updated,4247,"on. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options)  None; print the global, cross-module options. print_module_options(self: psi4.core.Options)  None; print global and local options prepared for current module. read_globals(self: psi4.core.Options)  bool; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str)  None; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool)  None; set bool option. set_current_module(self: psi4.core.Options, arg0: str)  None; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float)  None; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int)  None; set int option. set_read_globals(self: psi4.core.Options, arg0: bool)  None; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. validate_options(self: psi4.core.Options)  None; validate options for arg0 module. table of contents. Options; Options; Options.add_array(); Options.add_bool(); Options.add_int(); Options.add_str(); Options.add_str_i(); Options.get_bool(); Options.get_current_module(); Options.get_double(); Options.get_int(); Options.get_int_vector(); Options.get_str(); Options.print_global_options(); Options.print_module_options(); Options.read_globals(); Options.set_array(); Options.set_bool(); Options.set_current_module(); Options.set_double(); Options.set_int(); Options.set_read_globals(); Options.set_str(); Options.set_str_i(); Options.validate_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Options.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Options.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Options.html:1345,Security,validat,validate,1345,"(self,arg0,arg1,arg2); add string option. add_str_i(self,arg0,arg1,arg2); add string option. get_bool(self,arg0); get boolean option. get_current_module(self); gets current module. get_double(self,arg0); get double option. get_int(self,arg0); get integer option. get_int_vector(self,arg0); get int vector option. get_str(*args,**kwargs); Overloaded function. print_global_options(self); print the global, cross-module options. print_module_options(self); print global and local options prepared for current module. read_globals(self); expert. set_array(self,arg0,arg1); set array option. set_bool(self,arg0,arg1,arg2); set bool option. set_current_module(self,arg0); sets arg0 (all CAPS) as current module. set_double(self,arg0,arg1,arg2); set double option. set_int(self,arg0,arg1,arg2); set int option. set_read_globals(self,arg0); expert. set_str(self,arg0,arg1,arg2); set string option. set_str_i(self,arg0,arg1,arg2); set string option. validate_options(self); validate options for arg0 module. Methods Documentation. add_array(self: psi4.core.Options, arg0: str)  None; add array option. add_bool(self: psi4.core.Options, arg0: str, arg1: bool)  None; add bool option. add_int(self: psi4.core.Options, arg0: str, arg1: int)  None; add int option. add_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; add string option. add_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; add string option. get_bool(self: psi4.core.Options, arg0: str)  bool; get boolean option. get_current_module(self: psi4.core.Options)  str; gets current module. get_double(self: psi4.core.Options, arg0: str)  float; get double option. get_int(self: psi4.core.Options, arg0: str)  int; get integer option. get_int_vector(self: psi4.core.Options, arg0: str)  List[int]; get int vector option. get_str(*args, **kwargs); Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Options.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Options.html:3450,Security,validat,validate,3450,"on. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options)  None; print the global, cross-module options. print_module_options(self: psi4.core.Options)  None; print global and local options prepared for current module. read_globals(self: psi4.core.Options)  bool; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str)  None; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool)  None; set bool option. set_current_module(self: psi4.core.Options, arg0: str)  None; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float)  None; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int)  None; set int option. set_read_globals(self: psi4.core.Options, arg0: bool)  None; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. validate_options(self: psi4.core.Options)  None; validate options for arg0 module. table of contents. Options; Options; Options.add_array(); Options.add_bool(); Options.add_int(); Options.add_str(); Options.add_str_i(); Options.get_bool(); Options.get_current_module(); Options.get_double(); Options.get_int(); Options.get_int_vector(); Options.get_str(); Options.print_global_options(); Options.print_module_options(); Options.read_globals(); Options.set_array(); Options.set_bool(); Options.set_current_module(); Options.set_double(); Options.set_int(); Options.set_read_globals(); Options.set_str(); Options.set_str_i(); Options.validate_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Options.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Options.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.options_to_python.html:534,Deployability,update,updated,534,". options_to_python. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; options_to_python. options_to_python. psi4.core.options_to_python(arg0: str)  dict; Get dictionary of whether options of module have changed. table of contents. options_to_python; options_to_python(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; options_to_python.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.options_to_python.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.options_to_python.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.option_exists_in_module.html:581,Deployability,update,updated,581,". option_exists_in_module. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; option_exists_in_module. option_exists_in_module. psi4.core.option_exists_in_module(module: str, key: str)  bool; Whether keyword key is a valid keyword for module. table of contents. option_exists_in_module; option_exists_in_module(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; option_exists_in_module.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.option_exists_in_module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.option_exists_in_module.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html:1776,Availability,toler,tolerance,1776,"dimensions. evals(self); Corresponding eigenvalues of the C matrix. id(self); Unique identifier. integral(self); The integral factory used to create C. name(self); Name of the orbital space. nirrep(self); Returns number of irreps. print_out(self); Print information about the orbital space to the output file. Methods Documentation. C(self: psi4.core.OrbitalSpace)  psi4.core.Matrix; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace)  psi4.core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html:2377,Availability,toler,tolerance,2377,".core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. table of contents. OrbitalSpace; OrbitalSpace; OrbitalSpace.C(); OrbitalSpace.basisset(); OrbitalSpace.build_cabs_space(); OrbitalSpace.build_ri_space(); OrbitalSpace.dim(); OrbitalSpace.evals(); OrbitalSpace.id(); OrbitalSpace.integral(); Orbita",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html:3514,Deployability,update,updated,3514,"eturned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. table of contents. OrbitalSpace; OrbitalSpace; OrbitalSpace.C(); OrbitalSpace.basisset(); OrbitalSpace.build_cabs_space(); OrbitalSpace.build_ri_space(); OrbitalSpace.dim(); OrbitalSpace.evals(); OrbitalSpace.id(); OrbitalSpace.integral(); OrbitalSpace.name(); OrbitalSpace.nirrep(); OrbitalSpace.print_out(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OrbitalSpace.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html:1797,Integrability,depend,dependencies,1797,"dimensions. evals(self); Corresponding eigenvalues of the C matrix. id(self); Unique identifier. integral(self); The integral factory used to create C. name(self); Name of the orbital space. nirrep(self); Returns number of irreps. print_out(self); Print information about the orbital space to the output file. Methods Documentation. C(self: psi4.core.OrbitalSpace)  psi4.core.Matrix; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace)  psi4.core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html:2057,Integrability,depend,dependent,2057,"thods Documentation. C(self: psi4.core.OrbitalSpace)  psi4.core.Matrix; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace)  psi4.core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. table of contents. OrbitalSpace; OrbitalSpace; OrbitalSpace.C();",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html:2398,Integrability,depend,dependencies,2398,".core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. table of contents. OrbitalSpace; OrbitalSpace; OrbitalSpace.C(); OrbitalSpace.basisset(); OrbitalSpace.build_cabs_space(); OrbitalSpace.build_ri_space(); OrbitalSpace.dim(); OrbitalSpace.evals(); OrbitalSpace.id(); OrbitalSpace.integral(); Orbita",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.outfile_name.html:468,Deployability,update,updated,468,". outfile_name. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; outfile_name. outfile_name. psi4.core.outfile_name()  str; Returns the name of the output file. table of contents. outfile_name; outfile_name(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; outfile_name.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.outfile_name.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.outfile_name.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.OverlapInt.html:462,Deployability,update,updated,462,". OverlapInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OverlapInt. OverlapInt. class psi4.core.OverlapInt; Bases: OneBodyAOInt; Computes overlap integrals. table of contents. OverlapInt; OverlapInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OverlapInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.OverlapInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OverlapInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.PetiteList.html:974,Deployability,update,updated,974,". PetiteList. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PetiteList. PetiteList. class psi4.core.PetiteList; Bases: pybind11_object; Handles symmetry transformations; Methods Summary. aotoso(self); Return the AO->SO coefficient matrix. print(self,arg0); Print to outfile. sotoao(self); Return the SO->AO coefficient matrix. Methods Documentation. aotoso(self: psi4.core.PetiteList)  psi4.core.Matrix; Return the AO->SO coefficient matrix. print(self: psi4.core.PetiteList, arg0: str)  None; Print to outfile. sotoao(self: psi4.core.PetiteList)  psi4.core.Matrix; Return the SO->AO coefficient matrix. table of contents. PetiteList; PetiteList; PetiteList.aotoso(); PetiteList.print(); PetiteList.sotoao(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PetiteList.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.PetiteList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.PetiteList.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html:509,Deployability,update,updated,509,". plugin. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html:3,Modifiability,plugin,plugin,3,". plugin. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html:115,Modifiability,plugin,plugin,115,". plugin. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html:123,Modifiability,plugin,plugin,123,". plugin. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html:142,Modifiability,plugin,plugin,142,". plugin. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html:226,Modifiability,plugin,plugin,226,". plugin. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html:259,Modifiability,plugin,plugin,259,". plugin. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html:298,Modifiability,plugin,plugin,298,". plugin. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html:306,Modifiability,plugin,plugin,306,". plugin. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html:454,Modifiability,plugin,plugin,454,". plugin. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_close.html:472,Deployability,update,updated,472,". plugin_close. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_close. plugin_close. psi4.core.plugin_close(arg0: str)  None; Close the plugin of name arg0. table of contents. plugin_close; plugin_close(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_close.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin_close.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_close.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_close.html:203,Modifiability,plugin,plugin,203,". plugin_close. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_close. plugin_close. psi4.core.plugin_close(arg0: str)  None; Close the plugin of name arg0. table of contents. plugin_close; plugin_close(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_close.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin_close.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_close.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_close_all.html:484,Deployability,update,updated,484,". plugin_close_all. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all. plugin_close_all. psi4.core.plugin_close_all()  None; Close all open plugins. table of contents. plugin_close_all; plugin_close_all(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin_close_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_close_all.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_close_all.html:215,Modifiability,plugin,plugins,215,". plugin_close_all. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all. plugin_close_all. psi4.core.plugin_close_all()  None; Close all open plugins. table of contents. plugin_close_all; plugin_close_all(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin_close_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_close_all.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_load.html:522,Deployability,update,updated,522,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. table of contents. plugin_load; plugin_load(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_load.html:197,Modifiability,plugin,plugin,197,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. table of contents. plugin_load; plugin_load(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_load.html:235,Performance,load,loaded,235,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. table of contents. plugin_load; plugin_load(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_load.html:248,Performance,load,loaded,248,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. table of contents. plugin_load; plugin_load(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_load.html:269,Performance,load,loaded,269,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. table of contents. plugin_load; plugin_load(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.PMLocalizer.html:481,Deployability,update,updated,481,". PMLocalizer. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PMLocalizer. PMLocalizer. class psi4.core.PMLocalizer; Bases: Localizer; Performs Pipek-Mezey orbital localization. table of contents. PMLocalizer; PMLocalizer. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PMLocalizer.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.PMLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.PMLocalizer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.PointFunctions.html:1803,Deployability,update,updated,1803,". PointFunctions. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PointFunctions. PointFunctions. class psi4.core.PointFunctions; Bases: BasisFunctions; docstring; Methods Summary. ansatz(self); docstring. compute_points(self,block[,force_compute]); docstring. orbital_values(self); docstring. point_values(self); docstring. print_out(self[,out_fname,print]); docstring. set_ansatz(self,arg0); docstring. set_pointers(*args,**kwargs); Overloaded function. Methods Documentation. ansatz(self: psi4.core.PointFunctions)  int; docstring. compute_points(self: psi4.core.PointFunctions, block: psi4.core.BlockOPoints, force_compute: bool = True)  None; docstring. orbital_values(self: psi4.core.PointFunctions)  Dict[str, psi4.core.Matrix]; docstring. point_values(self: psi4.core.PointFunctions)  Dict[str, psi4.core.Vector]; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str = 'outfile', print: int = 2)  None; docstring. set_ansatz(self: psi4.core.PointFunctions, arg0: int)  None; docstring. set_pointers(*args, **kwargs); Overloaded function. set_pointers(self: psi4.core.PointFunctions, arg0: psi4.core.Matrix) -> None. docstring. set_pointers(self: psi4.core.PointFunctions, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> None. docstring. table of contents. PointFunctions; PointFunctions; PointFunctions.ansatz(); PointFunctions.compute_points(); PointFunctions.orbital_values(); PointFunctions.point_values(); PointFunctions.print_out(); PointFunctions.set_ansatz(); PointFunctions.set_pointers(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PointFunctions.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.PointFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.PointFunctions.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.PointGroup.html:1390,Deployability,update,updated,1390,". PointGroup. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PointGroup. PointGroup. class psi4.core.PointGroup; Bases: pybind11_object; Contains information about the point group; Methods Summary. bits(self); Return the bit representation of the point group. char_table(self); Return the CharacterTable of the point group. full_name(self); Return the Schoenflies symbol with direction. order(self); Return the order of the point group. symbol(self); Returns Schoenflies symbol for point group. Methods Documentation. bits(self: psi4.core.PointGroup)  int; Return the bit representation of the point group. char_table(self: psi4.core.PointGroup)  psi4.core.CharacterTable; Return the CharacterTable of the point group. full_name(self: psi4.core.PointGroup)  str; Return the Schoenflies symbol with direction. order(self: psi4.core.PointGroup)  int; Return the order of the point group. symbol(self: psi4.core.PointGroup)  str; Returns Schoenflies symbol for point group. table of contents. PointGroup; PointGroup; PointGroup.bits(); PointGroup.char_table(); PointGroup.full_name(); PointGroup.order(); PointGroup.symbol(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PointGroup.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.PointGroup.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.PointGroup.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.PotentialInt.html:478,Deployability,update,updated,478,". PotentialInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PotentialInt. PotentialInt. class psi4.core.PotentialInt; Bases: OneBodyAOInt; Computes potential integrals. table of contents. PotentialInt; PotentialInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PotentialInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.PotentialInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.PotentialInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.prepare_options_for_module.html:637,Deployability,update,updated,637,". prepare_options_for_module. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module. prepare_options_for_module. psi4.core.prepare_options_for_module(name: str)  None; Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). table of contents. prepare_options_for_module; prepare_options_for_module(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.prepare_options_for_module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.prepare_options_for_module.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.prepare_options_for_module.html:323,Modifiability,plugin,plugin,323,". prepare_options_for_module. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module. prepare_options_for_module. psi4.core.prepare_options_for_module(name: str)  None; Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). table of contents. prepare_options_for_module; prepare_options_for_module(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.prepare_options_for_module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.prepare_options_for_module.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.PrimitiveType.html:818,Deployability,update,updated,818,". PrimitiveType. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PrimitiveType. PrimitiveType. class psi4.core.PrimitiveType; Bases: pybind11_object; May be Normalized or Unnormalized; Members:. Normalized; Unnormalized. Attributes Summary. Normalized. Unnormalized. name. value. Attributes Documentation. Normalized = <PrimitiveType.Normalized: 0>. Unnormalized = <PrimitiveType.Unnormalized: 1>. name. value. table of contents. PrimitiveType; PrimitiveType; PrimitiveType.Normalized; PrimitiveType.Unnormalized; PrimitiveType.name; PrimitiveType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PrimitiveType.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.PrimitiveType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.PrimitiveType.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.print_global_options.html:562,Deployability,update,updated,562,". print_global_options. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; print_global_options. print_global_options. psi4.core.print_global_options()  None; Prints the currently set global (all modules) options to the output file. table of contents. print_global_options; print_global_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; print_global_options.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.print_global_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.print_global_options.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.print_options.html:517,Deployability,update,updated,517,". print_options. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; print_options. print_options. psi4.core.print_options()  None; Prints the currently set options (to the output file) for the current module. table of contents. print_options; print_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; print_options.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.print_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.print_options.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.print_out.html:486,Deployability,update,updated,486,". print_out. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; print_out. print_out. psi4.core.print_out(arg0: str)  None; Prints a string (using sprintf-like notation) to the output file. table of contents. print_out; print_out(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; print_out.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.print_out.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.print_out.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.print_variables.html:528,Deployability,update,updated,528,". print_variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; print_variables. print_variables. psi4.core.print_variables()  None; Prints to output file all QCVariables that have been set in global memory. table of contents. print_variables; print_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; print_variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.print_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.print_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Prop.html:406,Deployability,update,updated,406,". Prop. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Prop. Prop. class psi4.core.Prop; Bases: pybind11_object; docstring. table of contents. Prop; Prop. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Prop.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Prop.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ProtoIntVector.html:465,Deployability,update,updated,465,". ProtoIntVector. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ProtoIntVector. ProtoIntVector. class psi4.core.ProtoIntVector; Bases: pybind11_object. table of contents. ProtoIntVector; ProtoIntVector. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ProtoIntVector.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ProtoIntVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ProtoIntVector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ProtoVector.html:444,Deployability,update,updated,444,". ProtoVector. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ProtoVector. ProtoVector. class psi4.core.ProtoVector; Bases: pybind11_object. table of contents. ProtoVector; ProtoVector. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ProtoVector.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ProtoVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ProtoVector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.psimrcc.html:489,Deployability,update,updated,489,". psimrcc. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; psimrcc. psimrcc. psi4.core.psimrcc(arg0: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the multireference coupled cluster code. table of contents. psimrcc; psimrcc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; psimrcc.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.psimrcc.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.psio_entry.html:448,Deployability,update,updated,448,". psio_entry. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; psio_entry. psio_entry. class psi4.core.psio_entry; Bases: pybind11_object; docstring. table of contents. psio_entry; psio_entry. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; psio_entry.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.psio_entry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.psio_entry.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.PsiReturnType.html:759,Deployability,update,updated,759,". PsiReturnType. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType. PsiReturnType. class psi4.core.PsiReturnType; Bases: pybind11_object; Return status.; Members:. Success; Failure. Attributes Summary. Failure. Success. name. value. Attributes Documentation. Failure = <PsiReturnType.Failure: 1>. Success = <PsiReturnType.Success: 0>. name. value. table of contents. PsiReturnType; PsiReturnType; PsiReturnType.Failure; PsiReturnType.Success; PsiReturnType.name; PsiReturnType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.PsiReturnType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.PsiReturnType.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.psi_top_srcdir.html:486,Deployability,update,updated,486,". psi_top_srcdir. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; psi_top_srcdir. psi_top_srcdir. psi4.core.psi_top_srcdir()  str; Returns the location of the source code. table of contents. psi_top_srcdir; psi_top_srcdir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; psi_top_srcdir.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.psi_top_srcdir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.psi_top_srcdir.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.QuadrupoleInt.html:486,Deployability,update,updated,486,". QuadrupoleInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; QuadrupoleInt. QuadrupoleInt. class psi4.core.QuadrupoleInt; Bases: OneBodyAOInt; Computes quadrupole integrals. table of contents. QuadrupoleInt; QuadrupoleInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; QuadrupoleInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.QuadrupoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.QuadrupoleInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.reopen_outfile.html:471,Deployability,update,updated,471,". reopen_outfile. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; reopen_outfile. reopen_outfile. psi4.core.reopen_outfile()  None; Reopens the output file. table of contents. reopen_outfile; reopen_outfile(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; reopen_outfile.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.reopen_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.reopen_outfile.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.revoke_global_option_changed.html:911,Deployability,update,updated,911,". revoke_global_option_changed. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; revoke_global_option_changed. revoke_global_option_changed. psi4.core.revoke_global_option_changed(key: str)  None; Clear the touched status for keyword key at global (all-module) scope. Sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. table of contents. revoke_global_option_changed; revoke_global_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; revoke_global_option_changed.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.revoke_global_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.revoke_global_option_changed.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.revoke_local_option_changed.html:904,Deployability,update,updated,904,". revoke_local_option_changed. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; revoke_local_option_changed. revoke_local_option_changed. psi4.core.revoke_local_option_changed(module: str, key: str)  None; Clear the touched status for keyword key at module scope. Sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. table of contents. revoke_local_option_changed; revoke_local_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; revoke_local_option_changed.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.revoke_local_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.revoke_local_option_changed.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.RHF.html:1546,Deployability,update,updated,1546,". RHF. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; RHF. RHF. class psi4.core.RHF; Bases: HF; docstring; Methods Summary. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock,...); docstring. diis(self,arg0); docstring. mintshelper(self); The MintsHelper object. twoel_Hx_full(self,arg0,arg1,arg2,arg3); Two-electron Hessian-vector products. Methods Documentation. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet)  psi4.core.RHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, max_diis_vectors); docstring. Return type:; float. Parameters:. save_fock (bool)  ; max_diis_vectors (int)  . diis(self: psi4.core.HF, arg0: float)  bool; docstring. mintshelper(self: psi4.core.RHF)  psi4.core.MintsHelper; The MintsHelper object. twoel_Hx_full(self: psi4.core.RHF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str, arg3: bool)  List[psi4.core.Matrix]; Two-electron Hessian-vector products. Triplet supported. table of contents. RHF; RHF; RHF.c1_deep_copy(); RHF.compute_orbital_gradient(); RHF.diis(); RHF.mintshelper(); RHF.twoel_Hx_full(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; RHF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.RHF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.RHF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.RKSFunctions.html:461,Deployability,update,updated,461,". RKSFunctions. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; RKSFunctions. RKSFunctions. class psi4.core.RKSFunctions; Bases: PointFunctions; docstring. table of contents. RKSFunctions; RKSFunctions. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; RKSFunctions.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.RKSFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.RKSFunctions.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ROHF.html:2060,Deployability,update,updated,2060,"re.ROHF; Bases: HF; docstring; Methods Summary. Ct(self); MO coefficients in the orthogonalized MO basis. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock,...); docstring. diis(self,arg0); docstring. mintshelper(self); The MintsHelper object. moFa(self); docstring. moFb(self); docstring. moFeff(self); docstring. soFeff(self); Returns the effective Fock matrix in the orthogonalized SO basis. Methods Documentation. Ct(self: psi4.core.ROHF)  psi4.core.Matrix; MO coefficients in the orthogonalized MO basis. Differs from the standard C matrix by an orthogonalizer matrix. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet)  psi4.core.ROHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, max_diis_vectors); docstring. Return type:; float. Parameters:. save_fock (bool)  ; max_diis_vectors (int)  . diis(self: psi4.core.HF, arg0: float)  bool; docstring. mintshelper(self: psi4.core.ROHF)  psi4.core.MintsHelper; The MintsHelper object. moFa(self: psi4.core.ROHF)  psi4.core.Matrix; docstring. moFb(self: psi4.core.ROHF)  psi4.core.Matrix; docstring. moFeff(self: psi4.core.ROHF)  psi4.core.Matrix; docstring. soFeff(self: psi4.core.ROHF)  psi4.core.Matrix; Returns the effective Fock matrix in the orthogonalized SO basis. See libscf_solver/rohf.cc::form_Cfor technical definition. table of contents. ROHF; ROHF; ROHF.Ct(); ROHF.c1_deep_copy(); ROHF.compute_orbital_gradient(); ROHF.diis(); ROHF.mintshelper(); ROHF.moFa(); ROHF.moFb(); ROHF.moFeff(); ROHF.soFeff(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ROHF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ROHF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ROHF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.run_gdma.html:484,Deployability,update,updated,484,". run_gdma. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; run_gdma. run_gdma. psi4.core.run_gdma(ref_wfn: psi4.core.Wavefunction, datfilename: str)  float; Runs the GDMA interface code. table of contents. run_gdma; run_gdma(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; run_gdma.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.run_gdma.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.run_gdma.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.run_gdma.html:232,Integrability,interface,interface,232,". run_gdma. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; run_gdma. run_gdma. psi4.core.run_gdma(ref_wfn: psi4.core.Wavefunction, datfilename: str)  float; Runs the GDMA interface code. table of contents. run_gdma; run_gdma(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; run_gdma.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.run_gdma.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.run_gdma.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SADGuess.html:1370,Deployability,update,updated,1370,". SADGuess. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SADGuess. SADGuess. class psi4.core.SADGuess; Bases: pybind11_object; docstring; Methods Summary. Ca(self). Cb(self). Da(self). Db(self). build_SAD(arg0,arg1). compute_guess(self). set_atomic_fit_bases(self,arg0). set_debug(self,arg0). set_print(self,arg0). Methods Documentation. Ca(self: psi4.core.SADGuess)  psi4.core.Matrix. Cb(self: psi4.core.SADGuess)  psi4.core.Matrix. Da(self: psi4.core.SADGuess)  psi4.core.Matrix. Db(self: psi4.core.SADGuess)  psi4.core.Matrix. static build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet])  psi4.core.SADGuess. compute_guess(self: psi4.core.SADGuess)  None. set_atomic_fit_bases(self: psi4.core.SADGuess, arg0: List[psi4.core.BasisSet])  None. set_debug(self: psi4.core.SADGuess, arg0: int)  None. set_print(self: psi4.core.SADGuess, arg0: int)  None. table of contents. SADGuess; SADGuess; SADGuess.Ca(); SADGuess.Cb(); SADGuess.Da(); SADGuess.Db(); SADGuess.build_SAD(); SADGuess.compute_guess(); SADGuess.set_atomic_fit_bases(); SADGuess.set_debug(); SADGuess.set_print(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SADGuess.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SADGuess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SADGuess.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SalcComponent.html:981,Deployability,update,updated,981,". SalcComponent. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SalcComponent. SalcComponent. class psi4.core.SalcComponent; Bases: pybind11_object; Component of a Cartesian displacement SALC in the basis of atomic displacements.; Attributes Summary. atom; The index of the atom being displaced. coef; The coefficient of the displacement. xyz; The direction of the displacement, given by x as 0, y as 1, z as 2. Attributes Documentation. atom; The index of the atom being displaced. 0-indexed. coef; The coefficient of the displacement. xyz; The direction of the displacement, given by x as 0, y as 1, z as 2. table of contents. SalcComponent; SalcComponent; SalcComponent.atom; SalcComponent.coef; SalcComponent.xyz. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SalcComponent.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SalcComponent.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SalcComponent.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.sapt.html:532,Deployability,update,updated,532,". sapt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; sapt. sapt. psi4.core.sapt(dimer_wfn: psi4.core.Wavefunction, monoa_wfn: psi4.core.Wavefunction, monob_wfn: psi4.core.Wavefunction)  float; Runs the symmetry adapted perturbation theory code. table of contents. sapt; sapt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; sapt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.sapt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.sapt.html:274,Energy Efficiency,adapt,adapted,274,". sapt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; sapt. sapt. psi4.core.sapt(dimer_wfn: psi4.core.Wavefunction, monoa_wfn: psi4.core.Wavefunction, monob_wfn: psi4.core.Wavefunction)  float; Runs the symmetry adapted perturbation theory code. table of contents. sapt; sapt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; sapt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.sapt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.sapt.html:274,Modifiability,adapt,adapted,274,". sapt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; sapt. sapt. psi4.core.sapt(dimer_wfn: psi4.core.Wavefunction, monoa_wfn: psi4.core.Wavefunction, monob_wfn: psi4.core.Wavefunction)  float; Runs the symmetry adapted perturbation theory code. table of contents. sapt; sapt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; sapt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.sapt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SaveType.html:810,Deployability,update,updated,810,". SaveType. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SaveType. SaveType. class psi4.core.SaveType; Bases: pybind11_object; The layout of the matrix for saving; Members:. Full; SubBlocks; LowerTriangle. Attributes Summary. Full. LowerTriangle. SubBlocks. name. value. Attributes Documentation. Full = <SaveType.Full: 0>. LowerTriangle = <SaveType.LowerTriangle: 2>. SubBlocks = <SaveType.SubBlocks: 1>. name. value. table of contents. SaveType; SaveType; SaveType.Full; SaveType.LowerTriangle; SaveType.SubBlocks; SaveType.name; SaveType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SaveType.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SaveType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SaveType.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.scalar_variable.html:535,Deployability,update,updated,535,". scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scalar_variable. scalar_variable. psi4.core.scalar_variable(key: str)  float; Returns the double QCVariable key (case-insensitive); prefer variable(). table of contents. scalar_variable; scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scalar_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.scalar_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.scalar_variable.html:266,Modifiability,variab,variable,266,". scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scalar_variable. scalar_variable. psi4.core.scalar_variable(key: str)  float; Returns the double QCVariable key (case-insensitive); prefer variable(). table of contents. scalar_variable; scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scalar_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.scalar_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.scalar_variables.html:538,Deployability,update,updated,538,". scalar_variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scalar_variables. scalar_variables. psi4.core.scalar_variables()  Dict[str, float]; Returns dictionary of all double QCVariables; prefer variables(). table of contents. scalar_variables; scalar_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scalar_variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.scalar_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.scalar_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.scalar_variables.html:265,Modifiability,variab,variables,265,". scalar_variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scalar_variables. scalar_variables. psi4.core.scalar_variables()  Dict[str, float]; Returns dictionary of all double QCVariables; prefer variables(). table of contents. scalar_variables; scalar_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scalar_variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.scalar_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.scalar_variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.scatter.html:492,Deployability,update,updated,492,". scatter. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scatter. scatter. psi4.core.scatter(arg0: psi4.core.Molecule, arg1: float, arg2: list, arg3: list, arg4: list)  None; New Scatter function. table of contents. scatter; scatter(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scatter.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.scatter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.scatter.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.scfgrad.html:491,Deployability,update,updated,491,". scfgrad. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scfgrad. scfgrad. psi4.core.scfgrad(ref_wfn: psi4.core.HF)  psi4.core.Matrix; Run scfgrad, which is a specialized DF-SCF gradient program. table of contents. scfgrad; scfgrad(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scfgrad.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.scfgrad.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.scfgrad.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.scfhess.html:490,Deployability,update,updated,490,". scfhess. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scfhess. scfhess. psi4.core.scfhess(ref_wfn: psi4.core.HF)  psi4.core.Matrix; Run scfhess, which is a specialized DF-SCF hessian program. table of contents. scfhess; scfhess(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; scfhess.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.scfhess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.scfhess.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_active_molecule.html:595,Deployability,update,updated,595,". set_active_molecule. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_active_molecule. set_active_molecule. psi4.core.set_active_molecule(molecule: psi4.core.Molecule)  None; Activates a previously defined molecule in global memory so next computations use it. table of contents. set_active_molecule; set_active_molecule(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_active_molecule.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_active_molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_active_molecule.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_array_variable.html:587,Deployability,update,updated,587,". set_array_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_array_variable. set_array_variable. psi4.core.set_array_variable(key: str, value: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). table of contents. set_array_variable; set_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_array_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_array_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_datadir.html:492,Deployability,update,updated,492,". set_datadir. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_datadir. set_datadir. psi4.core.set_datadir(psidatadir: str)  None; Sets the path to shared text resources, PSIDATADIR. table of contents. set_datadir; set_datadir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_datadir.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_datadir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_datadir.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_global_option.html:895,Deployability,update,updated,895,". set_global_option. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_global_option. set_global_option. psi4.core.set_global_option(*args, **kwargs); Overloaded function. set_global_option(key: str, value: list) -> bool. Sets value to array keyword key for all modules. set_global_option(key: str, value: int) -> bool. Sets value to integer keyword key for all modules. set_global_option(key: str, value: float) -> bool. Sets value to double keyword key for all modules. set_global_option(key: str, value: str) -> bool. Sets value to string keyword key for all modules. table of contents. set_global_option; set_global_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_global_option.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_global_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_global_option_python.html:682,Deployability,update,updated,682,". set_global_option_python. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_global_option_python. set_global_option_python. psi4.core.set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul. table of contents. set_global_option_python; set_global_option_python(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_global_option_python.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_global_option_python.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_global_option_python.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_global_option_python.html:311,Integrability,rout,routing,311,". set_global_option_python. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_global_option_python. set_global_option_python. psi4.core.set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul. table of contents. set_global_option_python; set_global_option_python(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_global_option_python.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_global_option_python.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_global_option_python.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_local_option.html:996,Deployability,update,updated,996,". set_local_option. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_local_option. set_local_option. psi4.core.set_local_option(*args, **kwargs); Overloaded function. set_local_option(module: str, key: str, value: list) -> bool. Sets value to array keyword key scoped only to specific module. set_local_option(module: str, key: str, value: int) -> bool. Sets value to integer keyword key scoped only to specific module. set_local_option(module: str, key: str, value: float) -> bool. Sets value to double keyword key scoped only to specific module. set_local_option(module: str, key: str, value: str) -> bool. Sets value to string keyword key scoped only to specific module. table of contents. set_local_option; set_local_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_local_option.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_local_option.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_local_option_python.html:597,Deployability,update,updated,597,". set_local_option_python. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_local_option_python. set_local_option_python. psi4.core.set_local_option_python(key: str, value: object)  None; Sets value to Python keyword key scoped only to a single module. table of contents. set_local_option_python; set_local_option_python(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_local_option_python.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_local_option_python.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_local_option_python.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_memory_bytes.html:248,Availability,avail,available,248,". set_memory_bytes. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_memory_bytes. set_memory_bytes. psi4.core.set_memory_bytes(memory: int, quiet: bool = False)  None; Sets the memory available to Psi (in bytes); prefer psi4.driver.set_memory(). table of contents. set_memory_bytes; set_memory_bytes(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_memory_bytes.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_memory_bytes.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_memory_bytes.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_memory_bytes.html:570,Deployability,update,updated,570,". set_memory_bytes. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_memory_bytes. set_memory_bytes. psi4.core.set_memory_bytes(memory: int, quiet: bool = False)  None; Sets the memory available to Psi (in bytes); prefer psi4.driver.set_memory(). table of contents. set_memory_bytes; set_memory_bytes(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_memory_bytes.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_memory_bytes.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_memory_bytes.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_num_threads.html:550,Deployability,update,updated,550,". set_num_threads. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_num_threads. set_num_threads. psi4.core.set_num_threads(nthread: int, quiet: bool = False)  None; Sets the number of threads to use in SMP parallel computations. table of contents. set_num_threads; set_num_threads(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_num_threads.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_num_threads.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_output_file.html:634,Deployability,update,updated,634,". set_output_file. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_output_file. set_output_file. psi4.core.set_output_file(*args, **kwargs); Overloaded function. set_output_file(arg0: str) -> None; set_output_file(ofname: str, append: bool = False) -> None. Set the name for output file; prefer set_output_file(). table of contents. set_output_file; set_output_file(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_output_file.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_output_file.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_output_file.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_psi_file_prefix.html:511,Deployability,update,updated,511,". set_psi_file_prefix. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_psi_file_prefix. set_psi_file_prefix. psi4.core.set_psi_file_prefix()  None. Deprecated since version 1.4. table of contents. set_psi_file_prefix; set_psi_file_prefix(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_psi_file_prefix.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_psi_file_prefix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_psi_file_prefix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_scalar_variable.html:577,Deployability,update,updated,577,". set_scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_scalar_variable. set_scalar_variable. psi4.core.set_scalar_variable(key: str, value: float)  None; Sets the double QCVariable key (case-insensitive); prefer set_variable(). table of contents. set_scalar_variable; set_scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_scalar_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_scalar_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_variable.html:1001,Deployability,update,updated,1001,". set_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_variable. set_variable. psi4.core.set_variable(key, val); Sets scalar or array QCVariable key to; val in global memory. Parameters:. key (str)  Case-insensitive key to global double or Matrix; storage maps.; val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. table of contents. set_variable; set_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_variable.html:479,Energy Efficiency,charge,charge,479,". set_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_variable. set_variable. psi4.core.set_variable(key, val); Sets scalar or array QCVariable key to; val in global memory. Parameters:. key (str)  Case-insensitive key to global double or Matrix; storage maps.; val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. table of contents. set_variable; set_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_variable.html:655,Modifiability,variab,variable,655,". set_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_variable. set_variable. psi4.core.set_variable(key, val); Sets scalar or array QCVariable key to; val in global memory. Parameters:. key (str)  Case-insensitive key to global double or Matrix; storage maps.; val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. table of contents. set_variable; set_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_variable.html:723,Modifiability,variab,variable,723,". set_variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_variable. set_variable. psi4.core.set_variable(key, val); Sets scalar or array QCVariable key to; val in global memory. Parameters:. key (str)  Case-insensitive key to global double or Matrix; storage maps.; val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. table of contents. set_variable; set_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; set_variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.set_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.set_variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ShellInfo.html:430,Deployability,update,updated,430,". ShellInfo. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ShellInfo. ShellInfo. class psi4.core.ShellInfo; Bases: pybind11_object. table of contents. ShellInfo; ShellInfo. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ShellInfo.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ShellInfo.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ShellInfo.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Slice.html:799,Deployability,update,updated,799,". Slice. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Slice. Slice. class psi4.core.Slice; Bases: pybind11_object; Slicing for Matrix and Vector objects; Methods Summary. begin(self); Get the first element of this slice. end(self); Get the past-the-end element of this slice. Methods Documentation. begin(self: psi4.core.Slice)  psi4.core.Dimension; Get the first element of this slice. end(self: psi4.core.Slice)  psi4.core.Dimension; Get the past-the-end element of this slice. table of contents. Slice; Slice; Slice.begin(); Slice.end(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Slice.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Slice.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Slice.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SOBasisSet.html:815,Deployability,update,updated,815,". SOBasisSet. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SOBasisSet. SOBasisSet. class psi4.core.SOBasisSet; Bases: pybind11_object; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis.; Methods Summary. petite_list(self); Return the PetiteList object used in creating this SO basis. Methods Documentation. petite_list(self: psi4.core.SOBasisSet)  psi4.core.PetiteList; Return the PetiteList object used in creating this SO basis. table of contents. SOBasisSet; SOBasisSet; SOBasisSet.petite_list(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SOBasisSet.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SOBasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SOBasisSet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SOMCSCF.html:639,Deployability,update,update,639,". SOMCSCF. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SOMCSCF. SOMCSCF. class psi4.core.SOMCSCF; Bases: pybind11_object; docstring; Methods Summary. Ck(self,arg0,arg1). H_approx_diag(self). approx_solve(self). compute_AFock(self,arg0). compute_Hk(self,arg0). compute_Q(self,arg0). compute_Qk(self,arg0,arg1,arg2). current_AFock(self). current_IFock(self). current_ci_energy(self). current_docc_energy(self). current_total_energy(self). form_rotation_matrix(self,x[,order]). gradient(self). gradient_rms(self). rhf_energy(self,arg0). solve(self,arg0,arg1,arg2). update(self,arg0,arg1,arg2,arg3,arg4). zero_redundant(self,arg0). Methods Documentation. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix. H_approx_diag(self: psi4.core.SOMCSCF)  psi4.core.Matrix. approx_solve(self: psi4.core.SOMCSCF)  psi4.core.Matrix. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int = 2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCS",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SOMCSCF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SOMCSCF.html:1973,Deployability,update,update,1973,"si4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int = 2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. table of contents. SOMCSCF; SOMCSCF; SOMCSCF.Ck(); SOMCSCF.H_approx_diag(); SOMCSCF.approx_solve(); SOMCSCF.compute_AFock(); SOMCSCF.compute_Hk(); SOMCSCF.compute_Q(); SOMCSCF.compute_Qk(); SOMCSCF.current_AFock(); SOMCSCF.current_IFock(); SOMCSCF.current_ci_energy(); SOMCSCF.current_docc_energy(); SOMCSCF.current_total_energy(); SOMCSCF.form_rotation_matrix(); SOMCSCF.gradient(); SOMCSCF.gradient_rms(); SOMCSCF.rhf_energy(); SOMCSCF.solve(); SOMCSCF.update(); SOMCSCF.zero_redundant(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SOMCSCF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SOMCSCF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SOMCSCF.html:2662,Deployability,update,update,2662,"si4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int = 2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. table of contents. SOMCSCF; SOMCSCF; SOMCSCF.Ck(); SOMCSCF.H_approx_diag(); SOMCSCF.approx_solve(); SOMCSCF.compute_AFock(); SOMCSCF.compute_Hk(); SOMCSCF.compute_Q(); SOMCSCF.compute_Qk(); SOMCSCF.current_AFock(); SOMCSCF.current_IFock(); SOMCSCF.current_ci_energy(); SOMCSCF.current_docc_energy(); SOMCSCF.current_total_energy(); SOMCSCF.form_rotation_matrix(); SOMCSCF.gradient(); SOMCSCF.gradient_rms(); SOMCSCF.rhf_energy(); SOMCSCF.solve(); SOMCSCF.update(); SOMCSCF.zero_redundant(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SOMCSCF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SOMCSCF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SOMCSCF.html:2892,Deployability,update,updated,2892,"si4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int = 2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. table of contents. SOMCSCF; SOMCSCF; SOMCSCF.Ck(); SOMCSCF.H_approx_diag(); SOMCSCF.approx_solve(); SOMCSCF.compute_AFock(); SOMCSCF.compute_Hk(); SOMCSCF.compute_Q(); SOMCSCF.compute_Qk(); SOMCSCF.current_AFock(); SOMCSCF.current_IFock(); SOMCSCF.current_ci_energy(); SOMCSCF.current_docc_energy(); SOMCSCF.current_total_energy(); SOMCSCF.form_rotation_matrix(); SOMCSCF.gradient(); SOMCSCF.gradient_rms(); SOMCSCF.rhf_energy(); SOMCSCF.solve(); SOMCSCF.update(); SOMCSCF.zero_redundant(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SOMCSCF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SOMCSCF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html:13123,Deployability,update,updated,13123,"citation(); SuperFunctional.compute_functional(); SuperFunctional.density_tolerance(); SuperFunctional.deriv(); SuperFunctional.description(); SuperFunctional.grac_alpha(); SuperFunctional.grac_beta(); SuperFunctional.grac_shift(); SuperFunctional.is_c_hybrid(); SuperFunctional.is_c_lrc(); SuperFunctional.is_c_scs_hybrid(); SuperFunctional.is_gga(); SuperFunctional.is_libxc_func(); SuperFunctional.is_meta(); SuperFunctional.is_x_hybrid(); SuperFunctional.is_x_lrc(); SuperFunctional.max_points(); SuperFunctional.name(); SuperFunctional.needs_grac(); SuperFunctional.needs_vv10(); SuperFunctional.needs_xc(); SuperFunctional.print_density_threshold(); SuperFunctional.print_detail(); SuperFunctional.print_out(); SuperFunctional.set_c_alpha(); SuperFunctional.set_c_omega(); SuperFunctional.set_c_os_alpha(); SuperFunctional.set_c_ss_alpha(); SuperFunctional.set_citation(); SuperFunctional.set_density_tolerance(); SuperFunctional.set_deriv(); SuperFunctional.set_description(); SuperFunctional.set_do_vv10(); SuperFunctional.set_grac_alpha(); SuperFunctional.set_grac_beta(); SuperFunctional.set_grac_shift(); SuperFunctional.set_lock(); SuperFunctional.set_max_points(); SuperFunctional.set_name(); SuperFunctional.set_vv10_b(); SuperFunctional.set_vv10_c(); SuperFunctional.set_x_alpha(); SuperFunctional.set_x_beta(); SuperFunctional.set_x_omega(); SuperFunctional.set_xclib_description(); SuperFunctional.test_functional(); SuperFunctional.value(); SuperFunctional.values(); SuperFunctional.vv10_b(); SuperFunctional.vv10_c(); SuperFunctional.x_alpha(); SuperFunctional.x_beta(); SuperFunctional.x_functional(); SuperFunctional.x_functionals(); SuperFunctional.x_omega(); SuperFunctional.xclib_description(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SuperFunctional.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html:427,Energy Efficiency,allocate,allocate,427,". SuperFunctional. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SuperFunctional. SuperFunctional. class psi4.core.SuperFunctional; Bases: pybind11_object; docstring; Methods Summary. XC_build(arg0,arg1); Builds a SuperFunctional from a XC string. add_c_functional(self,arg0); Add a correlation Functional. add_x_functional(self,arg0); Add a exchange Functional. allocate(self); Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self); SuperFunctional rung. blank(); Initialize a blank SuperFunctional. c_alpha(self); Amount of MP2 correlation. c_functional(self,arg0); Returns the desired C Functional. c_functionals(self); Returns all C Functionals. c_omega(self); Range-seperated correlation parameter. c_os_alpha(self); Amount of SS MP2 correlation. c_ss_alpha(self); Amount of OS MP2 correlation. citation(self); SuperFunctional citation. compute_functional(self,vals[,npoints,...]); Computes the SuperFunctional. density_tolerance(self); Density threshold for LibXC. deriv(self); Maximum derivative to compute. description(self); The description of the SuperFunctional. grac_alpha(self); GRAC Alpha. grac_beta(self); GRAC Beta. grac_shift(self); Shift of the bulk potenital. is_c_hybrid(self); Requires MP2 correlation?. is_c_lrc(self); Contains range-seperated correlation?. is_c_scs_hybrid(self); Requires SCS-MP2 correlation?. is_gga(self); Is this a GGA?. is_libxc_func(self); A full SuperFunctional definition from LibXC. is_meta(self); Is this a MGGA?. is_x_hybrid(self); Requires exact exchange?. is_x_lrc(self); Contains range-seperated exchange?. max_points(self); Maximum number of grid points per block. name(self); The name of the SuperFunctional. needs_grac(self); Does this functional need GRAC. needs_vv10(self); Does this functional need VV10 dispersion. needs_xc(self); Does this functional need XC quantities. print_density_threshold(self); Queries the LibXCFunctionals for their ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html:4400,Energy Efficiency,allocate,allocate,4400," set_xclib_description(self,arg0); Sets the LibXC version and citation string. test_functional(self,arg0,arg1,arg2,...); Quick testing capabilities. value(self,arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self,arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. xclib_description(self); LibXC version and citation string. Methods Documentation. static XC_build(arg0: str, arg1: bool)  psi4.core.SuperFunctional; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional)  None; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional)  None; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional)  None; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional)  int; SuperFunctional rung. static blank()  psi4.core.SuperFunctional; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional)  float; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str)  psi4.core.Functional; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional)  List[psi4.core.Functional]; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional)  float; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional)  float; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional)  float; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional)  str; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, vals: Dict[str, psi4.core.Vector], npoints: int = -",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html:10944,Energy Efficiency,allocate,allocate,10944,"rnal value. values(self: psi4.core.SuperFunctional)  Dict[str, psi4.core.Vector]; Return all internal values. vv10_b(self: psi4.core.SuperFunctional)  float; The VV10 b parameter. vv10_c(self: psi4.core.SuperFunctional)  float; The VV10 c parameter. x_alpha(self: psi4.core.SuperFunctional)  float; Amount of exact HF exchange. x_beta(self: psi4.core.SuperFunctional)  float; Amount of exact HF exchange. x_functional(self: psi4.core.SuperFunctional, arg0: str)  psi4.core.Functional; Returns the desired X Functional. x_functionals(self: psi4.core.SuperFunctional)  List[psi4.core.Functional]; Returns all X Functionals. x_omega(self: psi4.core.SuperFunctional)  float; Range-seperated exchange parameter. xclib_description(self: psi4.core.SuperFunctional)  str; LibXC version and citation string. table of contents. SuperFunctional; SuperFunctional; SuperFunctional.XC_build(); SuperFunctional.add_c_functional(); SuperFunctional.add_x_functional(); SuperFunctional.allocate(); SuperFunctional.ansatz(); SuperFunctional.blank(); SuperFunctional.c_alpha(); SuperFunctional.c_functional(); SuperFunctional.c_functionals(); SuperFunctional.c_omega(); SuperFunctional.c_os_alpha(); SuperFunctional.c_ss_alpha(); SuperFunctional.citation(); SuperFunctional.compute_functional(); SuperFunctional.density_tolerance(); SuperFunctional.deriv(); SuperFunctional.description(); SuperFunctional.grac_alpha(); SuperFunctional.grac_beta(); SuperFunctional.grac_shift(); SuperFunctional.is_c_hybrid(); SuperFunctional.is_c_lrc(); SuperFunctional.is_c_scs_hybrid(); SuperFunctional.is_gga(); SuperFunctional.is_libxc_func(); SuperFunctional.is_meta(); SuperFunctional.is_x_hybrid(); SuperFunctional.is_x_lrc(); SuperFunctional.max_points(); SuperFunctional.name(); SuperFunctional.needs_grac(); SuperFunctional.needs_vv10(); SuperFunctional.needs_xc(); SuperFunctional.print_density_threshold(); SuperFunctional.print_detail(); SuperFunctional.print_out(); SuperFunctional.set_c_alpha(); SuperFun",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html:3541,Testability,test,testing,3541,"_deriv(self,arg0); Sets the derivative level. set_description(self,arg0); Sets the SuperFunctional description. set_do_vv10(self,arg0); Sets whether to do VV10 correction. set_grac_alpha(self,arg0); Sets the GRAC alpha parameter. set_grac_beta(self,arg0); Sets the GRAC beta parameter. set_grac_shift(self,arg0); Sets the GRAC bulk shift value. set_lock(self,arg0); Locks the functional to prevent changes. set_max_points(self,arg0); Sets the maximum number of points. set_name(self,arg0); Sets the SuperFunctional name. set_vv10_b(self,arg0); Sets the VV10 b parameter. set_vv10_c(self,arg0); Sets the VV10 c parameter. set_x_alpha(self,arg0); Sets the amount of exact global HF exchange. set_x_beta(self,arg0); Sets how much more long-range exchange than short-range exchange. set_x_omega(self,arg0); Sets the range-seperation exchange parameter. set_xclib_description(self,arg0); Sets the LibXC version and citation string. test_functional(self,arg0,arg1,arg2,...); Quick testing capabilities. value(self,arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self,arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. xclib_description(self); LibXC version and citation string. Methods Documentation. static XC_build(arg0: str, arg1: bool)  psi4.core.SuperFunctional; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional)  None; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional)  None; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional)  None; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.S",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html:9845,Testability,test,testing,9845,"er of points. set_name(self: psi4.core.SuperFunctional, arg0: str)  None; Sets the SuperFunctional name. set_vv10_b(self: psi4.core.SuperFunctional, arg0: float)  None; Sets the VV10 b parameter. set_vv10_c(self: psi4.core.SuperFunctional, arg0: float)  None; Sets the VV10 c parameter. set_x_alpha(self: psi4.core.SuperFunctional, arg0: float)  None; Sets the amount of exact global HF exchange. set_x_beta(self: psi4.core.SuperFunctional, arg0: float)  None; Sets how much more long-range exchange than short-range exchange. set_x_omega(self: psi4.core.SuperFunctional, arg0: float)  None; Sets the range-seperation exchange parameter. set_xclib_description(self: psi4.core.SuperFunctional, arg0: str)  None; Sets the LibXC version and citation string. test_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Vector, arg1: psi4.core.Vector, arg2: psi4.core.Vector, arg3: psi4.core.Vector, arg4: psi4.core.Vector, arg5: psi4.core.Vector, arg6: psi4.core.Vector)  None; Quick testing capabilities. value(self: psi4.core.SuperFunctional, arg0: str)  psi4.core.Vector; Returns a given internal value. values(self: psi4.core.SuperFunctional)  Dict[str, psi4.core.Vector]; Return all internal values. vv10_b(self: psi4.core.SuperFunctional)  float; The VV10 b parameter. vv10_c(self: psi4.core.SuperFunctional)  float; The VV10 c parameter. x_alpha(self: psi4.core.SuperFunctional)  float; Amount of exact HF exchange. x_beta(self: psi4.core.SuperFunctional)  float; Amount of exact HF exchange. x_functional(self: psi4.core.SuperFunctional, arg0: str)  psi4.core.Functional; Returns the desired X Functional. x_functionals(self: psi4.core.SuperFunctional)  List[psi4.core.Functional]; Returns all X Functionals. x_omega(self: psi4.core.SuperFunctional)  float; Range-seperated exchange parameter. xclib_description(self: psi4.core.SuperFunctional)  str; LibXC version and citation string. table of contents. SuperFunctional; SuperFunctional; SuperFunctional.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.SymmetryOperation.html:3639,Deployability,update,updated,3639,"e matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation)  psi4.core.SymmetryOperation; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int)  None; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float)  None; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation)  None; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation)  None; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation)  None; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation)  float; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation)  psi4.core.SymmetryOperation; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation)  None; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation)  None; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation)  None; Zero out the symmetry operation. table of contents. SymmetryOperation; SymmetryOperation; SymmetryOperation.E(); SymmetryOperation.c2_x(); SymmetryOperation.c2_y(); SymmetryOperation.c2_z(); SymmetryOperation.i(); SymmetryOperation.matrix(); SymmetryOperation.operate(); SymmetryOperation.rotate_n(); SymmetryOperation.rotate_theta(); SymmetryOperation.sigma_xy(); SymmetryOperation.sigma_xz(); SymmetryOperation.sigma_yz(); SymmetryOperation.trace(); SymmetryOperation.transform(); SymmetryOperation.transpose(); SymmetryOperation.unit(); SymmetryOperation.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.SymmetryOperation.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SymmetryOperation.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.test_matrix_dpd_interface.html:523,Deployability,update,updated,523,". test_matrix_dpd_interface. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; test_matrix_dpd_interface. test_matrix_dpd_interface. psi4.core.test_matrix_dpd_interface()  bool. table of contents. test_matrix_dpd_interface; test_matrix_dpd_interface(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; test_matrix_dpd_interface.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.test_matrix_dpd_interface.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.test_matrix_dpd_interface.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.ThreeCenterOverlapInt.html:845,Deployability,update,updated,845,". ThreeCenterOverlapInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ThreeCenterOverlapInt. ThreeCenterOverlapInt. class psi4.core.ThreeCenterOverlapInt; Bases: pybind11_object; Three center overlap integrals; Methods Summary. compute_shell(self,arg0,arg1,arg2); Compute the integrals of the form (a|b|c). Methods Documentation. compute_shell(self: psi4.core.ThreeCenterOverlapInt, arg0: int, arg1: int, arg2: int)  None; Compute the integrals of the form (a|b|c). table of contents. ThreeCenterOverlapInt; ThreeCenterOverlapInt; ThreeCenterOverlapInt.compute_shell(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ThreeCenterOverlapInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.ThreeCenterOverlapInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ThreeCenterOverlapInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.timer_off.html:444,Deployability,update,updated,444,". timer_off. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; timer_off. timer_off. psi4.core.timer_off(label: str)  None; Stop timer with label. table of contents. timer_off; timer_off(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; timer_off.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.timer_off.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.timer_off.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.timer_on.html:485,Deployability,update,updated,485,". timer_on. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; timer_on. timer_on. psi4.core.timer_on(label: str)  None; Start timer with label. Needs to be paired with psi4.core.timer_off(). table of contents. timer_on; timer_on(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; timer_on.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.timer_on.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.timer_on.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.TLaplaceDenominator.html:1326,Deployability,update,updated,1326,". TLaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; TLaplaceDenominator. TLaplaceDenominator. class psi4.core.TLaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the six-index energy denominator in coupled-cluster theory; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized triples denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized triples denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.TLaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized triples denominator (nweights * nocc). denominator_vir(self: psi4.core.TLaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized triples denominator (nweights * nvirt). table of contents. TLaplaceDenominator; TLaplaceDenominator; TLaplaceDenominator.denominator_occ(); TLaplaceDenominator.denominator_vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; TLaplaceDenominator.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.TLaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.TLaplaceDenominator.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.TLaplaceDenominator.html:293,Energy Efficiency,energy,energy,293,". TLaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; TLaplaceDenominator. TLaplaceDenominator. class psi4.core.TLaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the six-index energy denominator in coupled-cluster theory; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized triples denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized triples denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.TLaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized triples denominator (nweights * nocc). denominator_vir(self: psi4.core.TLaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized triples denominator (nweights * nvirt). table of contents. TLaplaceDenominator; TLaplaceDenominator; TLaplaceDenominator.denominator_occ(); TLaplaceDenominator.denominator_vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; TLaplaceDenominator.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.TLaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.TLaplaceDenominator.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.TracelessQuadrupoleInt.html:559,Deployability,update,updated,559,". TracelessQuadrupoleInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; TracelessQuadrupoleInt. TracelessQuadrupoleInt. class psi4.core.TracelessQuadrupoleInt; Bases: OneBodyAOInt; Computes traceless quadrupole integrals. table of contents. TracelessQuadrupoleInt; TracelessQuadrupoleInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; TracelessQuadrupoleInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.TracelessQuadrupoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.TracelessQuadrupoleInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.triplet.html:1108,Deployability,update,updated,1108,". triplet. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; triplet. triplet. psi4.core.triplet(A: psi4.core.Matrix, B: psi4.core.Matrix, C: psi4.core.Matrix, transA: bool = False, transB: bool = False, transC: bool = False)  psi4.core.Matrix; Returns the multiplication of three matrices, with options to transpose each beforehand. Parameters:. A  First matrix to multiply.; B  Second matrix to multiply.; C  Third matrix to multiply.; transA  Transpose the first matrix before operations?; transB  Transpose the second matrix before operations?; transC  Transpose the third matrix before operations?. Returns:; New matrix of ABC. Return type:; Matrix. Notes. (AB)C vs. A(BC) selected by cost analysis of overall (not per-irrep) dimensions.; If A, B, C not of the the same symmetry, always computed as (AB)C. table of contents. triplet; triplet(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; triplet.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.triplet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.triplet.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.tstart.html:441,Deployability,update,updated,441,". tstart. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; tstart. tstart. psi4.core.tstart()  None; Start module-level timer. Only one active at once. table of contents. tstart; tstart(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; tstart.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.tstart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.tstart.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.tstop.html:457,Deployability,update,updated,457,". tstop. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; tstop. tstop. psi4.core.tstop()  None; Stop module-level timer. Prints user, system, and total times to outfile. table of contents. tstop; tstop(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; tstop.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.tstop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.tstop.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.TwoBodyAOInt.html:1363,Deployability,update,updated,1363,". TwoBodyAOInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; TwoBodyAOInt. TwoBodyAOInt. class psi4.core.TwoBodyAOInt; Bases: pybind11_object; Two body integral base class; Methods Summary. compute_shell(self,arg0,arg1,arg2,arg3); Compute ERIs between 4 shells. shell_significant(self,arg0,arg1,arg2,arg3); Determines if the P,Q,R,S shell combination is significant. update_density(self,arg0); Update density matrix (c1 symmetry) for Density-matrix based integral screening. Methods Documentation. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; Compute ERIs between 4 shells. shell_significant(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  bool; Determines if the P,Q,R,S shell combination is significant. update_density(self: psi4.core.TwoBodyAOInt, arg0: List[psi4.core.Matrix])  None; Update density matrix (c1 symmetry) for Density-matrix based integral screening. table of contents. TwoBodyAOInt; TwoBodyAOInt; TwoBodyAOInt.compute_shell(); TwoBodyAOInt.shell_significant(); TwoBodyAOInt.update_density(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; TwoBodyAOInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.TwoBodyAOInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.TwoBodyAOInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.TwoElectronInt.html:1090,Deployability,update,updated,1090,". TwoElectronInt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; TwoElectronInt. TwoElectronInt. class psi4.core.TwoElectronInt; Bases: TwoBodyAOInt; Computes two-electron repulsion integrals; Methods Summary. compute_shell(self,arg0,arg1,arg2,arg3); Compute ERIs between 4 shells. shell_significant(self,arg0,arg1,arg2,arg3); Determines if the P,Q,R,S shell combination is significant. Methods Documentation. compute_shell(self: psi4.core.TwoElectronInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; Compute ERIs between 4 shells. shell_significant(self: psi4.core.TwoElectronInt, arg0: int, arg1: int, arg2: int, arg3: int)  bool; Determines if the P,Q,R,S shell combination is significant. table of contents. TwoElectronInt; TwoElectronInt; TwoElectronInt.compute_shell(); TwoElectronInt.shell_significant(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; TwoElectronInt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.TwoElectronInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.TwoElectronInt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.UHF.html:1452,Deployability,update,updated,1452,". UHF. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; UHF. UHF. class psi4.core.UHF; Bases: HF; docstring; Methods Summary. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock,...); docstring. diis(self,arg0); docstring. mintshelper(self); The MintsHelper object. stability_analysis(self); Assess wfn stability and correct if requested. Methods Documentation. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet)  psi4.core.UHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, max_diis_vectors); docstring. Return type:; float. Parameters:. save_fock (bool)  ; max_diis_vectors (int)  . diis(self: psi4.core.HF, arg0: float)  bool; docstring. mintshelper(self: psi4.core.UHF)  psi4.core.MintsHelper; The MintsHelper object. stability_analysis(self: psi4.core.HF)  bool; Assess wfn stability and correct if requested. table of contents. UHF; UHF; UHF.c1_deep_copy(); UHF.compute_orbital_gradient(); UHF.diis(); UHF.mintshelper(); UHF.stability_analysis(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; UHF.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.UHF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.UHF.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.UKSFunctions.html:461,Deployability,update,updated,461,". UKSFunctions. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; UKSFunctions. UKSFunctions. class psi4.core.UKSFunctions; Bases: PointFunctions; docstring. table of contents. UKSFunctions; UKSFunctions. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; UKSFunctions.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.UKSFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.UKSFunctions.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:1370,Deployability,update,updated,1370,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:474,Energy Efficiency,charge,charges,474,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:3,Modifiability,variab,variable,3,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:117,Modifiability,variab,variable,117,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:127,Modifiability,variab,variable,127,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:148,Modifiability,variab,variable,148,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:377,Modifiability,variab,variables,377,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:418,Modifiability,variab,variables,418,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:548,Modifiability,variab,variables,548,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:778,Modifiability,variab,variable,778,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:836,Modifiability,variab,variable,836,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:906,Modifiability,variab,variable,906,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:987,Modifiability,variab,variable,987,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:1153,Modifiability,variab,variable,1153,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:1163,Modifiability,variab,variable,1163,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html:1313,Modifiability,variab,variable,1313,". variable. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:985,Deployability,update,updated,985,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:524,Energy Efficiency,charge,charges,524,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:3,Modifiability,variab,variables,3,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:118,Modifiability,variab,variables,118,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:129,Modifiability,variab,variables,129,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:151,Modifiability,variab,variables,151,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:427,Modifiability,variab,variables,427,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:468,Modifiability,variab,variables,468,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:598,Modifiability,variab,variables,598,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:765,Modifiability,variab,variables,765,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:776,Modifiability,variab,variables,776,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html:927,Modifiability,variab,variables,927,". variables. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.VBase.html:4412,Deployability,update,updated,4412,"l(self: psi4.core.VBase)  psi4.core.SuperFunctional; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int)  psi4.core.BlockOPoints; Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. Parameters:; self (VBase)  VBase instance. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray]. grid(self: psi4.core.VBase)  psi4.core.DFTGrid; Returns the grid object. initialize(*args, **kwargs); Overloaded function. initialize(self: psi4.core.VBase) -> None. doctsring. initialize(self: psi4.core.VBase) -> None. Initializes the V object. nblocks(self: psi4.core.VBase)  int; Total number of blocks. print_header(self: psi4.core.VBase)  None; Prints the objects header. properties(self: psi4.core.VBase)  List[psi4.core.PointFunctions]; Returns the properties computer. quadrature_values(self: psi4.core.VBase)  Dict[str, float]; Returns the quadrature values. set_D(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; Sets the internal density. set_debug(self: psi4.core.VBase, arg0: int)  None; Sets the debug level of the object. set_print(self: psi4.core.VBase, arg0: int)  None; Sets the print level of the object. table of contents. VBase; VBase; VBase.Dao(); VBase.basis(); VBase.build(); VBase.build_collocation_cache(); VBase.clear_collocation_cache(); VBase.compute_V(); VBase.compute_Vx(); VBase.compute_gradient(); VBase.compute_hessain(); VBase.finalize(); VBase.functional(); VBase.get_block(); VBase.get_np_xyzw(); VBase.grid(); VBase.initialize(); VBase.nblocks(); VBase.print_header(); VBase.properties(); VBase.quadrature_values(); VBase.set_D(); VBase.set_debug(); VBase.set_print(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; VBase.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.VBase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.VBase.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.VBase.html:383,Performance,cache,cache,383,". VBase. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; VBase. VBase. class psi4.core.VBase; Bases: pybind11_object; docstring; Methods Summary. Dao(self,arg0); Returns internal AO density. basis(self); Returns the internal basis set. build(arg0,arg1,arg2). build_collocation_cache(self,arg0); Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self); Clears the collocation cache. compute_V(self,arg0); doctsring. compute_Vx(self,arg0,arg1); doctsring. compute_gradient(self); Compute the DFT nuclear gradient contribution. compute_hessain(self); Compute the DFT nuclear Hessian contribution. finalize(*args,**kwargs); Overloaded function. functional(self); Returns the interal superfunctional. get_block(self,arg0); Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args,**kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self,arg0); Sets the internal density. set_debug(self,arg0); Sets the debug level of the object. set_print(self,arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; Returns internal AO density. basis(self: psi4.core.VBase)  psi4.core.BasisSet; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str)  psi4.core.VBase. build_collocation_cache(self: psi4.core.VBase, arg0: int)  None; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase)  None; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; doctsring. compute_Vx(se",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.VBase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.VBase.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.VBase.html:469,Performance,cache,cache,469,". VBase. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; VBase. VBase. class psi4.core.VBase; Bases: pybind11_object; docstring; Methods Summary. Dao(self,arg0); Returns internal AO density. basis(self); Returns the internal basis set. build(arg0,arg1,arg2). build_collocation_cache(self,arg0); Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self); Clears the collocation cache. compute_V(self,arg0); doctsring. compute_Vx(self,arg0,arg1); doctsring. compute_gradient(self); Compute the DFT nuclear gradient contribution. compute_hessain(self); Compute the DFT nuclear Hessian contribution. finalize(*args,**kwargs); Overloaded function. functional(self); Returns the interal superfunctional. get_block(self,arg0); Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args,**kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self,arg0); Sets the internal density. set_debug(self,arg0); Sets the debug level of the object. set_print(self,arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; Returns internal AO density. basis(self: psi4.core.VBase)  psi4.core.BasisSet; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str)  psi4.core.VBase. build_collocation_cache(self: psi4.core.VBase, arg0: int)  None; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase)  None; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; doctsring. compute_Vx(se",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.VBase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.VBase.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.VBase.html:1787,Performance,cache,cache,1787," superfunctional. get_block(self,arg0); Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args,**kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self,arg0); Sets the internal density. set_debug(self,arg0); Sets the debug level of the object. set_print(self,arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; Returns internal AO density. basis(self: psi4.core.VBase)  psi4.core.BasisSet; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str)  psi4.core.VBase. build_collocation_cache(self: psi4.core.VBase, arg0: int)  None; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase)  None; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; doctsring. compute_Vx(self: psi4.core.VBase, arg0: List[psi4.core.Matrix], arg1: List[psi4.core.Matrix])  None; doctsring. compute_gradient(self: psi4.core.VBase)  psi4.core.Matrix; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase)  psi4.core.Matrix; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs); Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase)  psi4.core.SuperFunctional; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int)  psi4.core.BlockOPoints; Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array ob",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.VBase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.VBase.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.VBase.html:1898,Performance,cache,cache,1898,", y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args,**kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self,arg0); Sets the internal density. set_debug(self,arg0); Sets the debug level of the object. set_print(self,arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; Returns internal AO density. basis(self: psi4.core.VBase)  psi4.core.BasisSet; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str)  psi4.core.VBase. build_collocation_cache(self: psi4.core.VBase, arg0: int)  None; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase)  None; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; doctsring. compute_Vx(self: psi4.core.VBase, arg0: List[psi4.core.Matrix], arg1: List[psi4.core.Matrix])  None; doctsring. compute_gradient(self: psi4.core.VBase)  psi4.core.Matrix; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase)  psi4.core.Matrix; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs); Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase)  psi4.core.SuperFunctional; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int)  psi4.core.BlockOPoints; Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. Parameters:; self (VBase)  VBase instance. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.VBase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.VBase.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:8780,Deployability,update,updated,8780,"dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector)  float; Take the dot product of two vectors. zero(self: psi4.core.Vector)  None; Zeros the vector. table of contents. Vector; Vector; Vector.name; Vector.np; Vector.nph; Vector.shape; Vector.add(); Vector.array_interface(); Vector.axpby(); Vector.axpy(); Vector.clone(); Vector.copy(); Vector.dim(); Vector.dimpi(); Vector.from_array(); Vector.from_list(); Vector.from_serial(); Vector.get(); Vector.get_block(); Vector.init(); Vector.load(); Vector.nirrep(); Vector.np_read(); Vector.np_write(); Vector.print_out(); Vector.save(); Vector.scale(); Vector.set(); Vector.set_block(); Vector.to_array(); Vector.to_serial(); Vector.vector_dot(); Vector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Vector.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:7335,Integrability,depend,depending,7335,"ore.IO, file: int)  None; Save the vector to disk. scale(self: psi4.core.Vector, sc: float)  None; Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.ProtoVector)  None; Set a vector block. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector)  float; Take the dot product of two vectors. zero(self: psi4.core.Vector)  None; Zeros the vector. table of contents. Vector; Vector; Vector.name; Vector.np; Vector.nph; Vector.shape; Vector.add(); Vector.array_interface(); Vector.axpby(); Vector.axpy(); Vector.clone(); Vector.copy(); Vector.dim(); Vector.dimpi(); Vector.from_array(); Vector.from_list(); Vector.from_serial(); Vector.get(",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:1209,Performance,load,load,1209,"Summary. name; The name of the Vector. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Summary. add(*args,**kwargs); Overloaded function. array_interface(self). axpby(self,a,b,other); Adds to this vector scaled by b another vector scaled by a; self <- a * other + b * self. axpy(self,a,other); Adds to this vector (unscaled) another vector scaled by a; self <- a * other + self. clone(self); Clone the vector. copy(self,arg0); Copy another vector into this. dim(self[,h]); Returns the dimensions of the vector per irrep h. dimpi(self); Returns the Dimension object. from_array([name,dim1,dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. get(*args,**kwargs); Overloaded function. get_block(self,slice); Get a vector block. init(self,arg0); Reallocate the data of the Vector. load(self,psio,file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). print_out(self); Prints the vector to the output file. save(self,psio,file); Save the vector to disk. scale(self,sc); Scales the elements of a vector by sc. set(*args,**kwargs); Overloaded function. set_block(self,slice,block); Set a vector block. to_array([copy,dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self,other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name; The name of the Vector. Used in printing. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. add(*args, **kwargs); Overload",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:1395,Performance,load,load,1395,"; Overloaded function. array_interface(self). axpby(self,a,b,other); Adds to this vector scaled by b another vector scaled by a; self <- a * other + b * self. axpy(self,a,other); Adds to this vector (unscaled) another vector scaled by a; self <- a * other + self. clone(self); Clone the vector. copy(self,arg0); Copy another vector into this. dim(self[,h]); Returns the dimensions of the vector per irrep h. dimpi(self); Returns the Dimension object. from_array([name,dim1,dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. get(*args,**kwargs); Overloaded function. get_block(self,slice); Get a vector block. init(self,arg0); Reallocate the data of the Vector. load(self,psio,file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). print_out(self); Prints the vector to the output file. save(self,psio,file); Save the vector to disk. scale(self,sc); Scales the elements of a vector by sc. set(*args,**kwargs); Overloaded function. set_block(self,slice,block); Set a vector block. to_array([copy,dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self,other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name; The name of the Vector. Used in printing. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. add(*args, **kwargs); Overloaded function. add(self: psi4.core.Vector, m: int, val: float) -> None. Add to a single element value located at m. add(self: psi4.core.Vector, h: int, m: int, val: fl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:5134,Performance,load,load,5134,"4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). classmethod from_list(x). classmethod from_serial(); Converts serialized data to the correct Psi4 data type. Parameters:. self  Pointer to which class to be constructed.; json_data (Dict[str, Any])  Serialization of class. See to_serial() for data layout. Return type:; Union[Matrix, Vector]. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice)  psi4.core.Vector; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension)  None; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int)  None; Load the vector from disk. nirrep(self: psi4.core.Vector)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict seriali",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:5405,Performance,load,load,5405,"erial(); Converts serialized data to the correct Psi4 data type. Parameters:. self  Pointer to which class to be constructed.; json_data (Dict[str, Any])  Serialization of class. See to_serial() for data layout. Return type:; Union[Matrix, Vector]. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice)  psi4.core.Vector; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension)  None; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int)  None; Load the vector from disk. nirrep(self: psi4.core.Vector)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. print_out(self: psi4.core.Vector)  None; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int)  None; Save the vector to disk. scale(self: psi4.core.Vector, sc: flo",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:8365,Performance,load,load,8365,"dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector)  float; Take the dot product of two vectors. zero(self: psi4.core.Vector)  None; Zeros the vector. table of contents. Vector; Vector; Vector.name; Vector.np; Vector.nph; Vector.shape; Vector.add(); Vector.array_interface(); Vector.axpby(); Vector.axpy(); Vector.clone(); Vector.copy(); Vector.dim(); Vector.dimpi(); Vector.from_array(); Vector.from_list(); Vector.from_serial(); Vector.get(); Vector.get_block(); Vector.init(); Vector.load(); Vector.nirrep(); Vector.np_read(); Vector.np_write(); Vector.print_out(); Vector.save(); Vector.scale(); Vector.set(); Vector.set_block(); Vector.to_array(); Vector.to_serial(); Vector.vector_dot(); Vector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Vector.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:1884,Security,access,accessor,1884,"umPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. get(*args,**kwargs); Overloaded function. get_block(self,slice); Get a vector block. init(self,arg0); Reallocate the data of the Vector. load(self,psio,file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). print_out(self); Prints the vector to the output file. save(self,psio,file); Save the vector to disk. scale(self,sc); Scales the elements of a vector by sc. set(*args,**kwargs); Overloaded function. set_block(self,slice,block); Set a vector block. to_array([copy,dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self,other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name; The name of the Vector. Used in printing. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. add(*args, **kwargs); Overloaded function. add(self: psi4.core.Vector, m: int, val: float) -> None. Add to a single element value located at m. add(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Add to a single element value located at m in irrep h. array_interface(self: psi4.core.Vector)  list. axpby(self: psi4.core.Vector, a: float, b: float, other: psi4.core.Vector)  None; Adds to this vector scaled by b another vector scaled by a; self <- a * other + b * self. axpy(self: psi4.core.Vector, a: float, other: psi4.core.Vector)  None; Adds to this vector (unscaled) another vector scaled by a; self <- a * other + self. clone(self: psi4.core.Vector)  psi4.core.Vector; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:7630,Security,access,accessor,7630,", val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.ProtoVector)  None; Set a vector block. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector)  float; Take the dot product of two vectors. zero(self: psi4.core.Vector)  None; Zeros the vector. table of contents. Vector; Vector; Vector.name; Vector.np; Vector.nph; Vector.shape; Vector.add(); Vector.array_interface(); Vector.axpby(); Vector.axpy(); Vector.clone(); Vector.copy(); Vector.dim(); Vector.dimpi(); Vector.from_array(); Vector.from_list(); Vector.from_serial(); Vector.get(); Vector.get_block(); Vector.init(); Vector.load(); Vector.nirrep(); Vector.np_read(); Vector.np_write(); Vector.print_out(); Vector.save(); Vector.scale(); Vector.set(); Vector.set_block(); Vector.to_array(); Vector.to_serial(); Vector.vector_dot(); Vector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. module",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:6952,Usability,simpl,simply,6952," Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. print_out(self: psi4.core.Vector)  None; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int)  None; Save the vector to disk. scale(self: psi4.core.Vector, sc: float)  None; Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.ProtoVector)  None; Set a vector block. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector)  float; Take the dot pr",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector3.html:1479,Deployability,update,updated,1479,". Vector3. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Vector3. Vector3. class psi4.core.Vector3; Bases: pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; Methods Summary. cross(self,arg0); Returns cross product of arg1 and arg2. distance(self,arg0); Returns distance between two points represented by arg1 and arg2. dot(self,arg0); Returns dot product of arg1 and arg2. norm(self); Returns Euclidean norm of arg1. normalize(self); Returns vector of unit length and arg1 direction. Methods Documentation. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  psi4.core.Vector3; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  float; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  float; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3)  float; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3)  None; Returns vector of unit length and arg1 direction. table of contents. Vector3; Vector3; Vector3.cross(); Vector3.distance(); Vector3.dot(); Vector3.norm(); Vector3.normalize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Vector3.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Vector3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector3.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.version.html:427,Deployability,update,updated,427,". version. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; version. version. psi4.core.version()  None. Deprecated since version 1.4. table of contents. version; version(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; version.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.version.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.version.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:32580,Deployability,update,updated,32580," Wavefunction.get_basisset(); Wavefunction.get_density(); Wavefunction.get_dipole_field_strength(); Wavefunction.get_print(); Wavefunction.get_scratch_filename(); Wavefunction.get_variable(); Wavefunction.gradient(); Wavefunction.has_array_variable(); Wavefunction.has_potential_variable(); Wavefunction.has_scalar_variable(); Wavefunction.has_variable(); Wavefunction.hessian(); Wavefunction.lagrangian(); Wavefunction.mintshelper(); Wavefunction.mo_extents(); Wavefunction.module(); Wavefunction.molecule(); Wavefunction.nalpha(); Wavefunction.nalphapi(); Wavefunction.name(); Wavefunction.nbeta(); Wavefunction.nbetapi(); Wavefunction.nfrzc(); Wavefunction.nirrep(); Wavefunction.nmo(); Wavefunction.nmopi(); Wavefunction.no_occupations(); Wavefunction.nso(); Wavefunction.nsopi(); Wavefunction.options(); Wavefunction.potential_variable(); Wavefunction.potential_variables(); Wavefunction.reference_wavefunction(); Wavefunction.same_a_b_dens(); Wavefunction.same_a_b_orbs(); Wavefunction.scalar_variable(); Wavefunction.scalar_variables(); Wavefunction.set_array(); Wavefunction.set_array_variable(); Wavefunction.set_basisset(); Wavefunction.set_energy(); Wavefunction.set_external_potential(); Wavefunction.set_gradient(); Wavefunction.set_hessian(); Wavefunction.set_lagrangian(); Wavefunction.set_module(); Wavefunction.set_name(); Wavefunction.set_potential_variable(); Wavefunction.set_print(); Wavefunction.set_reference_wavefunction(); Wavefunction.set_scalar_variable(); Wavefunction.set_variable(); Wavefunction.shallow_copy(); Wavefunction.sobasisset(); Wavefunction.soccpi(); Wavefunction.to_file(); Wavefunction.variable(); Wavefunction.variables(); Wavefunction.write_molden(); Wavefunction.write_nbo(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Wavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:1562,Energy Efficiency,charge,charges,1562,"sted Alpha Density subset. Db(self); Returns the Beta Density Matrix. Db_subset(self,arg0); Returns the requested Beta Density subset. Fa(self); Returns the Alpha Fock Matrix. Fa_subset(self,arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self,arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the 'Core' Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. alpha_orbital_space(self,id,basis,subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self,arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) doubl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:2043,Energy Efficiency,energy,energy,2043,"ation. S(self); Returns the One-electron Overlap Matrix. alpha_orbital_space(self,id,basis,subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self,arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subs",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:2761,Energy Efficiency,energy,energy,2761,",arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:2769,Energy Efficiency,energy,energy,2769,"sis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:2810,Energy Efficiency,energy,energy,2810,"sis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:6513,Energy Efficiency,energy,energy,6513,". nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar or array QCVariable key to val on self. shallow_copy(self,arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmet",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:11655,Energy Efficiency,charge,charges,11655,"ut the requested alpha orbital space. Parameters:. id  Unique name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set. Parameters:. mol (Molecule)  Molecule for which to build the wavefunction instance.; basis (Union[None, str, BasisSet])  Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool)  When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunctio",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:12874,Energy Efficiency,energy,energy,12874," basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set. Parameters:. mol (Molecule)  Molecule for which to build the wavefunction instance.; basis (Union[None, str, BasisSet])  Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool)  When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet)  psi4.core.Wavefunction; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key; from self if present. Parameters:. self (Wavefunction)  Wav",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:14209,Energy Efficiency,energy,energy,14209,"on)  None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key; from self if present. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Alpha orbital energies subset. Parameters:. basis  {AO, SO, MO}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:14217,Energy Efficiency,energy,energy,14217," data. del_array_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key; from self if present. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Alpha orbital energies subset. Parameters:. basis  {AO, SO, MO}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Beta orbital energies ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:14291,Energy Efficiency,energy,energy,14291,"vefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key; from self if present. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Alpha orbital energies subset. Parameters:. basis  {AO, SO, MO}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Beta orbital energies subset. Parameters:. basis  {AO, SO, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:22262,Energy Efficiency,energy,energy,22262,"l; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefuncti",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:24350,Energy Efficiency,charge,charge,24350,". (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to; val on self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return c",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:25697,Energy Efficiency,charge,charges,25697,")  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:26782,Energy Efficiency,charge,charges,26782," are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool])  Do write all the MOs to the MOLDEN file (True) or d",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:27312,Energy Efficiency,energy,energy,27312,"np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool])  Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NOs. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUAL.; use_natural (bool)  Write natural orbitals determined from density on wavefunction.; self (Wavefunction)  . Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:28096,Energy Efficiency,energy,energy,28096,"to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool])  Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NOs. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUAL.; use_natural (bool)  Write natural orbitals determined from density on wavefunction.; self (Wavefunction)  . Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; properties or gradient must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.; The first two arguments of get_opdm(); can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:28251,Energy Efficiency,energy,energy,28251,"he density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool])  Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NOs. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUAL.; use_natural (bool)  Write natural orbitals determined from density on wavefunction.; self (Wavefunction)  . Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; properties or gradient must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.; The first two arguments of get_opdm(); can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name); Write wavefunction information in wfn to name in NBO format. Parameters:; name (str)  ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:28973,Energy Efficiency,energy,energy,28973,"elf (Wavefunction)  . Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; properties or gradient must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.; The first two arguments of get_opdm(); can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name); Write wavefunction information in wfn to name in NBO format. Parameters:; name (str)  Destination file name for NBO file. table of contents. Wavefunction; Wavefunction; Wavefunction.Ca(); Wavefunction.Ca_subset(); Wavefunction.Cb(); Wavefunction.Cb_subset(); Wavefunction.Da(); Wavefunction.Da_subset(); Wavefunction.Db(); Wavefunction.Db_subset(); Wavefunction.Fa(); Wavefunction.Fa_subset(); Wavefunction.Fb(); Wavefunction.Fb_subset(); Wavefunction.H(); Wavefunction.PCM_enabled(); Wavefunction.S(); Wavefunction.alpha_orbital_space(); Wavefunction.aotoso(); Wavefunction.array_variable(); Wavefunction.array_variables(); Wavefunction.arrays(); Wavefunction.atomic_point_charges(); Wavefunction.basis_projection(); Wavefunction.basisset(); Wavefunction.beta_orbital_space(); Wavefunction.build(); Wavefunction.c1",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:30319,Energy Efficiency,energy,energy,30319,efunction; Wavefunction.Ca(); Wavefunction.Ca_subset(); Wavefunction.Cb(); Wavefunction.Cb_subset(); Wavefunction.Da(); Wavefunction.Da_subset(); Wavefunction.Db(); Wavefunction.Db_subset(); Wavefunction.Fa(); Wavefunction.Fa_subset(); Wavefunction.Fb(); Wavefunction.Fb_subset(); Wavefunction.H(); Wavefunction.PCM_enabled(); Wavefunction.S(); Wavefunction.alpha_orbital_space(); Wavefunction.aotoso(); Wavefunction.array_variable(); Wavefunction.array_variables(); Wavefunction.arrays(); Wavefunction.atomic_point_charges(); Wavefunction.basis_projection(); Wavefunction.basisset(); Wavefunction.beta_orbital_space(); Wavefunction.build(); Wavefunction.c1_deep_copy(); Wavefunction.compute_energy(); Wavefunction.compute_gradient(); Wavefunction.compute_hessian(); Wavefunction.deep_copy(); Wavefunction.del_array_variable(); Wavefunction.del_potential_variable(); Wavefunction.del_scalar_variable(); Wavefunction.del_variable(); Wavefunction.doccpi(); Wavefunction.efzc(); Wavefunction.energy(); Wavefunction.epsilon_a(); Wavefunction.epsilon_a_subset(); Wavefunction.epsilon_b(); Wavefunction.epsilon_b_subset(); Wavefunction.esp_at_nuclei(); Wavefunction.external_pot(); Wavefunction.force_occpi(); Wavefunction.frequencies(); Wavefunction.from_file(); Wavefunction.frzcpi(); Wavefunction.frzvpi(); Wavefunction.get_array(); Wavefunction.get_basisset(); Wavefunction.get_density(); Wavefunction.get_dipole_field_strength(); Wavefunction.get_print(); Wavefunction.get_scratch_filename(); Wavefunction.get_variable(); Wavefunction.gradient(); Wavefunction.has_array_variable(); Wavefunction.has_potential_variable(); Wavefunction.has_scalar_variable(); Wavefunction.has_variable(); Wavefunction.hessian(); Wavefunction.lagrangian(); Wavefunction.mintshelper(); Wavefunction.mo_extents(); Wavefunction.module(); Wavefunction.molecule(); Wavefunction.nalpha(); Wavefunction.nalphapi(); Wavefunction.name(); Wavefunction.nbeta(); Wavefunction.nbetapi(); Wavefunction.nfrzc(); Wavefunction.nirrep(); Wa,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:1381,Modifiability,variab,variable,1381,"t. Cb(self); Returns the Beta Orbitals. Cb_subset(self,arg0,arg1); Returns the requested Beta orbital subset. Da(self); Returns the Alpha Density Matrix. Da_subset(self,arg0); Returns the requested Alpha Density subset. Db(self); Returns the Beta Density Matrix. Db_subset(self,arg0); Returns the requested Beta Density subset. Fa(self); Returns the Alpha Fock Matrix. Fa_subset(self,arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self,arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the 'Core' Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. alpha_orbital_space(self,id,basis,subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self,arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC va",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:1454,Modifiability,variab,variables,1454,"sted Beta orbital subset. Da(self); Returns the Alpha Density Matrix. Da_subset(self,arg0); Returns the requested Alpha Density subset. Db(self); Returns the Beta Density Matrix. Db_subset(self,arg0); Returns the requested Beta Density subset. Fa(self); Returns the Alpha Fock Matrix. Fa_subset(self,arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self,arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the 'Core' Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. alpha_orbital_space(self,id,basis,subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self,arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:2340,Modifiability,variab,variable,2340,"riable(self,arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:2448,Modifiability,variab,variable,2448,"les(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:2542,Modifiability,variab,variable,2542," atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:4138,Modifiability,variab,variable,4138,"otentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self,arg0); Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self,arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self,arg0); Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:4258,Modifiability,variab,variable,4258,"only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self,arg0); Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self,arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self,arg0); Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); N",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:4409,Modifiability,variab,variable,4409,"(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self,arg0); Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self,arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self,arg0); Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:5757,Modifiability,variab,variable,5757,"ts(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:5849,Modifiability,variab,variables,5849,"t level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name o",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:6165,Modifiability,variab,variable,6165,"ber of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets th",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:6239,Modifiability,variab,variables,6239,"p. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstrin",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:6387,Modifiability,variab,variable,6387,"opi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:7089,Modifiability,variab,variable,7089," the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar or array QCVariable key to val on self. shallow_copy(self,arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self[,assume_socc_alpha]); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Serialize a Wavefunction object. variable(key); Return copy of scalar or array QCVariable key from self. variables([include_deprecated_keys]); Return all scalar or array QCVariables from self. write_molden([filename,do_virtual,use_natural]); Writes wavefunction information in wfn to filename in molden format. write_nbo(name); Write wavefunction information in wfn to name in NBO format. Methods Documentation. Ca(s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:7302,Modifiability,variab,variable,7302,"y,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar or array QCVariable key to val on self. shallow_copy(self,arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self[,assume_socc_alpha]); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Serialize a Wavefunction object. variable(key); Return copy of scalar or array QCVariable key from self. variables([include_deprecated_keys]); Return all scalar or array QCVariables from self. write_molden([filename,do_virtual,use_natural]); Writes wavefunction information in wfn to filename in molden format. write_nbo(name); Write wavefunction information in wfn to name in NBO format. Methods Documentation. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha orbital subset. Parameters:. ba",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:7658,Modifiability,variab,variable,7658,"efunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar or array QCVariable key to val on self. shallow_copy(self,arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self[,assume_socc_alpha]); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Serialize a Wavefunction object. variable(key); Return copy of scalar or array QCVariable key from self. variables([include_deprecated_keys]); Return all scalar or array QCVariables from self. write_molden([filename,do_virtual,use_natural]); Writes wavefunction information in wfn to filename in molden format. write_nbo(name); Write wavefunction information in wfn to name in NBO format. Methods Documentation. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha orbital subset. Parameters:. basis (str)  {SO, AO}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str)  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with respect to c1 symmetry if basis is AO. Return type:; Matr",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:7730,Modifiability,variab,variables,7730,"rix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar or array QCVariable key to val on self. shallow_copy(self,arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self[,assume_socc_alpha]); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Serialize a Wavefunction object. variable(key); Return copy of scalar or array QCVariable key from self. variables([include_deprecated_keys]); Return all scalar or array QCVariables from self. write_molden([filename,do_virtual,use_natural]); Writes wavefunction information in wfn to filename in molden format. write_nbo(name); Write wavefunction information in wfn to name in NBO format. Methods Documentation. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha orbital subset. Parameters:. basis (str)  {SO, AO}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str)  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with respect to c1 symmetry if basis is AO. Return type:; Matrix. Cb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Orbit",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:11287,Modifiability,variab,variable,11287,"the Core Matrix (Potential + Kinetic) Integrals. PCM_enabled(self: psi4.core.Wavefunction)  bool; Whether running a PCM calculation. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str)  psi4.core.OrbitalSpace; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters:. id  Unique name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set. Parameters:. mol (Molecule)  Molecule ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:11304,Modifiability,variab,variable,11304,"s. PCM_enabled(self: psi4.core.Wavefunction)  bool; Whether running a PCM calculation. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str)  psi4.core.OrbitalSpace; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters:. id  Unique name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set. Parameters:. mol (Molecule)  Molecule for which to build the wavefunction instance.; b",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:11434,Modifiability,variab,variables,11434,"vefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str)  psi4.core.OrbitalSpace; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters:. id  Unique name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set. Parameters:. mol (Molecule)  Molecule for which to build the wavefunction instance.; basis (Union[None, str, BasisSet])  Basis set for which to build the wavefunction instance. If a; BasisSet, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:11452,Modifiability,variab,variables,11452," the One-electron Overlap Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str)  psi4.core.OrbitalSpace; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters:. id  Unique name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set. Parameters:. mol (Molecule)  Molecule for which to build the wavefunction instance.; basis (Union[None, str, BasisSet])  Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a nam",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:11533,Modifiability,variab,variables,11533,"tr, basis: str, subset: str)  psi4.core.OrbitalSpace; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters:. id  Unique name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set. Parameters:. mol (Molecule)  Molecule for which to build the wavefunction instance.; basis (Union[None, str, BasisSet])  Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool)  When True, do n",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:13351,Modifiability,variab,variable,13351,"nion[None, str, BasisSet])  Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool)  When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet)  psi4.core.Wavefunction; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key; from self if present. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self:",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:13518,Modifiability,variab,variable,13518,"sis. If None, name taken from BASIS.; quiet (bool)  When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet)  psi4.core.Wavefunction; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key; from self if present. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:13716,Modifiability,variab,variable,13716,"ore.Wavefunction; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key; from self if present. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Alpha orbital energies subset. Parameters:. basis  {AO, SO, MO}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:17063,Modifiability,variab,variable,17063,"oubly and singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies(); Returns the results of a frequency analysis. Parameters:; self  Wavefunction instance. Returns:; A dictionary of vibrational information. See psi4.driver.qcdb.vib.harmonic_analysis(). Return type:; Optional[Dict[str, ndarray]]. static from_file(wfn_data); Build Wavefunction from data laid out like; to_file(). Parameters:; wfn_data (Union[str, Dict, Path])  If a dict, use data directly. Otherwise, path-like passed to; numpy.load() to read from disk. Returns:; A deserialized Wavefunction object. Return type:; Wavefunction. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction)  List[float[3]]; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction)  int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction)  Wavefunction instance.; filenumber (int)  Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the Ma",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:17878,Modifiability,variab,variable,17878,"4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction)  List[float[3]]; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction)  int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction)  Wavefunction instance.; filenumber (int)  Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key; has been set on self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. lagrangian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns t",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:18081,Modifiability,variab,variable,18081,"get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction)  List[float[3]]; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction)  int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction)  Wavefunction instance.; filenumber (int)  Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key; has been set on self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. lagrangian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction)  psi4.core.MintsHelper; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction)  List[psi4.core.Vector]",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:18238,Modifiability,variab,variable,18238,"i4.core.Matrix; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction)  List[float[3]]; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction)  int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction)  Wavefunction instance.; filenumber (int)  Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key; has been set on self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. lagrangian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction)  psi4.core.MintsHelper; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction)  List[psi4.core.Vector]; returns the wavefunctions electronic orbital extents. module(self: psi4.core.Wavefunction)  str; Name of the last/highest level of theory module (internal or external)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:18426,Modifiability,variab,variable,18426,"ield strengths. get_print(self: psi4.core.Wavefunction)  int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction)  Wavefunction instance.; filenumber (int)  Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key; has been set on self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. lagrangian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction)  psi4.core.MintsHelper; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction)  List[psi4.core.Vector]; returns the wavefunctions electronic orbital extents. module(self: psi4.core.Wavefunction)  str; Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self: psi4.core.Wavefunction)  psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction)  int; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:20765,Modifiability,variab,variable,20765,"trons. nbetapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction)  int; Number of frozen core electrons. nirrep(self: psi4.core.Wavefunction)  int; Number of irreps in the system. nmo(self: psi4.core.Wavefunction)  int; Number of molecule orbitals. nmopi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction)  List[List[Tuple[float, int, int]]]; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction)  int; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of symmetry orbitals per irrep. options(self: psi4.core.Wavefunction)  psi::Options; Returns the Wavefunctions options object. potential_variable(self: psi4.core.Wavefunction, key: str)  psi4.core.ExternalPotential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:20991,Modifiability,variab,variables,20991,"t; Number of irreps in the system. nmo(self: psi4.core.Wavefunction)  int; Number of molecule orbitals. nmopi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction)  List[List[Tuple[float, int, int]]]; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction)  int; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of symmetry orbitals per irrep. options(self: psi4.core.Wavefunction)  psi::Options; Returns the Wavefunctions options object. potential_variable(self: psi4.core.Wavefunction, key: str)  psi4.core.ExternalPotential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:21527,Modifiability,variab,variable,21527,"bitals per irrep. options(self: psi4.core.Wavefunction)  psi::Options; Returns the Wavefunctions options object. potential_variable(self: psi4.core.Wavefunction, key: str)  psi4.core.ExternalPotential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:21544,Modifiability,variab,variable,21544," psi::Options; Returns the Wavefunctions options object. potential_variable(self: psi4.core.Wavefunction, key: str)  psi4.core.ExternalPotential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the W",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:21664,Modifiability,variab,variables,21664,"i4.core.Wavefunction, key: str)  psi4.core.ExternalPotential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_he",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:21682,Modifiability,variab,variables,21682,"otential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:21939,Modifiability,variab,variable,21939,"i4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_modu",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:22299,Modifiability,variab,variable,22299,". same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential)  None; S",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:22599,Modifiability,variab,variable,22599,"tion)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential)  None; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:22763,Modifiability,variab,variable,22763,".Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential)  None; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:23354,Modifiability,variab,variable,23354," ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential)  None; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to; val on self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:23772,Modifiability,variab,variable,23772,"ian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential)  None; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to; val on self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:24526,Modifiability,variab,variable,24526,"; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to; val on self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-i",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:24594,Modifiability,variab,variable,24594,"i4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to; val on self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requeste",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:25136,Modifiability,inherit,inherited,25136,"RADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:25339,Modifiability,variab,variable,25339,"ariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:25600,Modifiability,variab,variables,25600,"ype:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecat",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:25641,Modifiability,variab,variables,25641,")  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:25771,Modifiability,variab,variables,25771,"t; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as nd",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:26026,Modifiability,variab,variable,26026,"efunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:26083,Modifiability,variab,variable,26083," (Wavefunction)  Wavefunction or inherited class instance.; filename (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:26152,Modifiability,variab,variable,26152,"e (str)  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals fr",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:26232,Modifiability,variab,variable,26232,"onary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do n",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:26379,Modifiability,variab,variables,26379," self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transform",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:26685,Modifiability,variab,variables,26685,"charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.;",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:26726,Modifiability,variab,variables,26726," are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool])  Do write all the MOs to the MOLDEN file (True) or d",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:26856,Modifiability,variab,variables,26856,"or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool])  Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NOs. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUA",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:32288,Modifiability,variab,variable,32288," Wavefunction.get_basisset(); Wavefunction.get_density(); Wavefunction.get_dipole_field_strength(); Wavefunction.get_print(); Wavefunction.get_scratch_filename(); Wavefunction.get_variable(); Wavefunction.gradient(); Wavefunction.has_array_variable(); Wavefunction.has_potential_variable(); Wavefunction.has_scalar_variable(); Wavefunction.has_variable(); Wavefunction.hessian(); Wavefunction.lagrangian(); Wavefunction.mintshelper(); Wavefunction.mo_extents(); Wavefunction.module(); Wavefunction.molecule(); Wavefunction.nalpha(); Wavefunction.nalphapi(); Wavefunction.name(); Wavefunction.nbeta(); Wavefunction.nbetapi(); Wavefunction.nfrzc(); Wavefunction.nirrep(); Wavefunction.nmo(); Wavefunction.nmopi(); Wavefunction.no_occupations(); Wavefunction.nso(); Wavefunction.nsopi(); Wavefunction.options(); Wavefunction.potential_variable(); Wavefunction.potential_variables(); Wavefunction.reference_wavefunction(); Wavefunction.same_a_b_dens(); Wavefunction.same_a_b_orbs(); Wavefunction.scalar_variable(); Wavefunction.scalar_variables(); Wavefunction.set_array(); Wavefunction.set_array_variable(); Wavefunction.set_basisset(); Wavefunction.set_energy(); Wavefunction.set_external_potential(); Wavefunction.set_gradient(); Wavefunction.set_hessian(); Wavefunction.set_lagrangian(); Wavefunction.set_module(); Wavefunction.set_name(); Wavefunction.set_potential_variable(); Wavefunction.set_print(); Wavefunction.set_reference_wavefunction(); Wavefunction.set_scalar_variable(); Wavefunction.set_variable(); Wavefunction.shallow_copy(); Wavefunction.sobasisset(); Wavefunction.soccpi(); Wavefunction.to_file(); Wavefunction.variable(); Wavefunction.variables(); Wavefunction.write_molden(); Wavefunction.write_nbo(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Wavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:32313,Modifiability,variab,variables,32313," Wavefunction.get_basisset(); Wavefunction.get_density(); Wavefunction.get_dipole_field_strength(); Wavefunction.get_print(); Wavefunction.get_scratch_filename(); Wavefunction.get_variable(); Wavefunction.gradient(); Wavefunction.has_array_variable(); Wavefunction.has_potential_variable(); Wavefunction.has_scalar_variable(); Wavefunction.has_variable(); Wavefunction.hessian(); Wavefunction.lagrangian(); Wavefunction.mintshelper(); Wavefunction.mo_extents(); Wavefunction.module(); Wavefunction.molecule(); Wavefunction.nalpha(); Wavefunction.nalphapi(); Wavefunction.name(); Wavefunction.nbeta(); Wavefunction.nbetapi(); Wavefunction.nfrzc(); Wavefunction.nirrep(); Wavefunction.nmo(); Wavefunction.nmopi(); Wavefunction.no_occupations(); Wavefunction.nso(); Wavefunction.nsopi(); Wavefunction.options(); Wavefunction.potential_variable(); Wavefunction.potential_variables(); Wavefunction.reference_wavefunction(); Wavefunction.same_a_b_dens(); Wavefunction.same_a_b_orbs(); Wavefunction.scalar_variable(); Wavefunction.scalar_variables(); Wavefunction.set_array(); Wavefunction.set_array_variable(); Wavefunction.set_basisset(); Wavefunction.set_energy(); Wavefunction.set_external_potential(); Wavefunction.set_gradient(); Wavefunction.set_hessian(); Wavefunction.set_lagrangian(); Wavefunction.set_module(); Wavefunction.set_name(); Wavefunction.set_potential_variable(); Wavefunction.set_print(); Wavefunction.set_reference_wavefunction(); Wavefunction.set_scalar_variable(); Wavefunction.set_variable(); Wavefunction.shallow_copy(); Wavefunction.sobasisset(); Wavefunction.soccpi(); Wavefunction.to_file(); Wavefunction.variable(); Wavefunction.variables(); Wavefunction.write_molden(); Wavefunction.write_nbo(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; Wavefunction.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html:16656,Performance,load,load,16656,"als. Return type:; Vector. esp_at_nuclei(self: psi4.core.Wavefunction)  psi4.core.Vector; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction)  psi4.core.ExternalPotential; Gets the requested external potential. force_occpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension, arg1: psi4.core.Dimension)  None; Specialized expert use only. Sets the number of doubly and singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies(); Returns the results of a frequency analysis. Parameters:; self  Wavefunction instance. Returns:; A dictionary of vibrational information. See psi4.driver.qcdb.vib.harmonic_analysis(). Return type:; Optional[Dict[str, ndarray]]. static from_file(wfn_data); Build Wavefunction from data laid out like; to_file(). Parameters:; wfn_data (Union[str, Dict, Path])  If a dict, use data directly. Otherwise, path-like passed to; numpy.load() to read from disk. Returns:; A deserialized Wavefunction object. Return type:; Wavefunction. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction)  List[float[3]]; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction)  int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefu",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.activate.html:599,Deployability,update,updated,599,". activate. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; activate. activate. psi4.driver.activate(mol)[source]; Function to set molecule object mol as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. Parameters:; mol (Molecule)  . table of contents. activate; activate(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; activate.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.activate.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.activate.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:2795,Availability,error,error,2795,"efault"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additionalProperties"": false; },; ""NativeFilesProtocolEnum"": {; ""title"": ""NativeFilesProtocolEnum"",; ""description"": ""CMS program files to keep from a computation."",; ""enum"": [; ""all"",; ""input"",; ""none""; ],; ""type"": ""string""; },; ""AtomicResultProtocols"": {; ""title"": ""AtomicResultProtocols"",; ""description"": ""Protocols regarding the manipulation of computational result data."",; ""type"": ""object"",; ""properties"": {; ""wavefunction"": {; ""description"": ""Wavefunction to keep from a computation."",;",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:3023,Availability,error,error,3023,"efault"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additionalProperties"": false; },; ""NativeFilesProtocolEnum"": {; ""title"": ""NativeFilesProtocolEnum"",; ""description"": ""CMS program files to keep from a computation."",; ""enum"": [; ""all"",; ""input"",; ""none""; ],; ""type"": ""string""; },; ""AtomicResultProtocols"": {; ""title"": ""AtomicResultProtocols"",; ""description"": ""Protocols regarding the manipulation of computational result data."",; ""type"": ""object"",; ""properties"": {; ""wavefunction"": {; ""description"": ""Wavefunction to keep from a computation."",;",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:3227,Availability,error,error,3227,"efault"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additionalProperties"": false; },; ""NativeFilesProtocolEnum"": {; ""title"": ""NativeFilesProtocolEnum"",; ""description"": ""CMS program files to keep from a computation."",; ""enum"": [; ""all"",; ""input"",; ""none""; ],; ""type"": ""string""; },; ""AtomicResultProtocols"": {; ""title"": ""AtomicResultProtocols"",; ""description"": ""Protocols regarding the manipulation of computational result data."",; ""type"": ""object"",; ""properties"": {; ""wavefunction"": {; ""description"": ""Wavefunction to keep from a computation."",;",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:3287,Availability,error,error,3287,",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additionalProperties"": false; },; ""NativeFilesProtocolEnum"": {; ""title"": ""NativeFilesProtocolEnum"",; ""description"": ""CMS program files to keep from a computation."",; ""enum"": [; ""all"",; ""input"",; ""none""; ],; ""type"": ""string""; },; ""AtomicResultProtocols"": {; ""title"": ""AtomicResultProtocols"",; ""description"": ""Protocols regarding the manipulation of computational result data."",; ""type"": ""object"",; ""properties"": {; ""wavefunction"": {; ""description"": ""Wavefunction to keep from a computation."",; ""default"": ""none"",; ""allOf"": [; {; ""$ref"": ""#/definitions/WavefunctionProtocolEnum""; }; ]; },; ""stdout"": {; ""title"": ""Stdout"",; ""description"": ""Primary output file to keep from the computation"",; ""default"": true,; ""type"": ""boolean""; },; ""error_correction"": {; ""title"": ""Error Correction"",; ""description"": ""Policies for error correction"",; ""allOf"": [; {; ""$ref"": ""#/definitions/ErrorCor",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:4233,Availability,error,error,4233,"orrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additionalProperties"": false; },; ""NativeFilesProtocolEnum"": {; ""title"": ""NativeFilesProtocolEnum"",; ""description"": ""CMS program files to keep from a computation."",; ""enum"": [; ""all"",; ""input"",; ""none""; ],; ""type"": ""string""; },; ""AtomicResultProtocols"": {; ""title"": ""AtomicResultProtocols"",; ""description"": ""Protocols regarding the manipulation of computational result data."",; ""type"": ""object"",; ""properties"": {; ""wavefunction"": {; ""description"": ""Wavefunction to keep from a computation."",; ""default"": ""none"",; ""allOf"": [; {; ""$ref"": ""#/definitions/WavefunctionProtocolEnum""; }; ]; },; ""stdout"": {; ""title"": ""Stdout"",; ""description"": ""Primary output file to keep from the computation"",; ""default"": true,; ""type"": ""boolean""; },; ""error_correction"": {; ""title"": ""Error Correction"",; ""description"": ""Policies for error correction"",; ""allOf"": [; {; ""$ref"": ""#/definitions/ErrorCorrectionProtocol""; }; ]; },; ""native_files"": {; ""description"": ""Policies for keeping processed files from the computation"",; ""default"": ""none"",; ""allOf"": [; {; ""$ref"": ""#/definitions/NativeFilesProtocolEnum""; }; ]; }; },; ""additionalProperties"": false; }; }; }. Fields:. basis (str); computed (bool); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); method (str); molecule (Any); owner_group (str | None); priority (str); protocols (qcelemental.models.results.AtomicResultProtocols | Dict[str, Any] | None); result (Any); result_id (str | None); tag (str). Validators:. set_basis  basis; set_keywords  keywords; set_method  method. field basis: str [Required]; The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ). Validated by:. set_basis. field computed: bool = False; Whether quantum chemistry has been run on this task. field driver: DriverEnum [Required]; The resulting type of",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:7448,Deployability,update,updated,7448,"tum chemistry method to evaluate (e.g., B3LYP, MP2, ). Validated by:. set_method. field molecule: Any [Required]; The molecule to use in the computation. field owner_group: Optional[str] = None; group in the chown sense. field priority: str = 1; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}; Output modifications. field result: Any [Optional]; AtomicResult return. field result_id: Optional[str] = None; The optional ID for the computation. field tag: str = '*'; The tags to pass along to compute managers. compute(client=None)[source]; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None)  . get_results(client=None)[source]; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None)  . Return type:; AtomicResult. plan()[source]; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  psi4.driver.AtomicComputer.basis[source]. validator set_keywords  psi4.driver.AtomicComputer.keywords[source]. validator set_method  psi4.driver.AtomicComputer.method[source]. table of contents. AtomicComputer; AtomicComputer; AtomicComputer.basis; AtomicComputer.computed; AtomicComputer.driver; AtomicComputer.keywords; AtomicComputer.method; AtomicComputer.molecule; AtomicComputer.owner_group; AtomicComputer.priority; AtomicComputer.protocols; AtomicComputer.result; AtomicComputer.result_id; AtomicComputer.tag; AtomicComputer.compute(); AtomicComputer.get_results(); AtomicComputer.plan(); AtomicComputer.set_basis; AtomicComputer.set_keywords; AtomicComputer.set_method. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:862,Energy Efficiency,energy,energy,862,". AtomicComputer. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer. AtomicComputer. pydantic model psi4.driver.AtomicComputer[source]; Computer for analytic single-geometry computations. Show JSON schema{; ""title"": ""AtomicComputer"",; ""description"": ""Computer for analytic single-geometry computations."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule"",; ""description"": ""The molecule to use in the computation.""; },; ""basis"": {; ""title"": ""Basis"",; ""description"": ""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...)."",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""description"": ""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...)."",; ""type"": ""string""; },; ""driver"": {; ""description"": ""The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver."",; ""allOf"": [; {; ""$ref"": ""#/definitions/DriverEnum""; }; ]; },; ""keywords"": {; ""title"": ""Keywords"",; ""description"": ""The keywords to use in the computation."",; ""type"": ""object""; },; ""protocols"": {; ""title"": ""Protocols"",; ""description"": ""Output modifications."",; ""default"": {; ""stdout"": true; },; ""anyOf"": [; {; ""$ref"": ""#/definitions/AtomicResultProtocols""; },; {; ""type"": ""object""; }; ]; },; ""tag"": {; ""title"": ""Tag"",; ""description"": ""The tags to pass along to compute managers."",; ""default"": ""*"",; ""type"": ""string""; },; ""priority"": {; ""title"": ""Priority"",; ""description"": ""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}"",; ""default"": 1,; ""type"": ""string""; },; ""owner_group"": {; ""title"": ""Owner Group"",; ""description"": ""group in the chown sense."",; ""type"": ""string""; },; ""computed"": {; ""title"": ""Computed"",; ""description"": ""Whether quantum chemistry has been run on this task."",; ""default"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": """,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:2368,Energy Efficiency,energy,energy,2368,"nagers."",; ""default"": ""*"",; ""type"": ""string""; },; ""priority"": {; ""title"": ""Priority"",; ""description"": ""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}"",; ""default"": 1,; ""type"": ""string""; },; ""owner_group"": {; ""title"": ""Owner Group"",; ""description"": ""group in the chown sense."",; ""type"": ""string""; },; ""computed"": {; ""title"": ""Computed"",; ""description"": ""Whether quantum chemistry has been run on this task."",; ""default"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additionalProperties"": false; },; ""Nati",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:5249,Energy Efficiency,energy,energy,5249,"r error correction"",; ""allOf"": [; {; ""$ref"": ""#/definitions/ErrorCorrectionProtocol""; }; ]; },; ""native_files"": {; ""description"": ""Policies for keeping processed files from the computation"",; ""default"": ""none"",; ""allOf"": [; {; ""$ref"": ""#/definitions/NativeFilesProtocolEnum""; }; ]; }; },; ""additionalProperties"": false; }; }; }. Fields:. basis (str); computed (bool); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); method (str); molecule (Any); owner_group (str | None); priority (str); protocols (qcelemental.models.results.AtomicResultProtocols | Dict[str, Any] | None); result (Any); result_id (str | None); tag (str). Validators:. set_basis  basis; set_keywords  keywords; set_method  method. field basis: str [Required]; The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ). Validated by:. set_basis. field computed: bool = False; Whether quantum chemistry has been run on this task. field driver: DriverEnum [Required]; The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver. field keywords: Dict[str, Any] [Optional]; The keywords to use in the computation. Validated by:. set_keywords. field method: str [Required]; The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ). Validated by:. set_method. field molecule: Any [Required]; The molecule to use in the computation. field owner_group: Optional[str] = None; group in the chown sense. field priority: str = 1; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}; Output modifications. field result: Any [Optional]; AtomicResult return. field result_id: Optional[str] = None; The optional ID for the computation. field tag: str = '*'; The tags to pass along to compute managers. compute(client=None)[source]; Run quantum chemistry. Para",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:1171,Integrability,protocol,protocols,1171,"er[source]; Computer for analytic single-geometry computations. Show JSON schema{; ""title"": ""AtomicComputer"",; ""description"": ""Computer for analytic single-geometry computations."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule"",; ""description"": ""The molecule to use in the computation.""; },; ""basis"": {; ""title"": ""Basis"",; ""description"": ""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...)."",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""description"": ""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...)."",; ""type"": ""string""; },; ""driver"": {; ""description"": ""The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver."",; ""allOf"": [; {; ""$ref"": ""#/definitions/DriverEnum""; }; ]; },; ""keywords"": {; ""title"": ""Keywords"",; ""description"": ""The keywords to use in the computation."",; ""type"": ""object""; },; ""protocols"": {; ""title"": ""Protocols"",; ""description"": ""Output modifications."",; ""default"": {; ""stdout"": true; },; ""anyOf"": [; {; ""$ref"": ""#/definitions/AtomicResultProtocols""; },; {; ""type"": ""object""; }; ]; },; ""tag"": {; ""title"": ""Tag"",; ""description"": ""The tags to pass along to compute managers."",; ""default"": ""*"",; ""type"": ""string""; },; ""priority"": {; ""title"": ""Priority"",; ""description"": ""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}"",; ""default"": 1,; ""type"": ""string""; },; ""owner_group"": {; ""title"": ""Owner Group"",; ""description"": ""group in the chown sense."",; ""type"": ""string""; },; ""computed"": {; ""title"": ""Computed"",; ""description"": ""Whether quantum chemistry has been run on this task."",; ""default"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:2830,Integrability,protocol,protocols,2830,"efault"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""WavefunctionProtocolEnum"": {; ""title"": ""WavefunctionProtocolEnum"",; ""description"": ""Wavefunction to keep from a computation."",; ""enum"": [; ""all"",; ""orbitals_and_eigenvalues"",; ""return_results"",; ""none""; ],; ""type"": ""string""; },; ""ErrorCorrectionProtocol"": {; ""title"": ""ErrorCorrectionProtocol"",; ""description"": ""Configuration for how QCEngine handles error correction\n\nWARNING: These protocols are currently experimental and only supported by NWChem tasks"",; ""type"": ""object"",; ""properties"": {; ""default_policy"": {; ""title"": ""Default Policy"",; ""description"": ""Whether to allow error corrections to be used if not directly specified in `policies`"",; ""default"": true,; ""type"": ""boolean""; },; ""policies"": {; ""title"": ""Policies"",; ""description"": ""Settings that define whether specific error corrections are allowed. Keys are the name of a known error and values are whether it is allowed to be used."",; ""type"": ""object"",; ""additionalProperties"": {; ""type"": ""boolean""; }; }; },; ""additionalProperties"": false; },; ""NativeFilesProtocolEnum"": {; ""title"": ""NativeFilesProtocolEnum"",; ""description"": ""CMS program files to keep from a computation."",; ""enum"": [; ""all"",; ""input"",; ""none""; ],; ""type"": ""string""; },; ""AtomicResultProtocols"": {; ""title"": ""AtomicResultProtocols"",; ""description"": ""Protocols regarding the manipulation of computational result data."",; ""type"": ""object"",; ""properties"": {; ""wavefunction"": {; ""description"": ""Wavefunction to keep from a computation."",;",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:4752,Integrability,protocol,protocols,4752,"ls"",; ""description"": ""Protocols regarding the manipulation of computational result data."",; ""type"": ""object"",; ""properties"": {; ""wavefunction"": {; ""description"": ""Wavefunction to keep from a computation."",; ""default"": ""none"",; ""allOf"": [; {; ""$ref"": ""#/definitions/WavefunctionProtocolEnum""; }; ]; },; ""stdout"": {; ""title"": ""Stdout"",; ""description"": ""Primary output file to keep from the computation"",; ""default"": true,; ""type"": ""boolean""; },; ""error_correction"": {; ""title"": ""Error Correction"",; ""description"": ""Policies for error correction"",; ""allOf"": [; {; ""$ref"": ""#/definitions/ErrorCorrectionProtocol""; }; ]; },; ""native_files"": {; ""description"": ""Policies for keeping processed files from the computation"",; ""default"": ""none"",; ""allOf"": [; {; ""$ref"": ""#/definitions/NativeFilesProtocolEnum""; }; ]; }; },; ""additionalProperties"": false; }; }; }. Fields:. basis (str); computed (bool); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); method (str); molecule (Any); owner_group (str | None); priority (str); protocols (qcelemental.models.results.AtomicResultProtocols | Dict[str, Any] | None); result (Any); result_id (str | None); tag (str). Validators:. set_basis  basis; set_keywords  keywords; set_method  method. field basis: str [Required]; The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ). Validated by:. set_basis. field computed: bool = False; Whether quantum chemistry has been run on this task. field driver: DriverEnum [Required]; The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver. field keywords: Dict[str, Any] [Optional]; The keywords to use in the computation. Validated by:. set_keywords. field method: str [Required]; The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ). Validated by:. set_method. field molecule: Any [Required]; The molecule to use in the computation. field owner_group: Option",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:5872,Integrability,protocol,protocols,5872,"et_keywords  keywords; set_method  method. field basis: str [Required]; The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ). Validated by:. set_basis. field computed: bool = False; Whether quantum chemistry has been run on this task. field driver: DriverEnum [Required]; The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver. field keywords: Dict[str, Any] [Optional]; The keywords to use in the computation. Validated by:. set_keywords. field method: str [Required]; The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ). Validated by:. set_method. field molecule: Any [Required]; The molecule to use in the computation. field owner_group: Optional[str] = None; group in the chown sense. field priority: str = 1; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}; Output modifications. field result: Any [Optional]; AtomicResult return. field result_id: Optional[str] = None; The optional ID for the computation. field tag: str = '*'; The tags to pass along to compute managers. compute(client=None)[source]; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None)  . get_results(client=None)[source]; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None)  . Return type:; AtomicResult. plan()[source]; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  psi4.driver.AtomicComputer.basis[source]. validator set_keywords  psi4.driver.AtomicComputer.keywords[source]. validator set_method  psi4.driver.AtomicComputer.method[source]. table of contents. AtomicComputer; AtomicComputer; AtomicComputer.basis; AtomicComputer.computed; AtomicComputer.driver; AtomicComputer.keywords; AtomicComputer.method; AtomicCo",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:7006,Integrability,protocol,protocols,7006,"tum chemistry method to evaluate (e.g., B3LYP, MP2, ). Validated by:. set_method. field molecule: Any [Required]; The molecule to use in the computation. field owner_group: Optional[str] = None; group in the chown sense. field priority: str = 1; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}; Output modifications. field result: Any [Optional]; AtomicResult return. field result_id: Optional[str] = None; The optional ID for the computation. field tag: str = '*'; The tags to pass along to compute managers. compute(client=None)[source]; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None)  . get_results(client=None)[source]; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None)  . Return type:; AtomicResult. plan()[source]; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  psi4.driver.AtomicComputer.basis[source]. validator set_keywords  psi4.driver.AtomicComputer.keywords[source]. validator set_method  psi4.driver.AtomicComputer.method[source]. table of contents. AtomicComputer; AtomicComputer; AtomicComputer.basis; AtomicComputer.computed; AtomicComputer.driver; AtomicComputer.keywords; AtomicComputer.method; AtomicComputer.molecule; AtomicComputer.owner_group; AtomicComputer.priority; AtomicComputer.protocols; AtomicComputer.result; AtomicComputer.result_id; AtomicComputer.tag; AtomicComputer.compute(); AtomicComputer.get_results(); AtomicComputer.plan(); AtomicComputer.set_basis; AtomicComputer.set_keywords; AtomicComputer.set_method. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:6535,Security,validat,validator,6535,"tum chemistry method to evaluate (e.g., B3LYP, MP2, ). Validated by:. set_method. field molecule: Any [Required]; The molecule to use in the computation. field owner_group: Optional[str] = None; group in the chown sense. field priority: str = 1; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}; Output modifications. field result: Any [Optional]; AtomicResult return. field result_id: Optional[str] = None; The optional ID for the computation. field tag: str = '*'; The tags to pass along to compute managers. compute(client=None)[source]; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None)  . get_results(client=None)[source]; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None)  . Return type:; AtomicResult. plan()[source]; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  psi4.driver.AtomicComputer.basis[source]. validator set_keywords  psi4.driver.AtomicComputer.keywords[source]. validator set_method  psi4.driver.AtomicComputer.method[source]. table of contents. AtomicComputer; AtomicComputer; AtomicComputer.basis; AtomicComputer.computed; AtomicComputer.driver; AtomicComputer.keywords; AtomicComputer.method; AtomicComputer.molecule; AtomicComputer.owner_group; AtomicComputer.priority; AtomicComputer.protocols; AtomicComputer.result; AtomicComputer.result_id; AtomicComputer.tag; AtomicComputer.compute(); AtomicComputer.get_results(); AtomicComputer.plan(); AtomicComputer.set_basis; AtomicComputer.set_keywords; AtomicComputer.set_method. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:6602,Security,validat,validator,6602,"tum chemistry method to evaluate (e.g., B3LYP, MP2, ). Validated by:. set_method. field molecule: Any [Required]; The molecule to use in the computation. field owner_group: Optional[str] = None; group in the chown sense. field priority: str = 1; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}; Output modifications. field result: Any [Optional]; AtomicResult return. field result_id: Optional[str] = None; The optional ID for the computation. field tag: str = '*'; The tags to pass along to compute managers. compute(client=None)[source]; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None)  . get_results(client=None)[source]; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None)  . Return type:; AtomicResult. plan()[source]; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  psi4.driver.AtomicComputer.basis[source]. validator set_keywords  psi4.driver.AtomicComputer.keywords[source]. validator set_method  psi4.driver.AtomicComputer.method[source]. table of contents. AtomicComputer; AtomicComputer; AtomicComputer.basis; AtomicComputer.computed; AtomicComputer.driver; AtomicComputer.keywords; AtomicComputer.method; AtomicComputer.molecule; AtomicComputer.owner_group; AtomicComputer.priority; AtomicComputer.protocols; AtomicComputer.result; AtomicComputer.result_id; AtomicComputer.tag; AtomicComputer.compute(); AtomicComputer.get_results(); AtomicComputer.plan(); AtomicComputer.set_basis; AtomicComputer.set_keywords; AtomicComputer.set_method. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:6675,Security,validat,validator,6675,"tum chemistry method to evaluate (e.g., B3LYP, MP2, ). Validated by:. set_method. field molecule: Any [Required]; The molecule to use in the computation. field owner_group: Optional[str] = None; group in the chown sense. field priority: str = 1; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}; Output modifications. field result: Any [Optional]; AtomicResult return. field result_id: Optional[str] = None; The optional ID for the computation. field tag: str = '*'; The tags to pass along to compute managers. compute(client=None)[source]; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None)  . get_results(client=None)[source]; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None)  . Return type:; AtomicResult. plan()[source]; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  psi4.driver.AtomicComputer.basis[source]. validator set_keywords  psi4.driver.AtomicComputer.keywords[source]. validator set_method  psi4.driver.AtomicComputer.method[source]. table of contents. AtomicComputer; AtomicComputer; AtomicComputer.basis; AtomicComputer.computed; AtomicComputer.driver; AtomicComputer.keywords; AtomicComputer.method; AtomicComputer.molecule; AtomicComputer.owner_group; AtomicComputer.priority; AtomicComputer.protocols; AtomicComputer.result; AtomicComputer.result_id; AtomicComputer.tag; AtomicComputer.compute(); AtomicComputer.get_results(); AtomicComputer.plan(); AtomicComputer.set_basis; AtomicComputer.set_keywords; AtomicComputer.set_method. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.banner.html:878,Deployability,update,updated,878,". banner. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; banner. banner. psi4.driver.banner(text, type=1, width=35, strNotOutfile=False)[source]; Format text into a banner style and print or return it. Parameters:. text (str)  String to be emphasized.; type (int)  Style 1 has minimum three-line height. Style 2 has minimum one-light; height.; width (int)  Minimum length of banner string.; strNotOutfile (bool)  Controls mode of return. Return type:; Optional[str]. Returns:. str  If strNotOutfile is True, return string.; None  If strNotOutfile is False, print it to output file. table of contents. banner; banner(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; banner.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.banner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.banner.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.basis_helper.html:1111,Deployability,update,updated,1111,". basis_helper. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str)  Text that goes in a PSIthon basis {...} block.; name (str)  Name label to associated with basis specified by block.; key (str)  Basis keyword specified by block.; set_option (bool)  When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. table of contents. basis_helper; basis_helper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; basis_helper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.basis_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.basis_helper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.basis_helper.html:533,Testability,test,test,533,". basis_helper. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str)  Text that goes in a PSIthon basis {...} block.; name (str)  Name label to associated with basis specified by block.; key (str)  Basis keyword specified by block.; set_option (bool)  When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. table of contents. basis_helper; basis_helper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; basis_helper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.basis_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.basis_helper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:7742,Availability,avail,available,7742,"]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:. scf_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta_scheme (str)  \(\Rightarrow\) 'xtpl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:7787,Availability,avail,available,7787," basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:. scf_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:11944,Availability,avail,available,11944," default it is worked out from the number of basis sets (1 - 3) supplied as `basis`.; `alpha`: alpha for the above scheme, if the default is to be overriden; `options`: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both `options` and `options_lo`. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise nonrelativistic.; `options_lo`: special options for lower method in a given stage. This is useful to calculate a direct stage in an otherwise density-fitted calculation, or similar.; `treatment`: treat extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 co",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:14933,Deployability,update,updated,14933,"cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). table of contents. cbs; cbs(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cbs.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:204,Energy Efficiency,energy,energy,204,". cbs. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cbs. cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:; complete_basis_set(). Returns:; (float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2,  ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \tex",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:424,Energy Efficiency,energy,energy,424,". cbs. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cbs. cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:; complete_basis_set(). Returns:; (float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2,  ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \tex",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:827,Energy Efficiency,energy,energy,827,". cbs. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cbs. cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:; complete_basis_set(). Returns:; (float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2,  ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \tex",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:957,Energy Efficiency,energy,energy,957,". cbs. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cbs. cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:; complete_basis_set(). Returns:; (float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2,  ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \tex",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:981,Energy Efficiency,energy,energy,981,". cbs. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cbs. cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:; complete_basis_set(). Returns:; (float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2,  ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \tex",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:1028,Energy Efficiency,energy,energy,1028,". cbs. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cbs. cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:; complete_basis_set(). Returns:; (float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2,  ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \tex",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:1806,Energy Efficiency,energy,energy,1806,"ENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2,  ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_wfn}}^{\textbf{delta_basis}}\right) - \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_wfn_lesser}}^{\textbf{delta_basis}}\right)\]. \[\delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; = \mathcal{F}_{\textbf{delta2_scheme}} \left(E_{\text{corl},\; \textbf{delta2_wfn}}^{\textbf{delta2_basis}}\right) - \mathcal{F}_{\textbf{delta2_scheme}} \left(E_{\text{corl},\; \textbf{delta2_wfn_lesser}}^{\textbf{delta2_basis}}\right)\]. \[\delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; = \mathcal",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:1816,Energy Efficiency,energy,energy,1816,"ENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2,  ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_wfn}}^{\textbf{delta_basis}}\right) - \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_wfn_lesser}}^{\textbf{delta_basis}}\right)\]. \[\delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; = \mathcal{F}_{\textbf{delta2_scheme}} \left(E_{\text{corl},\; \textbf{delta2_wfn}}^{\textbf{delta2_basis}}\right) - \mathcal{F}_{\textbf{delta2_scheme}} \left(E_{\text{corl},\; \textbf{delta2_wfn_lesser}}^{\textbf{delta2_basis}}\right)\]. \[\delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; = \mathcal",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:3669,Energy Efficiency,energy,energy,3669,"orl},\; \textbf{delta3_wfn}}^{\textbf{delta3_basis}}\right) - \mathcal{F}_{\textbf{delta3_scheme}} \left(E_{\text{corl},\; \textbf{delta3_wfn_lesser}}^{\textbf{delta3_basis}}\right)\]. \[\delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; = \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn}}^{\textbf{delta4_basis}}\right) - \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn_lesser}}^{\textbf{delta4_basis}}\right)\]. \[\delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}} \; = \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn}}^{\textbf{delta5_basis}}\right) - \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn_lesser}}^{\textbf{delta5_basis}}\right)\]; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy MethodsThe presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step onl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:3717,Energy Efficiency,energy,energy,3717,"orl},\; \textbf{delta3_wfn}}^{\textbf{delta3_basis}}\right) - \mathcal{F}_{\textbf{delta3_scheme}} \left(E_{\text{corl},\; \textbf{delta3_wfn_lesser}}^{\textbf{delta3_basis}}\right)\]. \[\delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; = \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn}}^{\textbf{delta4_basis}}\right) - \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn_lesser}}^{\textbf{delta4_basis}}\right)\]. \[\delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}} \; = \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn}}^{\textbf{delta5_basis}}\right) - \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn_lesser}}^{\textbf{delta5_basis}}\right)\]; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy MethodsThe presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step onl",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:4466,Energy Efficiency,energy,energy,4466,"]; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy MethodsThe presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the referenc",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:4668,Energy Efficiency,energy,energy,4668,"ded to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy MethodsThe presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to b",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:5129,Energy Efficiency,energy,energy,5129,"text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy MethodsThe presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:5343,Energy Efficiency,energy,energy,5343," (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarro",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:5381,Energy Efficiency,energy,energy,5381," (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarro",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:5627,Energy Efficiency,energy,energy,5627,"; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string) ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:5667,Energy Efficiency,energy,energy,5667,"; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string) ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:5851,Energy Efficiency,energy,energy,5851,"t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can de",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:5914,Energy Efficiency,energy,energy,5914,"t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can de",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:6046,Energy Efficiency,energy,energy,6046,"cates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basi",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:6109,Energy Efficiency,energy,energy,6109,"cates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basi",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:6208,Energy Efficiency,energy,energy,6208,"ds supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:6278,Energy Efficiency,energy,energy,6278,"ds supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:6416,Energy Efficiency,energy,energy,6416,"in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransform",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:6486,Energy Efficiency,energy,energy,6486,"in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransform",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:6817,Energy Efficiency,energy,energy,6817,"n (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all a",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:7053,Energy Efficiency,energy,energy,7053," Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:. scf_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xt",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:7236,Energy Efficiency,energy,energy,7236,"the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str)  \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:. scf_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_high",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:7427,Energy Efficiency,energy,energy,7427,"t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:. scf_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftar",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:7465,Energy Efficiency,energy,energy,7465,"ergy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string)  \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:. scf_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:7996,Energy Efficiency,energy,energy,7996,"q5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string)  'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:. scf_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_bas",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:8500,Energy Efficiency,energy,energy,8500,"e energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:. scf_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta2_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). scf_alpha (float)  \(\Rightarrow\) 1.63 \(\",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:8872,Energy Efficiency,energy,energy,8872,"scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta2_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). scf_alpha (float)  \(\Rightarrow\) 1.63 \(\Leftarrow\); Overrides the default alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including xtpl_highest_1() and scf_xtpl_helgaker_3(). scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_alpha (float)  \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the liste",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:9253,Energy Efficiency,energy,energy,9253," otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta2_scheme (str)  \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). scf_alpha (float)  \(\Rightarrow\) 1.63 \(\Leftarrow\); Overrides the default alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including xtpl_highest_1() and scf_xtpl_helgaker_3(). scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_alpha (float)  \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed corl_xtpl_helgaker_2() correlation; extrapolation to the corl stage. The supplied alpha does not impact delta or any further stages. corl_xtpl_helgaker_2(). delta_alpha (float)  \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed; corl_xtpl_helgaker_2() correlation extrapolation for the delta correction. Useful when; delta correcti",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:10663,Energy Efficiency,energy,energy,10663,"xtpl_helgaker_3(). scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_alpha (float)  \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed corl_xtpl_helgaker_2() correlation; extrapolation to the corl stage. The supplied alpha does not impact delta or any further stages. corl_xtpl_helgaker_2(). delta_alpha (float)  \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed; corl_xtpl_helgaker_2() correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different alpha might; be more appropriate. corl_xtpl_helgaker_2(). Combined interface. Parameters:; cbs_metadata (List[Dict])  \(\Rightarrow\) autogenerated from above keywords \(\Leftarrow\) || [{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}] || etc.; This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. `wfn`: typically `HF`, which is subsumed in correlated methods anyway.; `basis`: basis set, can be in a bracketed form (eg. `cc-pv[tq]z`). Other supported arguments for the first dictionary are:. `scheme`: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as `basis`.; `alpha`: alpha for the above scheme, if the default is to be overriden; `options`: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both `options` and `options_lo`. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise nonrelativistic.; `options_lo`: special options for lower method in a given stage. This is useful to calculate a direct stage in an otherwi",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:12534,Energy Efficiency,energy,energy,12534,"ial options for lower method in a given stage. This is useful to calculate a direct stage in an otherwise density-fitted calculation, or similar.; `treatment`: treat extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:12553,Energy Efficiency,energy,energy,12553,"ial options for lower method in a given stage. This is useful to calculate a direct stage in an otherwise density-fitted calculation, or similar.; `treatment`: treat extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:12700,Energy Efficiency,energy,energy,12700," extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:12719,Energy Efficiency,energy,energy,12719," extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:12820,Energy Efficiency,energy,energy,12820,"e next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:12832,Energy Efficiency,energy,energy,12832,"e next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:12968,Energy Efficiency,energy,energy,12968,"ther supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calcul",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:13004,Energy Efficiency,energy,energy,13004,"ther supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calcul",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:13200,Energy Efficiency,energy,energy,13200,"thers. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:13254,Energy Efficiency,energy,energy,13254,"thers. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:13369,Energy Efficiency,energy,energy,13369,"thers. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:13687,Energy Efficiency,energy,energy,13687,"c-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). table of contents. cbs; cbs(). ; hide menu. menu; si",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:13723,Energy Efficiency,energy,energy,13723,"c-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). table of contents. cbs; cbs(). ; hide menu. menu; si",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:14129,Energy Efficiency,energy,energy,14129,"cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). table of contents. cbs; cbs(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cbs.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:10331,Integrability,interface,interface,10331,"n delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). scf_alpha (float)  \(\Rightarrow\) 1.63 \(\Leftarrow\); Overrides the default alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including xtpl_highest_1() and scf_xtpl_helgaker_3(). scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_alpha (float)  \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed corl_xtpl_helgaker_2() correlation; extrapolation to the corl stage. The supplied alpha does not impact delta or any further stages. corl_xtpl_helgaker_2(). delta_alpha (float)  \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed; corl_xtpl_helgaker_2() correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different alpha might; be more appropriate. corl_xtpl_helgaker_2(). Combined interface. Parameters:; cbs_metadata (List[Dict])  \(\Rightarrow\) autogenerated from above keywords \(\Leftarrow\) || [{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}] || etc.; This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. `wfn`: typically `HF`, which is subsumed in correlated methods anyway.; `basis`: basis set, can be in a bracketed form (eg. `cc-pv[tq]z`). Other supported arguments for the first dictionary are:. `scheme`: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as `basis`.; `alpha`: alpha for the above scheme, if the default is to be overriden; `options`: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both `options` and `options_lo`. Th",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:10512,Integrability,interface,interface,10512,"xtrapolation procedures.; Has no effect on others, including xtpl_highest_1() and scf_xtpl_helgaker_3(). scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_alpha (float)  \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed corl_xtpl_helgaker_2() correlation; extrapolation to the corl stage. The supplied alpha does not impact delta or any further stages. corl_xtpl_helgaker_2(). delta_alpha (float)  \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed; corl_xtpl_helgaker_2() correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different alpha might; be more appropriate. corl_xtpl_helgaker_2(). Combined interface. Parameters:; cbs_metadata (List[Dict])  \(\Rightarrow\) autogenerated from above keywords \(\Leftarrow\) || [{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}] || etc.; This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. `wfn`: typically `HF`, which is subsumed in correlated methods anyway.; `basis`: basis set, can be in a bracketed form (eg. `cc-pv[tq]z`). Other supported arguments for the first dictionary are:. `scheme`: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as `basis`.; `alpha`: alpha for the above scheme, if the default is to be overriden; `options`: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both `options` and `options_lo`. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise nonrelativistic.; `options_lo`: special options for l",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:448,Modifiability,variab,variables,448,". cbs. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cbs. cbs. psi4.driver.cbs(func, label, **kwargs)[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:; complete_basis_set(). Returns:; (float)  Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2,  ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}\]; Here, \(\mathcal{F}\) is an energy or energy extrapolation scheme, and the following also hold. \[\delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \tex",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:5170,Performance,perform,performed,5170,"text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy MethodsThe presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str)  'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str)  \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as scf is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str)  'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str)  'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str)  \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:10207,Performance,perform,performed,10207,"o the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). scf_alpha (float)  \(\Rightarrow\) 1.63 \(\Leftarrow\); Overrides the default alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including xtpl_highest_1() and scf_xtpl_helgaker_3(). scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_alpha (float)  \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed corl_xtpl_helgaker_2() correlation; extrapolation to the corl stage. The supplied alpha does not impact delta or any further stages. corl_xtpl_helgaker_2(). delta_alpha (float)  \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed; corl_xtpl_helgaker_2() correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different alpha might; be more appropriate. corl_xtpl_helgaker_2(). Combined interface. Parameters:; cbs_metadata (List[Dict])  \(\Rightarrow\) autogenerated from above keywords \(\Leftarrow\) || [{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}] || etc.; This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. `wfn`: typically `HF`, which is subsumed in correlated methods anyway.; `basis`: basis set, can be in a bracketed form (eg. `cc-pv[tq]z`). Other supported arguments for the first dictionary are:. `scheme`: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as `basis`.; `alpha`: alpha for the above scheme, if the default is to be overriden; `options`: if special options are required for a step, they should be entered as a dict here. If some options should be",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:14603,Performance,optimiz,optimize,14603,"cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). table of contents. cbs; cbs(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cbs.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:14624,Performance,optimiz,optimize,14624,"cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). table of contents. cbs; cbs(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cbs.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:12480,Usability,simpl,simple,12480,"ial options for lower method in a given stage. This is useful to calculate a direct stage in an otherwise density-fitted calculation, or similar.; `treatment`: treat extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html:12638,Usability,simpl,simple,12638," extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cbs.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html:302,Availability,checkpoint,checkpoint,302,". compare_fchkfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4s FCHK files. Parameters:. expected (str)  Path to reference FCHK file against which computed is compared.; computed (str)  Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html:532,Availability,avail,available,532,". compare_fchkfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4s FCHK files. Parameters:. expected (str)  Path to reference FCHK file against which computed is compared.; computed (str)  Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html:1069,Availability,toler,tolerance,1069,". compare_fchkfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4s FCHK files. Parameters:. expected (str)  Path to reference FCHK file against which computed is compared.; computed (str)  Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html:1401,Availability,error,error,1401,". compare_fchkfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4s FCHK files. Parameters:. expected (str)  Path to reference FCHK file against which computed is compared.; computed (str)  Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html:1680,Deployability,update,updated,1680,". compare_fchkfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4s FCHK files. Parameters:. expected (str)  Path to reference FCHK file against which computed is compared.; computed (str)  Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html:1407,Integrability,message,messages,1407,". compare_fchkfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4s FCHK files. Parameters:. expected (str)  Path to reference FCHK file against which computed is compared.; computed (str)  Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html:682,Testability,log,logical,682,". compare_fchkfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4s FCHK files. Parameters:. expected (str)  Path to reference FCHK file against which computed is compared.; computed (str)  Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html:733,Testability,test,test,733,". compare_fchkfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4s FCHK files. Parameters:. expected (str)  Path to reference FCHK file against which computed is compared.; computed (str)  Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html:1267,Deployability,update,updated,1267,". compare_fcidumps. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps. psi4.driver.compare_fcidumps(expected, computed, label)[source]; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. norb : number of basis functions; nelec : number of electrons; ms2 : spin polarization of the system; isym : symmetry of state (if present in FCIDUMP); orbsym : list of symmetry labels of each orbital; uhf : whether restricted or unrestricted; ONE-ELECTRON ENERGY : SCF one-electron energy; TWO-ELECTRON ENERGY : SCF two-electron energy; SCF TOTAL ENERGY : SCF total energy; MP2 CORRELATION ENERGY : MP2 correlation energy. Parameters:. expected (str)  Reference FCIDUMP file against which computed is compared.; computed (str)  Input FCIDUMP file to compare against expected.; label (str)  string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html:664,Energy Efficiency,energy,energy,664,". compare_fcidumps. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps. psi4.driver.compare_fcidumps(expected, computed, label)[source]; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. norb : number of basis functions; nelec : number of electrons; ms2 : spin polarization of the system; isym : symmetry of state (if present in FCIDUMP); orbsym : list of symmetry labels of each orbital; uhf : whether restricted or unrestricted; ONE-ELECTRON ENERGY : SCF one-electron energy; TWO-ELECTRON ENERGY : SCF two-electron energy; SCF TOTAL ENERGY : SCF total energy; MP2 CORRELATION ENERGY : MP2 correlation energy. Parameters:. expected (str)  Reference FCIDUMP file against which computed is compared.; computed (str)  Input FCIDUMP file to compare against expected.; label (str)  string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html:713,Energy Efficiency,energy,energy,713,". compare_fcidumps. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps. psi4.driver.compare_fcidumps(expected, computed, label)[source]; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. norb : number of basis functions; nelec : number of electrons; ms2 : spin polarization of the system; isym : symmetry of state (if present in FCIDUMP); orbsym : list of symmetry labels of each orbital; uhf : whether restricted or unrestricted; ONE-ELECTRON ENERGY : SCF one-electron energy; TWO-ELECTRON ENERGY : SCF two-electron energy; SCF TOTAL ENERGY : SCF total energy; MP2 CORRELATION ENERGY : MP2 correlation energy. Parameters:. expected (str)  Reference FCIDUMP file against which computed is compared.; computed (str)  Input FCIDUMP file to compare against expected.; label (str)  string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html:752,Energy Efficiency,energy,energy,752,". compare_fcidumps. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps. psi4.driver.compare_fcidumps(expected, computed, label)[source]; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. norb : number of basis functions; nelec : number of electrons; ms2 : spin polarization of the system; isym : symmetry of state (if present in FCIDUMP); orbsym : list of symmetry labels of each orbital; uhf : whether restricted or unrestricted; ONE-ELECTRON ENERGY : SCF one-electron energy; TWO-ELECTRON ENERGY : SCF two-electron energy; SCF TOTAL ENERGY : SCF total energy; MP2 CORRELATION ENERGY : MP2 correlation energy. Parameters:. expected (str)  Reference FCIDUMP file against which computed is compared.; computed (str)  Input FCIDUMP file to compare against expected.; label (str)  string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html:803,Energy Efficiency,energy,energy,803,". compare_fcidumps. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps. psi4.driver.compare_fcidumps(expected, computed, label)[source]; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. norb : number of basis functions; nelec : number of electrons; ms2 : spin polarization of the system; isym : symmetry of state (if present in FCIDUMP); orbsym : list of symmetry labels of each orbital; uhf : whether restricted or unrestricted; ONE-ELECTRON ENERGY : SCF one-electron energy; TWO-ELECTRON ENERGY : SCF two-electron energy; SCF TOTAL ENERGY : SCF total energy; MP2 CORRELATION ENERGY : MP2 correlation energy. Parameters:. expected (str)  Reference FCIDUMP file against which computed is compared.; computed (str)  Input FCIDUMP file to compare against expected.; label (str)  string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html:1001,Testability,test,test,1001,". compare_fcidumps. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps. psi4.driver.compare_fcidumps(expected, computed, label)[source]; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. norb : number of basis functions; nelec : number of electrons; ms2 : spin polarization of the system; isym : symmetry of state (if present in FCIDUMP); orbsym : list of symmetry labels of each orbital; uhf : whether restricted or unrestricted; ONE-ELECTRON ENERGY : SCF one-electron energy; TWO-ELECTRON ENERGY : SCF two-electron energy; SCF TOTAL ENERGY : SCF total energy; MP2 CORRELATION ENERGY : MP2 correlation energy. Parameters:. expected (str)  Reference FCIDUMP file against which computed is compared.; computed (str)  Input FCIDUMP file to compare against expected.; label (str)  string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html:502,Availability,avail,available,502,". compare_moldenfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_moldenfiles. compare_moldenfiles. psi4.driver.compare_moldenfiles(expected, computed, atol_exponent=1e-07, label='Compare Molden')[source]; Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters:. expected (str)  Path to reference Molden file against which computed is compared.; computed (str)  Path to input Molden file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_moldenfiles; compare_moldenfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_moldenfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html:812,Availability,toler,tolerance,812,". compare_moldenfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_moldenfiles. compare_moldenfiles. psi4.driver.compare_moldenfiles(expected, computed, atol_exponent=1e-07, label='Compare Molden')[source]; Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters:. expected (str)  Path to reference Molden file against which computed is compared.; computed (str)  Path to input Molden file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_moldenfiles; compare_moldenfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_moldenfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html:1144,Availability,error,error,1144,". compare_moldenfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_moldenfiles. compare_moldenfiles. psi4.driver.compare_moldenfiles(expected, computed, atol_exponent=1e-07, label='Compare Molden')[source]; Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters:. expected (str)  Path to reference Molden file against which computed is compared.; computed (str)  Path to input Molden file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_moldenfiles; compare_moldenfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_moldenfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html:1429,Deployability,update,updated,1429,". compare_moldenfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_moldenfiles. compare_moldenfiles. psi4.driver.compare_moldenfiles(expected, computed, atol_exponent=1e-07, label='Compare Molden')[source]; Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters:. expected (str)  Path to reference Molden file against which computed is compared.; computed (str)  Path to input Molden file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_moldenfiles; compare_moldenfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_moldenfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html:1150,Integrability,message,messages,1150,". compare_moldenfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_moldenfiles. compare_moldenfiles. psi4.driver.compare_moldenfiles(expected, computed, atol_exponent=1e-07, label='Compare Molden')[source]; Comparison function for output data in Molden file format.; Compares many fields including geometry, basis set, occupations, symmetries, energies.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters:. expected (str)  Path to reference Molden file against which computed is compared.; computed (str)  Path to input Molden file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_moldenfiles; compare_moldenfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_moldenfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_moldenfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html:977,Deployability,update,updated,977,". ConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError. ConvergenceError. exception psi4.driver.ConvergenceError(eqn_description, iteration, additional_info=None)[source]; Error called for problems with converging an iterative method. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., SCF, optimization).; iteration (int)  Iteration number on which routine failed.; additional_info (Optional[str])  Any additional message to convey. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. table of contents. ConvergenceError; ConvergenceError; ConvergenceError.message; ConvergenceError.iteration. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html:372,Integrability,rout,routine,372,". ConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError. ConvergenceError. exception psi4.driver.ConvergenceError(eqn_description, iteration, additional_info=None)[source]; Error called for problems with converging an iterative method. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., SCF, optimization).; iteration (int)  Iteration number on which routine failed.; additional_info (Optional[str])  Any additional message to convey. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. table of contents. ConvergenceError; ConvergenceError; ConvergenceError.message; ConvergenceError.iteration. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html:468,Integrability,rout,routine,468,". ConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError. ConvergenceError. exception psi4.driver.ConvergenceError(eqn_description, iteration, additional_info=None)[source]; Error called for problems with converging an iterative method. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., SCF, optimization).; iteration (int)  Iteration number on which routine failed.; additional_info (Optional[str])  Any additional message to convey. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. table of contents. ConvergenceError; ConvergenceError; ConvergenceError.message; ConvergenceError.iteration. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html:534,Integrability,message,message,534,". ConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError. ConvergenceError. exception psi4.driver.ConvergenceError(eqn_description, iteration, additional_info=None)[source]; Error called for problems with converging an iterative method. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., SCF, optimization).; iteration (int)  Iteration number on which routine failed.; additional_info (Optional[str])  Any additional message to convey. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. table of contents. ConvergenceError; ConvergenceError; ConvergenceError.message; ConvergenceError.iteration. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html:553,Integrability,message,message,553,". ConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError. ConvergenceError. exception psi4.driver.ConvergenceError(eqn_description, iteration, additional_info=None)[source]; Error called for problems with converging an iterative method. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., SCF, optimization).; iteration (int)  Iteration number on which routine failed.; additional_info (Optional[str])  Any additional message to convey. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. table of contents. ConvergenceError; ConvergenceError; ConvergenceError.message; ConvergenceError.iteration. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html:649,Integrability,rout,routine,649,". ConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError. ConvergenceError. exception psi4.driver.ConvergenceError(eqn_description, iteration, additional_info=None)[source]; Error called for problems with converging an iterative method. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., SCF, optimization).; iteration (int)  Iteration number on which routine failed.; additional_info (Optional[str])  Any additional message to convey. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. table of contents. ConvergenceError; ConvergenceError; ConvergenceError.message; ConvergenceError.iteration. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html:737,Integrability,message,message,737,". ConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError. ConvergenceError. exception psi4.driver.ConvergenceError(eqn_description, iteration, additional_info=None)[source]; Error called for problems with converging an iterative method. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., SCF, optimization).; iteration (int)  Iteration number on which routine failed.; additional_info (Optional[str])  Any additional message to convey. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. table of contents. ConvergenceError; ConvergenceError; ConvergenceError.message; ConvergenceError.iteration. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html:408,Performance,optimiz,optimization,408,". ConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError. ConvergenceError. exception psi4.driver.ConvergenceError(eqn_description, iteration, additional_info=None)[source]; Error called for problems with converging an iterative method. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., SCF, optimization).; iteration (int)  Iteration number on which routine failed.; additional_info (Optional[str])  Any additional message to convey. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. table of contents. ConvergenceError; ConvergenceError; ConvergenceError.message; ConvergenceError.iteration. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.copy_file_from_scratch.html:1377,Deployability,update,updated,1377,". copy_file_from_scratch. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; copy_file_from_scratch. copy_file_from_scratch. psi4.driver.copy_file_from_scratch(filename, prefix, namespace, unit, move=False)[source]; Move a file out of scratch following the naming convention. Parameters:. filename (str)  Full path to target file.; prefix (str)  Computation prefix, usually psi.; namespace (str)  Context namespace, usually molecule name.; unit (int)  Unit number, e.g. 32; move (bool)  Whether to copy (default) or move?. Examples; >>> # Assume PID is 12345 and SCRATCH is /scratch/parrish/; >>> copy_file_to_scratch('temp', 'psi', 'h2o', 32):; Out[1]: -cp /scratch/parrish/psi.12345.h2o.32 .temp; >>> copy_file_to_scratch('/tmp/temp', 'psi', 'h2o', 32):; Out[2]: -cp /scratch/parrish/psi.12345.h2o.32 /tmp/temp; >>> copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; Out[3]: -cp /scratch/parrish/psi.12345.32 /tmp/temp; >>> copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; Out[4]: -mv /scratch/parrish/psi.12345.32 /tmp/temp. table of contents. copy_file_from_scratch; copy_file_from_scratch(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; copy_file_from_scratch.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.copy_file_from_scratch.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.copy_file_from_scratch.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.copy_file_to_scratch.html:1356,Deployability,update,updated,1356,". copy_file_to_scratch. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; copy_file_to_scratch. copy_file_to_scratch. psi4.driver.copy_file_to_scratch(filename, prefix, namespace, unit, move=False)[source]; Move a file into scratch following the naming convention. Parameters:. filename (str)  Full path to file.; prefix (str)  Computation prefix, usually psi.; namespace (str)  Context namespace, usually molecule name.; unit (int)  Unit number, e.g. 32.; move (bool)  Whether to copy (default) or move?. Examples; >>> # Assume PID is 12345 and SCRATCH is /scratch/parrish/; >>> copy_file_to_scratch('temp', 'psi', 'h2o', 32):; Out[1]: -cp ./temp /scratch/parrish/psi.12345.h2o.32; >>> copy_file_to_scratch('/tmp/temp', 'psi', 'h2o', 32):; Out[2]: -cp /tmp/temp /scratch/parrish/psi.12345.h2o.32; >>> copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; Out[3]: -cp /tmp/temp /scratch/parrish/psi.12345.32; >>> copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; Out[4]: -mv /tmp/temp /scratch/parrish/psi.12345.32. table of contents. copy_file_to_scratch; copy_file_to_scratch(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; copy_file_to_scratch.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.copy_file_to_scratch.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.copy_file_to_scratch.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.create_plugin.html:523,Deployability,update,updated,523,". create_plugin. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; create_plugin. create_plugin. psi4.driver.create_plugin(name, template)[source]. Return type:; None. Parameters:. name (str)  ; template (str)  . table of contents. create_plugin; create_plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; create_plugin.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.create_plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.create_plugin.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cubeprop.html:1024,Deployability,update,updated,1024,". cubeprop. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cubeprop. cubeprop. psi4.driver.cubeprop(wfn, **kwargs)[source]; Evaluate properties on a grid and generate cube files. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:; wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files. Examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). table of contents. cubeprop; cubeprop(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cubeprop.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cubeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cubeprop.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cubeprop.html:473,Energy Efficiency,energy,energy,473,". cubeprop. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cubeprop. cubeprop. psi4.driver.cubeprop(wfn, **kwargs)[source]; Evaluate properties on a grid and generate cube files. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:; wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files. Examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). table of contents. cubeprop; cubeprop(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cubeprop.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cubeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cubeprop.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cubeprop.html:737,Energy Efficiency,energy,energy,737,". cubeprop. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cubeprop. cubeprop. psi4.driver.cubeprop(wfn, **kwargs)[source]; Evaluate properties on a grid and generate cube files. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:; wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files. Examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). table of contents. cubeprop; cubeprop(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cubeprop.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.cubeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.cubeprop.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.docs_table_link.html:753,Deployability,update,updated,753,". docs_table_link. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; docs_table_link. docs_table_link. psi4.driver.docs_table_link(name, mode)[source]; Compose a link to mode documentation table.; For modes {summary, details}, link will be anchored at the table row for method name. (Method row not guaranteed to exist.); For other modes, link will be to table in general. Return type:; str. Parameters:. name (str)  ; mode (str)  . table of contents. docs_table_link; docs_table_link(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; docs_table_link.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.docs_table_link.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.docs_table_link.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.dynamic_variable_bind.html:572,Deployability,update,updated,572,". dynamic_variable_bind. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dynamic_variable_bind. dynamic_variable_bind. psi4.driver.dynamic_variable_bind(cls)[source]; Function to dynamically add extra members to; the core.Molecule class. table of contents. dynamic_variable_bind; dynamic_variable_bind(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; dynamic_variable_bind.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.dynamic_variable_bind.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.dynamic_variable_bind.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:3179,Availability,error,error,3179,"nl. Type:; str. disp; Only present for engine =libdisp. Psi4 class instance prepared; to compute dispersion. Type:; Dispersion. ordered_params; Fixed-order list of relevant parameters for dashlevel. Matches; DISPERSION CORRECTION ENERGY ordering. Used for printing. Type:; list. Parameters:. name_hint (str)  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (str)  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to one.; param_tweaks (Union[Dict, List])  Values for the same keys as dashcoeff[dashlevel][default]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (str)  Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (str)  Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool)  Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[,wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[,wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[,wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molec",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:6289,Deployability,update,updated,6289,"rection.; wfn (Wavefunction)  Location to set QCVariables. Returns:; Dispersion energy [Eh]. Return type:; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for -3C methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule)  System for which to compute empirical dispersion correction.; wfn (Wavefunction)  Location to set QCVariables. Returns:; (nat, 3) dispersion gradient [Eh/a0]. Return type:; Matrix. compute_hessian(molecule, wfn=None)[source]; Compute dispersion Hessian based on engine, dispersion level, and parameters in self.; Uses finite difference, as no dispersion engine has analytic second derivatives. Parameters:. molecule (Molecule)  System for which to compute empirical dispersion correction.; wfn (Wavefunction)  Location to set QCVariables. Returns:; (3*nat, 3*nat) dispersion Hessian [Eh/a0/a0]. Return type:; Matrix. print_out()[source]; Format dispersion parameters of self for output file. table of contents. EmpiricalDispersion; EmpiricalDispersion; EmpiricalDispersion.dashlevel; EmpiricalDispersion.dashparams; EmpiricalDispersion.fctldash; EmpiricalDispersion.description; EmpiricalDispersion.dashlevel_citation; EmpiricalDispersion.dashparams_citation; EmpiricalDispersion.dashcoeff_supplement; EmpiricalDispersion.engine; EmpiricalDispersion.disp; EmpiricalDispersion.ordered_params; EmpiricalDispersion.compute_energy(); EmpiricalDispersion.compute_gradient(); EmpiricalDispersion.compute_hessian(); EmpiricalDispersion.print_out(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; EmpiricalDispersion.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:3753,Energy Efficiency,energy,energy,3753,"ional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (str)  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to one.; param_tweaks (Union[Dict, List])  Values for the same keys as dashcoeff[dashlevel][default]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (str)  Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (str)  Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool)  Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[,wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[,wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[,wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule)  System for which to compute empirical dispersion correction.; wfn (Wavefunction)  Location to set QCVariables. Returns:; Dispersion energy [Eh]. Return type:; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for -3C methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]; Compute dispersion gradient based on engine, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:4215,Energy Efficiency,energy,energy,4215,"h code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (str)  Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool)  Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[,wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[,wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[,wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule)  System for which to compute empirical dispersion correction.; wfn (Wavefunction)  Location to set QCVariables. Returns:; Dispersion energy [Eh]. Return type:; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for -3C methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule)  System for which to compute empirical dispersion correction.; wfn (Wavefunction)  Location to set QCVariables. Returns:; (nat, 3) dispersion gradient [Eh/a0]. Return type:; Matrix. compute_hessian(molecule, wfn=None)[source]; Compute dispersion Hessian based on engine, dispersion level, and parameters in self.; Uses finite difference, as no dispersion engine has analytic sec",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:4449,Energy Efficiency,energy,energy,4449,"ftd3 executable or simple-dftd3 Python module.; gcp_engine (str)  Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool)  Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[,wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[,wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[,wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule)  System for which to compute empirical dispersion correction.; wfn (Wavefunction)  Location to set QCVariables. Returns:; Dispersion energy [Eh]. Return type:; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for -3C methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule)  System for which to compute empirical dispersion correction.; wfn (Wavefunction)  Location to set QCVariables. Returns:; (nat, 3) dispersion gradient [Eh/a0]. Return type:; Matrix. compute_hessian(molecule, wfn=None)[source]; Compute dispersion Hessian based on engine, dispersion level, and parameters in self.; Uses finite difference, as no dispersion engine has analytic second derivatives. Parameters:. molecule (Molecule)  System for which to compute empirical dispersion correction.; wfn (Wavefunction)  Location to set QCVariables. Returns:; (3*nat, 3*nat) dispersion Hessian [Eh/a0/a0]. Return ty",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:807,Modifiability,flexible,flexible,807,". EmpiricalDispersion. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; EmpiricalDispersion. EmpiricalDispersion. class psi4.driver.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, gcp_engine=None, save_pairwise_disp=False)[source]; Bases: object; Lightweight unification of empirical dispersion calculation modes. dashlevel; {d1, d2, chg, das2009, das2010, nl, dmp2, d3zero2b, d3bj2b, d3mzero2b, d3mbj2b, d3zeroatm, d3bjatm, d3mzeroatm, d3mbjatm, d4bjeeqatm}; Name of dispersion correction to be applied. Resolved; from name_hint and/or level_hint into a key of; empirical_dispersion_resources.dashcoeff. Type:; str. dashparams; Complete set of parameter values defining the flexible parts; of dashlevel. Number and parameter names vary by; dashlevel. Resolved into a complete set (keys of; dashcoeff[dashlevel][default]) from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type:; dict. fctldash; If dashparams for dashlevel corresponds to a defined,; named, untweaked functional-dashlevel set, then that; functional. Otherwise, empty string. Type:; str. description; Tagline for dispersion dashlevel. Type:; str. dashlevel_citation; Literature reference for dispersion dashlevel in general,; not necessarily for dashparams. Type:; str. dashparams_citation; Literature reference for dispersion parameters, if dashparams; corresponds to a defined, named, untweaked functional-dashlevel; set with a citation. Otherwise, empty string. Type:; str. dashcoeff_supplement; See description in qcengine.programs.empirical_dispersion_resources.from_arrays. Used; here to bless the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; qcengine.programs.empirical_dispersion_resources.dashcoeff itself for purposes of; validating fctldash. Type:; dict. engine",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:1961,Security,validat,validating,1961,") from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type:; dict. fctldash; If dashparams for dashlevel corresponds to a defined,; named, untweaked functional-dashlevel set, then that; functional. Otherwise, empty string. Type:; str. description; Tagline for dispersion dashlevel. Type:; str. dashlevel_citation; Literature reference for dispersion dashlevel in general,; not necessarily for dashparams. Type:; str. dashparams_citation; Literature reference for dispersion parameters, if dashparams; corresponds to a defined, named, untweaked functional-dashlevel; set with a citation. Otherwise, empty string. Type:; str. dashcoeff_supplement; See description in qcengine.programs.empirical_dispersion_resources.from_arrays. Used; here to bless the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; qcengine.programs.empirical_dispersion_resources.dashcoeff itself for purposes of; validating fctldash. Type:; dict. engine; {libdisp, s-dftd3, dftd3, nl, mp2d, dftd4}; Compute engine for dispersion. One of Psi4s internal libdisp; library, external Grimme or Beran projects, or nl. Type:; str. disp; Only present for engine =libdisp. Psi4 class instance prepared; to compute dispersion. Type:; Dispersion. ordered_params; Fixed-order list of relevant parameters for dashlevel. Matches; DISPERSION CORRECTION ENERGY ordering. Used for printing. Type:; list. Parameters:. name_hint (str)  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (str)  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:3463,Usability,simpl,simple-,3463," printing. Type:; list. Parameters:. name_hint (str)  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (str)  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to one.; param_tweaks (Union[Dict, List])  Values for the same keys as dashcoeff[dashlevel][default]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (str)  Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (str)  Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool)  Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[,wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[,wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[,wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule)  System for which to compute empirical dispersion correction.; wfn (Wavefunction)  Location to set QCVariables.",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energies_from_fcidump.html:776,Deployability,update,updated,776,". energies_from_fcidump. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energies_from_fcidump. energies_from_fcidump. psi4.driver.energies_from_fcidump(intdump)[source]; From integrals dictionary generated from fcidump_from_file(),; compute energies. Return type:; Dict[str, float]. Returns:; a dictionary with energies. NUCLEAR REPULSION ENERGY; ONE-ELECTRON ENERGY; TWO-ELECTRON ENERGY; SCF TOTAL ENERGY; MP2 CORRELATION ENERGY. table of contents. energies_from_fcidump; energies_from_fcidump(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energies_from_fcidump.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energies_from_fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energies_from_fcidump.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:5359,Deployability,configurat,configuration,5359,"s]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual] [details]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual] [details]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. a-ccsd(t); CCSD with asymmetric perturbative triples (A-CCSD(T)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual] [details]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual] [details]. ccenergy; expert full control over ccenergy module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual] [details]. fci; full configuration interaction (FCI) [manual] [details]. detci; expert full control over detci module. gaussian-2, g2; Gaussian-2 composite method [manual]. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. psimrcc_scf; Mk-MRCC with regular SCF module (convenience function) [manual]. dmrg-scf; (with CheMPS2) density matrix renormalization group SCF [manual]. dmrg-caspt2; (with CheMPS2) density matrix renormalization group CASPT2 [manual]. dmrg-ci; (with CheMPS2) density matrix renormalization gr",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:5669,Deployability,configurat,configuration,5669,"ual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual] [details]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual] [details]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. a-ccsd(t); CCSD with asymmetric perturbative triples (A-CCSD(T)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual] [details]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual] [details]. ccenergy; expert full control over ccenergy module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual] [details]. fci; full configuration interaction (FCI) [manual] [details]. detci; expert full control over detci module. gaussian-2, g2; Gaussian-2 composite method [manual]. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. psimrcc_scf; Mk-MRCC with regular SCF module (convenience function) [manual]. dmrg-scf; (with CheMPS2) density matrix renormalization group SCF [manual]. dmrg-caspt2; (with CheMPS2) density matrix renormalization group CASPT2 [manual]. dmrg-ci; (with CheMPS2) density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sf-sapt; 0th-order spin-flip SAPT [manual]. sapt(dft); 0th-order SAPT upon KS",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:38022,Deployability,update,updated,38022,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:3,Energy Efficiency,energy,energy,3,". energy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy. energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:; float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean)  filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str)  ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; (with LibEFP) effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. qchf; quadratically-convergent HF. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. scs-mp2; spin-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:115,Energy Efficiency,energy,energy,115,". energy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy. energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:; float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean)  filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str)  ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; (with LibEFP) effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. qchf; quadratically-convergent HF. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. scs-mp2; spin-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:123,Energy Efficiency,energy,energy,123,". energy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy. energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:; float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean)  filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str)  ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; (with LibEFP) effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. qchf; quadratically-convergent HF. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. scs-mp2; spin-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:144,Energy Efficiency,energy,energy,144,". energy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy. energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:; float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean)  filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str)  ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; (with LibEFP) effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. qchf; quadratically-convergent HF. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. scs-mp2; spin-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:225,Energy Efficiency,energy,energy,225,". energy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy. energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:; float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean)  filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str)  ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; (with LibEFP) effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. qchf; quadratically-convergent HF. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. scs-mp2; spin-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:268,Energy Efficiency,energy,energy,268,". energy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy. energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:; float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean)  filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str)  ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; (with LibEFP) effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. qchf; quadratically-convergent HF. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. scs-mp2; spin-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:318,Energy Efficiency,energy,energy,318,". energy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy. energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:; float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean)  filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str)  ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; (with LibEFP) effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. qchf; quadratically-convergent HF. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. scs-mp2; spin-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:360,Energy Efficiency,energy,energy,360,". energy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy. energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:; float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean)  filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str)  ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; (with LibEFP) effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. qchf; quadratically-convergent HF. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. scs-mp2; spin-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:919,Energy Efficiency,energy,energy,919,". energy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy. energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:; float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean)  filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str)  ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; (with LibEFP) effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. qchf; quadratically-convergent HF. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. scs-mp2; spin-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:6437,Energy Efficiency,adapt,adapted,6437,"; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual] [details]. fci; full configuration interaction (FCI) [manual] [details]. detci; expert full control over detci module. gaussian-2, g2; Gaussian-2 composite method [manual]. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. psimrcc_scf; Mk-MRCC with regular SCF module (convenience function) [manual]. dmrg-scf; (with CheMPS2) density matrix renormalization group SCF [manual]. dmrg-caspt2; (with CheMPS2) density matrix renormalization group CASPT2 [manual]. dmrg-ci; (with CheMPS2) density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sf-sapt; 0th-order spin-flip SAPT [manual]. sapt(dft); 0th-order SAPT upon KS reference [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) wi",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:7608,Energy Efficiency,charge,charge,7608,"f-sapt; 0th-order spin-flip SAPT [manual]. sapt(dft); 0th-order SAPT upon KS reference [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC), deprecated [manual]. adc(1); (with ADCC) 1st-order algebraic diagrammatic construction (ADC) [manual]. adc(2); (with ADCC) 2nd-order ADC [manual]. adc(2)-x; (with ADCC) extended 2nd-order ADC [manual]. adc(3); (with ADCC) 3rd-order ADC [manual]. cvs-adc(1); (with ADCC) core-valence separation (CVS) 1st-order ADC [manual]. cvs-adc(2); (with ADCC) CVS 2nd-order ADC [manual]. cvs-adc(2)-x; (with ADCC) CVS extended 2nd-order ADC [manual]. cvs-adc(3); (with ADCC) CVS 3rd-order ADC [manual]. ep2; 2nd-order electron propagator theory. eom-cc2; equation of motion (EOM) CC2 [manual]. eom-ccsd; EOM-CCSD [manual]",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:36394,Energy Efficiency,energy,energy,36394,". ccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). ccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). ccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:36626,Energy Efficiency,energy,energy,36626,"most expensive terms). ccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:36693,Energy Efficiency,energy,energy,36693,"nd Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for mo",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37010,Energy Efficiency,energy,energy,37010,"cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37128,Energy Efficiency,energy,energy,37128,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37320,Energy Efficiency,energy,energy,37320,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37357,Energy Efficiency,energy,energy,37357,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37465,Energy Efficiency,energy,energy,37465,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37713,Energy Efficiency,energy,energy,37713,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37811,Energy Efficiency,energy,energy,37811,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37819,Energy Efficiency,energy,energy,37819,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37967,Energy Efficiency,energy,energy,37967,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:415,Modifiability,variab,variables,415,". energy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy. energy. psi4.driver.energy(name, **kwargs)[source]; Function to compute the single-point electronic energy. Returns:; float  Total electronic energy in Hartrees. SAPT & EFP return interaction energy. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. write_orbitals (str, boolean)  filename || \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after PSI4 finishes.; (boolean) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless PSI4 is called with -m flag. restart_file (str)  ['file.1, file.32] || ./file || etc.; Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. name; calls method. efp; (with LibEFP) effective fragment potential (EFP) [manual]. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. qchf; quadratically-convergent HF. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. scs-mp2; spin-",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:5359,Modifiability,config,configuration,5359,"s]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual] [details]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual] [details]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. a-ccsd(t); CCSD with asymmetric perturbative triples (A-CCSD(T)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual] [details]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual] [details]. ccenergy; expert full control over ccenergy module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual] [details]. fci; full configuration interaction (FCI) [manual] [details]. detci; expert full control over detci module. gaussian-2, g2; Gaussian-2 composite method [manual]. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. psimrcc_scf; Mk-MRCC with regular SCF module (convenience function) [manual]. dmrg-scf; (with CheMPS2) density matrix renormalization group SCF [manual]. dmrg-caspt2; (with CheMPS2) density matrix renormalization group CASPT2 [manual]. dmrg-ci; (with CheMPS2) density matrix renormalization gr",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:5669,Modifiability,config,configuration,5669,"ual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual] [details]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual] [details]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. a-ccsd(t); CCSD with asymmetric perturbative triples (A-CCSD(T)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual] [details]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual] [details]. ccenergy; expert full control over ccenergy module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual] [details]. fci; full configuration interaction (FCI) [manual] [details]. detci; expert full control over detci module. gaussian-2, g2; Gaussian-2 composite method [manual]. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. psimrcc_scf; Mk-MRCC with regular SCF module (convenience function) [manual]. dmrg-scf; (with CheMPS2) density matrix renormalization group SCF [manual]. dmrg-caspt2; (with CheMPS2) density matrix renormalization group CASPT2 [manual]. dmrg-ci; (with CheMPS2) density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sf-sapt; 0th-order spin-flip SAPT [manual]. sapt(dft); 0th-order SAPT upon KS",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:6437,Modifiability,adapt,adapted,6437,"; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual] [details]. fci; full configuration interaction (FCI) [manual] [details]. detci; expert full control over detci module. gaussian-2, g2; Gaussian-2 composite method [manual]. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. psimrcc_scf; Mk-MRCC with regular SCF module (convenience function) [manual]. dmrg-scf; (with CheMPS2) density matrix renormalization group SCF [manual]. dmrg-caspt2; (with CheMPS2) density matrix renormalization group CASPT2 [manual]. dmrg-ci; (with CheMPS2) density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sf-sapt; 0th-order spin-flip SAPT [manual]. sapt(dft); 0th-order SAPT upon KS reference [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) wi",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:8174,Modifiability,extend,extended,8174," sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC), deprecated [manual]. adc(1); (with ADCC) 1st-order algebraic diagrammatic construction (ADC) [manual]. adc(2); (with ADCC) 2nd-order ADC [manual]. adc(2)-x; (with ADCC) extended 2nd-order ADC [manual]. adc(3); (with ADCC) 3rd-order ADC [manual]. cvs-adc(1); (with ADCC) core-valence separation (CVS) 1st-order ADC [manual]. cvs-adc(2); (with ADCC) CVS 2nd-order ADC [manual]. cvs-adc(2)-x; (with ADCC) CVS extended 2nd-order ADC [manual]. cvs-adc(3); (with ADCC) CVS 3rd-order ADC [manual]. ep2; 2nd-order electron propagator theory. eom-cc2; equation of motion (EOM) CC2 [manual]. eom-ccsd; EOM-CCSD [manual]. eom-cc3; EOM-CC3 [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. td-b1lyp; TDDFT B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. td-b1pw91; TDDFT B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. td-b1wc; TDDFT B1WC Hyb-GGA Exchange-Correlation Functional. b2gpplyp; B2GPPLYP Double Hybrid Exchange-Correlation Functional. b2gpplyp-d3bj2b. b2gpply",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:8411,Modifiability,extend,extended,8411,"]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC), deprecated [manual]. adc(1); (with ADCC) 1st-order algebraic diagrammatic construction (ADC) [manual]. adc(2); (with ADCC) 2nd-order ADC [manual]. adc(2)-x; (with ADCC) extended 2nd-order ADC [manual]. adc(3); (with ADCC) 3rd-order ADC [manual]. cvs-adc(1); (with ADCC) core-valence separation (CVS) 1st-order ADC [manual]. cvs-adc(2); (with ADCC) CVS 2nd-order ADC [manual]. cvs-adc(2)-x; (with ADCC) CVS extended 2nd-order ADC [manual]. cvs-adc(3); (with ADCC) CVS 3rd-order ADC [manual]. ep2; 2nd-order electron propagator theory. eom-cc2; equation of motion (EOM) CC2 [manual]. eom-ccsd; EOM-CCSD [manual]. eom-cc3; EOM-CC3 [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. td-b1lyp; TDDFT B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. td-b1pw91; TDDFT B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. td-b1wc; TDDFT B1WC Hyb-GGA Exchange-Correlation Functional. b2gpplyp; B2GPPLYP Double Hybrid Exchange-Correlation Functional. b2gpplyp-d3bj2b. b2gpplyp-d3bjatm. b2gpplyp-d3zero2b. b2gpplyp-d3zeroatm. b2gpplyp-nl; B2GPPLYP Double Hybrid Exchange-Correlation Functional. b2plyp; B2PLYP Double Hybrid Exchange-Correlation Functional. b2plyp-d3bj2b. b2plyp-d3bjatm. b2plyp-d3mbj2b. b2ply",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:3056,Performance,optimiz,optimized,3056,"eobase interactions [manual]. scs-mp2-vdw; a special version of SCS-MP2 (from ethene dimers) [manual]. sos-mp2; spin-opposite scaled MP2 [manual]. dlpno-mp2; local MP2 with pair natural orbital domains (DLPNO) [manual]. scs-dlpno-mp2; spin-component-scaled DLPNO MP2 [manual]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. scs-mp3; spin-component scaled MP3 [manual]. sos-pi-mp2; A special version of SOS-MP2 for pi systems [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual] [details]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual] [details]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. scs-omp2; spin-component scaled OMP2 [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. scs-omp3; spin-component scaled OMP3 [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. omp2.5; orbital-optimized MP2.5 [manual] [details]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual] [details]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual] [details]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual] [details]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual] [details]. fno-aqcc; AQCC with frozen natural orbitals [",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:3229,Performance,optimiz,optimized,3229," pair natural orbital domains (DLPNO) [manual]. scs-dlpno-mp2; spin-component-scaled DLPNO MP2 [manual]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. scs-mp3; spin-component scaled MP3 [manual]. sos-pi-mp2; A special version of SOS-MP2 for pi systems [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual] [details]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual] [details]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. scs-omp2; spin-component scaled OMP2 [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. scs-omp3; spin-component scaled OMP3 [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. omp2.5; orbital-optimized MP2.5 [manual] [details]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual] [details]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual] [details]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual] [details]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual] [details]. fno-aqcc; AQCC with frozen natural orbitals [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual] [details]. fno-qcisd; QCISD with frozen natural orbitals [manual]. remp2; 2nd-order retaining-the-excitation-de",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:3403,Performance,optimiz,optimized,3403,"ory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. scs-mp3; spin-component scaled MP3 [manual]. sos-pi-mp2; A special version of SOS-MP2 for pi systems [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual] [details]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order MllerPlesset (MP) perturbation theory [manual] [details]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. scs-omp2; spin-component scaled OMP2 [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. scs-omp3; spin-component scaled OMP3 [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. omp2.5; orbital-optimized MP2.5 [manual] [details]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual] [details]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual] [details]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual] [details]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual] [details]. fno-aqcc; AQCC with frozen natural orbitals [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual] [details]. fno-qcisd; QCISD with frozen natural orbitals [manual]. remp2; 2nd-order retaining-the-excitation-degree MP hybrid perturbation theory [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. fno-lcc",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:4325,Performance,optimiz,optimized,4325,"nual]. sos-omp3; spin-opposite scaled OMP3 [manual]. omp2.5; orbital-optimized MP2.5 [manual] [details]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual] [details]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual] [details]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual] [details]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual] [details]. fno-aqcc; AQCC with frozen natural orbitals [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual] [details]. fno-qcisd; QCISD with frozen natural orbitals [manual]. remp2; 2nd-order retaining-the-excitation-degree MP hybrid perturbation theory [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual] [details]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual] [details]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. a-ccsd(t); CCSD with asymmetric perturbative triples (A-CCSD(T)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual] [details]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual] [details]. ccenergy; expert full control ove",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:4467,Performance,optimiz,optimized,4467," approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual] [details]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual] [details]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual] [details]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual] [details]. fno-aqcc; AQCC with frozen natural orbitals [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual] [details]. fno-qcisd; QCISD with frozen natural orbitals [manual]. remp2; 2nd-order retaining-the-excitation-degree MP hybrid perturbation theory [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual] [details]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual] [details]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. a-ccsd(t); CCSD with asymmetric perturbative triples (A-CCSD(T)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual] [details]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual] [details]. ccenergy; expert full control over ccenergy module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbi",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:31811,Performance,tune,tuned-cam-,31811, GGA Exchange-Correlation Functional. td-th1; TDDFT TH1 GGA Exchange-Correlation Functional. th2; TH2 GGA Exchange-Correlation Functional. td-th2; TDDFT TH2 GGA Exchange-Correlation Functional. th3; TH3 GGA Exchange-Correlation Functional. td-th3; TDDFT TH3 GGA Exchange-Correlation Functional. th4; TH4 GGA Exchange-Correlation Functional. td-th4; TDDFT TH4 GGA Exchange-Correlation Functional. tpss; TPSS Meta-GGA XC Functional. td-tpss; TDDFT TPSS Meta-GGA XC Functional. tpss-d3bj2b. tpss-d3bjatm. tpss-d3opatm. tpss-d3zero2b. tpss-d3zeroatm. tpss-nl; TPSS Meta-GGA XC Functional. tpssh; TPSSh Hyb-GGA Exchange-Correlation Functional. td-tpssh; TDDFT TPSSh Hyb-GGA Exchange-Correlation Functional. tpssh-d3bj2b. tpssh-d3bjatm. tpssh-d3opatm. tpssh-d3zero2b. tpssh-d3zeroatm. tpssh-nl; TPSSh-nl Hyb-GGA Exchange-Correlation Functional. tpsslyp1w; TPSSLYP1W GGA Exchange-Correlation Functional. td-tpsslyp1w; TDDFT TPSSLYP1W GGA Exchange-Correlation Functional. tuned-cam-b3lyp; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional. td-tuned-cam-b3lyp; TDDFT TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional. vsxc; VSXC Meta-GGA XC Functional. td-vsxc; TDDFT VSXC Meta-GGA XC Functional. vv10; VV10 GGA Exchange-Correlation Functional. td-vv10; TDDFT VV10 GGA Exchange-Correlation Functional. wb97; wB97 GGA Exchange-Correlation Functional. td-wb97; TDDFT wB97 GGA Exchange-Correlation Functional. wb97m-d3bj. wb97m-v; wB97M-V Hyb-GGA Exchange-Correlation Functional. td-wb97m-v; TDDFT wB97M-V Hyb-GGA Exchange-Correlation Functional. wb97x; wB97X Hyb-GGA Exchange-Correlation Functional. td-wb97x; TDDFT wB97X Hyb-GGA Exchange-Correlation Functional. wb97x-d. wb97x-d3. wb97x-d3bj. wb97x-d3bjatm. wb97x-d3zero2b. wb97x-d3zeroatm. wb97x-v; wB97X-V Hyb-GGA Exchange-Correlation Functional. td-wb97x-v; TDDFT wB97X-V Hyb-GGA Exchange-Correlation Functional. wpbe; PBE SR-XC Functional (HJS Model). td-wpbe; TDDFT PBE SR-XC Functional (HJS Model). wpbe-d3bj2b. wpbe-d3bjatm. wpbe-d3mbj2b. wp,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:31888,Performance,tune,tuned-cam-,31888,on Functional. th2; TH2 GGA Exchange-Correlation Functional. td-th2; TDDFT TH2 GGA Exchange-Correlation Functional. th3; TH3 GGA Exchange-Correlation Functional. td-th3; TDDFT TH3 GGA Exchange-Correlation Functional. th4; TH4 GGA Exchange-Correlation Functional. td-th4; TDDFT TH4 GGA Exchange-Correlation Functional. tpss; TPSS Meta-GGA XC Functional. td-tpss; TDDFT TPSS Meta-GGA XC Functional. tpss-d3bj2b. tpss-d3bjatm. tpss-d3opatm. tpss-d3zero2b. tpss-d3zeroatm. tpss-nl; TPSS Meta-GGA XC Functional. tpssh; TPSSh Hyb-GGA Exchange-Correlation Functional. td-tpssh; TDDFT TPSSh Hyb-GGA Exchange-Correlation Functional. tpssh-d3bj2b. tpssh-d3bjatm. tpssh-d3opatm. tpssh-d3zero2b. tpssh-d3zeroatm. tpssh-nl; TPSSh-nl Hyb-GGA Exchange-Correlation Functional. tpsslyp1w; TPSSLYP1W GGA Exchange-Correlation Functional. td-tpsslyp1w; TDDFT TPSSLYP1W GGA Exchange-Correlation Functional. tuned-cam-b3lyp; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional. td-tuned-cam-b3lyp; TDDFT TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional. vsxc; VSXC Meta-GGA XC Functional. td-vsxc; TDDFT VSXC Meta-GGA XC Functional. vv10; VV10 GGA Exchange-Correlation Functional. td-vv10; TDDFT VV10 GGA Exchange-Correlation Functional. wb97; wB97 GGA Exchange-Correlation Functional. td-wb97; TDDFT wB97 GGA Exchange-Correlation Functional. wb97m-d3bj. wb97m-v; wB97M-V Hyb-GGA Exchange-Correlation Functional. td-wb97m-v; TDDFT wB97M-V Hyb-GGA Exchange-Correlation Functional. wb97x; wB97X Hyb-GGA Exchange-Correlation Functional. td-wb97x; TDDFT wB97X Hyb-GGA Exchange-Correlation Functional. wb97x-d. wb97x-d3. wb97x-d3bj. wb97x-d3bjatm. wb97x-d3zero2b. wb97x-d3zeroatm. wb97x-v; wB97X-V Hyb-GGA Exchange-Correlation Functional. td-wb97x-v; TDDFT wB97X-V Hyb-GGA Exchange-Correlation Functional. wpbe; PBE SR-XC Functional (HJS Model). td-wpbe; TDDFT PBE SR-XC Functional (HJS Model). wpbe-d3bj2b. wpbe-d3bjatm. wpbe-d3mbj2b. wpbe-d3mbjatm. wpbe-d3mzero2b. wpbe-d3mzeroatm. wpbe-d3zero2b. wpbe-d3zeroatm. wp,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37418,Performance,perform,perform,37418,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37520,Performance,perform,perform,37520,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; energy.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.energy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fchk.html:2062,Deployability,update,updated,2062,"k(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate fchk file; filename (str)  destination file name for FCHK file; debug (bool)  returns a dictionary to aid with debugging; strict_label (bool)  If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., Total SCF|MP2|CI|CC Density,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the Orbital Energy field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction)  ; filename (str)  ; debug (bool)  ; strict_label (bool)  . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). table of contents. fchk; fchk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fchk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fchk.html:1499,Energy Efficiency,energy,energy,1499,"k(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate fchk file; filename (str)  destination file name for FCHK file; debug (bool)  returns a dictionary to aid with debugging; strict_label (bool)  If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., Total SCF|MP2|CI|CC Density,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the Orbital Energy field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction)  ; filename (str)  ; debug (bool)  ; strict_label (bool)  . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). table of contents. fchk; fchk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fchk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fchk.html:1240,Performance,optimiz,optimized,1240,"k(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate fchk file; filename (str)  destination file name for FCHK file; debug (bool)  returns a dictionary to aid with debugging; strict_label (bool)  If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., Total SCF|MP2|CI|CC Density,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the Orbital Energy field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction)  ; filename (str)  ; debug (bool)  ; strict_label (bool)  . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). table of contents. fchk; fchk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fchk.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fchk.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fcidump.html:1394,Deployability,update,updated,1394,". fcidump. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump. fcidump. psi4.driver.fcidump(wfn, fname='INTDUMP', oe_ints=None)[source]; Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters:. wfn (Wavefunction)  Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname (str)  Name of the integrals file, defaults to INTDUMP.; oe_ints (Optional[List])  List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises:; ValidationError  When SCF wavefunction is not RHF. Examples; >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). table of contents. fcidump; fcidump(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fcidump.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fcidump.html:956,Energy Efficiency,energy,energy,956,". fcidump. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump. fcidump. psi4.driver.fcidump(wfn, fname='INTDUMP', oe_ints=None)[source]; Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters:. wfn (Wavefunction)  Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname (str)  Name of the integrals file, defaults to INTDUMP.; oe_ints (Optional[List])  List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises:; ValidationError  When SCF wavefunction is not RHF. Examples; >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). table of contents. fcidump; fcidump(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fcidump.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fcidump.html:1086,Energy Efficiency,energy,energy,1086,". fcidump. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump. fcidump. psi4.driver.fcidump(wfn, fname='INTDUMP', oe_ints=None)[source]; Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters:. wfn (Wavefunction)  Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname (str)  Name of the integrals file, defaults to INTDUMP.; oe_ints (Optional[List])  List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises:; ValidationError  When SCF wavefunction is not RHF. Examples; >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). table of contents. fcidump; fcidump(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fcidump.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fcidump_from_file.html:1049,Deployability,update,updated,1049,". fcidump_from_file. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump_from_file. fcidump_from_file. psi4.driver.fcidump_from_file(fname)[source]; Function to read in a FCIDUMP file. Return type:; Dict[str, Any]. Returns:; a dictionary with FCIDUMP header and integrals. norb : number of basis functions; nelec : number of electrons; ms2 : spin polarization of the system; isym : symmetry of state (if present in FCIDUMP); orbsym : list of symmetry labels of each orbital; uhf : whether restricted or unrestricted; enuc : nuclear repulsion plus frozen core energy; epsilon : orbital energies; hcore : core Hamiltonian; eri : electron-repulsion integrals. Parameters:; fname (str)  FCIDUMP file name. table of contents. fcidump_from_file; fcidump_from_file(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump_from_file.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.fcidump_from_file.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fcidump_from_file.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fcidump_from_file.html:636,Energy Efficiency,energy,energy,636,". fcidump_from_file. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump_from_file. fcidump_from_file. psi4.driver.fcidump_from_file(fname)[source]; Function to read in a FCIDUMP file. Return type:; Dict[str, Any]. Returns:; a dictionary with FCIDUMP header and integrals. norb : number of basis functions; nelec : number of electrons; ms2 : spin polarization of the system; isym : symmetry of state (if present in FCIDUMP); orbsym : list of symmetry labels of each orbital; uhf : whether restricted or unrestricted; enuc : nuclear repulsion plus frozen core energy; epsilon : orbital energies; hcore : core Hamiltonian; eri : electron-repulsion integrals. Parameters:; fname (str)  FCIDUMP file name. table of contents. fcidump_from_file; fcidump_from_file(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; fcidump_from_file.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.fcidump_from_file.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fcidump_from_file.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.find_approximate_string_matches.html:928,Deployability,update,updated,928,". find_approximate_string_matches. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; find_approximate_string_matches. find_approximate_string_matches. psi4.driver.find_approximate_string_matches(seq1, options, max_distance)[source]; Find list of approximate (within max_distance) matches to string seq1 among options. Parameters:. seq1 (str)  Target string to look for near matches to.; options (List[str])  Alternatives among which to look for near matches to seq1.; max_distance (int)  Maximum Levenshtein distance from seq1 to return. Return type:; List[str]. table of contents. find_approximate_string_matches; find_approximate_string_matches(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; find_approximate_string_matches.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.find_approximate_string_matches.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.find_approximate_string_matches.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:1412,Availability,avail,available,1412,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:1473,Availability,avail,available,1473,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:1876,Availability,avail,available,1876," be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:1992,Availability,avail,availability,1992,"\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. freq; freq(). ; hide menu. ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:2207,Availability,avail,available,2207,"ython functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. freq; freq(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; freq.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:3143,Deployability,update,updated,3143,"ded (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. freq; freq(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; freq.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:283,Energy Efficiency,energy,energy,283,". freq. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; freq. freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availabil",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:337,Energy Efficiency,energy,energy,337,". freq. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; freq. freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availabil",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:810,Energy Efficiency,energy,energy,810,". freq. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; freq. freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availabil",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:972,Energy Efficiency,energy,energy,972,". freq. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; freq. freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availabil",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:1099,Energy Efficiency,energy,energy,1099,"freq. freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:1372,Energy Efficiency,energy,energy,1372,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:1027,Performance,perform,performed,1027,". freq. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; freq. freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availabil",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:1121,Performance,perform,performs,1121,"freq. freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:1527,Performance,perform,performed,1527,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:2834,Performance,optimiz,optimize,2834,"ded (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. freq; freq(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; freq.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:876,Security,access,accessed,876,". freq. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; freq. freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availabil",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html:1075,Security,access,accesses,1075,"freq. freq. psi4.driver.freq(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.freq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.freq.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1440,Availability,avail,available,1440,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1501,Availability,avail,available,1501,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1904,Availability,avail,available,1904," be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:2020,Availability,avail,availability,2020,"\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. frequencies; frequencies(). ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:2235,Availability,avail,available,2235,"ython functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. frequencies; frequencies(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequencies.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:3192,Deployability,update,updated,3192,"ercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. frequencies; frequencies(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequencies.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:311,Energy Efficiency,energy,energy,311,". frequencies. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:365,Energy Efficiency,energy,energy,365,". frequencies. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:838,Energy Efficiency,energy,energy,838,". frequencies. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1000,Energy Efficiency,energy,energy,1000,"ncies. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1127,Energy Efficiency,energy,energy,1127,"ies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1400,Energy Efficiency,energy,energy,1400,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1055,Performance,perform,performed,1055,"ncies. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1149,Performance,perform,performs,1149,"ies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1555,Performance,perform,performed,1555,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:2862,Performance,optimiz,optimize,2862,"ercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. frequencies; frequencies(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequencies.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:904,Security,access,accessed,904,". frequencies. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1103,Security,access,accesses,1103,"ies. psi4.driver.frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequencies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1440,Availability,avail,available,1440,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1501,Availability,avail,available,1501,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1904,Availability,avail,available,1904," be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:2020,Availability,avail,availability,2020,"\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. frequency; frequency(). ; h",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:2235,Availability,avail,available,2235,"ython functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. frequency; frequency(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequency.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:3186,Deployability,update,updated,3186,"on Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. frequency; frequency(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequency.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:311,Energy Efficiency,energy,energy,311,". frequency. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:365,Energy Efficiency,energy,energy,365,". frequency. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:838,Energy Efficiency,energy,energy,838,". frequency. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1000,Energy Efficiency,energy,energy,1000,"ncy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1127,Energy Efficiency,energy,energy,1127,"psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1400,Energy Efficiency,energy,energy,1400,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1055,Performance,perform,performed,1055,"ncy. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1149,Performance,perform,performs,1149,"psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1555,Performance,perform,performed,1555,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:2862,Performance,optimiz,optimize,2862,"on Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. frequency; frequency(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequency.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:904,Security,access,accessed,904,". frequency. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency. psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1103,Security,access,accesses,1103,"psi4.driver.frequency(name, **kwargs)[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float  Total electronic energy in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype)  \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- theyre not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str)  \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; HartreeFock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.frequency.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.gdma.html:1065,Deployability,update,updated,1065,". gdma. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; gdma. gdma. psi4.driver.gdma(wfn, datafile='')[source]; Function to use wavefunction information in wfn and, if specified,; additional commands in filename to run GDMA analysis. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate DMA analysis; datafile (str)  optional control file (see GDMA manual) to peform more complicated DMA; analyses. If this option is used, the File keyword must be set to read; a filename.fchk, where filename is provided by WRITER_FILE_LABEL . Examples:. >>> # [1] DMA analysis from MP2 wavefunction. N.B. gradient must be requested to generate MP2 density.; >>> grad, wfn = gradient('mp2', return_wfn=True); >>> gdma(wfn). table of contents. gdma; gdma(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; gdma.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.gdma.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.gdma.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.geometry.html:709,Deployability,update,updated,709,". geometry. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; geometry. geometry. psi4.driver.geometry(geom, name='default')[source]; Function to create a molecule object of name name from the; geometry in string geom. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the string are filtered. Return type:; Molecule. Parameters:. geom (str)  ; name (str)  . table of contents. geometry; geometry(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; geometry.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.geometry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.geometry.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.get_memory.html:485,Deployability,update,updated,485,". get_memory. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_memory. get_memory. psi4.driver.get_memory()[source]; Return the total memory allocation in bytes. Return type:; int. table of contents. get_memory; get_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; get_memory.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.get_memory.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.gradient.html:926,Deployability,update,updated,926,". gradient. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; gradient. gradient. psi4.driver.gradient(name, **kwargs)[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix  Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction)  gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). table of contents. gradient; gradient(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; gradient.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.gradient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.gradient.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.gradient.html:211,Performance,optimiz,optimize,211,". gradient. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; gradient. gradient. psi4.driver.gradient(name, **kwargs)[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix  Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction)  gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). table of contents. gradient; gradient(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; gradient.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.gradient.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.gradient.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.hessian.html:1069,Deployability,update,updated,1069,". hessian. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; hessian. hessian. psi4.driver.hessian(name, **kwargs)[source]; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. Returns:; Matrix  Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. Returns:; (Matrix, Wavefunction)  Hessian and wavefunction when return_wfn specified. Examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). table of contents. hessian; hessian(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; hessian.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.hessian.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.hessian.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ipi_broker.html:774,Deployability,update,updated,774,". ipi_broker. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ipi_broker. ipi_broker. psi4.driver.ipi_broker(LOT, molecule=None, serverdata=False, options=None)[source]; Runs IPIBroker to connect to i-PI (https://ipi-code.org/). Parameters:. LOT (str)  level of theory; molecule (Optional[Molecule])  Initial molecule; serverdata (Union[str, bool])  Configuration where to connect to ipi; options (Optional[Dict])  any additional Psi4 options. Return type:; IPIBroker. table of contents. ipi_broker; ipi_broker(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ipi_broker.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ipi_broker.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.levenshtein.html:580,Deployability,update,updated,580,". levenshtein. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; levenshtein. levenshtein. psi4.driver.levenshtein(seq1, seq2)[source]; Compute the Levenshtein distance between two strings. Parameters:. seq1 (str)  First string.; seq2 (str)  Second string. Return type:; int. table of contents. levenshtein; levenshtein(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; levenshtein.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.levenshtein.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.levenshtein.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.libint2_configuration.html:467,Deployability,configurat,configuration,467,". libint2_configuration. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; libint2_configuration. libint2_configuration. psi4.driver.libint2_configuration()[source]; Returns information on integral classes, derivatives, and AM from currently linked Libint2. Return type:; Dict[str, List[int]]. Returns:. Dictionary of integrals classes with values an array of max angular momentum per derivative level.; Usual configuration returns  {eri: [5, 4, 3], eri2: [6, 5, 4], eri3: [6, 5, 4], onebody: [6, 5, 4]}. table of contents. libint2_configuration; libint2_configuration(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; libint2_configuration.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.libint2_configuration.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.libint2_configuration.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.libint2_configuration.html:846,Deployability,update,updated,846,". libint2_configuration. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; libint2_configuration. libint2_configuration. psi4.driver.libint2_configuration()[source]; Returns information on integral classes, derivatives, and AM from currently linked Libint2. Return type:; Dict[str, List[int]]. Returns:. Dictionary of integrals classes with values an array of max angular momentum per derivative level.; Usual configuration returns  {eri: [5, 4, 3], eri2: [6, 5, 4], eri3: [6, 5, 4], onebody: [6, 5, 4]}. table of contents. libint2_configuration; libint2_configuration(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; libint2_configuration.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.libint2_configuration.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.libint2_configuration.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.libint2_configuration.html:467,Modifiability,config,configuration,467,". libint2_configuration. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; libint2_configuration. libint2_configuration. psi4.driver.libint2_configuration()[source]; Returns information on integral classes, derivatives, and AM from currently linked Libint2. Return type:; Dict[str, List[int]]. Returns:. Dictionary of integrals classes with values an array of max angular momentum per derivative level.; Usual configuration returns  {eri: [5, 4, 3], eri2: [6, 5, 4], eri3: [6, 5, 4], onebody: [6, 5, 4]}. table of contents. libint2_configuration; libint2_configuration(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; libint2_configuration.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.libint2_configuration.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.libint2_configuration.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.libint2_print_out.html:490,Deployability,update,updated,490,". libint2_print_out. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; libint2_print_out. libint2_print_out. psi4.driver.libint2_print_out()[source]. Return type:; None. table of contents. libint2_print_out; libint2_print_out(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; libint2_print_out.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.libint2_print_out.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.libint2_print_out.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html:308,Availability,avail,available,308,". ManagedMethodError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError. ManagedMethodError. exception psi4.driver.ManagedMethodError(circs)[source]; Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters:; circs (List[str])  List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. message; Human readable string describing the exception. stats; Dictionary of conditions for which method request was made.; Keys are:. driver : {energy, gradient, hessian, properties}; derivative_int : {0, 1, 2, prop}, integer representation of driver; method : str, model/method/level-of-theory; link : str, link address to table in docs; method_type : (str, str), raw value and str repr of governing variable and algorithm; reference : (str, str), raw value and str repr of reference type; qc_module : (str, str), raw value and str repr of targeted implementation; fcae : (str, str), raw value and str repr of all-electron/frozen-core status. table of contents. ManagedMethodError; ManagedMethodError; ManagedMethodError.message; ManagedMethodError.stats. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html:1580,Deployability,update,updated,1580,". ManagedMethodError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError. ManagedMethodError. exception psi4.driver.ManagedMethodError(circs)[source]; Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters:; circs (List[str])  List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. message; Human readable string describing the exception. stats; Dictionary of conditions for which method request was made.; Keys are:. driver : {energy, gradient, hessian, properties}; derivative_int : {0, 1, 2, prop}, integer representation of driver; method : str, model/method/level-of-theory; link : str, link address to table in docs; method_type : (str, str), raw value and str repr of governing variable and algorithm; reference : (str, str), raw value and str repr of reference type; qc_module : (str, str), raw value and str repr of targeted implementation; fcae : (str, str), raw value and str repr of all-electron/frozen-core status. table of contents. ManagedMethodError; ManagedMethodError; ManagedMethodError.message; ManagedMethodError.stats. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html:753,Energy Efficiency,energy,energy,753,". ManagedMethodError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError. ManagedMethodError. exception psi4.driver.ManagedMethodError(circs)[source]; Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters:; circs (List[str])  List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. message; Human readable string describing the exception. stats; Dictionary of conditions for which method request was made.; Keys are:. driver : {energy, gradient, hessian, properties}; derivative_int : {0, 1, 2, prop}, integer representation of driver; method : str, model/method/level-of-theory; link : str, link address to table in docs; method_type : (str, str), raw value and str repr of governing variable and algorithm; reference : (str, str), raw value and str repr of reference type; qc_module : (str, str), raw value and str repr of targeted implementation; fcae : (str, str), raw value and str repr of all-electron/frozen-core status. table of contents. ManagedMethodError; ManagedMethodError; ManagedMethodError.message; ManagedMethodError.stats. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html:604,Integrability,message,message,604,". ManagedMethodError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError. ManagedMethodError. exception psi4.driver.ManagedMethodError(circs)[source]; Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters:; circs (List[str])  List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. message; Human readable string describing the exception. stats; Dictionary of conditions for which method request was made.; Keys are:. driver : {energy, gradient, hessian, properties}; derivative_int : {0, 1, 2, prop}, integer representation of driver; method : str, model/method/level-of-theory; link : str, link address to table in docs; method_type : (str, str), raw value and str repr of governing variable and algorithm; reference : (str, str), raw value and str repr of reference type; qc_module : (str, str), raw value and str repr of targeted implementation; fcae : (str, str), raw value and str repr of all-electron/frozen-core status. table of contents. ManagedMethodError; ManagedMethodError; ManagedMethodError.message; ManagedMethodError.stats. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html:1340,Integrability,message,message,1340,". ManagedMethodError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError. ManagedMethodError. exception psi4.driver.ManagedMethodError(circs)[source]; Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters:; circs (List[str])  List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. message; Human readable string describing the exception. stats; Dictionary of conditions for which method request was made.; Keys are:. driver : {energy, gradient, hessian, properties}; derivative_int : {0, 1, 2, prop}, integer representation of driver; method : str, model/method/level-of-theory; link : str, link address to table in docs; method_type : (str, str), raw value and str repr of governing variable and algorithm; reference : (str, str), raw value and str repr of reference type; qc_module : (str, str), raw value and str repr of targeted implementation; fcae : (str, str), raw value and str repr of all-electron/frozen-core status. table of contents. ManagedMethodError; ManagedMethodError; ManagedMethodError.message; ManagedMethodError.stats. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html:1019,Modifiability,variab,variable,1019,". ManagedMethodError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError. ManagedMethodError. exception psi4.driver.ManagedMethodError(circs)[source]; Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters:; circs (List[str])  List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. message; Human readable string describing the exception. stats; Dictionary of conditions for which method request was made.; Keys are:. driver : {energy, gradient, hessian, properties}; derivative_int : {0, 1, 2, prop}, integer representation of driver; method : str, model/method/level-of-theory; link : str, link address to table in docs; method_type : (str, str), raw value and str repr of governing variable and algorithm; reference : (str, str), raw value and str repr of reference type; qc_module : (str, str), raw value and str repr of targeted implementation; fcae : (str, str), raw value and str repr of all-electron/frozen-core status. table of contents. ManagedMethodError; ManagedMethodError; ManagedMethodError.message; ManagedMethodError.stats. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; ManagedMethodError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.ManagedMethodError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.mdi_run.html:758,Deployability,update,updated,758,". mdi_run. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mdi_run. mdi_run. psi4.driver.mdi_run(scf_method, **kwargs)[source]; Begin functioning as an MDI (MolSSI driver interface) engine. Parameters:. scf_method (str)  Method (SCF or post-SCF) used when calculating energies or gradients.; molecule  The target molecule, if not the last molecule defined.; kwargs  Any additional arguments to pass to psi4.driver.energy() or; psi4.driver.gradient() computation. table of contents. mdi_run; mdi_run(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mdi_run.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.mdi_run.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.mdi_run.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.mdi_run.html:476,Energy Efficiency,energy,energy,476,". mdi_run. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mdi_run. mdi_run. psi4.driver.mdi_run(scf_method, **kwargs)[source]; Begin functioning as an MDI (MolSSI driver interface) engine. Parameters:. scf_method (str)  Method (SCF or post-SCF) used when calculating energies or gradients.; molecule  The target molecule, if not the last molecule defined.; kwargs  Any additional arguments to pass to psi4.driver.energy() or; psi4.driver.gradient() computation. table of contents. mdi_run; mdi_run(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mdi_run.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.mdi_run.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.mdi_run.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.mdi_run.html:230,Integrability,interface,interface,230,". mdi_run. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mdi_run. mdi_run. psi4.driver.mdi_run(scf_method, **kwargs)[source]; Begin functioning as an MDI (MolSSI driver interface) engine. Parameters:. scf_method (str)  Method (SCF or post-SCF) used when calculating energies or gradients.; molecule  The target molecule, if not the last molecule defined.; kwargs  Any additional arguments to pass to psi4.driver.energy() or; psi4.driver.gradient() computation. table of contents. mdi_run; mdi_run(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; mdi_run.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.mdi_run.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.mdi_run.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.message_box.html:762,Deployability,update,updated,762,". message_box. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; message_box. message_box. psi4.driver.message_box(message, max_width=80, min_width=30)[source]; Put a message string into a box for extra attention. Parameters:. message (str)  Message string to be boxed.; max_width (int)  Maximal character width of the box.; min_width (int)  Minimal character width of the box. Returns:; Box containing the message as a multiline string. Return type:; str. table of contents. message_box; message_box(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; message_box.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.message_box.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.message_box.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.message_box.html:171,Integrability,message,message,171,". message_box. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; message_box. message_box. psi4.driver.message_box(message, max_width=80, min_width=30)[source]; Put a message string into a box for extra attention. Parameters:. message (str)  Message string to be boxed.; max_width (int)  Maximal character width of the box.; min_width (int)  Minimal character width of the box. Returns:; Box containing the message as a multiline string. Return type:; str. table of contents. message_box; message_box(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; message_box.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.message_box.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.message_box.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.message_box.html:224,Integrability,message,message,224,". message_box. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; message_box. message_box. psi4.driver.message_box(message, max_width=80, min_width=30)[source]; Put a message string into a box for extra attention. Parameters:. message (str)  Message string to be boxed.; max_width (int)  Maximal character width of the box.; min_width (int)  Minimal character width of the box. Returns:; Box containing the message as a multiline string. Return type:; str. table of contents. message_box; message_box(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; message_box.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.message_box.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.message_box.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.message_box.html:284,Integrability,message,message,284,". message_box. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; message_box. message_box. psi4.driver.message_box(message, max_width=80, min_width=30)[source]; Put a message string into a box for extra attention. Parameters:. message (str)  Message string to be boxed.; max_width (int)  Maximal character width of the box.; min_width (int)  Minimal character width of the box. Returns:; Box containing the message as a multiline string. Return type:; str. table of contents. message_box; message_box(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; message_box.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.message_box.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.message_box.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.message_box.html:467,Integrability,message,message,467,". message_box. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; message_box. message_box. psi4.driver.message_box(message, max_width=80, min_width=30)[source]; Put a message string into a box for extra attention. Parameters:. message (str)  Message string to be boxed.; max_width (int)  Maximal character width of the box.; min_width (int)  Minimal character width of the box. Returns:; Box containing the message as a multiline string. Return type:; str. table of contents. message_box; message_box(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; message_box.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.message_box.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.message_box.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html:297,Availability,avail,available,297,". MissingMethodError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MissingMethodError. MissingMethodError. exception psi4.driver.MissingMethodError(msg)[source]; Error called when requested level or theory or derivative level are not; available. Parameters:; msg (str)  Human readable string describing the exception. message; Human readable string describing the exception. table of contents. MissingMethodError; MissingMethodError; MissingMethodError.message. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MissingMethodError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html:731,Deployability,update,updated,731,". MissingMethodError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MissingMethodError. MissingMethodError. exception psi4.driver.MissingMethodError(msg)[source]; Error called when requested level or theory or derivative level are not; available. Parameters:; msg (str)  Human readable string describing the exception. message; Human readable string describing the exception. table of contents. MissingMethodError; MissingMethodError; MissingMethodError.message. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MissingMethodError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html:381,Integrability,message,message,381,". MissingMethodError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MissingMethodError. MissingMethodError. exception psi4.driver.MissingMethodError(msg)[source]; Error called when requested level or theory or derivative level are not; available. Parameters:; msg (str)  Human readable string describing the exception. message; Human readable string describing the exception. table of contents. MissingMethodError; MissingMethodError; MissingMethodError.message. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MissingMethodError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html:517,Integrability,message,message,517,". MissingMethodError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MissingMethodError. MissingMethodError. exception psi4.driver.MissingMethodError(msg)[source]; Error called when requested level or theory or derivative level are not; available. Parameters:; msg (str)  Human readable string describing the exception. message; Human readable string describing the exception. table of contents. MissingMethodError; MissingMethodError; MissingMethodError.message. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; MissingMethodError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.MissingMethodError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molden.html:2876,Deployability,update,updated,2876,"onal); density_b (Matrix)  density in the MO basis to build beta NOs from, assumes restricted if not supplied (optional); dovirtual (bool)  do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NOs (false) (optional). Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO).; >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). table of contents. molden; molden(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; molden.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molden.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molden.html:482,Energy Efficiency,energy,energy,482,". molden. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; molden. molden. psi4.driver.molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None)[source]; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files; filename (str)  destination file name for MOLDEN file (optional); density_a (Matrix)  density in the MO basis to build alpha NOs from (optional); density_b (Matrix)  density in the MO basis to build beta NOs from, assumes restricted if not supplied (optional); dovirtual (bool)  do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NOs (false) (optional). Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function n",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molden.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molden.html:1302,Energy Efficiency,energy,energy,1302,"tural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. wfn (Wavefunction)  set of molecule, basis, orbitals from which to generate cube files; filename (str)  destination file name for MOLDEN file (optional); density_a (Matrix)  density in the MO basis to build alpha NOs from (optional); density_b (Matrix)  density in the MO basis to build beta NOs from, assumes restricted if not supplied (optional); dovirtual (bool)  do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NOs (false) (optional). Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molden.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molden.html:1811,Energy Efficiency,energy,energy,1811,"tination file name for MOLDEN file (optional); density_a (Matrix)  density in the MO basis to build alpha NOs from (optional); density_b (Matrix)  density in the MO basis to build beta NOs from, assumes restricted if not supplied (optional); dovirtual (bool)  do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NOs (false) (optional). Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO).; >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). table of contents. molden; molden(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; molden.  Cop",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molden.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molden.html:2174,Energy Efficiency,energy,energy,2174,"onal); density_b (Matrix)  density in the MO basis to build beta NOs from, assumes restricted if not supplied (optional); dovirtual (bool)  do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NOs (false) (optional). Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO).; >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). table of contents. molden; molden(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; molden.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molden.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molecule_get_attr.html:539,Deployability,update,updated,539,". molecule_get_attr. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; molecule_get_attr. molecule_get_attr. psi4.driver.molecule_get_attr(self, name)[source]; Function to redefine __getattr__ method of molecule class. table of contents. molecule_get_attr; molecule_get_attr(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; molecule_get_attr.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.molecule_get_attr.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molecule_get_attr.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molecule_set_attr.html:546,Deployability,update,updated,546,". molecule_set_attr. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; molecule_set_attr. molecule_set_attr. psi4.driver.molecule_set_attr(self, name, value)[source]; Function to redefine __setattr__ method of molecule class. table of contents. molecule_set_attr; molecule_set_attr(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; molecule_set_attr.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.molecule_set_attr.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.molecule_set_attr.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.oeprop.html:888,Deployability,update,updated,888,". oeprop. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; oeprop. oeprop. psi4.driver.oeprop(wfn, *args, **kwargs)[source]; Evaluate one-electron properties. Returns:; None. Parameters:. wfn (Wavefunction)  set of molecule, basis, orbitals from which to compute properties; args (List[str])  Arbitrary-number of properties to be computed from wfn.; See Available One-Electron Properties.; title (str)  label prepended to all psivars computed. Examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). table of contents. oeprop; oeprop(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; oeprop.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.oeprop.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.oeprop.html:568,Energy Efficiency,energy,energy,568,". oeprop. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; oeprop. oeprop. psi4.driver.oeprop(wfn, *args, **kwargs)[source]; Evaluate one-electron properties. Returns:; None. Parameters:. wfn (Wavefunction)  set of molecule, basis, orbitals from which to compute properties; args (List[str])  Arbitrary-number of properties to be computed from wfn.; See Available One-Electron Properties.; title (str)  label prepended to all psivars computed. Examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). table of contents. oeprop; oeprop(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; oeprop.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.oeprop.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:2163,Availability,avail,available,2163,"tries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:2584,Availability,avail,available,2584," optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; couple",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:17220,Deployability,update,updated,17220,"sss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:254,Energy Efficiency,energy,energy,254,". opt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt. opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:331,Energy Efficiency,energy,energy,331,". opt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt. opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:731,Energy Efficiency,energy,energy,731,". opt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt. opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1004,Energy Efficiency,energy,energy,1004,". opt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt. opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1768,Energy Efficiency,energy,energy,1768,"he target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1895,Energy Efficiency,energy,energy,1895,"to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; densit",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:2123,Energy Efficiency,energy,energy,2123,"tries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:2671,Energy Efficiency,energy,energy,2671," not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and dou",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16609,Energy Efficiency,energy,energy,16609,"sss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16671,Energy Efficiency,energy,energy,16671,"sss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:500,Modifiability,variab,variables,500,". opt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt. opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:169,Performance,perform,perform,169,". opt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt. opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:188,Performance,optimiz,optimization,188,". opt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt. opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:264,Performance,optimiz,optimized,264,". opt. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt. opt. psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python f",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1209,Performance,optimiz,optimization,1209," psi4.driver.opt(name, **kwargs); Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || '",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1309,Performance,optimiz,optimization,1309,"efunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1380,Performance,optimiz,optimizer,1380,"efunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1493,Performance,optimiz,optimizers,1493,"URRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being c",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1564,Performance,optimiz,optimizer,1564,"URRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being c",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1592,Performance,optimiz,optimization,1592,"URRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being c",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1823,Performance,perform,performed,1823,"he target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1917,Performance,perform,performs,1917,"to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; densit",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:2196,Performance,optimiz,optimization,2196,"tries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:2218,Performance,perform,performed,2218,"tries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:2323,Performance,perform,perform,2323,"to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-op",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:2373,Performance,optimiz,optimization,2373,"to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-op",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:2750,Performance,optimiz,optimizations,2750," \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:3166,Performance,optimiz,optimized,3166,nce; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbj,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:3246,Performance,optimiz,optimized,3246,c.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3opatm. b3lyp-d3zero2b. b3lyp-d3z,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:3327,Performance,optimiz,optimized,3327,rm a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3opatm. b3lyp-d3zero2b. b3lyp-d3zeroatm. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Fu,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:3379,Performance,optimiz,optimized,3379,arning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3opatm. b3lyp-d3zero2b. b3lyp-d3zeroatm. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Funct,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:3467,Performance,optimiz,optimized,3467,ms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3opatm. b3lyp-d3zero2b. b3lyp-d3zeroatm. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exch,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:15956,Performance,optimiz,optimization,15956,"A Exchange-Correlation Functional. x3lyp-d3bj2b. x3lyp-d3bjatm. x3lyp-d3zero2b. x3lyp-d3zeroatm. xb1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj2b. xlyp-d3bjatm. xlyp-d3zero2b. xlyp-d3zeroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:15974,Performance,optimiz,optimize,15974,"A Exchange-Correlation Functional. x3lyp-d3bj2b. x3lyp-d3bjatm. x3lyp-d3zero2b. x3lyp-d3zeroatm. xb1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj2b. xlyp-d3bjatm. xlyp-d3zero2b. xlyp-d3zeroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16022,Performance,optimiz,optimization,16022,"1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj2b. xlyp-d3bjatm. xlyp-d3zero2b. xlyp-d3zeroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16183,Performance,perform,perform,16183,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt.  Copyright 2007-2023, The Psi4 Pro",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16230,Performance,optimiz,optimize,16230,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt.  Copyright 2007-2023, The Psi4 Pro",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16291,Performance,perform,perform,16291,"sss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16484,Performance,optimiz,optimize,16484,"sss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16637,Performance,optimiz,optimization,16637,"sss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16721,Performance,optimiz,optimization,16721,"sss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16808,Performance,optimiz,optimization,16808,"sss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16842,Performance,optimiz,optimize,16842,"sss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; opt.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:1871,Security,access,accesses,1871,"to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; densit",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:2354,Usability,guid,guide,2354,"to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-op",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html:1123,Deployability,update,updated,1123,". OptimizationConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError. OptimizationConvergenceError. exception psi4.driver.OptimizationConvergenceError(eqn_description, iteration, wfn)[source]; Error called for problems with geometry optimizer. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., geometry optimization).; iteration (int)  Iteration number on which routine failed.; wfn (Wavefunction)  Wavefunction at time of exception. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. wfn; Wavefunction at time of exception. table of contents. OptimizationConvergenceError; OptimizationConvergenceError; OptimizationConvergenceError.message; OptimizationConvergenceError.iteration; OptimizationConvergenceError.wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html:391,Integrability,rout,routine,391,". OptimizationConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError. OptimizationConvergenceError. exception psi4.driver.OptimizationConvergenceError(eqn_description, iteration, wfn)[source]; Error called for problems with geometry optimizer. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., geometry optimization).; iteration (int)  Iteration number on which routine failed.; wfn (Wavefunction)  Wavefunction at time of exception. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. wfn; Wavefunction at time of exception. table of contents. OptimizationConvergenceError; OptimizationConvergenceError; OptimizationConvergenceError.message; OptimizationConvergenceError.iteration; OptimizationConvergenceError.wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html:491,Integrability,rout,routine,491,". OptimizationConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError. OptimizationConvergenceError. exception psi4.driver.OptimizationConvergenceError(eqn_description, iteration, wfn)[source]; Error called for problems with geometry optimizer. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., geometry optimization).; iteration (int)  Iteration number on which routine failed.; wfn (Wavefunction)  Wavefunction at time of exception. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. wfn; Wavefunction at time of exception. table of contents. OptimizationConvergenceError; OptimizationConvergenceError; OptimizationConvergenceError.message; OptimizationConvergenceError.iteration; OptimizationConvergenceError.wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html:564,Integrability,message,message,564,". OptimizationConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError. OptimizationConvergenceError. exception psi4.driver.OptimizationConvergenceError(eqn_description, iteration, wfn)[source]; Error called for problems with geometry optimizer. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., geometry optimization).; iteration (int)  Iteration number on which routine failed.; wfn (Wavefunction)  Wavefunction at time of exception. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. wfn; Wavefunction at time of exception. table of contents. OptimizationConvergenceError; OptimizationConvergenceError; OptimizationConvergenceError.message; OptimizationConvergenceError.iteration; OptimizationConvergenceError.wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html:660,Integrability,rout,routine,660,". OptimizationConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError. OptimizationConvergenceError. exception psi4.driver.OptimizationConvergenceError(eqn_description, iteration, wfn)[source]; Error called for problems with geometry optimizer. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., geometry optimization).; iteration (int)  Iteration number on which routine failed.; wfn (Wavefunction)  Wavefunction at time of exception. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. wfn; Wavefunction at time of exception. table of contents. OptimizationConvergenceError; OptimizationConvergenceError; OptimizationConvergenceError.message; OptimizationConvergenceError.iteration; OptimizationConvergenceError.wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html:825,Integrability,message,message,825,". OptimizationConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError. OptimizationConvergenceError. exception psi4.driver.OptimizationConvergenceError(eqn_description, iteration, wfn)[source]; Error called for problems with geometry optimizer. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., geometry optimization).; iteration (int)  Iteration number on which routine failed.; wfn (Wavefunction)  Wavefunction at time of exception. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. wfn; Wavefunction at time of exception. table of contents. OptimizationConvergenceError; OptimizationConvergenceError; OptimizationConvergenceError.message; OptimizationConvergenceError.iteration; OptimizationConvergenceError.wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html:332,Performance,optimiz,optimizer,332,". OptimizationConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError. OptimizationConvergenceError. exception psi4.driver.OptimizationConvergenceError(eqn_description, iteration, wfn)[source]; Error called for problems with geometry optimizer. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., geometry optimization).; iteration (int)  Iteration number on which routine failed.; wfn (Wavefunction)  Wavefunction at time of exception. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. wfn; Wavefunction at time of exception. table of contents. OptimizationConvergenceError; OptimizationConvergenceError; OptimizationConvergenceError.message; OptimizationConvergenceError.iteration; OptimizationConvergenceError.wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html:431,Performance,optimiz,optimization,431,". OptimizationConvergenceError. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError. OptimizationConvergenceError. exception psi4.driver.OptimizationConvergenceError(eqn_description, iteration, wfn)[source]; Error called for problems with geometry optimizer. Parameters:. eqn_description (str)  Type of QC routine that has failed (e.g., geometry optimization).; iteration (int)  Iteration number on which routine failed.; wfn (Wavefunction)  Wavefunction at time of exception. message; Human readable string describing the exception. iteration; Iteration number on which routine failed. wfn; Wavefunction at time of exception. table of contents. OptimizationConvergenceError; OptimizationConvergenceError; OptimizationConvergenceError.message; OptimizationConvergenceError.iteration; OptimizationConvergenceError.wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; OptimizationConvergenceError.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.OptimizationConvergenceError.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:2191,Availability,avail,available,2191,"tries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:2612,Availability,avail,available,2612," optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; couple",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:17263,Deployability,update,updated,17263,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:282,Energy Efficiency,energy,energy,282,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:359,Energy Efficiency,energy,energy,359,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:759,Energy Efficiency,energy,energy,759,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1032,Energy Efficiency,energy,energy,1032,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1796,Energy Efficiency,energy,energy,1796,"he target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1923,Energy Efficiency,energy,energy,1923,"to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; densit",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:2151,Energy Efficiency,energy,energy,2151,"tries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:2699,Energy Efficiency,energy,energy,2699," not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and dou",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16637,Energy Efficiency,energy,energy,16637,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16699,Energy Efficiency,energy,energy,16699,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:528,Modifiability,variab,variables,528,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:3,Performance,optimiz,optimize,3,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:117,Performance,optimiz,optimize,117,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:127,Performance,optimiz,optimize,127,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:150,Performance,optimiz,optimize,150,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:197,Performance,perform,perform,197,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:216,Performance,optimiz,optimization,216,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:292,Performance,optimiz,optimized,292,". optimize. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize. optimize. psi4.driver.optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1237,Performance,optimiz,optimization,1237,"optimize(name, **kwargs)[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float  Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || '",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1337,Performance,optimiz,optimization,1337,"efunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1408,Performance,optimiz,optimizer,1408,"efunction)  energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1521,Performance,optimiz,optimizers,1521,"URRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being c",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1592,Performance,optimiz,optimizer,1592,"URRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being c",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1620,Performance,optimiz,optimization,1620,"URRENT ENERGY. Parameters:. name (str)  'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule)  h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being c",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1851,Performance,perform,performed,1851,"he target molecule, if not the last molecule defined. return_wfn (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1945,Performance,perform,performs,1945,"to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; densit",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:2224,Performance,optimiz,optimization,2224,"tries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:2246,Performance,perform,performed,2246,"tries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:2351,Performance,perform,perform,2351,"to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-op",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:2401,Performance,optimiz,optimization,2401,"to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-op",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:2778,Performance,optimiz,optimizations,2778," \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:3194,Performance,optimiz,optimized,3194,nce; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbj,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:3274,Performance,optimiz,optimized,3274,c.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3opatm. b3lyp-d3zero2b. b3lyp-d3z,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:3355,Performance,optimiz,optimized,3355,rm a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3opatm. b3lyp-d3zero2b. b3lyp-d3zeroatm. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Fu,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:3407,Performance,optimiz,optimized,3407,arning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3opatm. b3lyp-d3zero2b. b3lyp-d3zeroatm. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Funct,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:3495,Performance,optimiz,optimized,3495,ms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3opatm. b3lyp-d3zero2b. b3lyp-d3zeroatm. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exch,MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:15984,Performance,optimiz,optimization,15984,"A Exchange-Correlation Functional. x3lyp-d3bj2b. x3lyp-d3bjatm. x3lyp-d3zero2b. x3lyp-d3zeroatm. xb1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj2b. xlyp-d3bjatm. xlyp-d3zero2b. xlyp-d3zeroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16002,Performance,optimiz,optimize,16002,"A Exchange-Correlation Functional. x3lyp-d3bj2b. x3lyp-d3bjatm. x3lyp-d3zero2b. x3lyp-d3zeroatm. xb1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj2b. xlyp-d3bjatm. xlyp-d3zero2b. xlyp-d3zeroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16050,Performance,optimiz,optimization,16050,"1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj2b. xlyp-d3bjatm. xlyp-d3zero2b. xlyp-d3zeroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16211,Performance,perform,perform,16211,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-202",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16258,Performance,optimiz,optimize,16258,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gausss CFOUR program [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-202",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16319,Performance,perform,perform,16319,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16512,Performance,optimiz,optimize,16512,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16665,Performance,optimiz,optimization,16665,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16749,Performance,optimiz,optimization,16749,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16836,Performance,optimiz,optimization,16836,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16870,Performance,optimiz,optimize,16870,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:17046,Performance,optimiz,optimize,17046,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:17056,Performance,optimiz,optimize,17056,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:17206,Performance,optimiz,optimize,17206,"ram [manual]. c4-scf; HartreeFock (HF). c4-mp2; 2nd-order MllerPlesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order MllerPlesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:1899,Security,access,accesses,1899,"to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean)  'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str)  \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; densit",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:2382,Usability,guid,guide,2382,"to use, which can be either Psi4s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict)  Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function)  \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype)  'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str)  'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; HartreeFock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order MllerPlesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order MllerPlesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-op",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize_geometric.html:491,Deployability,update,updated,491,". optimize_geometric. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize_geometric. optimize_geometric. psi4.driver.optimize_geometric(name, **kwargs)[source]. table of contents. optimize_geometric; optimize_geometric(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; optimize_geometric.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.optimize_geometric.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize_geometric.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.all_casings.html:614,Deployability,update,updated,614,". all_casings. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; all_casings. all_casings. psi4.driver.p4util.all_casings(input_string)[source]; Return a generator of all lettercase permutations of input_string. Parameters:; input_string (str)  String of which to permute the case. Return type:; Iterator[str]. table of contents. all_casings; all_casings(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; all_casings.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.all_casings.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.all_casings.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.array_to_matrix.html:1636,Deployability,update,updated,1636,". array_to_matrix. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; array_to_matrix. array_to_matrix. psi4.driver.p4util.array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None)[source]; Converts a NumPy array or list of; NumPy arrays into a PSI4 Matrix or; Vector (irrepped if list). Parameters:. self (Union[Matrix, Vector])  Matrix or Vector class.; arr (Union[ndarray, List[ndarray]])  NumPy array or list of arrays to use as the data for a new; Matrix or Vector.; name (str)  Name to give the new Matrix.; dim1 (Union[List, Tuple, Dimension, None])  If a single dense NumPy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension])  Same as dim1 only if using a Dimension object. Returns:; Returns the given (self) Psi4 object. Return type:; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). table of contents. array_to_matrix; array_to_matrix(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; array_to_matrix.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.array_to_matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.array_to_matrix.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.banner.html:885,Deployability,update,updated,885,". banner. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; banner. banner. psi4.driver.p4util.banner(text, type=1, width=35, strNotOutfile=False)[source]; Format text into a banner style and print or return it. Parameters:. text (str)  String to be emphasized.; type (int)  Style 1 has minimum three-line height. Style 2 has minimum one-light; height.; width (int)  Minimum length of banner string.; strNotOutfile (bool)  Controls mode of return. Return type:; Optional[str]. Returns:. str  If strNotOutfile is True, return string.; None  If strNotOutfile is False, print it to output file. table of contents. banner; banner(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; banner.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.banner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.banner.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.basis_helper.html:1118,Deployability,update,updated,1118,". basis_helper. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper. psi4.driver.p4util.basis_helper(block, name='', key='BASIS', set_option=True)[source]; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str)  Text that goes in a PSIthon basis {...} block.; name (str)  Name label to associated with basis specified by block.; key (str)  Basis keyword specified by block.; set_option (bool)  When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. table of contents. basis_helper; basis_helper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; basis_helper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.basis_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.basis_helper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.basis_helper.html:540,Testability,test,test,540,". basis_helper. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper. psi4.driver.p4util.basis_helper(block, name='', key='BASIS', set_option=True)[source]; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str)  Text that goes in a PSIthon basis {...} block.; name (str)  Name label to associated with basis specified by block.; key (str)  Basis keyword specified by block.; set_option (bool)  When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. table of contents. basis_helper; basis_helper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; basis_helper.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.basis_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.basis_helper.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.block_diagonal_array.html:703,Deployability,update,updated,703,". block_diagonal_array. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; block_diagonal_array. block_diagonal_array. psi4.driver.p4util.block_diagonal_array(*args)[source]; Convert square NumPy array to a single block diagonal array.; Mimic of SciPys scipy.linalg.block_diag(). Parameters:; args (List[ndarray])  Arbitrary number of square arrays. Return type:; ndarray. table of contents. block_diagonal_array; block_diagonal_array(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; block_diagonal_array.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.block_diagonal_array.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.block_diagonal_array.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.cg_solver.html:545,Availability,mask,mask,545,". cg_solver. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cg_solver. cg_solver. psi4.driver.p4util.cg_solver(rhs_vec, hx_function, preconditioner, guess=None, printer=None, printlvl=1, maxiter=20, rcond=1e-06)[source]; Solves the \(Ax = b\) linear equations via Conjugate Gradient. The A matrix must be a hermitian, positive definite matrix. Parameters:. rhs_vec (List[Matrix])  The RHS vector in the Ax=b equation.; hx_function (Callable)  Takes in a list of Matrix objects and a mask of active indices. Returns the Hessian-vector product.; preconditioner (Callable)  Takes in a list of Matrix objects and a mask of active indices. Returns the preconditioned value.; guess (Optional[List[Matrix]])  Starting vectors. If None, use a preconditioner (rhs) guess; printer (Optional[Callable])  Takes in a list of current x and residual vectors and provides a print function. This function can also; return a value that represents the current residual.; printlvl (int)  The level of printing provided by this function.; maxiter (int)  The maximum number of iterations this function will take.; rcond (float)  The residual norm for convergence. Returns:; ret  Solved x vectors and r vectors. Return type:; List[Matrix]. Notes; This is a generalized cg solver that can also take advantage of solving multiple RHSs simultaneously when; it is advantageous to do so. table of contents. cg_solver; cg_solver(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cg_solver.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.cg_solver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.cg_solver.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.cg_solver.html:674,Availability,mask,mask,674,". cg_solver. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cg_solver. cg_solver. psi4.driver.p4util.cg_solver(rhs_vec, hx_function, preconditioner, guess=None, printer=None, printlvl=1, maxiter=20, rcond=1e-06)[source]; Solves the \(Ax = b\) linear equations via Conjugate Gradient. The A matrix must be a hermitian, positive definite matrix. Parameters:. rhs_vec (List[Matrix])  The RHS vector in the Ax=b equation.; hx_function (Callable)  Takes in a list of Matrix objects and a mask of active indices. Returns the Hessian-vector product.; preconditioner (Callable)  Takes in a list of Matrix objects and a mask of active indices. Returns the preconditioned value.; guess (Optional[List[Matrix]])  Starting vectors. If None, use a preconditioner (rhs) guess; printer (Optional[Callable])  Takes in a list of current x and residual vectors and provides a print function. This function can also; return a value that represents the current residual.; printlvl (int)  The level of printing provided by this function.; maxiter (int)  The maximum number of iterations this function will take.; rcond (float)  The residual norm for convergence. Returns:; ret  Solved x vectors and r vectors. Return type:; List[Matrix]. Notes; This is a generalized cg solver that can also take advantage of solving multiple RHSs simultaneously when; it is advantageous to do so. table of contents. cg_solver; cg_solver(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cg_solver.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.cg_solver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.cg_solver.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.cg_solver.html:1669,Deployability,update,updated,1669,". cg_solver. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cg_solver. cg_solver. psi4.driver.p4util.cg_solver(rhs_vec, hx_function, preconditioner, guess=None, printer=None, printlvl=1, maxiter=20, rcond=1e-06)[source]; Solves the \(Ax = b\) linear equations via Conjugate Gradient. The A matrix must be a hermitian, positive definite matrix. Parameters:. rhs_vec (List[Matrix])  The RHS vector in the Ax=b equation.; hx_function (Callable)  Takes in a list of Matrix objects and a mask of active indices. Returns the Hessian-vector product.; preconditioner (Callable)  Takes in a list of Matrix objects and a mask of active indices. Returns the preconditioned value.; guess (Optional[List[Matrix]])  Starting vectors. If None, use a preconditioner (rhs) guess; printer (Optional[Callable])  Takes in a list of current x and residual vectors and provides a print function. This function can also; return a value that represents the current residual.; printlvl (int)  The level of printing provided by this function.; maxiter (int)  The maximum number of iterations this function will take.; rcond (float)  The residual norm for convergence. Returns:; ret  Solved x vectors and r vectors. Return type:; List[Matrix]. Notes; This is a generalized cg solver that can also take advantage of solving multiple RHSs simultaneously when; it is advantageous to do so. table of contents. cg_solver; cg_solver(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; cg_solver.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.cg_solver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.cg_solver.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html:309,Availability,checkpoint,checkpoint,309,". compare_fchkfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles. psi4.driver.p4util.compare_fchkfiles(expected, computed, atol_exponent, label)[source]; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4s FCHK files. Parameters:. expected (str)  Path to reference FCHK file against which computed is compared.; computed (str)  Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html:539,Availability,avail,available,539,". compare_fchkfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles. psi4.driver.p4util.compare_fchkfiles(expected, computed, atol_exponent, label)[source]; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4s FCHK files. Parameters:. expected (str)  Path to reference FCHK file against which computed is compared.; computed (str)  Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html
https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html:1076,Availability,toler,tolerance,1076,". compare_fchkfiles. Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles. psi4.driver.p4util.compare_fchkfiles(expected, computed, atol_exponent, label)[source]; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4s FCHK files. Parameters:. expected (str)  Path to reference FCHK file against which computed is compared.; computed (str)  Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float])  Absolute tolerance for high accuracy fields  1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str)  Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.8.2; . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html
