id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html530/TGeoManager.html:33259,Security,hash,hash,33259,,MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:33319,Security,hash,hash,33319,,MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:68844,Security,access,access,68844,"unction).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Int_t * GetIntBuffer(Int_t length); Get a temporary buffer of Int_t*. Double_t * GetDblBuffer(Int_t length); Get a temporary buffer of Double_t*. Bool_t GetTminTmax(Double_t& tmin, Double_t& tmax) const; Get time cut for drawing tracks. void SetTminTmax(Double_t tmin = 0, Double_t tmax = 999); Set time cut interval for drawing tracks. If called with no arguments, time; cut will be disabled. void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. Bool_t IsLoopingVolumes() const; --- private methods. {return fLoopVolumes;}. void SetLoopVolumes(Bool_t flag = kTRUE); {fLoopVolumes=flag;}. Int_t GetNmany() const; {return fCurrentNavigator->GetNmany();}. Bool_t IsFolder() const; --- visualization settings. { return kTRUE; }. TGeoShape * GetClippingShape() const; {return fCl",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:2033,Testability,log,logical,2033,"d; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Constructive solid geometry composition is used only in order to create more; complex shapes from an existing set of primitives through boolean operations.; This feature is not implemented yet but in future full definition of boolean; expressions will be supported. Practically every geometry defined in GEANT style can be mapped by the modeler.; The basic components used for building the logical hierarchy of the geometry; are called ""volumes"" and ""nodes"". Volumes (sometimes called ""solids"") are fully; defined geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of volumes; inside a container volume and they are not directly defined by user. They are; automatically created as a result of adding one volume inside other or dividing; a volume. The geometrical transformation hold by nodes is always defined with; respect to their mother (relative positioning). Reflection matrices are allowed.; All volumes have to be fully aware of their containees when the geometry is; closed. They will build aditional structures (voxels) in order to fasten-up; the search algorithms. Finally, nodes can be regarded as bidirectional links; between containers and containees objects. The structure defined in this way is a graph structure since volumes are; replicable (same volume can become daughter node of several other volu",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:3116,Testability,log,logical,3116,"ned geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of volumes; inside a container volume and they are not directly defined by user. They are; automatically created as a result of adding one volume inside other or dividing; a volume. The geometrical transformation hold by nodes is always defined with; respect to their mother (relative positioning). Reflection matrices are allowed.; All volumes have to be fully aware of their containees when the geometry is; closed. They will build aditional structures (voxels) in order to fasten-up; the search algorithms. Finally, nodes can be regarded as bidirectional links; between containers and containees objects. The structure defined in this way is a graph structure since volumes are; replicable (same volume can become daughter node of several other volumes),; every volume becoming a branch in this graph. Any volume in the logical graph; can become the actual top volume at run time (see TGeoManager::SetTopVolume()).; All functionalities of the modeler will behave in this case as if only the; corresponding branch starting from this volume is the registered geometry. /*. */. A given volume can be positioned several times in the geometry. A volume; can be divided according default or user-defined patterns, creating automatically; the list of division nodes inside. The elementary volumes created during the; dividing process follow the same scheme as usual volumes, therefore it is possible; to position further geometrical structures inside or to divide them further more; (see TGeoVolume::Divide()). The primitive shapes supported by the package are basically the GEANT3; shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:5494,Testability,log,logical,5494,"ne; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is clo",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:7367,Testability,log,logical,7367,"volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method.",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:7564,Testability,log,logical,7564,"ld not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the curren",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:7888,Testability,log,logical,7888,"rence frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a giv",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:12625,Testability,test,testNo,12625,,MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:64558,Testability,test,testNo,64558,"ials->At(i);; for (Int_t j=0; j<i; j++) {; matref = (TGeoMaterial*)fMaterials->At(j);; if (mat->IsEq(matref)) {; mat->SetMedia(media[j]);; break;; }; if (j==(i-1)) {; // different material; mat->SetMedia(imedia);; media[i] = imedia++;; mat->Print();; }; }; }. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); Classify a given point. See TGeoChecker::CheckPoint(). void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0., Option_t* option = ""ob""); Geometry checking.; - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; - if option contains 'b': Optional boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per v",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:64648,Testability,test,test,64648," if (mat->IsEq(matref)) {; mat->SetMedia(media[j]);; break;; }; if (j==(i-1)) {; // different material; mat->SetMedia(imedia);; media[i] = imedia++;; mat->Print();; }; }; }. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); Classify a given point. See TGeoChecker::CheckPoint(). void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0., Option_t* option = ""ob""); Geometry checking.; - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; - if option contains 'b': Optional boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing compute",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:4680,Usability,simpl,simple,4680,"is possible; to position further geometrical structures inside or to divide them further more; (see TGeoVolume::Divide()). The primitive shapes supported by the package are basically the GEANT3; shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual class TGeoShape (point and segment; classification). User-defined primitives can be direcly plugged into the modeler; provided that they override these methods. Composite shapes will be soon supported; by the modeler. In order to build a TGeoCompositeShape, one will have to define; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class;",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManagerEditor.html:7344,Availability,error,error,7344,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManagerEditor.html
https://root.cern/root/html530/TGeoManagerEditor.html:7428,Availability,error,error,7428,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManagerEditor.html
https://root.cern/root/html530/TGeoManagerEditor.html:21907,Availability,mask,mask,21907,"tton*fBSelShape2Button for selecting a shape; TGPictureButton*fBSelTopButton for selecting top volume; TGPictureButton*fBSelVolumeButton for selecting a volume; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGShutter*fCategoriesCategories shutter; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseGeometryButton for closing the geometry; TCanvas*fConnectedCanvasCanvas connected to SelectedSlot(); Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGTextButton*fEditMaterialButton for editing a material; TGTextButton*fEditMatrixButton for editing a matrix; TGTextButton*fEditMediumButton for editing a medium; TGTextButton*fEditShapeButton for editing selected shape; TGTextButton*fEditVolumeButton for editing a volume; TGComboBox*fElementListCombo box for elements; TGNumberEntry*fEntryDensityNumber entry for material density; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGTextButton*fExportButtonButton to export geometry; TGRadioButton*fExportOption[2]Export option buttons; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; TGeoManager*fGeometrySelected geometry manager; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tfIsModifiedFlag that manager was modified; TGLabel*fLSelMaterialSelected material label; TGLabel*fLSelMaterial2Selected material label; TGLabel*fLSelMatrixSelected matrix label; TGLabel*fLSelMediumSelected medium label; TGLabel*fLSelMedium2Selected medium label; TGLabel*fLSelShapeSelected shape label; TGLabel*fLSelShape2Selected shape label; TGLabel*fLSelTopSelected top volume; TGLabel*fLSelVolumeSelected volume label; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayou",MatchSource.WIKI,root/html530/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManagerEditor.html
https://root.cern/root/html530/TGeoManagerEditor.html:1282,Integrability,depend,depending,1282,"GedFrame. TGeoManagerEditor. Editor for TGeoManager class. Provides also builder functionality for the; main TGeo objects: TGeoVolume, TGeoShape - derived classes, TGeoMaterial,; TGeoMatrix - derived transformations and TGeoMedium.; The GUI represents the main entry point for editing geometry classes. It; can be started either by:; 1. TGeoManager::Edit(). The method must be used when starting from a new; geometry.; 2. Left-click on the 40x40 pixels top-right corner of a pad containing a; drawn volume. The region is always accesible when drawing geometry elements; and allows also restoring the manager editor in the ""Style"" tab of the GED; editor anytime. The TGeoManager editor is vertically split by a TGShutter widget into the; following categories:. - General. This allows changing the name/title of the geometry, setting the; top volume, closing the geometry and saving the geometry in a file. The name; of the geometry file is formed by geometry_name.C/.root depending if the geometry; need to be saved as a C macro or a .root file.; - Shapes. The category provide buttons for creation of all supported shapes. The; new shape name is chosen by the interface, but can be changed from the shape; editor GUI. Existing shapes can be browsed and edited from the same category.; - Volumes. The category allows the creation of a new volume having a given name,; shape and medium. For creating a volume assembly only the name is relevant.; Existing volumes can be browsed or edited from this category.; - Materials. Allows creation of new materials/mixtures or editing existing ones.; - Media. The same for creation/editing of tracking media (materials having a set; of properties related to tracking); - Matrices. Allows creation of translations, rotations or combined transformations.; Existing matrices can also be browser/edited. Function Members (Methods); public:. TGeoManagerEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = G",MatchSource.WIKI,root/html530/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManagerEditor.html
https://root.cern/root/html530/TGeoManagerEditor.html:1471,Integrability,interface,interface,1471,"aterial,; TGeoMatrix - derived transformations and TGeoMedium.; The GUI represents the main entry point for editing geometry classes. It; can be started either by:; 1. TGeoManager::Edit(). The method must be used when starting from a new; geometry.; 2. Left-click on the 40x40 pixels top-right corner of a pad containing a; drawn volume. The region is always accesible when drawing geometry elements; and allows also restoring the manager editor in the ""Style"" tab of the GED; editor anytime. The TGeoManager editor is vertically split by a TGShutter widget into the; following categories:. - General. This allows changing the name/title of the geometry, setting the; top volume, closing the geometry and saving the geometry in a file. The name; of the geometry file is formed by geometry_name.C/.root depending if the geometry; need to be saved as a C macro or a .root file.; - Shapes. The category provide buttons for creation of all supported shapes. The; new shape name is chosen by the interface, but can be changed from the shape; editor GUI. Existing shapes can be browsed and edited from the same category.; - Volumes. The category allows the creation of a new volume having a given name,; shape and medium. For creating a volume assembly only the name is relevant.; Existing volumes can be browsed or edited from this category.; - Materials. Allows creation of new materials/mixtures or editing existing ones.; - Media. The same for creation/editing of tracking media (materials having a set; of properties related to tracking); - Matrices. Allows creation of translations, rotations or combined transformations.; Existing matrices can also be browser/edited. Function Members (Methods); public:. TGeoManagerEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGeoManagerEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual v",MatchSource.WIKI,root/html530/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManagerEditor.html
https://root.cern/root/html530/TGeoManagerEditor.html:29269,Integrability,interface,interface,29269,"eateRotation(); Create a new rotation. void DoCreateVolume(); Create a new volume. void DoCreateAssembly(); Create a new volume assembly. void DoCreateCombi(); Create a new translation + rotation. void DoSetTopVolume(); Set top volume for the geometry. void DoEditShape(); Slot for editing selected shape. void DoEditVolume(); Slot for editing selected volume. void DoEditMedium(); Slot for editing selected medium. void DoEditMaterial(); Slot for editing selected material. void DoEditMatrix(); Slot for editing selected matrix. void DoSelectMatrix(); Slot for selecting an existing matrix. void DoSelectShape(); Slot for selecting an existing shape. void DoSelectShape2(); Slot for selecting a shape for making a volume. void DoSelectMaterial(); Slot for selecting an existing material. void DoSelectMaterial2(); Slot for selecting an existing material and making a medium. void DoSelectMedium(); Slot for selecting an existing medium. void DoSelectMedium2(); Slot for selecting an existing medium for making a volume. void DoSelectVolume(); Slot for selecting an existing volume. void DoSelectTopVolume(); Slot for seting top geometry volume. void DoCloseGeometry(); Slot for closing the geometry. void ShowSelectShape(Bool_t show = kTRUE); Show/hide interface for shape selection. void ShowSelectVolume(Bool_t show = kTRUE); Show/hide interface for volume selection. void ShowSelectMaterial(Bool_t show = kTRUE); Show/hide interface for material selection. void ShowSelectMedium(Bool_t show = kTRUE); Show/hide interface for medium selection. void ShowSelectMatrix(Bool_t show = kTRUE); Show/hide interface for matrix selection. void LoadLib(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoManagerEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManagerEditor.html
https://root.cern/root/html530/TGeoManagerEditor.html:29354,Integrability,interface,interface,29354,"eateRotation(); Create a new rotation. void DoCreateVolume(); Create a new volume. void DoCreateAssembly(); Create a new volume assembly. void DoCreateCombi(); Create a new translation + rotation. void DoSetTopVolume(); Set top volume for the geometry. void DoEditShape(); Slot for editing selected shape. void DoEditVolume(); Slot for editing selected volume. void DoEditMedium(); Slot for editing selected medium. void DoEditMaterial(); Slot for editing selected material. void DoEditMatrix(); Slot for editing selected matrix. void DoSelectMatrix(); Slot for selecting an existing matrix. void DoSelectShape(); Slot for selecting an existing shape. void DoSelectShape2(); Slot for selecting a shape for making a volume. void DoSelectMaterial(); Slot for selecting an existing material. void DoSelectMaterial2(); Slot for selecting an existing material and making a medium. void DoSelectMedium(); Slot for selecting an existing medium. void DoSelectMedium2(); Slot for selecting an existing medium for making a volume. void DoSelectVolume(); Slot for selecting an existing volume. void DoSelectTopVolume(); Slot for seting top geometry volume. void DoCloseGeometry(); Slot for closing the geometry. void ShowSelectShape(Bool_t show = kTRUE); Show/hide interface for shape selection. void ShowSelectVolume(Bool_t show = kTRUE); Show/hide interface for volume selection. void ShowSelectMaterial(Bool_t show = kTRUE); Show/hide interface for material selection. void ShowSelectMedium(Bool_t show = kTRUE); Show/hide interface for medium selection. void ShowSelectMatrix(Bool_t show = kTRUE); Show/hide interface for matrix selection. void LoadLib(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoManagerEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManagerEditor.html
https://root.cern/root/html530/TGeoManagerEditor.html:29442,Integrability,interface,interface,29442,"eateRotation(); Create a new rotation. void DoCreateVolume(); Create a new volume. void DoCreateAssembly(); Create a new volume assembly. void DoCreateCombi(); Create a new translation + rotation. void DoSetTopVolume(); Set top volume for the geometry. void DoEditShape(); Slot for editing selected shape. void DoEditVolume(); Slot for editing selected volume. void DoEditMedium(); Slot for editing selected medium. void DoEditMaterial(); Slot for editing selected material. void DoEditMatrix(); Slot for editing selected matrix. void DoSelectMatrix(); Slot for selecting an existing matrix. void DoSelectShape(); Slot for selecting an existing shape. void DoSelectShape2(); Slot for selecting a shape for making a volume. void DoSelectMaterial(); Slot for selecting an existing material. void DoSelectMaterial2(); Slot for selecting an existing material and making a medium. void DoSelectMedium(); Slot for selecting an existing medium. void DoSelectMedium2(); Slot for selecting an existing medium for making a volume. void DoSelectVolume(); Slot for selecting an existing volume. void DoSelectTopVolume(); Slot for seting top geometry volume. void DoCloseGeometry(); Slot for closing the geometry. void ShowSelectShape(Bool_t show = kTRUE); Show/hide interface for shape selection. void ShowSelectVolume(Bool_t show = kTRUE); Show/hide interface for volume selection. void ShowSelectMaterial(Bool_t show = kTRUE); Show/hide interface for material selection. void ShowSelectMedium(Bool_t show = kTRUE); Show/hide interface for medium selection. void ShowSelectMatrix(Bool_t show = kTRUE); Show/hide interface for matrix selection. void LoadLib(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoManagerEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManagerEditor.html
https://root.cern/root/html530/TGeoManagerEditor.html:29530,Integrability,interface,interface,29530,"eateRotation(); Create a new rotation. void DoCreateVolume(); Create a new volume. void DoCreateAssembly(); Create a new volume assembly. void DoCreateCombi(); Create a new translation + rotation. void DoSetTopVolume(); Set top volume for the geometry. void DoEditShape(); Slot for editing selected shape. void DoEditVolume(); Slot for editing selected volume. void DoEditMedium(); Slot for editing selected medium. void DoEditMaterial(); Slot for editing selected material. void DoEditMatrix(); Slot for editing selected matrix. void DoSelectMatrix(); Slot for selecting an existing matrix. void DoSelectShape(); Slot for selecting an existing shape. void DoSelectShape2(); Slot for selecting a shape for making a volume. void DoSelectMaterial(); Slot for selecting an existing material. void DoSelectMaterial2(); Slot for selecting an existing material and making a medium. void DoSelectMedium(); Slot for selecting an existing medium. void DoSelectMedium2(); Slot for selecting an existing medium for making a volume. void DoSelectVolume(); Slot for selecting an existing volume. void DoSelectTopVolume(); Slot for seting top geometry volume. void DoCloseGeometry(); Slot for closing the geometry. void ShowSelectShape(Bool_t show = kTRUE); Show/hide interface for shape selection. void ShowSelectVolume(Bool_t show = kTRUE); Show/hide interface for volume selection. void ShowSelectMaterial(Bool_t show = kTRUE); Show/hide interface for material selection. void ShowSelectMedium(Bool_t show = kTRUE); Show/hide interface for medium selection. void ShowSelectMatrix(Bool_t show = kTRUE); Show/hide interface for matrix selection. void LoadLib(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoManagerEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManagerEditor.html
https://root.cern/root/html530/TGeoManagerEditor.html:29616,Integrability,interface,interface,29616,"eateRotation(); Create a new rotation. void DoCreateVolume(); Create a new volume. void DoCreateAssembly(); Create a new volume assembly. void DoCreateCombi(); Create a new translation + rotation. void DoSetTopVolume(); Set top volume for the geometry. void DoEditShape(); Slot for editing selected shape. void DoEditVolume(); Slot for editing selected volume. void DoEditMedium(); Slot for editing selected medium. void DoEditMaterial(); Slot for editing selected material. void DoEditMatrix(); Slot for editing selected matrix. void DoSelectMatrix(); Slot for selecting an existing matrix. void DoSelectShape(); Slot for selecting an existing shape. void DoSelectShape2(); Slot for selecting a shape for making a volume. void DoSelectMaterial(); Slot for selecting an existing material. void DoSelectMaterial2(); Slot for selecting an existing material and making a medium. void DoSelectMedium(); Slot for selecting an existing medium. void DoSelectMedium2(); Slot for selecting an existing medium for making a volume. void DoSelectVolume(); Slot for selecting an existing volume. void DoSelectTopVolume(); Slot for seting top geometry volume. void DoCloseGeometry(); Slot for closing the geometry. void ShowSelectShape(Bool_t show = kTRUE); Show/hide interface for shape selection. void ShowSelectVolume(Bool_t show = kTRUE); Show/hide interface for volume selection. void ShowSelectMaterial(Bool_t show = kTRUE); Show/hide interface for material selection. void ShowSelectMedium(Bool_t show = kTRUE); Show/hide interface for medium selection. void ShowSelectMatrix(Bool_t show = kTRUE); Show/hide interface for matrix selection. void LoadLib(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoManagerEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManagerEditor.html
https://root.cern/root/html530/TGeoMaterial.html:1819,Availability,error,error,1819,"re); virtual~TGeoMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static Double_tCoulomb(Double_t z); virtual TGeoMaterial*DecayMaterial(Double_t time, Double_t precision = 0.001); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillMaterialEvolution(TObjArray* population, Double_t precision = 0.001); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; TGeoElement*GetBaseElement() const; virtual Int_tGetByteCount() const; virtual TObject*GetCerenkovProperties() const; virtual Int_tGetDefaultColor() const; virtual Double_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoElement*GetElement(Int_t i = 0) const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() c",MatchSource.WIKI,root/html530/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMaterial.html
https://root.cern/root/html530/TGeoMaterial.html:1903,Availability,error,error,1903,"re); virtual~TGeoMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static Double_tCoulomb(Double_t z); virtual TGeoMaterial*DecayMaterial(Double_t time, Double_t precision = 0.001); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillMaterialEvolution(TObjArray* population, Double_t precision = 0.001); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; TGeoElement*GetBaseElement() const; virtual Int_tGetByteCount() const; virtual TObject*GetCerenkovProperties() const; virtual Int_tGetDefaultColor() const; virtual Double_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoElement*GetElement(Int_t i = 0) const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() c",MatchSource.WIKI,root/html530/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMaterial.html
https://root.cern/root/html530/TGeoMaterialDialog.html:5142,Availability,error,error,5142,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGeoMaterialDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMaterialDialog.html
https://root.cern/root/html530/TGeoMaterialDialog.html:5226,Availability,error,error,5226,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGeoMaterialDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMaterialDialog.html
https://root.cern/root/html530/TGeoMaterialDialog.html:19806,Availability,mask,mask,19806,,MatchSource.WIKI,root/html530/TGeoMaterialDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMaterialDialog.html
https://root.cern/root/html530/TGeoMaterialEditor.html:4718,Availability,error,error,4718,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoMaterialEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMaterialEditor.html
https://root.cern/root/html530/TGeoMaterialEditor.html:4802,Availability,error,error,4802,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoMaterialEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMaterialEditor.html
https://root.cern/root/html530/TGeoMaterialEditor.html:17802,Availability,mask,mask,17802,,MatchSource.WIKI,root/html530/TGeoMaterialEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMaterialEditor.html
https://root.cern/root/html530/TGeoMaterialEditor.html:21589,Energy Efficiency,charge,charge,21589,"GC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMaterialEditor.h 32718 2010-03-23 15:58:34Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoMaterialEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMaterialEditor.html
https://root.cern/root/html530/TGeoMatrix.html:6218,Availability,error,error,6218,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* m",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:7126,Availability,avail,available,7126,"ruction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voi",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:8096,Availability,error,error,8096,,MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:8180,Availability,error,error,8180,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidGetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslation() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_t",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:3090,Integrability,interface,interface,3090," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:6224,Integrability,message,message,6224,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* m",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:6969,Modifiability,variab,variable,6969,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObje",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:474,Performance,optimiz,optimize,474,". TGeoMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoMatrix. class TGeoMatrix: public TNamed. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sca",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:483,Performance,perform,performance,483,". TGeoMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoMatrix. class TGeoMatrix: public TNamed. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sca",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:968,Performance,perform,performed,968,". TGeoMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoMatrix. class TGeoMatrix: public TNamed. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sca",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:1694,Performance,perform,performed,1694,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:6201,Performance,perform,performed,6201,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* m",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrix.html:1707,Usability,simpl,simple,1707,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrix.html
https://root.cern/root/html530/TGeoMatrixDialog.html:5132,Availability,error,error,5132,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGeoMatrixDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrixDialog.html
https://root.cern/root/html530/TGeoMatrixDialog.html:5216,Availability,error,error,5216,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGeoMatrixDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrixDialog.html
https://root.cern/root/html530/TGeoMatrixDialog.html:19796,Availability,mask,mask,19796,,MatchSource.WIKI,root/html530/TGeoMatrixDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMatrixDialog.html
https://root.cern/root/html530/TGeoMCGeometry.html:1487,Availability,error,error,1487,"st char* title, Bool_t g3CompatibleVolumeNames = false); virtual~TGeoMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tGetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); virtual Bool_tGetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); virtual const char*TNamed::GetName() const;",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:1571,Availability,error,error,1571,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tGetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); virtual Bool_tGetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:19417,Availability,error,error,19417," i-th daughters of the volume specified by volName; According to A. Morsch' G3toRoot class. Int_t VolId2Mate(Int_t id) const. Return material number for a given volume id. Bool_t GetTransformation(const TString& volumePath, TGeoHMatrix& matrix); Returns the Transformation matrix between the volume specified; by the path volumePath and the Top or mater volume. The format; of the path volumePath is as follows (assuming ALIC is the Top volume); ""/ALIC_1/DDIP_1/S05I_2/S05H_1/S05G_3"". Here ALIC is the top most; or master volume which has only 1 instance of. Of all of the daughter; volumes of ALICE, DDIP volume copy #1 is indicated. Similarly for; the daughter volume of DDIP is S05I copy #2 and so on.; Inputs:; TString& volumePath The volume path to the specific volume; for which you want the matrix. Volume name; hierarchy is separated by ""/"" while the; copy number is appended using a ""_"".; Outputs:; TGeoHMatrix &mat A matrix with its values set to those; appropriate to the Local to Master transformation; Return:; A logical value if kFALSE then an error occurred and no change to; mat was made. Bool_t GetShape(const TString& volumePath, TString& shapeType, TArrayD& par); Returns the shape and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name; Outputs:; TString &shapeType Shape type; TArrayD &par A TArrayD of parameters with all of the; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume na",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:19849,Availability,error,error,19849,"3"". Here ALIC is the top most; or master volume which has only 1 instance of. Of all of the daughter; volumes of ALICE, DDIP volume copy #1 is indicated. Similarly for; the daughter volume of DDIP is S05I copy #2 and so on.; Inputs:; TString& volumePath The volume path to the specific volume; for which you want the matrix. Volume name; hierarchy is separated by ""/"" while the; copy number is appended using a ""_"".; Outputs:; TGeoHMatrix &mat A matrix with its values set to those; appropriate to the Local to Master transformation; Return:; A logical value if kFALSE then an error occurred and no change to; mat was made. Bool_t GetShape(const TString& volumePath, TString& shapeType, TArrayD& par); Returns the shape and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name; Outputs:; TString &shapeType Shape type; TArrayD &par A TArrayD of parameters with all of the; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& ",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:20766,Availability,error,errors,20766,"he; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Re",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:21789,Availability,error,errors,21789,"er, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id: TGeoMCGeometry.h 34810 2010-08-13 13:36:26Z ivana $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:12480,Deployability,continuous,continuous,12480,"le_t* a, Double_t* z, Double_t dens, Int_t nlmat, Double_t* wmat). Defines mixture OR COMPOUND IMAT as composed by; THE BASIC NLMAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 i",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:21551,Deployability,continuous,continuous,21551,"er, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id: TGeoMCGeometry.h 34810 2010-08-13 13:36:26Z ivana $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:12403,Energy Efficiency,energy,energy,12403," weigths. void Mixture(Int_t& kmat, const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nlmat, Double_t* wmat). Defines mixture OR COMPOUND IMAT as composed by; THE BASIC NLMAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; if",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:13203,Energy Efficiency,energy,energy,13203,"ensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ). krot rotation matrix number assigned; theta1 polar angle for axis i; phi1 azimuthal angle for axis i; theta2 polar angle for axis ii; phi2 azimuthal angle for axis ii; theta3 polar angle for axis iii; phi3 azimuthal angle for axis iii. it defines the rotation matrix number irot. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. It creates a new volume in the JVOLUM data structure. Int_t Gsvolu(const cha",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:21521,Energy Efficiency,energy,energy,21521,"er, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id: TGeoMCGeometry.h 34810 2010-08-13 13:36:26Z ivana $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:360,Integrability,interface,interface,360,". TGeoMCGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TGeoMCGeometry. class TGeoMCGeometry: public TVirtualMCGeometry. Implementation of the TVirtualMCGeometry interface; for building TGeo geometry. Function Members (Methods); public:. TGeoMCGeometry(); TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false); virtual~TGeoMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:12604,Performance,perform,performed,12604,"MAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Dou",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:12652,Performance,perform,performed,12652,"MAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Dou",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:12699,Performance,perform,performed,12699,"MAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Dou",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:13403,Performance,perform,performed,13403,"t in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ). krot rotation matrix number assigned; theta1 polar angle for axis i; phi1 azimuthal angle for axis i; theta2 polar angle for axis ii; phi2 azimuthal angle for axis ii; theta3 polar angle for axis iii; phi3 azimuthal angle for axis iii. it defines the rotation matrix number irot. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. It creates a new volume in the JVOLUM data structure. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector conta",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:13451,Performance,perform,performed,13451,"t in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ). krot rotation matrix number assigned; theta1 polar angle for axis i; phi1 azimuthal angle for axis i; theta2 polar angle for axis ii; phi2 azimuthal angle for axis ii; theta3 polar angle for axis iii; phi3 azimuthal angle for axis iii. it defines the rotation matrix number irot. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. It creates a new volume in the JVOLUM data structure. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector conta",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:13498,Performance,perform,performed,13498,"t in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ). krot rotation matrix number assigned; theta1 polar angle for axis i; phi1 azimuthal angle for axis i; theta2 polar angle for axis ii; phi2 azimuthal angle for axis ii; theta3 polar angle for axis iii; phi3 azimuthal angle for axis iii. it defines the rotation matrix number irot. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. It creates a new volume in the JVOLUM data structure. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector conta",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:15605,Performance,perform,performed,15605,"eate a new volume by dividing an existing one. NAME Volume name; MOTHER Mother volume name; NDIV Number of divisions; IAXIS Axis value. X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS.; It divides a previously defined volume. void Gsdvn2(const char* name, const char* mother, Int_t ndiv, Int_t iaxis, Double_t c0i, Int_t numed). Create a new volume by dividing an existing one. Divides mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0.; the new volume created will be medium number numed. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS in steps of STEP. If not exactly divisible; will make as many as possible and will centre them; with respect to the mother. Divisions will have medium; number NUMED. If NUMED is 0, NUMED of MOTHER is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS starting at coordinate value C0 with step; size STEP.; The new volume created will have medium number NUMED.; If NUMED is 0, NUMED of mother is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsord(const char* name, Int_t iax). Flags volume CHNAME whose contents will have to be ordered; along axis IAX, by setting the search flag to -IAX; IAX = 1 X axis; IAX = 2 Y axis; IAX = 3 Z axis; IAX = 4 Rxy (static ordering only -> GTMEDI); IAX = 14 Rxy (also dynamic ordering -> GTNEXT); IAX = 5 Rxyz (static ordering only -> GTMEDI); IAX = 15 Rxyz (also dynamic ordering -> GTNEXT); IAX = 6 PHI (PHI=0 => X axis); IAX = 7 THETA (THETA=0 => Z axis). void Gspos(const char*",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:16078,Performance,perform,performed,16078,"lue c0.; the new volume created will be medium number numed. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS in steps of STEP. If not exactly divisible; will make as many as possible and will centre them; with respect to the mother. Divisions will have medium; number NUMED. If NUMED is 0, NUMED of MOTHER is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS starting at coordinate value C0 with step; size STEP.; The new volume created will have medium number NUMED.; If NUMED is 0, NUMED of mother is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsord(const char* name, Int_t iax). Flags volume CHNAME whose contents will have to be ordered; along axis IAX, by setting the search flag to -IAX; IAX = 1 X axis; IAX = 2 Y axis; IAX = 3 Z axis; IAX = 4 Rxy (static ordering only -> GTMEDI); IAX = 14 Rxy (also dynamic ordering -> GTNEXT); IAX = 5 Rxyz (static ordering only -> GTMEDI); IAX = 15 Rxyz (also dynamic ordering -> GTNEXT); IAX = 6 PHI (PHI=0 => X axis); IAX = 7 THETA (THETA=0 => Z axis). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly). Position a volume into an existing one. NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ONLY ONLY/MANY flag. It positions a previously defined vol",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:15595,Testability,test,tests,15595,"eate a new volume by dividing an existing one. NAME Volume name; MOTHER Mother volume name; NDIV Number of divisions; IAXIS Axis value. X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS.; It divides a previously defined volume. void Gsdvn2(const char* name, const char* mother, Int_t ndiv, Int_t iaxis, Double_t c0i, Int_t numed). Create a new volume by dividing an existing one. Divides mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0.; the new volume created will be medium number numed. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS in steps of STEP. If not exactly divisible; will make as many as possible and will centre them; with respect to the mother. Divisions will have medium; number NUMED. If NUMED is 0, NUMED of MOTHER is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS starting at coordinate value C0 with step; size STEP.; The new volume created will have medium number NUMED.; If NUMED is 0, NUMED of mother is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsord(const char* name, Int_t iax). Flags volume CHNAME whose contents will have to be ordered; along axis IAX, by setting the search flag to -IAX; IAX = 1 X axis; IAX = 2 Y axis; IAX = 3 Z axis; IAX = 4 Rxy (static ordering only -> GTMEDI); IAX = 14 Rxy (also dynamic ordering -> GTNEXT); IAX = 5 Rxyz (static ordering only -> GTMEDI); IAX = 15 Rxyz (also dynamic ordering -> GTNEXT); IAX = 6 PHI (PHI=0 => X axis); IAX = 7 THETA (THETA=0 => Z axis). void Gspos(const char*",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:16068,Testability,test,tests,16068,"lue c0.; the new volume created will be medium number numed. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS in steps of STEP. If not exactly divisible; will make as many as possible and will centre them; with respect to the mother. Divisions will have medium; number NUMED. If NUMED is 0, NUMED of MOTHER is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS starting at coordinate value C0 with step; size STEP.; The new volume created will have medium number NUMED.; If NUMED is 0, NUMED of mother is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsord(const char* name, Int_t iax). Flags volume CHNAME whose contents will have to be ordered; along axis IAX, by setting the search flag to -IAX; IAX = 1 X axis; IAX = 2 Y axis; IAX = 3 Z axis; IAX = 4 Rxy (static ordering only -> GTMEDI); IAX = 14 Rxy (also dynamic ordering -> GTNEXT); IAX = 5 Rxyz (static ordering only -> GTMEDI); IAX = 15 Rxyz (also dynamic ordering -> GTNEXT); IAX = 6 PHI (PHI=0 => X axis); IAX = 7 THETA (THETA=0 => Z axis). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly). Position a volume into an existing one. NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ONLY ONLY/MANY flag. It positions a previously defined vol",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:19385,Testability,log,logical,19385," i-th daughters of the volume specified by volName; According to A. Morsch' G3toRoot class. Int_t VolId2Mate(Int_t id) const. Return material number for a given volume id. Bool_t GetTransformation(const TString& volumePath, TGeoHMatrix& matrix); Returns the Transformation matrix between the volume specified; by the path volumePath and the Top or mater volume. The format; of the path volumePath is as follows (assuming ALIC is the Top volume); ""/ALIC_1/DDIP_1/S05I_2/S05H_1/S05G_3"". Here ALIC is the top most; or master volume which has only 1 instance of. Of all of the daughter; volumes of ALICE, DDIP volume copy #1 is indicated. Similarly for; the daughter volume of DDIP is S05I copy #2 and so on.; Inputs:; TString& volumePath The volume path to the specific volume; for which you want the matrix. Volume name; hierarchy is separated by ""/"" while the; copy number is appended using a ""_"".; Outputs:; TGeoHMatrix &mat A matrix with its values set to those; appropriate to the Local to Master transformation; Return:; A logical value if kFALSE then an error occurred and no change to; mat was made. Bool_t GetShape(const TString& volumePath, TString& shapeType, TArrayD& par); Returns the shape and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name; Outputs:; TString &shapeType Shape type; TArrayD &par A TArrayD of parameters with all of the; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume na",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMCGeometry.html:19809,Testability,log,logical,19809,"3"". Here ALIC is the top most; or master volume which has only 1 instance of. Of all of the daughter; volumes of ALICE, DDIP volume copy #1 is indicated. Similarly for; the daughter volume of DDIP is S05I copy #2 and so on.; Inputs:; TString& volumePath The volume path to the specific volume; for which you want the matrix. Volume name; hierarchy is separated by ""/"" while the; copy number is appended using a ""_"".; Outputs:; TGeoHMatrix &mat A matrix with its values set to those; appropriate to the Local to Master transformation; Return:; A logical value if kFALSE then an error occurred and no change to; mat was made. Bool_t GetShape(const TString& volumePath, TString& shapeType, TArrayD& par); Returns the shape and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name; Outputs:; TString &shapeType Shape type; TArrayD &par A TArrayD of parameters with all of the; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& ",MatchSource.WIKI,root/html530/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMCGeometry.html
https://root.cern/root/html530/TGeoMedium.html:2132,Availability,error,error,2132,"_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); virtual~TGeoMedium(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetId() const; TGeoMaterial*GetMaterial() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetParam(Int_t i) const; char*GetPointerName() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Handl",MatchSource.WIKI,root/html530/TGeoMedium.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMedium.html
https://root.cern/root/html530/TGeoMedium.html:2216,Availability,error,error,2216,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetId() const; TGeoMaterial*GetMaterial() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetParam(Int_t i) const; char*GetPointerName() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Inf",MatchSource.WIKI,root/html530/TGeoMedium.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMedium.html
https://root.cern/root/html530/TGeoMedium.html:861,Integrability,interface,interfaces,861,". TGeoMedium. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoMedium. class TGeoMedium: public TNamed. Media are used to store properties related to tracking and which are useful; only when using geometry with a particle transport MC package (via VMC). One; may define several tracking media for a given material. The media ID are user; defined values that are not used by the geometry package. In case geometry; is used via VMC (in GEANT) these numbers are overwritten, so one can only; rely on these values after gMC->FinishGeometry() is called.; The media parameters are inspired from GEANT3 and the values defined make sense; in context of GEANT (3 but also 4) or FLUKA interfaces. Function Members (Methods); public:. TGeoMedium(); TGeoMedium(const char* name, Int_t numed, const TGeoMaterial* mat, Double_t* params = 0); TGeoMedium(const char* name, Int_t numed, Int_t imat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); virtual~TGeoMedium(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject",MatchSource.WIKI,root/html530/TGeoMedium.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMedium.html
https://root.cern/root/html530/TGeoMediumDialog.html:5132,Availability,error,error,5132,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGeoMediumDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMediumDialog.html
https://root.cern/root/html530/TGeoMediumDialog.html:5216,Availability,error,error,5216,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGeoMediumDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMediumDialog.html
https://root.cern/root/html530/TGeoMediumDialog.html:19796,Availability,mask,mask,19796,,MatchSource.WIKI,root/html530/TGeoMediumDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMediumDialog.html
https://root.cern/root/html530/TGeoMediumEditor.html:4769,Availability,error,error,4769,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoMediumEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMediumEditor.html
https://root.cern/root/html530/TGeoMediumEditor.html:4853,Availability,error,error,4853,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoMediumEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMediumEditor.html
https://root.cern/root/html530/TGeoMediumEditor.html:17871,Availability,mask,mask,17871,,MatchSource.WIKI,root/html530/TGeoMediumEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMediumEditor.html
https://root.cern/root/html530/TGeoMediumEditor.html:22134,Usability,undo,undoing,22134,"created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMediumEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for medium editor. ~TGeoMediumEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoEditMaterial(); Edit selected material. void DoMedName(); Slot for medium name. void DoMedId(); Slot for medium id. void DoSelectMaterial(); Select the material component. void DoToggleSensitive(); Slot for sensitivity. void DoMagfldSelect(Int_t ientry); Slot for mag. field. void DoFieldm(); Slot for max field. void DoTmaxfd(); Slot for tmaxfd. void DoStemax(); Slot for the max allowed step. void DoDeemax(); Slot for the maximum allowed dedx. void DoEpsil(); Slot for tracking precision. void DoStmin(); Slot for min. step. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMediumEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoMediumEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMediumEditor.html
https://root.cern/root/html530/TGeometry.html:3337,Availability,error,error,3337,"try(const char* name, const char* title); virtual~TGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; Int_tGeomLevel() const; static TObjArray*Get(const char* name); Float_tGetBomb() const; TRotMatrix*GetCurrentMatrix() const; TNode*GetCurrentNode() const; TRotMatrix*GetCurrentPosition(Double_t* x, Double_t* y, Double_t* z) const; TRotMatrix*GetCurrentPosition(Float_t* x, Float_t* y, Float_t* z) const; Bool_tGetCurrentReflection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; THashList*GetListOfMaterials() const; THashList*GetListOfMatrices() const; TList*GetListOfNodes() const; THashList*GetListOfShapes() cons",MatchSource.WIKI,root/html530/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeometry.html
https://root.cern/root/html530/TGeometry.html:3421,Availability,error,error,3421,"Method(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; Int_tGeomLevel() const; static TObjArray*Get(const char* name); Float_tGetBomb() const; TRotMatrix*GetCurrentMatrix() const; TNode*GetCurrentNode() const; TRotMatrix*GetCurrentPosition(Double_t* x, Double_t* y, Double_t* z) const; TRotMatrix*GetCurrentPosition(Float_t* x, Float_t* y, Float_t* z) const; Bool_tGetCurrentReflection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; THashList*GetListOfMaterials() const; THashList*GetListOfMatrices() const; TList*GetListOfNodes() const; THashList*GetListOfShapes() const; TMaterial*GetMaterial(const char* name) const; TMaterial*GetMaterialByNumber(Int_",MatchSource.WIKI,root/html530/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeometry.html
https://root.cern/root/html530/TGeometry.html:366,Safety,detect,detector,366,". TGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TGeometry. class TGeometry: public TNamed. T G E O M E T R Y description. The Geometry class describes the geometry of a detector.; The current implementation supports the GEANT3 style description.; A special program provided in the ROOT utilities (toroot) can be used; to automatically translate a GEANT detector geometry into a ROOT geometry. a Geometry object is entered into the list of geometries into the; ROOT main object (see TROOT description) when the TGeometry; constructor is invoked.; Several geometries may coexist in memory. A Geometry object consist of the following linked lists:; - the TMaterial list (material definition only).; - the TRotmatrix list (Rotation matrices definition only).; - the TShape list (volume definition only).; - the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a ",MatchSource.WIKI,root/html530/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeometry.html
https://root.cern/root/html530/TGeometry.html:550,Safety,detect,detector,550,". TGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TGeometry. class TGeometry: public TNamed. T G E O M E T R Y description. The Geometry class describes the geometry of a detector.; The current implementation supports the GEANT3 style description.; A special program provided in the ROOT utilities (toroot) can be used; to automatically translate a GEANT detector geometry into a ROOT geometry. a Geometry object is entered into the list of geometries into the; ROOT main object (see TROOT description) when the TGeometry; constructor is invoked.; Several geometries may coexist in memory. A Geometry object consist of the following linked lists:; - the TMaterial list (material definition only).; - the TRotmatrix list (Rotation matrices definition only).; - the TShape list (volume definition only).; - the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a ",MatchSource.WIKI,root/html530/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeometry.html
https://root.cern/root/html530/TGeometry.html:1030,Safety,detect,detector,1030,"ks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TGeometry. class TGeometry: public TNamed. T G E O M E T R Y description. The Geometry class describes the geometry of a detector.; The current implementation supports the GEANT3 style description.; A special program provided in the ROOT utilities (toroot) can be used; to automatically translate a GEANT detector geometry into a ROOT geometry. a Geometry object is entered into the list of geometries into the; ROOT main object (see TROOT description) when the TGeometry; constructor is invoked.; Several geometries may coexist in memory. A Geometry object consist of the following linked lists:; - the TMaterial list (material definition only).; - the TRotmatrix list (Rotation matrices definition only).; - the TShape list (volume definition only).; - the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a subsequent session, s",MatchSource.WIKI,root/html530/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeometry.html
https://root.cern/root/html530/TGeometry.html:2021,Usability,simpl,simply,2021," list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a subsequent session, simply do:; Root > TFile gna49(""na49.root""); Root > na49.Draw(). The figure below shows the geometry above using the x3d viewer.; This x3d viewver is invoked by selecting ""View x3d"" in the View menu; of a canvas (See example of this tool bar in TCanvas). /*. */. Function Members (Methods); public:. TGeometry(); TGeometry(const char* name, const char* title); virtual~TGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Op",MatchSource.WIKI,root/html530/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeometry.html
https://root.cern/root/html530/TGeoMixture.html:1886,Availability,error,error,1886,"ndPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static Double_tTGeoMaterial::Coulomb(Double_t z); virtual TGeoMaterial*DecayMaterial(Double_t time, Double_t precision = 0.001); voidDefineElement(Int_t iel, TGeoElement* elem, Double_t weight); voidDefineElement(Int_t iel, Int_t z, Int_t natoms); voidDefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillMaterialEvolution(TObjArray* population, Double_t precision = 0.001); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTGeoMaterial::GetA() const; Double_t*GetAmixt() const; TGeoElement*TGeoMaterial::GetBaseElement() const; virtual Int_tGetByteCount() const; virtual TObject*TGeoMaterial::GetCerenkovProperties() const; virtual Int_tTGeoMaterial::GetDefaultColor() const; virtual Double_tTGeoMaterial::GetDensity() const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root/html530/TGeoMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMixture.html
https://root.cern/root/html530/TGeoMixture.html:1970,Availability,error,error,1970,"ndPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static Double_tTGeoMaterial::Coulomb(Double_t z); virtual TGeoMaterial*DecayMaterial(Double_t time, Double_t precision = 0.001); voidDefineElement(Int_t iel, TGeoElement* elem, Double_t weight); voidDefineElement(Int_t iel, Int_t z, Int_t natoms); voidDefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillMaterialEvolution(TObjArray* population, Double_t precision = 0.001); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTGeoMaterial::GetA() const; Double_t*GetAmixt() const; TGeoElement*TGeoMaterial::GetBaseElement() const; virtual Int_tGetByteCount() const; virtual TObject*TGeoMaterial::GetCerenkovProperties() const; virtual Int_tTGeoMaterial::GetDefaultColor() const; virtual Double_tTGeoMaterial::GetDensity() const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root/html530/TGeoMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMixture.html
https://root.cern/root/html530/TGeoMixtureEditor.html:5093,Availability,error,error,5093,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMixtureEditor.html
https://root.cern/root/html530/TGeoMixtureEditor.html:5177,Availability,error,error,5177,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMixtureEditor.html
https://root.cern/root/html530/TGeoMixtureEditor.html:18534,Availability,mask,mask,18534,,MatchSource.WIKI,root/html530/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMixtureEditor.html
https://root.cern/root/html530/TGeoMixtureEditor.html:23123,Usability,undo,undo,23123,"c const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMixtureEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for mixture editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected mixture. void DoChkFraction(); Check button state changed for fraction. void DoChkNatoms(); Check button state changed for natoms. void DoFraction(); Fraction changed. void DoNatoms(); Natoms changed. void DoSelectElement(Int_t iel); Slot for selecting an element. void DoAddElem(); Slot for adding an element. No undo. void DoApply1(); Slot for applying modifications. void DoUndo1(); Slot for undoing all changes. void UpdateElements(); Update the list of elements in the TGCanvas. virtual ~TGeoMixtureEditor(); {}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMaterialEditor.h 32718 2010-03-23 15:58:34Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMixtureEditor.html
https://root.cern/root/html530/TGeoMixtureEditor.html:23204,Usability,undo,undoing,23204,"c const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMixtureEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for mixture editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected mixture. void DoChkFraction(); Check button state changed for fraction. void DoChkNatoms(); Check button state changed for natoms. void DoFraction(); Fraction changed. void DoNatoms(); Natoms changed. void DoSelectElement(Int_t iel); Slot for selecting an element. void DoAddElem(); Slot for adding an element. No undo. void DoApply1(); Slot for applying modifications. void DoUndo1(); Slot for undoing all changes. void UpdateElements(); Update the list of elements in the TGCanvas. virtual ~TGeoMixtureEditor(); {}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMaterialEditor.h 32718 2010-03-23 15:58:34Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoMixtureEditor.html
https://root.cern/root/html530/TGeoNavigator.html:1586,Availability,down,downwards,1586," TGeoNavigator(); TGeoNavigator(TGeoManager* geom); virtual~TGeoNavigator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Bool_tcd(const char* path = """"); voidCdDown(Int_t index); voidCdNext(); voidCdNode(Int_t nodeid); voidCdTop(); voidCdUp(); Bool_tCheckPath(const char* path) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoNode*CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTOb",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:2136,Availability,error,error,2136,"wn(Int_t index); voidCdNext(); voidCdNode(Int_t nodeid); voidCdTop(); voidCdUp(); Bool_tCheckPath(const char* path) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoNode*CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGeoNode*FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); TGeoNode*FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); TGeoNode*FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); TGeoNode*FindNode(Bool_t safe_start = kTRUE); TGeoNode*FindNode(Double_t x, Double_t y, Double_t z); Double_t*FindNormal(Bool_t forward = kTRUE); Double_t*FindNormalFast(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetBranchNames(Int_t* names) const; voidGetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; voidGetBranchOnlys(Int_t* isonly) co",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:2220,Availability,error,error,2220,"ol_tCheckPath(const char* path) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoNode*CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGeoNode*FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); TGeoNode*FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); TGeoNode*FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); TGeoNode*FindNode(Bool_t safe_start = kTRUE); TGeoNode*FindNode(Double_t x, Double_t y, Double_t z); Double_t*FindNormal(Bool_t forward = kTRUE); Double_t*FindNormalFast(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetBranchNames(Int_t* names) const; voidGetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; voidGetBranchOnlys(Int_t* isonly) const; TGeoNodeCache*GetCache() const; const Double_t*GetCldir() const; const Double_t",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:7577,Availability,down,downwards,7577,"or delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidPopDummy(Int_t ipop = 9999); Bool_tPopPath(); Bool_tPopPath(Int_t index); Bool_tPopPoint(); Bool_tPopPoint(Int_t index); virtual voidTObject::Print(Option_t* option = """") const; Int_tPushPath(Int_t startlevel = 0); Int_tPushPoint(Int_t startlevel = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidResetAll(); voidTObject::ResetBit(UInt_t f); voidResetState(); Double_tSafety(Bool_t inside = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetCurrentDirection(const Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); voidSetCurrentPoint(const Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLastPoint(Double_t x, Double_t y, Double_t z); voidSetLastSafetyForPoint(Double_t safe, const Double_t* point); static voidTObject::SetObjectStat(Bool_t stat); voidSetOutside(Bool_t flag = kTRUE); voidSetStartSafe(Bool_t flag = kTRUE); voidSetStep(Double_t step); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); TGeoNode*Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtu",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:13837,Availability,down,downwards,13837,"Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the c",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:16968,Availability,down,downwards,16968,"xt surface that will be or was already; crossed when propagating on a straight line from a given point/direction.; Returns the normal vector cosines in the MASTER coordinate system. The dot; product of the normal and the current direction is positive defined. TGeoNode * InitTrack(const Double_t* point, const Double_t* dir); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. TGeoNode * InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. void ResetState(); Reset current state flags. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SafetyOverlaps(); Compute safe distance from the current point within an overlapping node. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * FindInCluster(Int_t* cluster, Int_t nc); Find a node inside a cluster of overlapping nodes. Current node must; be on top of all the nodes in cluster. Always nc>1. Int_t GetTouchedCluster(Int_t start, Double_t* point, Int_t* check_list, Int_t ncheck, Int_t* result); Make the cluster of overlapping nodes in a voxel, containing point in reference; of the mother. Returns number of nodes containing the point. Nodes should not be; offsets. TGeoNode * Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlap",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:9891,Performance,cache,cache,9891,,MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:10432,Performance,cache,cached,10432,,MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:12407,Performance,cache,cache,12407,"uble_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fil",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:12853,Performance,perform,performance,12853,"_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:13010,Performance,cache,cache,13010,"tance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:13079,Performance,cache,cache,13079,"; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr =",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:13212,Performance,cache,cache,13212,"Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified,",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:18945,Performance,cache,cache,18945,"t also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() const; {return fLastSafety;}. Double_t GetStep() const; {return fStep;}. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE). Bool_t IsStartSafe() const; {return fStartSafe;}. void Set",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:19029,Performance,cache,cache,19029,"current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() const; {return fLastSafety;}. Double_t GetStep() const; {return fStep;}. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE). Bool_t IsStartSafe() const; {return fStartSafe;}. void SetStartSafe(Bool_t flag = kTRUE); {fStartSafe=flag;}. void SetStep(Double_t step); {f",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:23202,Performance,cache,cache,23202,") {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return fCache->PushState(fCurrentOverlapping, startlevel, fNmany);}. Bool_t PopPath(); {fCurrentOverlapping=fCache->PopState(fNmany); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel();fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Bool_t PopPath(Int_t index); {fCurrentOverlapping=fCache->PopState(fNmany,index); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel();fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Int_t PushPoint(Int_t startlevel = 0); {return fCache->PushState(fCurrentOverlapping, startlevel,fNmany,fPoint);}. Bool_t PopPoint(); {fCurrentOverlapping=fCache->PopState(fNmany,fPoint); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel(); fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Bool_t PopPoint(Int_t index); {fCurrentOverlapping=fCache->PopState(fNmany,index, f",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:23235,Performance,cache,cache,23235,") {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return fCache->PushState(fCurrentOverlapping, startlevel, fNmany);}. Bool_t PopPath(); {fCurrentOverlapping=fCache->PopState(fNmany); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel();fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Bool_t PopPath(Int_t index); {fCurrentOverlapping=fCache->PopState(fNmany,index); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel();fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Int_t PushPoint(Int_t startlevel = 0); {return fCache->PushState(fCurrentOverlapping, startlevel,fNmany,fPoint);}. Bool_t PopPoint(); {fCurrentOverlapping=fCache->PopState(fNmany,fPoint); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel(); fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Bool_t PopPoint(Int_t index); {fCurrentOverlapping=fCache->PopState(fNmany,index, f",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:8192,Safety,safe,safe,8192,"ushPath(Int_t startlevel = 0); Int_tPushPoint(Int_t startlevel = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidResetAll(); voidTObject::ResetBit(UInt_t f); voidResetState(); Double_tSafety(Bool_t inside = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetCurrentDirection(const Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); voidSetCurrentPoint(const Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLastPoint(Double_t x, Double_t y, Double_t z); voidSetLastSafetyForPoint(Double_t safe, const Double_t* point); static voidTObject::SetObjectStat(Bool_t stat); voidSetOutside(Bool_t flag = kTRUE); voidSetStartSafe(Bool_t flag = kTRUE); voidSetStep(Double_t step); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); TGeoNode*Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTopToMaster(const Double_t* top, Double_t* master) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:11099,Safety,safe,safety,11099,nit vector to current checked shape; TGeoHMatrix*fCurrentMatrix! current stored global matrix; TGeoNode*fCurrentNode! current node ; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:11155,Safety,safe,safety,11155,nit vector to current checked shape; TGeoHMatrix*fCurrentMatrix! current stored global matrix; TGeoNode*fCurrentNode! current node ; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:11722,Safety,safe,safety,11722,nit vector to current checked shape; TGeoHMatrix*fCurrentMatrix! current stored global matrix; TGeoNode*fCurrentNode! current node ; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:11854,Safety,safe,safe,11854,nit vector to current checked shape; TGeoHMatrix*fCurrentMatrix! current stored global matrix; TGeoNode*fCurrentNode! current node ; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:14560,Safety,safe,safe,14560," into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. T",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:14671,Safety,safe,safety,14671,"y. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNo",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:14702,Safety,safe,safety,14702,"TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast norm",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:16740,Safety,safe,safe,16740,"g current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the current point; is close enough to the boundary. Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a straight line from a given point/direction.; Returns the normal vector cosines in the MASTER coordinate system. The dot; product of the normal and the current direction is positive defined. TGeoNode * InitTrack(const Double_t* point, const Double_t* dir); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. TGeoNode * InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. void ResetState(); Reset current state flags. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SafetyOverlaps(); Compute safe distance from the current point within an overlapping node. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * FindInCluster(Int_t* cluster, Int_t nc); Find a node inside a cluster of overlapping nodes. Current node must; be on top of all the nodes in cluster. Always nc>1. Int_t GetTouchedCluster(Int_t start, Double_t* point, Int_t* check_list, Int_t ncheck, Int_t* result); Make the cluster of overlapping nodes in a voxel, containing point in reference; of the mother. Returns number of nodes containing the point. Nodes should not be; offsets. TGeoNode * Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by g",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:16874,Safety,safe,safe,16874,". Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a straight line from a given point/direction.; Returns the normal vector cosines in the MASTER coordinate system. The dot; product of the normal and the current direction is positive defined. TGeoNode * InitTrack(const Double_t* point, const Double_t* dir); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. TGeoNode * InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. void ResetState(); Reset current state flags. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SafetyOverlaps(); Compute safe distance from the current point within an overlapping node. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * FindInCluster(Int_t* cluster, Int_t nc); Find a node inside a cluster of overlapping nodes. Current node must; be on top of all the nodes in cluster. Always nc>1. Int_t GetTouchedCluster(Int_t start, Double_t* point, Int_t* check_list, Int_t ncheck, Int_t* result); Make the cluster of overlapping nodes in a voxel, containing point in reference; of the mother. Returns number of nodes containing the point. Nodes should not be; offsets. TGeoNode * Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Return",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:18566,Safety,safe,safety,18566,", Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t ",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:18606,Safety,safe,safety,18606,", Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t ",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:18630,Safety,safe,safe,18630,", Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t ",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:18727,Safety,safe,safe,18727,"n). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() co",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:22312,Safety,safe,safe,22312,"ction;}. TGeoVolume * GetCurrentVolume() const; {return fCurrentNode->GetVolume();}. const Double_t * GetCldirChecked() const; {return fCldirChecked;}. const Double_t * GetCldir() const; Double_t GetNormalChecked() const {return fNormalChecked;}. {return fCldir;}. const Double_t * GetNormal() const; {return fNormal;}. Int_t GetLevel() const; {return fLevel;}. Int_t GetStackLevel() const; {return fCache->GetStackLevel();}. void SetCurrentPoint(const Double_t* point); {memcpy(fPoint,point,3*sizeof(Double_t));}. void SetCurrentPoint(Double_t x, Double_t y, Double_t z). void SetLastPoint(Double_t x, Double_t y, Double_t z). void SetCurrentDirection(const Double_t* dir); {memcpy(fDirection,dir,3*sizeof(Double_t));}. void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return fCache->P",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNavigator.html:22355,Safety,safe,safe,22355,"ction;}. TGeoVolume * GetCurrentVolume() const; {return fCurrentNode->GetVolume();}. const Double_t * GetCldirChecked() const; {return fCldirChecked;}. const Double_t * GetCldir() const; Double_t GetNormalChecked() const {return fNormalChecked;}. {return fCldir;}. const Double_t * GetNormal() const; {return fNormal;}. Int_t GetLevel() const; {return fLevel;}. Int_t GetStackLevel() const; {return fCache->GetStackLevel();}. void SetCurrentPoint(const Double_t* point); {memcpy(fPoint,point,3*sizeof(Double_t));}. void SetCurrentPoint(Double_t x, Double_t y, Double_t z). void SetLastPoint(Double_t x, Double_t y, Double_t z). void SetCurrentDirection(const Double_t* dir); {memcpy(fDirection,dir,3*sizeof(Double_t));}. void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return fCache->P",MatchSource.WIKI,root/html530/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html
https://root.cern/root/html530/TGeoNode.html:3380,Availability,avail,available,3380,"efore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd() const; voidCheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """")MENU ; voidCheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawOnly(Option_t* option = """"); voidDrawOverlaps(); virtual voidTObject::",MatchSource.WIKI,root/html530/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNode.html
https://root.cern/root/html530/TGeoNode.html:4542,Availability,error,error,4542,,MatchSource.WIKI,root/html530/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNode.html
https://root.cern/root/html530/TGeoNode.html:4626,Availability,error,error,4626,,MatchSource.WIKI,root/html530/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNode.html
https://root.cern/root/html530/TGeoNode.html:14440,Deployability,A/B,A/B,14440,"e, Int_t& nodeid, Int_t* array) const; Fill array with node id. Recursive on node branch. Int_t FindNode(const TGeoNode* node, Int_t level); Search for a node within the branch of this one. void SaveAttributes(ostream& out); save attributes for this node. Bool_t MayOverlap(Int_t iother) const; Check the overlab between the bounding box of the node overlaps with the one; the brother with index IOTHER. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert the point coordinates from mother reference to local reference system. void MasterToLocalVect(const Double_t* master, Double_t* local) const; Convert a vector from mother reference to local reference system. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert the point coordinates from local reference system to mother reference. void LocalToMasterVect(const Double_t* local, Double_t* master) const; Convert a vector from local reference system to mother reference. void ls(Option_t* option = """") const; Print the path (A/B/C/...) to this node on stdout. void Paint(Option_t* option = """"); Paint this node and its content according to visualization settings. void PrintCandidates() const; print daughters candidates for containing current point; cd();. void PrintOverlaps() const; print possible overlapping nodes; if (!IsOverlapping()) {printf(""node %s is ONLY\n"", GetName()); return;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape. void SetOverlaps(Int_t* ovlp, Int_t novlp); set the list of overlaps for this node (ovlp must be created with operator new). void SetVisibility(Bool_t vis = kTRUE); Set visibility of the node (obsolete). void VisibleDaughters(Bool_t vis = kTRUE); Set visibility of the daughters (obsolete). void cd() const; {;}. Int_t GetByteCount() const; {return 44;}. TGeoNode * GetDaughter(Int_t ind) const; {return fVolume->GetNode(ind);}. TGeoMatrix * GetMatrix() const. Int_t GetColour() const; {",MatchSource.WIKI,root/html530/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNode.html
https://root.cern/root/html530/TGeoNode.html:2893,Performance,perform,perform,2893,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd() const; voidCheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """")MENU ; voidCheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(",MatchSource.WIKI,root/html530/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNode.html
https://root.cern/root/html530/TGeoNode.html:1282,Testability,log,logical,1282," TGeoNode. A node represent a volume positioned inside another.They store links to both; volumes and to the TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from",MatchSource.WIKI,root/html530/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNode.html
https://root.cern/root/html530/TGeoNode.html:1363,Testability,log,logical,1363," TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a po",MatchSource.WIKI,root/html530/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNode.html
https://root.cern/root/html530/TGeoNode.html:1523,Testability,log,logical,1523," will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-ov",MatchSource.WIKI,root/html530/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNode.html
https://root.cern/root/html530/TGeoNode.html:1731,Testability,log,logical,1731," created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::Ad",MatchSource.WIKI,root/html530/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNode.html
https://root.cern/root/html530/TGeoNodeCache.html:1499,Availability,error,error,1499,"AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildIdArray(); Bool_tCdDown(Int_t index); voidCdNode(Int_t nodeid); voidCdTop(); voidCdUp(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillIdBranch(const Int_t* br, Int_t startlevel = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetBranch() const; voidGetBranchNames(Int_t* names) const; voidGetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; voidGetBranchOnlys(Int_t* isonly) const; TGeoHMatrix*GetCurrentMatrix() const; Int_tGetCurrentNodeId() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const Int_t*GetIdBranch() const; Int_tGetLevel() const; void*GetMatrices() const; TGeoNode*GetMother(Int_t up = 1) const; TGeoHMatrix*GetMotherMatrix(Int_t up = 1) const; virtual const char*TObject::GetNam",MatchSource.WIKI,root/html530/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeCache.html
https://root.cern/root/html530/TGeoNodeCache.html:1583,Availability,error,error,1583,"ption = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildIdArray(); Bool_tCdDown(Int_t index); voidCdNode(Int_t nodeid); voidCdTop(); voidCdUp(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillIdBranch(const Int_t* br, Int_t startlevel = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetBranch() const; voidGetBranchNames(Int_t* names) const; voidGetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; voidGetBranchOnlys(Int_t* isonly) const; TGeoHMatrix*GetCurrentMatrix() const; Int_tGetCurrentNodeId() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const Int_t*GetIdBranch() const; Int_tGetLevel() const; void*GetMatrices() const; TGeoNode*GetMother(Int_t up = 1) const; TGeoHMatrix*GetMotherMatrix(Int_t up = 1) const; virtual const char*TObject::GetName() const; TGeoNode*GetNode() const; Int_tGetNodeId() const; virtual char*TObject::G",MatchSource.WIKI,root/html530/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeCache.html
https://root.cern/root/html530/TGeoNodeCache.html:8341,Integrability,interface,interface,8341,"nt_tfStackLevelcurrent level in the stack; TGeoNode*fToptop node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. TGeoNodeCache(const TGeoNodeCache& ); Copy constructor. TGeoNodeCache& operator=(const TGeoNodeCache& ); Assignment operator. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Bool_t CdDown(Int_t index); Make daughter INDEX of current node the active state. Compute global matrix. void CdUp(); Make mother of current node the active state. Int_t GetCurrentNodeId() const; Returns a fixed ID for current physical node. Int_t GetNodeId() const; Get unique node id. void GetBranchNames(Int_t* names) const; Fill names with current branch volume names (4 char - used by GEANT3 interface). void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill copy numbers of current branch nodes. void GetBranchOnlys(Int_t* isonly) const; Fill copy numbers of current branch nodes. const char * GetPath(); Returns the current geometry path. Int_t PushState(Bool_t ovlp, Int_t ntmany = 0, Int_t startlevel = 0, Double_t* point = 0); Push current state into heap. Bool_t PopState(Int_t& nmany, Double_t* point = 0); Pop next state/point from heap. Bool_t PopState(Int_t& nmany, Int_t level, Double_t* point = 0); Pop next state/point from heap and restore matrices starting from LEVEL. Bool_t RestoreState(Int_t& nmany, TGeoCacheState* state, Double_t* point = 0); Pop next state/point from a backed-up state. void LocalToMaster(const Double_t* local, Double_t* master) const; Local point converted to master frame defined by current matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Point in maste",MatchSource.WIKI,root/html530/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeCache.html
https://root.cern/root/html530/TGeoNodeCache.html:7276,Performance,cache,cache,7276,":Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoNodeCache(const TGeoNodeCache&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoNodeCache&operator=(const TGeoNodeCache&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCurrentIDunique ID of current node; Int_tfGeoCacheMaxLevelsmaximum supported number of levels; Int_tfGeoCacheStackSizemaximum size of the stack; Int_tfIdBranch[100]current branch of indices; Int_tfIndexindex in array of ID's; Int_tfLevellevel in the current branch; TGeoHMatrix**fMPBpre-built matrices; TGeoHMatrix*fMatrix! current matrix; TGeoHMatrix**fMatrixBranchcurrent branch of global matrices; TGeoNode*fNode! current node; TGeoNode**fNodeBranchcurrent branch of nodes; Int_t*fNodeIdArray! array of node id's; TStringfPathpath for current branch; TObjArray*fStackstack of cache states; Int_tfStackLevelcurrent level in the stack; TGeoNode*fToptop node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. TGeoNodeCache(const TGeoNodeCache& ); Copy constructor. TGeoNodeCache& operator=(const TGeoNodeCache& ); Assignment operator. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Bool_t CdDown(Int_t index); Make daughter INDEX of current node the active stat",MatchSource.WIKI,root/html530/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeCache.html
https://root.cern/root/html530/TGeoNodeCache.html:7922,Performance,perform,performance,7922,"ex in array of ID's; Int_tfLevellevel in the current branch; TGeoHMatrix**fMPBpre-built matrices; TGeoHMatrix*fMatrix! current matrix; TGeoHMatrix**fMatrixBranchcurrent branch of global matrices; TGeoNode*fNode! current node; TGeoNode**fNodeBranchcurrent branch of nodes; Int_t*fNodeIdArray! array of node id's; TStringfPathpath for current branch; TObjArray*fStackstack of cache states; Int_tfStackLevelcurrent level in the stack; TGeoNode*fToptop node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. TGeoNodeCache(const TGeoNodeCache& ); Copy constructor. TGeoNodeCache& operator=(const TGeoNodeCache& ); Assignment operator. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Bool_t CdDown(Int_t index); Make daughter INDEX of current node the active state. Compute global matrix. void CdUp(); Make mother of current node the active state. Int_t GetCurrentNodeId() const; Returns a fixed ID for current physical node. Int_t GetNodeId() const; Get unique node id. void GetBranchNames(Int_t* names) const; Fill names with current branch volume names (4 char - used by GEANT3 interface). void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill copy numbers of current branch nodes. void GetBranchOnlys(Int_t* isonly) const; Fill copy numbers of current branch nodes. const char * GetPath(); Returns the current geometry path. Int_t PushState(Bool_t ovlp, Int_t ntmany = 0, Int_t startlevel = 0, Double_t* point = 0); Push current state into heap. Bool_t PopState(Int_t& nmany, Double_t* point = 0); Pop next state/point from heap. Bool_t PopState(Int_t& nmany, Int_t level, Double_t* point = 0); Pop next state/point f",MatchSource.WIKI,root/html530/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeCache.html
https://root.cern/root/html530/TGeoNodeEditor.html:4687,Availability,error,error,4687,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeEditor.html
https://root.cern/root/html530/TGeoNodeEditor.html:4771,Availability,error,error,4771,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeEditor.html
https://root.cern/root/html530/TGeoNodeEditor.html:18060,Availability,mask,mask,18060,,MatchSource.WIKI,root/html530/TGeoNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeEditor.html
https://root.cern/root/html530/TGeoNodeEditor.html:21831,Usability,undo,undoing,21831,"ag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for node editor. ~TGeoNodeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a editable object. void DoSelectMother(); Select the mother volume. void DoSelectVolume(); Select the volume. void DoSelectMatrix(); Select the matrix. void DoEditMother(); Edit the mother volume. void DoEditVolume(); Edit selected volume. void DoEditMatrix(); Edit selected material. void DoNodeName(); Change node name. void DoNodeNumber(); Change node copy number. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoNodeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeEditor.html
https://root.cern/root/html530/TGeoNodeMatrix.html:1713,Availability,error,error,1713,"1, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); vo",MatchSource.WIKI,root/html530/TGeoNodeMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeMatrix.html
https://root.cern/root/html530/TGeoNodeMatrix.html:1797,Availability,error,error,1797,"hapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidTGeoNode::FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Int_tTGeoNode::FindNode(const TGeoNode* node, Int_t level); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; Int_tTGeoNode::GetColour() const; TGeoNode*TGeoNode::GetDaughter(Int_t ind) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoPatternFinder*TGeoNode::GetFinder() const; virtual const char*TObject::GetIconName() const; virtual Int_tTGeoNode::GetIndex() const; virtual TGeoMatrix*GetMatrix() const; TGeoMedium*TGeoNode::GetMedium() const; TGeoVolume*TGeoNode::GetMotherVolume() const; virtual const char*TNamed::GetName() const; Int_tTGeoNode::GetNdaugh",MatchSource.WIKI,root/html530/TGeoNodeMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeMatrix.html
https://root.cern/root/html530/TGeoNodeOffset.html:4588,Availability,error,error,4588,,MatchSource.WIKI,root/html530/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeOffset.html
https://root.cern/root/html530/TGeoNodeOffset.html:4672,Availability,error,error,4672,"hapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidTGeoNode::FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Int_tTGeoNode::FindNode(const TGeoNode* node, Int_t level); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoNode::GetByteCount() const; Int_tTGeoNode::GetColour() const; TGeoNode*TGeoNode::GetDaughter(Int_t ind) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoPatternFinder*GetFinder() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetIndex() const; virtual TGeoMatrix*GetMatrix() const; TGeoMedium*TGeoNode::GetMedium() const; TGeoVolume*TGeoNode::GetMotherVolume() const; virtual const char*TNamed::GetName() const; Int_tTGeoNode::GetNdaughters() con",MatchSource.WIKI,root/html530/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeOffset.html
https://root.cern/root/html530/TGeoNodeOffset.html:2897,Performance,perform,perform,2897,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. TGeoNodeOffset(); TGeoNodeOffset(const TGeoVolume* vol, Int_t index, Double_t offset); virtual~TGeoNodeOffset(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoNode::Browse(TBrowser* b); virtual voidcd() const; voidTGeoNode::CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TO",MatchSource.WIKI,root/html530/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeOffset.html
https://root.cern/root/html530/TGeoNodeOffset.html:1286,Testability,log,logical,1286," TGeoNode. A node represent a volume positioned inside another.They store links to both; volumes and to the TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from",MatchSource.WIKI,root/html530/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeOffset.html
https://root.cern/root/html530/TGeoNodeOffset.html:1367,Testability,log,logical,1367," TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a po",MatchSource.WIKI,root/html530/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeOffset.html
https://root.cern/root/html530/TGeoNodeOffset.html:1527,Testability,log,logical,1527," will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-ov",MatchSource.WIKI,root/html530/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeOffset.html
https://root.cern/root/html530/TGeoNodeOffset.html:1735,Testability,log,logical,1735," created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::Ad",MatchSource.WIKI,root/html530/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoNodeOffset.html
https://root.cern/root/html530/TGeoOverlap.html:1778,Availability,error,error,1778,"ap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoHMatrix*GetFirstMatrix() const; TGeoVolume*GetFirstVolume() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t",MatchSource.WIKI,root/html530/TGeoOverlap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoOverlap.html
https://root.cern/root/html530/TGeoOverlap.html:1862,Availability,error,error,1862,"pendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoHMatrix*GetFirstMatrix() const; TGeoVolume*GetFirstVolume() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetOverlap() const; TPolyMarker3D*GetPolyMarker",MatchSource.WIKI,root/html530/TGeoOverlap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoOverlap.html
https://root.cern/root/html530/TGeoOverlap.html:8921,Energy Efficiency,green,green,8921,"me; TGeoHMatrix*fMatrix2positioning matrix for second volume; TStringTNamed::fNameobject identifier; Double_tfOverlapoverlap distance; TStringTNamed::fTitleobject title; TGeoVolume*fVolume1first volume; TGeoVolume*fVolume2second volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoOverlap(); Default ctor. TGeoOverlap(const char* name, TGeoVolume* vol1, TGeoVolume* vol2, const TGeoMatrix* matrix1, const TGeoMatrix* matrix2, Bool_t isovlp = kTRUE, Double_t ovlp = 0.01); Creates a named overlap belonging to volume VOL and having the size OVLP. ~TGeoOverlap(); Destructor. void Browse(TBrowser* b); Define double-click action. Int_t Compare(const TObject* obj) const; Method to compare this overlap with another. Returns :; -1 - this is smaller than OBJ; 0 - equal; 1 - greater. Int_t DistancetoPrimitive(Int_t px, Int_t py); Distance to primitive for an overlap. void Draw(Option_t* option = """"); Draw the overlap. One daughter will be blue, the other green,; extruding points red. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Event interception. void Paint(Option_t* option = """"); Paint the overlap. void Print(Option_t* option = """") const; Print detailed info. void PrintInfo() const; Print some info. void SetNextPoint(Double_t x, Double_t y, Double_t z); Set next overlapping point. void SampleOverlap(Int_t npoints = 1000000); Draw overlap and sample with random points the overlapping region. void Sizeof3D() const; Get 3D size of this. void Validate() const; Validate this overlap. TGeoOverlap(const TGeoOverlap& ). TGeoOverlap& operator=(const TGeoOverlap& ). TPolyMarker3D * GetPolyMarker() const; {return fMarker;}. TGeoVolume * GetFirstVolume() const; {return fVolume1;}. TGeoVolume * GetSecondVolume() const; {return fVolume2;}. TGeoHMatrix * GetFirstMatrix() const; {return fMatrix1;}. TGeoHMatrix * GetSecondMatrix() const; {return fMatrix2;}. Double_t GetOverlap() const; {return fOverlap;}. Bool_t IsExtrusion() const; {retur",MatchSource.WIKI,root/html530/TGeoOverlap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoOverlap.html
https://root.cern/root/html530/TGeoPainter.html:3197,Availability,error,error,3197,"Int_t px, Int_t py); virtual Int_tDistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCurrentPoint(Int_t color); virtual voidDrawOnly(Option_t* option = """"); virtual voidDrawOverlap(void* ovlp, Option_t* option = """"); virtual voidDrawPanel(); virtual voidDrawPath(const char* path); virtual voidDrawShape(TGeoShape* shape, Option_t* option = """"); virtual voidDrawVolume(TGeoVolume* vol, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidEditGeometry(Option_t* option = """"); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); virtual voidExecuteShapeEvent(TGeoShape* shape, Int_t event, Int_t px, Int_t py); virtual voidExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*TVirtualGeoPainter::GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual TGeoNode*GetCheckedNode(); TGeoChecker*GetChecker(); virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:3281,Availability,error,error,3281,"Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCurrentPoint(Int_t color); virtual voidDrawOnly(Option_t* option = """"); virtual voidDrawOverlap(void* ovlp, Option_t* option = """"); virtual voidDrawPanel(); virtual voidDrawPath(const char* path); virtual voidDrawShape(TGeoShape* shape, Option_t* option = """"); virtual voidDrawVolume(TGeoVolume* vol, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidEditGeometry(Option_t* option = """"); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); virtual voidExecuteShapeEvent(TGeoShape* shape, Int_t event, Int_t px, Int_t py); virtual voidExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*TVirtualGeoPainter::GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual TGeoNode*GetCheckedNode(); TGeoChecker*GetChecker(); virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDrawOption() const; virtual const char*GetDrawPath() const; static Long_tTObject::GetDto",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:13443,Availability,error,errors,13443,"Geometry painter default constructor; *-* ====================================. ~TGeoPainter(); -*-*Geometry painter default destructor; *-* ===================================. void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); --- Add numpoints, numsegs, numpolys to the global 3D size. TVirtualGeoTrack * AddTrack(Int_t id, Int_t pdgcode, TObject* part); Create a primary TGeoTrack. void AddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); Average center of view of all painted tracklets and compute view box. void BombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'bombed' translation vector according current exploded view mode. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); Geometry checking method (see: TGeoManager::CheckGeometry()). void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; Geometry checking method (see TGeoChecker). void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; Check overlaps for the top volume of the geometry, within a limit OVLP. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); check current point in the geometry. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFrom",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:15481,Availability,down,down,15481,"side. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. void Draw(Option_t* option = """"); Draw method. void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); Draw the time evolution of a radionuclide. void DrawVolume(TGeoVolume* vol, Option_t* option = """"); Draw method. void DrawShape(TGeoShape* shape, Option_t* option = """"); Draw a shape. void DrawOverlap(void* ovlp, Option_t* option = """"); Draw an overlap. void DrawOnly(Option_t* option = """"); Draw only one volume. void DrawCurrentPoint(Int_t color); Draw current point in the same view. void DrawPanel(). void DrawPath(const char* path); Draw all volumes for a given path. void EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); Estimate camera movement between tmin and tmax for best tra",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:19912,Availability,down,down,19912,"ndomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Shoot nrays in the current drawn geometry. void Raytrace(Option_t* option = """"); Raytrace current drawn geometry. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetNmeshPoints(Int_t npoints); Set number of points to be generated on the shape outline when checking for overlaps. void SetCheckedNode(TGeoNode* node); Select a node to be checked for overlaps. All overlaps not involving it will; be ignored. void SetVisLevel(Int_t level = 3); Set default level down to which visualization is performed. void SetTopVisible(Bool_t vis = kTRUE); Set top geometry volume as visible. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn. Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; Returns distance between point px,py on the pad an a shape. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void Ge",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:20122,Availability,down,down,20122,"nt_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetNmeshPoints(Int_t npoints); Set number of points to be generated on the shape outline when checking for overlaps. void SetCheckedNode(TGeoNode* node); Select a node to be checked for overlaps. All overlaps not involving it will; be ignored. void SetVisLevel(Int_t level = 3); Set default level down to which visualization is performed. void SetTopVisible(Bool_t vis = kTRUE); Set top geometry volume as visible. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn. Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; Returns distance between point px,py on the pad an a shape. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void GetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; {bombx=fBombX; bomby=fBombY; bombz=fBombZ; bombr=fBombR;}. Int_t GetBombMode() const; {return fExplodedView;}. TGeoNode * Get",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:6165,Deployability,update,update,6165,,MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:17653,Deployability,update,update,17653,"n shape. void ExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); Execute mouse actions on a given volume. const char * GetVolumeInfo(const TGeoVolume* volume, Int_t px, Int_t py) const; Get some info about the current selected volume. TGeoChecker * GetChecker(); Create/return geometry checker. void GetViewAngles(Double_t& longitude, Double_t& latitude, Double_t& psi); Get the current view angles. void GrabFocus(Int_t nfr = 0, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to current volume. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void LocalToMasterVect(const Double_t* local, Double_t* master) const; Convert a local vector according view rotation matrix. void ModifiedPad(Bool_t update = kFALSE) const; Check if a pad and view are present and send signal ""Modified"" to pad. void Paint(Option_t* option = """"); Paint current geometry according to option. void PaintOverlap(void* ovlp, Option_t* option = """"); Paint an overlap. void PaintNode(TGeoNode* node, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. void PaintVolume(TGeoVolume* vol, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. Bool_t PaintShape(const TGeoShape& shape, Option_t* option) const; Paint the supplied shape into the current 3D viewer. void PaintShape(TGeoShape* shape, Option_t* option = """"); Paint an overlap. void PaintPhysicalNode(TGeoPhysicalNode* node, Option_t* option = """"); Paints a physical node associated with a path. void PrintOverlaps() const; Print overlaps (see TGeoChecker::PrintOverlaps()). void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* ",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:354,Integrability,interface,interfaces,354,". TGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoPainter. class TGeoPainter: public TVirtualGeoPainter. TGeoPainter - class implementing all draw interfaces for a generic 3D viewer; using TBuffer3D mechanism. Function Members (Methods); public:. TGeoPainter(TGeoManager* manager); TGeoPainter(const TGeoPainter&); virtual~TGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* part); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); voidCheckEdit(); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountNodes(TGeoVolume* vol, Int_t level)",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:8650,Modifiability,plugin,plugin,8650,"l voidSetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); virtual voidSetCheckedNode(TGeoNode* node); virtual voidSetClippingShape(TGeoShape* shape); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExplodedView(Int_t iopt = 0); virtual voidSetGeoManager(TGeoManager* geom); virtual voidSetIteratorPlugin(TGeoIteratorPlugin* plugin); virtual voidSetNmeshPoints(Int_t npoints); virtual voidSetNsegments(Int_t nseg = 20); static voidTObject::SetObjectStat(Bool_t stat); static voidTVirtualGeoPainter::SetPainter(const TVirtualGeoPainter* painter); virtual voidSetRaytracing(Bool_t flag = kTRUE); virtual voidSetTopVisible(Bool_t vis = kTRUE); virtual voidSetTopVolume(TGeoVolume* vol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVisLevel(Int_t level = 3); virtual voidSetVisOption(Int_t option = 0); virtual Int_tShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTest(Int_t npoints, Option_t* option); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestOverlaps(const char* path); virtual Bool_tTestVoxels(TGeoVolume* vol); virtual voidUnbombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tWeight(Double_t precision, Option_t* option = ""v""); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidClearVisibleVolumes(); virtual voidTObject::DoError(int level, const char* locati",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:11956,Modifiability,plugin,plugin,11956,"; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static TVirtualGeoPainter*TVirtualGeoPainter::fgGeoPainterPointer to class painter. private:. Double_tfBombRbomb factor on radius (cyl or sph); Double_tfBombXbomb factor on X; Double_tfBombYbomb factor on Y; Double_tfBombZbomb factor on Z; TBuffer3D*fBufferbuffer used for painting; Double_tfCheckedBox[6]bounding box of checked node; TGeoNode*fCheckedNodechecked node; TGeoChecker*fCheckergeometry checker; TGeoShape*fClippingShapeclipping shape; Int_tfExplodedViewtype of exploding current view; TGeoManager*fGeoManagergeometry to which applies; TGeoHMatrix*fGlobalcurrent global matrix; Bool_tfIsEditableflag that geometry is editable; Bool_tfIsPaintingShapeflag for shape painting; Bool_tfIsRaytracingraytracing flag; TGeoVolume*fLastVolumelast drawn volume; Double_tfMat[9]view rotation matrix; Int_tfNVisNodesnumber of visible nodes; Int_tfNsegmentsnumber of segments approximating circles; TGeoOverlap*fOverlapcurrent overlap; Bool_tfPaintingOverlapslock overlaps painting; TGeoIteratorPlugin*fPluginUser iterator plugin for changing pain volume properties; Bool_tfTopVisibleset top volume visible; TGeoVolume*fTopVolumetop drawn volume; TStringfVisBranchdrawn branch; Int_tfVisLeveldepth for drawing; Bool_tfVisLocklock for adding visible volumes; Int_tfVisOptionglobal visualization option; TObjArray*fVisVolumeslist of visible volumes; TStringfVolInfovolume info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPainter(TGeoManager* manager); -*-*Geometry painter default constructor; *-* ====================================. ~TGeoPainter(); -*-*Geometry painter default destructor; *-* ===================================. void AddSize3D(Int_t numpoints, Int_t numsegs, Int_",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:21904,Modifiability,plugin,plugin,21904,"on_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void GetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; {bombx=fBombX; bomby=fBombY; bombz=fBombZ; bombr=fBombR;}. Int_t GetBombMode() const; {return fExplodedView;}. TGeoNode * GetCheckedNode(); {return fCheckedNode;}. const char * GetDrawPath() const; {return fVisBranch.Data();}. TGeoVolume * GetTopVolume() const; {return fTopVolume;}. Int_t GetVisLevel() const; {return fVisLevel;}. Int_t GetVisOption() const; {return fVisOption;}. Int_t GetNsegments() const; {return fNsegments;}. Double_t * GetViewBox(); {return &fCheckedBox[0];}. Bool_t IsExplodedView() const; {return ((fExplodedView==kGeoVisDefault)?kFALSE:kTRUE);}. Bool_t IsRaytracing() const; {return fIsRaytracing;}. Bool_t IsPaintingShape() const; {return fIsPaintingShape;}. void Lock(Bool_t flag = kTRUE); {fVisLock = flag;}. void SetClippingShape(TGeoShape* shape); {fClippingShape = shape;}. void SetGeoManager(TGeoManager* geom); {fGeoManager=geom;}. void SetIteratorPlugin(TGeoIteratorPlugin* plugin); {fPlugin = plugin; ModifiedPad();}. void SetRaytracing(Bool_t flag = kTRUE); {fIsRaytracing = flag;}. void SetTopVolume(TGeoVolume* vol); {fTopVolume = vol;}. » Author: Andrei Gheata 05/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: Mon Jul 4 15:31:51 2011 » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:21924,Modifiability,plugin,plugin,21924,"on_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void GetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; {bombx=fBombX; bomby=fBombY; bombz=fBombZ; bombr=fBombR;}. Int_t GetBombMode() const; {return fExplodedView;}. TGeoNode * GetCheckedNode(); {return fCheckedNode;}. const char * GetDrawPath() const; {return fVisBranch.Data();}. TGeoVolume * GetTopVolume() const; {return fTopVolume;}. Int_t GetVisLevel() const; {return fVisLevel;}. Int_t GetVisOption() const; {return fVisOption;}. Int_t GetNsegments() const; {return fNsegments;}. Double_t * GetViewBox(); {return &fCheckedBox[0];}. Bool_t IsExplodedView() const; {return ((fExplodedView==kGeoVisDefault)?kFALSE:kTRUE);}. Bool_t IsRaytracing() const; {return fIsRaytracing;}. Bool_t IsPaintingShape() const; {return fIsPaintingShape;}. void Lock(Bool_t flag = kTRUE); {fVisLock = flag;}. void SetClippingShape(TGeoShape* shape); {fClippingShape = shape;}. void SetGeoManager(TGeoManager* geom); {fGeoManager=geom;}. void SetIteratorPlugin(TGeoIteratorPlugin* plugin); {fPlugin = plugin; ModifiedPad();}. void SetRaytracing(Bool_t flag = kTRUE); {fIsRaytracing = flag;}. void SetTopVolume(TGeoVolume* vol); {fTopVolume = vol;}. » Author: Andrei Gheata 05/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: Mon Jul 4 15:31:51 2011 » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:15610,Performance,load,loaded,15610,"tFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. void Draw(Option_t* option = """"); Draw method. void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); Draw the time evolution of a radionuclide. void DrawVolume(TGeoVolume* vol, Option_t* option = """"); Draw method. void DrawShape(TGeoShape* shape, Option_t* option = """"); Draw a shape. void DrawOverlap(void* ovlp, Option_t* option = """"); Draw an overlap. void DrawOnly(Option_t* option = """"); Draw only one volume. void DrawCurrentPoint(Int_t color); Draw current point in the same view. void DrawPanel(). void DrawPath(const char* path); Draw all volumes for a given path. void EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); Estimate camera movement between tmin and tmax for best track display. void ExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); Execute mouse actions on a given volume. void ExecuteShapeEvent(TGeo",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:15621,Performance,load,load,15621,"tFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. void Draw(Option_t* option = """"); Draw method. void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); Draw the time evolution of a radionuclide. void DrawVolume(TGeoVolume* vol, Option_t* option = """"); Draw method. void DrawShape(TGeoShape* shape, Option_t* option = """"); Draw a shape. void DrawOverlap(void* ovlp, Option_t* option = """"); Draw an overlap. void DrawOnly(Option_t* option = """"); Draw only one volume. void DrawCurrentPoint(Int_t color); Draw current point in the same view. void DrawPanel(). void DrawPath(const char* path); Draw all volumes for a given path. void EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); Estimate camera movement between tmin and tmax for best track display. void ExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); Execute mouse actions on a given volume. void ExecuteShapeEvent(TGeo",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:19943,Performance,perform,performed,19943,"ndomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Shoot nrays in the current drawn geometry. void Raytrace(Option_t* option = """"); Raytrace current drawn geometry. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetNmeshPoints(Int_t npoints); Set number of points to be generated on the shape outline when checking for overlaps. void SetCheckedNode(TGeoNode* node); Select a node to be checked for overlaps. All overlaps not involving it will; be ignored. void SetVisLevel(Int_t level = 3); Set default level down to which visualization is performed. void SetTopVisible(Bool_t vis = kTRUE); Set top geometry volume as visible. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn. Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; Returns distance between point px,py on the pad an a shape. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void Ge",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:1628,Testability,test,testNo,1628,"1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountNodes(TGeoVolume* vol, Int_t level)",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:14323,Testability,test,testNo,14323,"ull bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); Geometry checking method (see: TGeoManager::CheckGeometry()). void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; Geometry checking method (see TGeoChecker). void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; Check overlaps for the top volume of the geometry, within a limit OVLP. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); check current point in the geometry. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors();",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:14413,Testability,test,test,14413,"ck the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); Geometry checking method (see: TGeoManager::CheckGeometry()). void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; Geometry checking method (see TGeoChecker). void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; Check overlaps for the top volume of the geometry, within a limit OVLP. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); check current point in the geometry. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* v",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPainter.html:18752,Usability,progress bar,progress bar,18752," a pad and view are present and send signal ""Modified"" to pad. void Paint(Option_t* option = """"); Paint current geometry according to option. void PaintOverlap(void* ovlp, Option_t* option = """"); Paint an overlap. void PaintNode(TGeoNode* node, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. void PaintVolume(TGeoVolume* vol, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. Bool_t PaintShape(const TGeoShape& shape, Option_t* option) const; Paint the supplied shape into the current 3D viewer. void PaintShape(TGeoShape* shape, Option_t* option = """"); Paint an overlap. void PaintPhysicalNode(TGeoPhysicalNode* node, Option_t* option = """"); Paints a physical node associated with a path. void PrintOverlaps() const; Print overlaps (see TGeoChecker::PrintOverlaps()). void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE); Text progress bar. void RandomPoints(const TGeoVolume* vol, Int_t npoints, Option_t* option = """"); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Shoot nrays in the current drawn geometry. void Raytrace(Option_t* option = """"); Raytrace current drawn geometry. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetNmeshPoints(Int_t npoints); Set number of points to be generated on ",MatchSource.WIKI,root/html530/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPainter.html
https://root.cern/root/html530/TGeoPara.html:3016,Availability,error,error,3016,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetA",MatchSource.WIKI,root/html530/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPara.html
https://root.cern/root/html530/TGeoPara.html:3100,Availability,error,error,3100,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGe",MatchSource.WIKI,root/html530/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPara.html
https://root.cern/root/html530/TGeoPara.html:2167,Safety,safe,safe,2167,"static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html530/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPara.html
https://root.cern/root/html530/TGeoPara.html:2308,Safety,safe,safe,2308,"testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html530/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPara.html
https://root.cern/root/html530/TGeoPara.html:13031,Safety,safe,safe,13031,"ncludes; Libraries. Function documentation; TGeoPara(); Default constructor. TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(co",MatchSource.WIKI,root/html530/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPara.html
https://root.cern/root/html530/TGeoPara.html:13116,Safety,safe,safe,13116,"ncludes; Libraries. Function documentation; TGeoPara(); Default constructor. TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(co",MatchSource.WIKI,root/html530/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPara.html
https://root.cern/root/html530/TGeoPara.html:13249,Safety,safe,safe,13249,"nimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this. Returns 0 if successfull. TGeoShape * GetMakeRuntimeShape(TG",MatchSource.WIKI,root/html530/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPara.html
https://root.cern/root/html530/TGeoPara.html:1310,Testability,test,testNo,1310," TGeoPara(); TGeoPara(Double_t* param); TGeoPara(const TGeoPara&); TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); virtual~TGeoPara(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox",MatchSource.WIKI,root/html530/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPara.html
https://root.cern/root/html530/TGeoPara.html:12864,Testability,test,test,12864,"Tyztangent of XZ section angle; Double_tfXX half-length; Double_tfYY half-length; Double_tfZZ half-length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPara(); Default constructor. TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* ",MatchSource.WIKI,root/html530/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPara.html
https://root.cern/root/html530/TGeoPara.html:12901,Testability,test,test,12901,"Tyztangent of XZ section angle; Double_tfXX half-length; Double_tfYY half-length; Double_tfZZ half-length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPara(); Default constructor. TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* ",MatchSource.WIKI,root/html530/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPara.html
https://root.cern/root/html530/TGeoParaboloid.html:3325,Availability,error,error,3325,"uble_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Double_tDistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::Ge",MatchSource.WIKI,root/html530/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html
https://root.cern/root/html530/TGeoParaboloid.html:3409,Availability,error,error,3409,"onst; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Double_tDistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBB",MatchSource.WIKI,root/html530/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html
https://root.cern/root/html530/TGeoParaboloid.html:2401,Safety,safe,safe,2401,"x* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Double_tDistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, In",MatchSource.WIKI,root/html530/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html
https://root.cern/root/html530/TGeoParaboloid.html:2542,Safety,safe,safe,2542,"ape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Double_tDistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root/html530/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html
https://root.cern/root/html530/TGeoParaboloid.html:13208,Safety,safe,safe,13208,"ngth. TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsA",MatchSource.WIKI,root/html530/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html
https://root.cern/root/html530/TGeoParaboloid.html:13407,Safety,safe,safe,13407,"m and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void",MatchSource.WIKI,root/html530/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html
https://root.cern/root/html530/TGeoParaboloid.html:13493,Safety,safe,safe,13493,"m and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void",MatchSource.WIKI,root/html530/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html
https://root.cern/root/html530/TGeoParaboloid.html:1554,Testability,test,testNo,1554," TGeoParaboloid(); TGeoParaboloid(Double_t* params); TGeoParaboloid(const TGeoParaboloid&); TGeoParaboloid(Double_t rlo, Double_t rhi, Double_t dz); TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); virtual~TGeoParaboloid(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual",MatchSource.WIKI,root/html530/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html
https://root.cern/root/html530/TGeoParaboloid.html:12779,Testability,test,test,12779," private:. Double_tfAquadratic coeff.; Double_tfBZ value of parabola at x=y=0; Double_tfDzrange on Z axis [-dz, dz]; Double_tfRhiradius at z=+dz; Double_tfRloradius at z=-dz. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParaboloid(); Dummy constructor. TGeoParaboloid(Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The ",MatchSource.WIKI,root/html530/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html
https://root.cern/root/html530/TGeoParaEditor.html:4611,Availability,error,error,4611,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoParaEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaEditor.html
https://root.cern/root/html530/TGeoParaEditor.html:4695,Availability,error,error,4695,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoParaEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaEditor.html
https://root.cern/root/html530/TGeoParaEditor.html:17952,Availability,mask,mask,17952,,MatchSource.WIKI,root/html530/TGeoParaEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaEditor.html
https://root.cern/root/html530/TGeoParaEditor.html:21434,Usability,undo,undoing,21434,"ool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParaEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoParaEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoX(); Slot for X. void DoY(); Slot for Y. void DoZ(); Slot for Z. void DoAlpha(); Slot for alpha. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoParaEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoParaEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoParaEditor.html
https://root.cern/root/html530/TGeoPatternCylPhi.html:2553,Availability,error,error,2553,"nCylPhi(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html530/TGeoPatternCylPhi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternCylPhi.html
https://root.cern/root/html530/TGeoPatternCylPhi.html:2637,Availability,error,error,2637,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html530/TGeoPatternCylPhi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternCylPhi.html
https://root.cern/root/html530/TGeoPatternCylR.html:2578,Availability,error,error,2578,"ernCylR(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html530/TGeoPatternCylR.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternCylR.html
https://root.cern/root/html530/TGeoPatternCylR.html:2662,Availability,error,error,2662,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html530/TGeoPatternCylR.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternCylR.html
https://root.cern/root/html530/TGeoPatternFinder.html:2360,Availability,error,error,2360,"div); virtual~TGeoPatternFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t); virtual TGeoNode*CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t*, const Double_t* = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; Int_tGetCurrent(); virtual Int_tGetDivAxis(); Int_tGetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; Int_tGetNdiv() const; Int_tGetNext() const; TGeoNode*GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetStart()",MatchSource.WIKI,root/html530/TGeoPatternFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternFinder.html
https://root.cern/root/html530/TGeoPatternFinder.html:2444,Availability,error,error,2444,"onst; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t); virtual TGeoNode*CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t*, const Double_t* = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; Int_tGetCurrent(); virtual Int_tGetDivAxis(); Int_tGetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; Int_tGetNdiv() const; Int_tGetNext() const; TGeoNode*GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetStart() const; Double_tGetStep() const; virtual const char*TObject::GetTitle() const; virtu",MatchSource.WIKI,root/html530/TGeoPatternFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternFinder.html
https://root.cern/root/html530/TGeoPatternHoneycomb.html:2413,Availability,error,error,2413,"neycomb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tTGeoPatternFinder::GetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffs",MatchSource.WIKI,root/html530/TGeoPatternHoneycomb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternHoneycomb.html
https://root.cern/root/html530/TGeoPatternHoneycomb.html:2497,Availability,error,error,2497,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tTGeoPatternFinder::GetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stati",MatchSource.WIKI,root/html530/TGeoPatternHoneycomb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternHoneycomb.html
https://root.cern/root/html530/TGeoPatternParaX.html:2588,Availability,error,error,2588,"rnParaX(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html530/TGeoPatternParaX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternParaX.html
https://root.cern/root/html530/TGeoPatternParaX.html:2672,Availability,error,error,2672,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html530/TGeoPatternParaX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternParaX.html
https://root.cern/root/html530/TGeoPatternParaY.html:2588,Availability,error,error,2588,"rnParaY(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html530/TGeoPatternParaY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternParaY.html
https://root.cern/root/html530/TGeoPatternParaY.html:2672,Availability,error,error,2672,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html530/TGeoPatternParaY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternParaY.html
https://root.cern/root/html530/TGeoPatternParaZ.html:2588,Availability,error,error,2588,"rnParaZ(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html530/TGeoPatternParaZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternParaZ.html
https://root.cern/root/html530/TGeoPatternParaZ.html:2672,Availability,error,error,2672,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html530/TGeoPatternParaZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternParaZ.html
https://root.cern/root/html530/TGeoPatternSphPhi.html:2598,Availability,error,error,2598,"nSphPhi(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html530/TGeoPatternSphPhi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternSphPhi.html
https://root.cern/root/html530/TGeoPatternSphPhi.html:2682,Availability,error,error,2682,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html530/TGeoPatternSphPhi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternSphPhi.html
https://root.cern/root/html530/TGeoPatternSphR.html:2578,Availability,error,error,2578,"ernSphR(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html530/TGeoPatternSphR.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternSphR.html
https://root.cern/root/html530/TGeoPatternSphR.html:2662,Availability,error,error,2662,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html530/TGeoPatternSphR.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternSphR.html
https://root.cern/root/html530/TGeoPatternSphTheta.html:2618,Availability,error,error,2618,"phTheta(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html530/TGeoPatternSphTheta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternSphTheta.html
https://root.cern/root/html530/TGeoPatternSphTheta.html:2702,Availability,error,error,2702,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html530/TGeoPatternSphTheta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternSphTheta.html
https://root.cern/root/html530/TGeoPatternTrapZ.html:2588,Availability,error,error,2588,"rnTrapZ(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html530/TGeoPatternTrapZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternTrapZ.html
https://root.cern/root/html530/TGeoPatternTrapZ.html:2672,Availability,error,error,2672,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html530/TGeoPatternTrapZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternTrapZ.html
https://root.cern/root/html530/TGeoPatternX.html:2548,Availability,error,error,2548,"atternX(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternF",MatchSource.WIKI,root/html530/TGeoPatternX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternX.html
https://root.cern/root/html530/TGeoPatternX.html:2632,Availability,error,error,2632,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtu",MatchSource.WIKI,root/html530/TGeoPatternX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternX.html
https://root.cern/root/html530/TGeoPatternY.html:2548,Availability,error,error,2548,"atternY(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternF",MatchSource.WIKI,root/html530/TGeoPatternY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternY.html
https://root.cern/root/html530/TGeoPatternY.html:2632,Availability,error,error,2632,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtu",MatchSource.WIKI,root/html530/TGeoPatternY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternY.html
https://root.cern/root/html530/TGeoPatternZ.html:2548,Availability,error,error,2548,"atternZ(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternF",MatchSource.WIKI,root/html530/TGeoPatternZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternZ.html
https://root.cern/root/html530/TGeoPatternZ.html:2632,Availability,error,error,2632,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtu",MatchSource.WIKI,root/html530/TGeoPatternZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPatternZ.html
https://root.cern/root/html530/TGeoPcon.html:3090,Availability,error,error,3090,"stFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) ",MatchSource.WIKI,root/html530/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPcon.html
https://root.cern/root/html530/TGeoPcon.html:3174,Availability,error,error,3174,"ape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* ma",MatchSource.WIKI,root/html530/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPcon.html
https://root.cern/root/html530/TGeoPcon.html:14487,Performance,perform,performed,14487,"io, Double_t sfio, Double_t cdfi) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Z divisions can be; performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetRmin(Int_t ipl) const; Returns Rmin for Z segment IPL. Double_t GetRmax(Int_t ipl) const; Returns Rmax for Z segment IPL. Double_t GetZ(Int_t ipl) const; Returns Z for segment IPL. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSegment(Double_t* point, Int_t ipl, B",MatchSource.WIKI,root/html530/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPcon.html
https://root.cern/root/html530/TGeoPcon.html:2058,Safety,safe,safe,2058,"b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method",MatchSource.WIKI,root/html530/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPcon.html
https://root.cern/root/html530/TGeoPcon.html:2199,Safety,safe,safe,2199,"lass(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeo",MatchSource.WIKI,root/html530/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPcon.html
https://root.cern/root/html530/TGeoPcon.html:13305,Safety,safe,safe,13305," nz); Default constructor. TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); Default constructor. TGeoPcon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nz. param[3] = z1; param[4] = Rmin1; param[5] = Rmax1. TGeoPcon(const TGeoPcon& ); copy constructor. TGeoPcon& operator=(const TGeoPcon& ); assignment operator. ~TGeoPcon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone sha",MatchSource.WIKI,root/html530/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPcon.html
https://root.cern/root/html530/TGeoPcon.html:13731,Safety,safe,safe,13731,"city() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Z divisions can be; performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name of ax",MatchSource.WIKI,root/html530/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPcon.html
https://root.cern/root/html530/TGeoPcon.html:15581,Safety,safe,safety,15581,"nes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetRmin(Int_t ipl) const; Returns Rmin for Z segment IPL. Double_t GetRmax(Int_t ipl) const; Returns Rmax for Z segment IPL. Double_t GetZ(Int_t ipl) const; Returns Z for segment IPL. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSegment(Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set polycone dimensions starting from an array. void SetPoints(Double_t* points) const; create polycone mesh points. void SetPoints(Float_t* points) const; create polycone mesh points. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomer();; if (!painter) return;; Int_t n;. n = gGeoManager->GetNsegments()+1;. Int_t numPoints = fNz*2*n;; Int_t numSegs = 4*(fNz*n-1+(fDphi == 360))",MatchSource.WIKI,root/html530/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPcon.html
https://root.cern/root/html530/TGeoPcon.html:1130,Testability,test,testNo,1130," TGeoPcon(); TGeoPcon(Double_t* params); TGeoPcon(Double_t phi, Double_t dphi, Int_t nz); TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); virtual~TGeoPcon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int",MatchSource.WIKI,root/html530/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPcon.html
https://root.cern/root/html530/TGeoPcon.html:13027,Testability,test,test,13027," TStringTNamed::fTitleobject title; Double_t*fZ[fNz] pointer to array of Z planes positions . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPcon(); dummy ctor. TGeoPcon(Double_t phi, Double_t dphi, Int_t nz); Default constructor. TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); Default constructor. TGeoPcon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nz. param[3] = z1; param[4] = Rmin1; param[5] = Rmax1. TGeoPcon(const TGeoPcon& ); copy constructor. TGeoPcon& operator=(const TGeoPcon& ); assignment operator. ~TGeoPcon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS",MatchSource.WIKI,root/html530/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPcon.html
https://root.cern/root/html530/TGeoPconEditor.html:4606,Availability,error,error,4606,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoPconEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPconEditor.html
https://root.cern/root/html530/TGeoPconEditor.html:4690,Availability,error,error,4690,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoPconEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPconEditor.html
https://root.cern/root/html530/TGeoPconEditor.html:18091,Availability,mask,mask,18091,,MatchSource.WIKI,root/html530/TGeoPconEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPconEditor.html
https://root.cern/root/html530/TGeoPconEditor.html:22073,Usability,undo,undoing,22073,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPconEditor.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoPconEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPconEditor.html
https://root.cern/root/html530/TGeoPconSection.html:4290,Availability,error,error,4290,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tT",MatchSource.WIKI,root/html530/TGeoPconSection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPconSection.html
https://root.cern/root/html530/TGeoPconSection.html:4374,Availability,error,error,4374,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_",MatchSource.WIKI,root/html530/TGeoPconSection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPconSection.html
https://root.cern/root/html530/TGeoPconSection.html:17367,Availability,mask,mask,17367,,MatchSource.WIKI,root/html530/TGeoPconSection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPconSection.html
https://root.cern/root/html530/TGeoPgon.html:3224,Availability,error,error,3224,"_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoPcon::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoPcon::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tTGeoPcon::GetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::",MatchSource.WIKI,root/html530/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgon.html
https://root.cern/root/html530/TGeoPgon.html:3308,Availability,error,error,3308,"* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoPcon::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoPcon::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tTGeoPcon::GetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeo",MatchSource.WIKI,root/html530/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgon.html
https://root.cern/root/html530/TGeoPgon.html:17065,Performance,perform,performed,17065,"pmax. Bool_t IsCrossingSlice(Double_t* point, Double_t* dir, Int_t iphi, Double_t sstart, Int_t& ipl, Double_t& snext, Double_t stepmax) const; Check crossing of a given pgon slice, from a starting point inside the slice. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the polygone. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polygone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Phi divisions are; allowed only if nedges%ndiv=0 and create polygone ""segments"" with nedges/ndiv edges.; Z divisions can be performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to volume that was divided. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; Inspect the PGON parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Rpg(Double_t z, Int_t ipl, Bool_t inner, Double_t& a, Double_t& b) const; Computes projected pgon radius (inner or outer) corresponding to a given Z; value. Fills corresponding coefficients of:; Rpg(z) = a + b*z; Note: ipl must be in range [0,fNz-2]. Double_t Rproj(Double_t z, Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& a, Double_t& b) const; Computes projected distance at a given Z fo",MatchSource.WIKI,root/html530/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgon.html
https://root.cern/root/html530/TGeoPgon.html:2172,Safety,safe,safe,2172,"l Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execut",MatchSource.WIKI,root/html530/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgon.html
https://root.cern/root/html530/TGeoPgon.html:2313,Safety,safe,safe,2313,"rtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = ",MatchSource.WIKI,root/html530/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgon.html
https://root.cern/root/html530/TGeoPgon.html:14698,Safety,safe,safe,14698,"nce; Inherited Members; Includes; Libraries. Function documentation; TGeoPgon(); dummy ctor. TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nedges; param[3] = nz. param[4] = z1; param[5] = Rmin1; param[6] = Rmax1. ~TGeoPgon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(Double_t* point, Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingIn(Double_t* point, Double_t* dir, Int_t ipl, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. R",MatchSource.WIKI,root/html530/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgon.html
https://root.cern/root/html530/TGeoPgon.html:16428,Safety,safe,safe,16428,"Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingIn(Double_t* point, Double_t* dir, Int_t ipl, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. Return distance snext to first crossing; if smaller than stepmax.; Protection in case point is in phi gap or close to phi boundaries and exiting. Bool_t SliceCrossing(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. Return distance snext to first crossing; if smaller than stepmax. Bool_t IsCrossingSlice(Double_t* point, Double_t* dir, Int_t iphi, Double_t sstart, Int_t& ipl, Double_t& snext, Double_t stepmax) const; Check crossing of a given pgon slice, from a starting point inside the slice. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the polygone. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polygone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Phi divisions are; allowed only if nedges%ndiv=0 and create polygone ""segments"" with nedges/ndiv edges.; Z divisions can be performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to volume that was divided. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape(",MatchSource.WIKI,root/html530/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgon.html
https://root.cern/root/html530/TGeoPgon.html:18313,Safety,safe,safety,18313,"- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; Inspect the PGON parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Rpg(Double_t z, Int_t ipl, Bool_t inner, Double_t& a, Double_t& b) const; Computes projected pgon radius (inner or outer) corresponding to a given Z; value. Fills corresponding coefficients of:; Rpg(z) = a + b*z; Note: ipl must be in range [0,fNz-2]. Double_t Rproj(Double_t z, Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& a, Double_t& b) const; Computes projected distance at a given Z for a given ray inside a given sector; and fills coefficients:; Rproj = a + b*z. Double_t SafetyToSegment(Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set PGON dimensions starting from an array. void SetPoints(Double_t* points) const; create polygone mesh points. void SetPoints(Float_t* points) const; create polygone mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painte",MatchSource.WIKI,root/html530/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgon.html
https://root.cern/root/html530/TGeoPgon.html:1234,Testability,test,testNo,1234," TGeoPgon(); TGeoPgon(Double_t* params); TGeoPgon(const TGeoPgon&); TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); virtual~TGeoPgon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtua",MatchSource.WIKI,root/html530/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgon.html
https://root.cern/root/html530/TGeoPgon.html:14525,Testability,test,test,14525,"sshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title; Double_t*TGeoPcon::fZ[fNz] pointer to array of Z planes positions . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPgon(); dummy ctor. TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nedges; param[3] = nz. param[4] = z1; param[5] = Rmin1; param[6] = Rmax1. ~TGeoPgon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(Double_t* point, Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingI",MatchSource.WIKI,root/html530/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgon.html
https://root.cern/root/html530/TGeoPgonEditor.html:4704,Availability,error,error,4704,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoPgonEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgonEditor.html
https://root.cern/root/html530/TGeoPgonEditor.html:4788,Availability,error,error,4788,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoPgonEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgonEditor.html
https://root.cern/root/html530/TGeoPgonEditor.html:18463,Availability,mask,mask,18463,,MatchSource.WIKI,root/html530/TGeoPgonEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgonEditor.html
https://root.cern/root/html530/TGeoPgonEditor.html:22139,Usability,undo,undoing,22139,"Manager*TGeoGedFrame::fTabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoPconEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; Double_t*TGeoPconEditor::fZiInitial Z positions; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPgonEditor(); Destructor. void SetModel(TObject* obj); Connect to a given pcon. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); Create number entry for Nedges. void DoNedges(); Change number of edges. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPgonEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoPgonEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPgonEditor.html
https://root.cern/root/html530/TGeoPhysicalNode.html:3148,Availability,error,error,3148,,MatchSource.WIKI,root/html530/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPhysicalNode.html
https://root.cern/root/html530/TGeoPhysicalNode.html:3232,Availability,error,error,3232,"al voidTObject::Browse(TBrowser* b); voidcd() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLevel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TGeoHMatrix*GetMatrix(Int_t level = -1) const; TGeoNode*GetMother(Int_t levup = 1) const; virtual const char*TNamed::GetName() const; TGeoNode*GetNode(Int_t level = -1) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoHMatrix*GetOriginalMatrix() const; TGeoShape*GetShap",MatchSource.WIKI,root/html530/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPhysicalNode.html
https://root.cern/root/html530/TGeoPhysicalNode.html:9479,Performance,perform,perform,9479,"Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArray*fMatricesglobal transformation matrices; TGeoHMatrix*fMatrixOrigoriginal local matrix of the last node in the path; TStringTNamed::fNameobject identifier; TObjArray*fNodesbranch of nodes; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPhysicalNode(); Default constructor. TGeoPhysicalNode(const char* path); Constructor. TGeoPhysicalNode(const TGeoPhysicalNode& ); copy constructor. TGeoPhysicalNode& operator=(const TGeoPhysicalNode& ); assignment operator. ~TGeoPhysicalNode(); Destructor. void Align(TGeoMatrix* newmat = 0, TGeoShape* newshape = 0, Bool_t check = kFALSE, Double_t ovlp = 0.001); Align a physical node with a new relative matrix/shape.; Example: /TOP_1/A_1/B_1/C_1; node->Align(transl_1, box) will perform:; - change RELATIVE translation of C_1 node (with respect to its; container volume B) to transl_1; - change the shape of the C volume; *NOTE* The operations will affect ONLY the LAST node in the branch. All; volumes/nodes in the branch represented by this physical node are; CLONED so the operation does not affect other possible replicas. void cd() const. void Draw(Option_t* option = """"); Draw this node. TGeoNode * GetMother(Int_t levup = 1) const; Return parent at LEVUP generation. TGeoHMatrix * GetMatrix(Int_t level = -1) const; Return global matrix for node at LEVEL. TGeoNode * GetNode(Int_t level = -1) const; Return node in branch at LEVEL. If not specified, return last leaf. TGeoVolume * GetVolume(Int_t level = -1) const; Return volume associated with node at LEVEL in the branch. TGeoShape * GetShape(Int_t level = -1) const; Return shape associated with volume. void Paint(Option_t* option = """"); Paint this node and its content according to visualization settings. void Print(Option_t* option = """") const; Print info about this node. void Refresh();",MatchSource.WIKI,root/html530/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPhysicalNode.html
https://root.cern/root/html530/TGeoPhysicalNode.html:683,Safety,detect,detector,683,". TGeoPhysicalNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPhysicalNode. class TGeoPhysicalNode: public TNamed, public TAttLine. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. TGeoPhysicalNode(); TGeoPhysicalNode(const char* path); virtual~TGeoPhy",MatchSource.WIKI,root/html530/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPhysicalNode.html
https://root.cern/root/html530/TGeoPNEntry.html:2906,Availability,error,error,2906,"(); TGeoPNEntry(const char* unique_name, const char* path); virtual~TGeoPNEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoHMatrix*GetGlobalOrig() const; virtual const char*TObject::GetIconName() const; const TGeoHMatrix*GetMatrix() const; TGeoHMatrix*GetMatrixOrig() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetPath() const; TGeoPhysicalNode*GetPhysicalNode() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; vi",MatchSource.WIKI,root/html530/TGeoPNEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPNEntry.html
https://root.cern/root/html530/TGeoPNEntry.html:2990,Availability,error,error,2990,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoHMatrix*GetGlobalOrig() const; virtual const char*TObject::GetIconName() const; const TGeoHMatrix*GetMatrix() const; TGeoHMatrix*GetMatrixOrig() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetPath() const; TGeoPhysicalNode*GetPhysicalNode() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const",MatchSource.WIKI,root/html530/TGeoPNEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPNEntry.html
https://root.cern/root/html530/TGeoPNEntry.html:651,Safety,detect,detector,651,". TGeoPNEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPNEntry. class TGeoPNEntry: public TNamed. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. TGeoPNEntry(); TGeoPNEntry(const char* unique_name, const char* path); virtual~TGeoPNEntry(); voidTObje",MatchSource.WIKI,root/html530/TGeoPNEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPNEntry.html
https://root.cern/root/html530/TGeoPolygon.html:2814,Availability,error,error,2814," virtual~TGeoPolygon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tArea() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFinishPolygon(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNvert() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_t*GetX(); Double_t*GetY(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char*",MatchSource.WIKI,root/html530/TGeoPolygon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPolygon.html
https://root.cern/root/html530/TGeoPolygon.html:2898,Availability,error,error,2898,"al voidTObject::AppendPad(Option_t* option = """"); Double_tArea() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFinishPolygon(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNvert() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_t*GetX(); Double_t*GetY(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; vi",MatchSource.WIKI,root/html530/TGeoPolygon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoPolygon.html
https://root.cern/root/html530/TGeoRotation.html:6228,Availability,error,error,6228,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Doubl",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:8330,Availability,error,error,8330,"hi2, Double_t theta3, Double_t phi3); virtual~TGeoRotation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidFastRotZ(Double_t* sincos); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; voidGetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; voidGetInverse(Double_t* invmat) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, ",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:8414,Availability,error,error,8414,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidFastRotZ(Double_t* sincos); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; voidGetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; voidGetInverse(Double_t* invmat) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::Ge",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:3100,Integrability,interface,interface,3100," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:6234,Integrability,message,message,6234,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Doubl",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:6979,Modifiability,variab,variable,6979,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Double_t psi); TGeoRotation(const char* name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); virtual~TGeoRotation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject:",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:484,Performance,optimiz,optimize,484,". TGeoRotation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRotation. class TGeoRotation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:493,Performance,perform,performance,493,". TGeoRotation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRotation. class TGeoRotation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:978,Performance,perform,performed,978,". TGeoRotation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRotation. class TGeoRotation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:1704,Performance,perform,performed,1704,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:6211,Performance,perform,performed,6211,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Doubl",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:18740,Performance,perform,performes,18740,"ply by a reflection respect to ZX. void ReflectZ(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to XY. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoMatrix& other); Copy rotation elements from other rotation matrix. void SetAngles(Double_t phi, Double_t theta, Double_t psi); Set matrix elements according to Euler angles. void SetAngles(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Set matrix elements in the GEANT3 way. void GetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; Retreive rotation angles. void GetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; Retreive Euler angles. Double_t Determinant() const; computes determinant of the rotation matrix. void CheckMatrix(); performes an orthogonality check and finds if the matrix is a reflection; Warning(""CheckMatrix"", ""orthogonality check not performed yet"");. void GetInverse(Double_t* invmat) const; Get the inverse rotation matrix (which is simply the transpose). void MultiplyBy(TGeoRotation* rot, Bool_t after = kTRUE); Multiply this rotation with the one specified by ROT.; - after=TRUE (default): THIS*ROT; - after=FALSE : ROT*THIS. TGeoMatrix& operator=(const TGeoMatrix& matrix); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void LocalToMasterBomb(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void MasterToLocalBomb(const Double_t* master, Double_t* local) const. TGeoTranslation& operator=(const TGeoMatrix& matrix). virtual ~TGeoRotation(); {}. void",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:18862,Performance,perform,performed,18862,"ply by a reflection respect to ZX. void ReflectZ(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to XY. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoMatrix& other); Copy rotation elements from other rotation matrix. void SetAngles(Double_t phi, Double_t theta, Double_t psi); Set matrix elements according to Euler angles. void SetAngles(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Set matrix elements in the GEANT3 way. void GetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; Retreive rotation angles. void GetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; Retreive Euler angles. Double_t Determinant() const; computes determinant of the rotation matrix. void CheckMatrix(); performes an orthogonality check and finds if the matrix is a reflection; Warning(""CheckMatrix"", ""orthogonality check not performed yet"");. void GetInverse(Double_t* invmat) const; Get the inverse rotation matrix (which is simply the transpose). void MultiplyBy(TGeoRotation* rot, Bool_t after = kTRUE); Multiply this rotation with the one specified by ROT.; - after=TRUE (default): THIS*ROT; - after=FALSE : ROT*THIS. TGeoMatrix& operator=(const TGeoMatrix& matrix); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void LocalToMasterBomb(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void MasterToLocalBomb(const Double_t* master, Double_t* local) const. TGeoTranslation& operator=(const TGeoMatrix& matrix). virtual ~TGeoRotation(); {}. void",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:16396,Testability,test,test,16396,"& other); Copy ctor. TGeoRotation(const TGeoMatrix& other); Copy ctor. TGeoRotation(const char* name); Named rotation constructor. TGeoRotation(const char* name, Double_t phi, Double_t theta, Double_t psi); Default rotation constructor with Euler angles. Phi is the rotation angle about; Z axis and is done first, theta is the rotation about new Y and is done; second, psi is the rotation angle about new Z and is done third. All angles are in; degrees. TGeoRotation(const char* name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Rotation constructor a la GEANT3. Angles theta(i), phi(i) are the polar and azimuthal; angles of the (i) axis of the rotated system with respect to the initial non-rotated; system.; Example : the identity matrix (no rotation) is composed by; theta1=90, phi1=0, theta2=90, phi2=90, theta3=0, phi3=0; SetBit(kGeoRotation);. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t IsValid() const; Perform orthogonality test for rotation. void Clear(Option_t* option = """"); reset data members. void FastRotZ(Double_t* sincos); Perform a rotation about Z having the sine/cosine of the rotation angle. Double_t GetPhiRotation(Bool_t fixX = kFALSE) const; --- Returns rotation angle about Z axis in degrees. If the rotation is a pure; rotation about Z, fixX parameter does not matter, otherwise its meaning is:; - fixX = true : result is the phi angle of the projection of the rotated X axis in the un-rotated XY; - fixX = false : result is the phi angle of the projection of the rotated Y axis - 90 degrees. void LocalToMaster(const Double_t* local, Double_t* master) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse. void MasterToLocal(const Double_t* master, Double_t* local) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void RotateX(Double_t angle); Rotate about X axis o",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:1717,Usability,simpl,simple,1717,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotation.html:18963,Usability,simpl,simply,18963,"oid SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoMatrix& other); Copy rotation elements from other rotation matrix. void SetAngles(Double_t phi, Double_t theta, Double_t psi); Set matrix elements according to Euler angles. void SetAngles(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Set matrix elements in the GEANT3 way. void GetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; Retreive rotation angles. void GetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; Retreive Euler angles. Double_t Determinant() const; computes determinant of the rotation matrix. void CheckMatrix(); performes an orthogonality check and finds if the matrix is a reflection; Warning(""CheckMatrix"", ""orthogonality check not performed yet"");. void GetInverse(Double_t* invmat) const; Get the inverse rotation matrix (which is simply the transpose). void MultiplyBy(TGeoRotation* rot, Bool_t after = kTRUE); Multiply this rotation with the one specified by ROT.; - after=TRUE (default): THIS*ROT; - after=FALSE : ROT*THIS. TGeoMatrix& operator=(const TGeoMatrix& matrix); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void LocalToMasterBomb(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void MasterToLocalBomb(const Double_t* master, Double_t* local) const. TGeoTranslation& operator=(const TGeoMatrix& matrix). virtual ~TGeoRotation(); {}. void SetMatrix(const Double_t* rot); {memcpy(&fRotationMatrix[0], rot, 9*sizeof(Double_t));CheckMatrix();}. » Author: Andrei Gheata 25/10",MatchSource.WIKI,root/html530/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotation.html
https://root.cern/root/html530/TGeoRotationEditor.html:4676,Availability,error,error,4676,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotationEditor.html
https://root.cern/root/html530/TGeoRotationEditor.html:4760,Availability,error,error,4760,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotationEditor.html
https://root.cern/root/html530/TGeoRotationEditor.html:17819,Availability,mask,mask,17819,,MatchSource.WIKI,root/html530/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotationEditor.html
https://root.cern/root/html530/TGeoRotationEditor.html:22008,Usability,undo,undoing,22008,"const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for rotation editor. ~TGeoRotationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected rotation. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoRotationEditor.html
https://root.cern/root/html530/TGeoScale.html:6219,Availability,error,error,6219,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTOb",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:8131,Availability,error,error,8131,"ale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::Get",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:8215,Availability,error,error,8215,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslation() const; virtual UInt_tTObject:",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:3091,Integrability,interface,interface,3091," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:6225,Integrability,message,message,6225,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTOb",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:6970,Modifiability,variab,variable,6970,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option =",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:475,Performance,optimiz,optimize,475,". TGeoScale. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoScale. class TGeoScale: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sc",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:484,Performance,perform,performance,484,". TGeoScale. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoScale. class TGeoScale: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sc",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:969,Performance,perform,performed,969,". TGeoScale. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoScale. class TGeoScale: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sc",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:1695,Performance,perform,performed,1695,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:6202,Performance,perform,performed,6202,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTOb",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:15222,Performance,perform,perform,15222,"; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScale(); default constructor. TGeoScale(const TGeoScale& other); Copy constructor. TGeoScale(Double_t sx, Double_t sy, Double_t sz); default constructor. TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); default constructor. ~TGeoScale(); destructor. TGeoMatrix& Inverse() const; Return a temporary inverse of this. void SetScale(Double_t sx, Double_t sy, Double_t sz); scale setter. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert a local point to the master frame. Double_t LocalToMaster(Double_t dist, const Double_t* dir = 0) const; Convert the local distance along unit vector DIR to master frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert a global point to local frame. Double_t MasterToLocal(Double_t dist, const Double_t* dir = 0) const; Convert the distance along unit vector DIR to local frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix& operator=(const TGeoScale& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void ReflectX(Bool_t , Bool_t ). void ReflectY(Bool_t , Bool_t ). void ReflectZ(Bool_t , Bool_t ). » Author: And",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:15643,Performance,perform,perform,15643,"er); Copy constructor. TGeoScale(Double_t sx, Double_t sy, Double_t sz); default constructor. TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); default constructor. ~TGeoScale(); destructor. TGeoMatrix& Inverse() const; Return a temporary inverse of this. void SetScale(Double_t sx, Double_t sy, Double_t sz); scale setter. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert a local point to the master frame. Double_t LocalToMaster(Double_t dist, const Double_t* dir = 0) const; Convert the local distance along unit vector DIR to master frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert a global point to local frame. Double_t MasterToLocal(Double_t dist, const Double_t* dir = 0) const; Convert the distance along unit vector DIR to local frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix& operator=(const TGeoScale& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void ReflectX(Bool_t , Bool_t ). void ReflectY(Bool_t , Bool_t ). void ReflectZ(Bool_t , Bool_t ). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoMatrix.h 34744 2010-08-07 06:16:36Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScale.html:1708,Usability,simpl,simple,1708,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScale.html
https://root.cern/root/html530/TGeoScaledShape.html:2705,Availability,error,error,2705,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(In",MatchSource.WIKI,root/html530/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScaledShape.html
https://root.cern/root/html530/TGeoScaledShape.html:2789,Availability,error,error,2789,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox,",MatchSource.WIKI,root/html530/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScaledShape.html
https://root.cern/root/html530/TGeoScaledShape.html:1856,Safety,safe,safe,1856,"x* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html530/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScaledShape.html
https://root.cern/root/html530/TGeoScaledShape.html:1997,Safety,safe,safe,1997,"ape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html530/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScaledShape.html
https://root.cern/root/html530/TGeoScaledShape.html:12225,Safety,safe,safe,12225,"r to an existing shape; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsReflected() const; Check if the scale transformat",MatchSource.WIKI,root/html530/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScaledShape.html
https://root.cern/root/html530/TGeoScaledShape.html:12426,Safety,safe,safe,12426,"nction documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. TGeoShape * MakeScaledShape(const char* name, TGeoShape* s",MatchSource.WIKI,root/html530/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScaledShape.html
https://root.cern/root/html530/TGeoScaledShape.html:1009,Testability,test,testNo,1009," TGeoScaledShape(); TGeoScaledShape(const TGeoScaledShape&); TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); virtual~TGeoScaledShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe",MatchSource.WIKI,root/html530/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoScaledShape.html
https://root.cern/root/html530/TGeoShape.html:6651,Availability,avail,available,6651,"outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is that that divisions are possible on whatever axis that; produces still known shapes as slices. The division of shapes should not be; performed by TGeoShape::Divide() calls, but rather by TGeoVolume::Divide().; The algorithm for dividing a specific shape is known by the shape object, but; is always invoked in a generic way from the volume level. Details on how to; do that can be found in TGeoVolume class. One can see how all division options; are interpreted and which is their result inside specific shape classes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtua",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:8577,Availability,error,error,8577,"U ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; virtual const char*TObject::GetIconName() const; Int_tGetId() const; virtual TGeoShape*GetMakeRu",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:8661,Availability,error,error,8661,"side(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; virtual const char*TObject::GetIconName() const; Int_tGetId() const; virtual TGeoShape*GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; virtual voidGetMeshNumbers(Int",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:15826,Availability,error,error,15826,"(); voidSetOnBoundary(Bool_t); voidTransformPoints(Double_t* points, UInt_t NbPoints) const. Data Members; public:. enum EShapeType { kBitMask32; kGeoNoShape; kGeoBad; kGeoRSeg; kGeoPhiSeg; kGeoThetaSeg; kGeoVisX; kGeoVisY; kGeoVisZ; kGeoRunTimeShape; kGeoInvalidShape; kGeoTorus; kGeoBox; kGeoPara; kGeoSph; kGeoTube; kGeoTubeSeg; kGeoCone; kGeoConeSeg; kGeoPcon; kGeoPgon; kGeoArb8; kGeoEltu; kGeoTrap; kGeoCtub; kGeoTrd1; kGeoTrd2; kGeoComb; kGeoClosedShape; kGeoXtru; kGeoParaboloid; kGeoHalfSpace; kGeoHype; kGeoSavePrimitive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, Double_t* point, Double_t ",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:16472,Availability,error,error,16472,"enced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& snext, Double_t& rxy); Compute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWit",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:16613,Availability,error,error,16613,"ie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& snext, Double_t& rxy); Compute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWithinTolerance(Double_t a, Double_t b); Check if two numbers differ with less than a tolerance. Bool_t IsSegCrossing(Doubl",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:17545,Availability,toler,tolerance,17545," that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& snext, Double_t& rxy); Compute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWithinTolerance(Double_t a, Double_t b); Check if two numbers differ with less than a tolerance. Bool_t IsSegCrossing(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4); Check if segments (A,B) and (C,D) are crossing,; where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4). Double_t DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); compute distance from point (inside phi) to both phi planes. Return minimum. void NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applie",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:6123,Performance,perform,performed,6123,"uble_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is that that divisions are possible on whatever axis that; produces still known shapes as slices. The division of shapes should not be; performed by TGeoShape::Divide() calls, but rather by TGeoVolume::Divide().; The algorithm for dividing a specific shape is known by the shape object, but; is always invoked in a generic way from the volume level. Details on how to; do that can be found in TGeoVolume class. One can see how all division options; are interpreted and which is their result inside specific shape classes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:941,Safety,safe,safe,941,". TGeoShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoShape. class TGeoShape: public TNamed. TGeoShape - Base abstract class for all shapes. Shapes are geometrical objects that provide the basic modelling; functionality. They provide the definition of the LOCAL frame of coordinates,; with respect to which they are defined. Any implementation of a shape deriving; from the base TGeoShape class has to provide methods for :; - finding out if a point defined in their local frame is or not contained; inside;; - computing the distance from a local point to getting outside/entering the; shape, given a known direction;; - computing the maximum distance in any direction from a local point that; does NOT result in a boundary crossing of the shape (safe distance);; - computing the cosines of the normal vector to the crossed shape surface,; given a starting local point and an ongoing direction.; All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, shapes have also to; implement additional specific abstract methods :; - computation of the minimal box bounding the shape, given that this box have; to be aligned with the local coordinates;; - algorithms for dividing the shape along a given axis and producing resulting; divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call; primitives. It also provides a special class allowing the creation of shapes; made as a result of boolean operations between primitives. These are called; composite shapes and the composition operation can be recursive (composition; of composites). This allows the creation of a quite large number of different; shape topologies and combinations. Shapes are named objects and register themselves to the manager cl",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:4062,Safety,safe,safe,4062,"s). Sometimes it is much easier to create a volume having a given shape in one; step, since shapes are not direcly linked in the geometrical tree but volumes; are :. TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"", ""mat1"", halfX, halfY, halfZ);; TGeoVolume *vol_tub = gGeoManager->MakeTube(""TUB_VOL"", ""mat2"", rmin, rmax, halfZ);; ... (see MakeXXX() utilities in TGeoManager class). Shape queries. Note that global queries related to a geometry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:4381,Safety,safe,safe,4381,"in, rmax, halfZ);; ... (see MakeXXX() utilities in TGeoManager class). Shape queries. Note that global queries related to a geometry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Doubl",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:4484,Safety,safe,safe,4484,"metry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape sur",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:4754,Safety,safe,safe,4754,"For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retr",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:5012,Safety,safe,safe,5012,"t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is tha",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:7761,Safety,safe,safe,7761,"rtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:7902,Safety,safe,safe,7902,"() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:18273,Safety,safe,safety,18273,"snext, Double_t& rxy); Compute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWithinTolerance(Double_t a, Double_t b); Check if two numbers differ with less than a tolerance. Bool_t IsSegCrossing(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4); Check if segments (A,B) and (C,D) are crossing,; where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4). Double_t DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); compute distance from point (inside phi) to both phi planes. Return minimum. void NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, In",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:19063,Safety,avoid,avoid,19063,"nt, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:19871,Safety,safe,safe,19871," with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit(kGeoRunT",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:2325,Security,access,accessible,2325,"; - computation of the minimal box bounding the shape, given that this box have; to be aligned with the local coordinates;; - algorithms for dividing the shape along a given axis and producing resulting; divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call; primitives. It also provides a special class allowing the creation of shapes; made as a result of boolean operations between primitives. These are called; composite shapes and the composition operation can be recursive (composition; of composites). This allows the creation of a quite large number of different; shape topologies and combinations. Shapes are named objects and register themselves to the manager class at; creation time. This is responsible for their final deletion. Shapes; can be created without name if their retreival by name is no needed. Generally; shapes are objects that are usefull only at geometry creation stage. The pointer; to a shape is in fact needed only when referring to a given volume and it is; always accessible at that level. A shape may be referenced by several volumes,; therefore its deletion is not possible once volumes were defined based on it. Creating shapes. Shape objects embeed only the minimum set of parameters that are fully; describing a valid physical shape. For instance, a tube is represented by; its half length, the minimum radius and the maximum radius. Shapes are used; togeather with media in order to create volumes, which in their turn; are the main components of the geometrical tree. A specific shape can be created; stand-alone :. TGeoBBox *box = new TGeoBBox(""s_box"", halfX, halfY, halfZ); // named; TGeoTube *tub = new TGeoTube(rmin, rmax, halfZ); // no name; ... (see each specific shape constructors). Sometimes it is much easier to create a volume having a given shape in one; step, since shapes are not direcly linked in the geometrical tree but volumes; are :. TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"", ""mat1"", halfX",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:6935,Testability,test,testNo,6935,,MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:16054,Testability,test,testNo,16054,"RunTimeShape; kGeoInvalidShape; kGeoTorus; kGeoBox; kGeoPara; kGeoSph; kGeoTube; kGeoTubeSeg; kGeoCone; kGeoConeSeg; kGeoPcon; kGeoPgon; kGeoArb8; kGeoEltu; kGeoTrap; kGeoCtub; kGeoTrd1; kGeoTrd2; kGeoComb; kGeoClosedShape; kGeoXtru; kGeoParaboloid; kGeoHalfSpace; kGeoHype; kGeoSavePrimitive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in ",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShape.html:16157,Testability,test,test,16157,"oTubeSeg; kGeoCone; kGeoConeSeg; kGeoPcon; kGeoPgon; kGeoArb8; kGeoEltu; kGeoTrap; kGeoCtub; kGeoTrd1; kGeoTrd2; kGeoComb; kGeoClosedShape; kGeoXtru; kGeoParaboloid; kGeoHalfSpace; kGeoHype; kGeoSavePrimitive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(Double_t* point, D",MatchSource.WIKI,root/html530/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShape.html
https://root.cern/root/html530/TGeoShapeAssembly.html:2653,Availability,error,error,2653,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFa",MatchSource.WIKI,root/html530/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShapeAssembly.html
https://root.cern/root/html530/TGeoShapeAssembly.html:2737,Availability,error,error,2737,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox*",MatchSource.WIKI,root/html530/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShapeAssembly.html
https://root.cern/root/html530/TGeoShapeAssembly.html:1804,Safety,safe,safe,1804,"static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html530/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShapeAssembly.html
https://root.cern/root/html530/TGeoShapeAssembly.html:1945,Safety,safe,safe,1945,"ape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html530/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShapeAssembly.html
https://root.cern/root/html530/TGeoShapeAssembly.html:12127,Safety,safe,safe,12127," origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title; TGeoVolumeAssembly*fVolumeassembly volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoShapeAssembly(); Default constructor. TGeoShapeAssembly(TGeoVolumeAssembly* vol); Constructor specifying hyperboloid parameters. ~TGeoShapeAssembly(); destructor. void ComputeBBox(); Compute bounding box of the assembly. void RecomputeBoxLast(); Recompute bounding box of the assembly after adding a node. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Should not be called. Bool_t Contains(Double_t* point) const; Test if point is inside the assembly. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void S",MatchSource.WIKI,root/html530/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShapeAssembly.html
https://root.cern/root/html530/TGeoShapeAssembly.html:12327,Safety,safe,safe,12327,"bers; Includes; Libraries. Function documentation; TGeoShapeAssembly(); Default constructor. TGeoShapeAssembly(TGeoVolumeAssembly* vol); Constructor specifying hyperboloid parameters. ~TGeoShapeAssembly(); destructor. void ComputeBBox(); Compute bounding box of the assembly. void RecomputeBoxLast(); Recompute bounding box of the assembly after adding a node. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Should not be called. Bool_t Contains(Double_t* point) const; Test if point is inside the assembly. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; No mesh for assemblies. void SetPoints(Float_t",MatchSource.WIKI,root/html530/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShapeAssembly.html
https://root.cern/root/html530/TGeoShapeAssembly.html:957,Testability,test,testNo,957," TGeoShapeAssembly(); TGeoShapeAssembly(TGeoVolumeAssembly* vol); TGeoShapeAssembly(const TGeoShapeAssembly&); virtual~TGeoShapeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(",MatchSource.WIKI,root/html530/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShapeAssembly.html
https://root.cern/root/html530/TGeoShapeDialog.html:5127,Availability,error,error,5127,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGeoShapeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShapeDialog.html
https://root.cern/root/html530/TGeoShapeDialog.html:5211,Availability,error,error,5211,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGeoShapeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShapeDialog.html
https://root.cern/root/html530/TGeoShapeDialog.html:19791,Availability,mask,mask,19791,,MatchSource.WIKI,root/html530/TGeoShapeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoShapeDialog.html
https://root.cern/root/html530/TGeoSphere.html:3160,Availability,error,error,3160,"Shape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoB",MatchSource.WIKI,root/html530/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphere.html
https://root.cern/root/html530/TGeoSphere.html:3244,Availability,error,error,3244,"oint, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t",MatchSource.WIKI,root/html530/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphere.html
https://root.cern/root/html530/TGeoSphere.html:13328,Availability,toler,tolerance,13328,"Members; Includes; Libraries. Function documentation; TGeoSphere(); Default constructor. TGeoSphere(Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); Default constructor specifying minimum and maximum radius. TGeoSphere(const char* name, Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); Default constructor specifying minimum and maximum radius. TGeoSphere(Double_t* param, Int_t nparam = 6); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax. ~TGeoSphere(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the sphere; Double_t xmin, xmax, ymin, ymax, zmin, zmax;. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape:",MatchSource.WIKI,root/html530/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphere.html
https://root.cern/root/html530/TGeoSphere.html:2187,Safety,safe,safe,2187,"x* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObjec",MatchSource.WIKI,root/html530/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphere.html
https://root.cern/root/html530/TGeoSphere.html:2328,Safety,safe,safe,2328,"ape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtu",MatchSource.WIKI,root/html530/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphere.html
https://root.cern/root/html530/TGeoSphere.html:14025,Safety,safe,safe,14025,"re; Double_t xmin, xmax, ymin, ymax, zmin, zmax;. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order;",MatchSource.WIKI,root/html530/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphere.html
https://root.cern/root/html530/TGeoSphere.html:14288,Safety,safe,safe,14288,"cal sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegs",MatchSource.WIKI,root/html530/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphere.html
https://root.cern/root/html530/TGeoSphere.html:1340,Testability,test,testNo,1340," TGeoSphere(); TGeoSphere(const TGeoSphere&); TGeoSphere(Double_t* param, Int_t nparam = 6); TGeoSphere(Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); TGeoSphere(const char* name, Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); virtual~TGeoSphere(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """,MatchSource.WIKI,root/html530/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphere.html
https://root.cern/root/html530/TGeoSphere.html:13745,Testability,test,test,13745,"here(Double_t* param, Int_t nparam = 6); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax. ~TGeoSphere(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the sphere; Double_t xmin, xmax, ymin, ymax, zmin, zmax;. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. const char * GetAxi",MatchSource.WIKI,root/html530/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphere.html
https://root.cern/root/html530/TGeoSphereEditor.html:4679,Availability,error,error,4679,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphereEditor.html
https://root.cern/root/html530/TGeoSphereEditor.html:4763,Availability,error,error,4763,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphereEditor.html
https://root.cern/root/html530/TGeoSphereEditor.html:18002,Availability,mask,mask,18002,,MatchSource.WIKI,root/html530/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphereEditor.html
https://root.cern/root/html530/TGeoSphereEditor.html:21690,Usability,undo,undoing,21690,"ame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoSphereEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for sphere editor. ~TGeoSphereEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given sphere. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoTheta1(); Slot for theta1. void DoTheta2(); Slot for theta2. void DoTheta(); Slot for theta slider. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoSphereEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSphereEditor.html
https://root.cern/root/html530/TGeoSubtraction.html:2879,Availability,error,error,2879,"uble_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitl",MatchSource.WIKI,root/html530/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSubtraction.html
https://root.cern/root/html530/TGeoSubtraction.html:2963,Availability,error,error,2963,"nt, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Handle",MatchSource.WIKI,root/html530/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSubtraction.html
https://root.cern/root/html530/TGeoSubtraction.html:2381,Safety,safe,safe,2381,"TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); virtual~TGeoSubtraction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root/html530/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSubtraction.html
https://root.cern/root/html530/TGeoSubtraction.html:2507,Safety,safe,safe,2507," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::",MatchSource.WIKI,root/html530/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSubtraction.html
https://root.cern/root/html530/TGeoSubtraction.html:8838,Safety,safe,safe,8838,"cludes; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT i",MatchSource.WIKI,root/html530/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSubtraction.html
https://root.cern/root/html530/TGeoSubtraction.html:9023,Safety,safe,safe,9023,"d Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSubtraction.html
https://root.cern/root/html530/TGeoSubtraction.html:9267,Safety,safe,safety,9267,"d Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoSubtraction.html
https://root.cern/root/html530/TGeoTabManager.html:1943,Availability,error,error,1943,"Editor* ged); virtual~TGeoTabManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidCleanup(TGCompositeFrame* frame); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static TGeoTabManager*GetMakeTabManager(TGedEditor* ged); voidGetMaterialEditor(TGeoMaterial* material); voidGetMatrixEditor(TGeoMatrix* matrix); voidGetMediumEditor(TGeoMedium* medium); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVirtualPad*GetPad() const; voidGetShapeEditor(TGeoShape* shape); TGTab*GetTab() const; Int_tGetTabIndex() const; virtual const",MatchSource.WIKI,root/html530/TGeoTabManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTabManager.html
https://root.cern/root/html530/TGeoTabManager.html:2027,Availability,error,error,2027,"od) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidCleanup(TGCompositeFrame* frame); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static TGeoTabManager*GetMakeTabManager(TGedEditor* ged); voidGetMaterialEditor(TGeoMaterial* material); voidGetMatrixEditor(TGeoMatrix* matrix); voidGetMediumEditor(TGeoMedium* medium); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVirtualPad*GetPad() const; voidGetShapeEditor(TGeoShape* shape); TGTab*GetTab() const; Int_tGetTabIndex() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TGeoVol",MatchSource.WIKI,root/html530/TGeoTabManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTabManager.html
https://root.cern/root/html530/TGeoTorus.html:3050,Availability,error,error,3050,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) ",MatchSource.WIKI,root/html530/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTorus.html
https://root.cern/root/html530/TGeoTorus.html:3134,Availability,error,error,3134,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* ma",MatchSource.WIKI,root/html530/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTorus.html
https://root.cern/root/html530/TGeoTorus.html:2201,Safety,safe,safe,2201,"_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Double_tDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html530/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTorus.html
https://root.cern/root/html530/TGeoTorus.html:2342,Safety,safe,safe,2342,"tual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Double_tDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html530/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTorus.html
https://root.cern/root/html530/TGeoTorus.html:13398,Safety,safe,safe,13398,"aram[1] = Rmin; param[2] = Rmax; param[3] = Phi1; param[4] = Dphi. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the torus. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mo",MatchSource.WIKI,root/html530/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTorus.html
https://root.cern/root/html530/TGeoTorus.html:13592,Safety,safe,safe,13592," void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAnd",MatchSource.WIKI,root/html530/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTorus.html
https://root.cern/root/html530/TGeoTorus.html:1165,Testability,test,testNo,1165," TGeoTorus(); TGeoTorus(Double_t* params); TGeoTorus(const TGeoTorus&); TGeoTorus(Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); TGeoTorus(const char* name, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); virtual~TGeoTorus(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Double_tDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option",MatchSource.WIKI,root/html530/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTorus.html
https://root.cern/root/html530/TGeoTorusEditor.html:4608,Availability,error,error,4608,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTorusEditor.html
https://root.cern/root/html530/TGeoTorusEditor.html:4692,Availability,error,error,4692,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTorusEditor.html
https://root.cern/root/html530/TGeoTorusEditor.html:17909,Availability,mask,mask,17909,,MatchSource.WIKI,root/html530/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTorusEditor.html
https://root.cern/root/html530/TGeoTorusEditor.html:21415,Usability,undo,undoing,21415,"osition; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for torus editor. ~TGeoTorusEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoR(); Slot for R. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi. void DoDphi(); Slot for Dphi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTorusEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTorusEditor.html
https://root.cern/root/html530/TGeoTrack.html:2037,Availability,error,error,2037,"Double_t nframes = 200, Option_t* option = ""/*"")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*TVirtualGeoTrack::FindTrackWithId(Int_t id) const; TVirtualGeoTrack*TVirtualGeoTrack::GetDaughter(Int_t index) const; virtual Int_tTVirtualGeoTrack::GetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*TVirtualGeoTrack::GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tTVirtualGeoTrack::GetId() const; const Double_t*TVirtualGeoTrack::GetLastPoint() const; Int_tTVirtualGeoTrack::GetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tT",MatchSource.WIKI,root/html530/TGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrack.html
https://root.cern/root/html530/TGeoTrack.html:2121,Availability,error,error,2121,"d(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*TVirtualGeoTrack::FindTrackWithId(Int_t id) const; TVirtualGeoTrack*TVirtualGeoTrack::GetDaughter(Int_t index) const; virtual Int_tTVirtualGeoTrack::GetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*TVirtualGeoTrack::GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tTVirtualGeoTrack::GetId() const; const Double_t*TVirtualGeoTrack::GetLastPoint() const; Int_tTVirtualGeoTrack::GetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtua",MatchSource.WIKI,root/html530/TGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrack.html
https://root.cern/root/html530/TGeoTransientPanel.html:4885,Availability,error,error,4885,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGeoTransientPanel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTransientPanel.html
https://root.cern/root/html530/TGeoTransientPanel.html:4969,Availability,error,error,4969,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGeoTransientPanel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTransientPanel.html
https://root.cern/root/html530/TGeoTransientPanel.html:19238,Availability,mask,mask,19238,,MatchSource.WIKI,root/html530/TGeoTransientPanel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTransientPanel.html
https://root.cern/root/html530/TGeoTranslation.html:6237,Availability,error,error,6237,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* na",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslation.html:8266,Availability,error,error,8266,"y, Double_t dz); virtual~TGeoTranslation(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TGeoTranslation* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::Get",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslation.html:8350,Availability,error,error,8350,"method) const; voidAdd(const TGeoTranslation* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslation() const; virtual UInt_tTObject:",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslation.html:3109,Integrability,interface,interface,3109," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslation.html:6243,Integrability,message,message,6243,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* na",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslation.html:6988,Modifiability,variab,variable,6988,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* name, Double_t dx, Double_t dy, Double_t dz); virtual~TGeoTranslation(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TGeoTranslation* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Optio",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslation.html:493,Performance,optimiz,optimize,493,". TGeoTranslation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoTranslation. class TGeoTranslation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1.",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslation.html:502,Performance,perform,performance,502,". TGeoTranslation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoTranslation. class TGeoTranslation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1.",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslation.html:987,Performance,perform,performed,987,". TGeoTranslation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoTranslation. class TGeoTranslation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1.",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslation.html:1713,Performance,perform,performed,1713,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslation.html:6220,Performance,perform,performed,6220,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* na",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslation.html:1726,Usability,simpl,simple,1726,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslation.html
https://root.cern/root/html530/TGeoTranslationEditor.html:4723,Availability,error,error,4723,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslationEditor.html
https://root.cern/root/html530/TGeoTranslationEditor.html:4807,Availability,error,error,4807,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslationEditor.html
https://root.cern/root/html530/TGeoTranslationEditor.html:17809,Availability,mask,mask,17809,,MatchSource.WIKI,root/html530/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslationEditor.html
https://root.cern/root/html530/TGeoTranslationEditor.html:21385,Usability,undo,undoing,21385,"e y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTranslationEditor.html
https://root.cern/root/html530/TGeoTrap.html:3952,Availability,error,error,3952,"_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha1() const; Double_tGetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tGetBl1() const; Double_tGetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const;",MatchSource.WIKI,root/html530/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrap.html
https://root.cern/root/html530/TGeoTrap.html:4036,Availability,error,error,4036,"uble_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha1() const; Double_tGetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tGetBl1() const; Double_tGetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtu",MatchSource.WIKI,root/html530/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrap.html
https://root.cern/root/html530/TGeoTrap.html:3012,Safety,safe,safe,3012," b); virtual Double_tTGeoArb8::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjA",MatchSource.WIKI,root/html530/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrap.html
https://root.cern/root/html530/TGeoTrap.html:3153,Safety,safe,safe,3153,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root/html530/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrap.html
https://root.cern/root/html530/TGeoTrap.html:14800,Safety,safe,safe,14800,"le; TStringTNamed::fTitleobject title; Double_tfTl1half length in x at low z and y high edge; Double_tfTl2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles ; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrap(); Default ctor. TGeoTrap(Double_t dz, Double_t theta, Double_t phi); Constructor providing just a range in Z, theta and phi. TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Normal constructor. TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor with name. ~TGeoTrap(); destructor. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trapezoid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trapezoid. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trapezoid shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these have to be computed; in order to fit the mother. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest di",MatchSource.WIKI,root/html530/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrap.html
https://root.cern/root/html530/TGeoTrap.html:14998,Safety,safe,safe,14998," angles ; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrap(); Default ctor. TGeoTrap(Double_t dz, Double_t theta, Double_t phi); Constructor providing just a range in Z, theta and phi. TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Normal constructor. TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor with name. ~TGeoTrap(); destructor. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trapezoid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trapezoid. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trapezoid shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these have to be computed; in order to fit the mother. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Se",MatchSource.WIKI,root/html530/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrap.html
https://root.cern/root/html530/TGeoTrap.html:2095,Testability,test,testNo,2095," TGeoTrap(); TGeoTrap(const TGeoTrap&); TGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); virtual~TGeoTrap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Bro",MatchSource.WIKI,root/html530/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrap.html
https://root.cern/root/html530/TGeoTrapEditor.html:4671,Availability,error,error,4671,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrapEditor.html
https://root.cern/root/html530/TGeoTrapEditor.html:4755,Availability,error,error,4755,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrapEditor.html
https://root.cern/root/html530/TGeoTrapEditor.html:18396,Availability,mask,mask,18396,"nges; Bool_tTGedFrame::fAvoidSignalflag for executing slots; TGCompositeFrame*fBFrameFrame containing Apply/Undo; Pixel_tTGFrame::fBackgroundframe background color; Double_tfBl1iInitial half length in x at low z and y low edge; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*fDelayedCheck button for delayed draw; Double_tfDziInitial Dz; TGNumberEntry*fEAlpha1Number entry for Alpha1; TGNumberEntry*fEBl1Number entry for Bl1; TGNumberEntry*fEDzNumber entry for DZ; TGNumberEntry*fEH1Number entry for H1 ; TGNumberEntry*fEPhiNumber entry for Theta ; TGNumberEntry*fESc1Number entry for lower scale; TGNumberEntry*fESc2Number entry for upper scale; TGNumberEntry*fEThetaNumber entry for Theta ; TGNumberEntry*fETl1Number entry for Tl1; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; Double_tfH1iInitial half length in y at low z; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tfIsModifiedFlag that volume was modified; Bool_tfIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGF",MatchSource.WIKI,root/html530/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrapEditor.html
https://root.cern/root/html530/TGeoTrapEditor.html:21972,Usability,undo,undoing,21972,"GC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrapEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrapEditor.html
https://root.cern/root/html530/TGeoTrd1.html:2836,Availability,error,error,2836,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; Double_tGetDy() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual ",MatchSource.WIKI,root/html530/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html
https://root.cern/root/html530/TGeoTrd1.html:2920,Availability,error,error,2920,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; Double_tGetDy() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index ",MatchSource.WIKI,root/html530/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html
https://root.cern/root/html530/TGeoTrd1.html:1987,Safety,safe,safe,1987,"static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html530/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html
https://root.cern/root/html530/TGeoTrd1.html:2128,Safety,safe,safe,2128,"testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html530/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html
https://root.cern/root/html530/TGeoTrd1.html:12548,Safety,safe,safe,12548,"gin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1(); dummy ctor. TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume t",MatchSource.WIKI,root/html530/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html
https://root.cern/root/html530/TGeoTrd1.html:12633,Safety,safe,safe,12633,"gin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1(); dummy ctor. TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume t",MatchSource.WIKI,root/html530/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html
https://root.cern/root/html530/TGeoTrd1.html:13059,Safety,safe,safe,13059,"m[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume to be divided. In case a wrong; division axis is supplied, returns pointer to volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters",MatchSource.WIKI,root/html530/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html
https://root.cern/root/html530/TGeoTrd1.html:13145,Safety,safe,safe,13145,"m[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume to be divided. In case a wrong; division axis is supplied, returns pointer to volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters",MatchSource.WIKI,root/html530/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html
https://root.cern/root/html530/TGeoTrd1.html:1130,Testability,test,testNo,1130," TGeoTrd1(); TGeoTrd1(Double_t* params); TGeoTrd1(const TGeoTrd1&); TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); virtual~TGeoTrd1(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) cons",MatchSource.WIKI,root/html530/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html
https://root.cern/root/html530/TGeoTrd1.html:12381,Testability,test,test,12381,"th in X at higher Z surface (+dz); Double_tfDyhalf length in Y; Double_tfDzhalf length in Z; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1(); dummy ctor. TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start posit",MatchSource.WIKI,root/html530/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1.html
https://root.cern/root/html530/TGeoTrd1Editor.html:4585,Availability,error,error,4585,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1Editor.html
https://root.cern/root/html530/TGeoTrd1Editor.html:4669,Availability,error,error,4669,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1Editor.html
https://root.cern/root/html530/TGeoTrd1Editor.html:17903,Availability,mask,mask,17903,,MatchSource.WIKI,root/html530/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1Editor.html
https://root.cern/root/html530/TGeoTrd1Editor.html:21266,Usability,undo,undoing,21266," position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd1Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd1Editor.html
https://root.cern/root/html530/TGeoTrd2.html:2877,Availability,error,error,2877,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDy1() const; Double_tGetDy2() const; Double",MatchSource.WIKI,root/html530/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html
https://root.cern/root/html530/TGeoTrd2.html:2961,Availability,error,error,2961,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDy1() const; Double_tGetDy2() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::",MatchSource.WIKI,root/html530/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html
https://root.cern/root/html530/TGeoTrd2.html:2028,Safety,safe,safe,2028,"static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html530/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html
https://root.cern/root/html530/TGeoTrd2.html:2169,Safety,safe,safe,2169,"testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html530/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html
https://root.cern/root/html530/TGeoTrd2.html:12743,Safety,safe,safe,12743,"ape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2(); dummy ctor. TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; ar",MatchSource.WIKI,root/html530/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html
https://root.cern/root/html530/TGeoTrd2.html:12828,Safety,safe,safe,12828,"ape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2(); dummy ctor. TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; ar",MatchSource.WIKI,root/html530/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html
https://root.cern/root/html530/TGeoTrd2.html:12961,Safety,safe,safe,12961,"ouble_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. void GetBoundingCylinder(Double_t* param) const",MatchSource.WIKI,root/html530/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html
https://root.cern/root/html530/TGeoTrd2.html:13047,Safety,safe,safe,13047,"ouble_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. void GetBoundingCylinder(Double_t* param) const",MatchSource.WIKI,root/html530/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html
https://root.cern/root/html530/TGeoTrd2.html:1171,Testability,test,testNo,1171," TGeoTrd2(); TGeoTrd2(Double_t* params); TGeoTrd2(const TGeoTrd2&); TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); virtual~TGeoTrd2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = T",MatchSource.WIKI,root/html530/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html
https://root.cern/root/html530/TGeoTrd2.html:12576,Testability,test,test,12576,"Z surface (+dz); Double_tfDzhalf length in Z; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2(); dummy ctor. TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)",MatchSource.WIKI,root/html530/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2.html
https://root.cern/root/html530/TGeoTrd2Editor.html:4599,Availability,error,error,4599,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2Editor.html
https://root.cern/root/html530/TGeoTrd2Editor.html:4683,Availability,error,error,4683,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2Editor.html
https://root.cern/root/html530/TGeoTrd2Editor.html:17988,Availability,mask,mask,17988,,MatchSource.WIKI,root/html530/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2Editor.html
https://root.cern/root/html530/TGeoTrd2Editor.html:21351,Usability,undo,undoing,21351,"me y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd2Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTrd2Editor.html
https://root.cern/root/html530/TGeoTreeDialog.html:1033,Availability,avail,available,1033,"inks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoTreeDialog. class TGeoTreeDialog: public TGTransientFrame. TGeoTabManager - manager for all editor tabs. TGeoTreeDialog - Base class for dialog frames for selecting objects; with a tree hierarchy. Specific implementations are:; TGeoVolumeDialog - Special tree dialog class for selecting volumes.; TGeoShapeDialog - Special tree dialog class for selecting shapes.; TGeoMediumDialog - Special tree dialog class for selecting media.; TGeoMaterialDialog - Special tree dialog class for selecting materials.; TGeoMatrixDialog - Special tree dialog class for selecting matrices.; TGeoTransientPanel - Special transient tab holding TGeo editors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoTreeDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); st",MatchSource.WIKI,root/html530/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTreeDialog.html
https://root.cern/root/html530/TGeoTreeDialog.html:5156,Availability,error,error,5156,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTreeDialog.html
https://root.cern/root/html530/TGeoTreeDialog.html:5240,Availability,error,error,5240,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTreeDialog.html
https://root.cern/root/html530/TGeoTreeDialog.html:19756,Availability,mask,mask,19756,,MatchSource.WIKI,root/html530/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTreeDialog.html
https://root.cern/root/html530/TGeoTube.html:3724,Availability,error,error,3724,"* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:3808,Availability,error,error,3808,"static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatr",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:2546,Safety,safe,safe,2546," voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Doub",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:2794,Safety,safe,safe,2794,"r* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* para",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:13779,Safety,safe,safe,13779,"ault constructor specifying minimum and maximum radius. TGeoTube(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = dz. ~TGeoTube(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:13947,Safety,safe,safe,13947,"t; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*d",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:14032,Safety,safe,safe,14032,"t; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*d",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:14245,Safety,safe,safe,14245," ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divi",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:14395,Safety,safe,safe,14395,"osest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radial division; creates all volumes with",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:14475,Safety,safe,safe,14475,"osest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radial division; creates all volumes with",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:14499,Safety,safe,safe,14499,"osest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radial division; creates all volumes with",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:1581,Testability,test,testNo,1581," TGeoTube(); TGeoTube(Double_t* params); TGeoTube(const TGeoTube&); TGeoTube(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube(const char* name, Double_t rmin, Double_t rmax, Double_t dz); virtual~TGeoTube(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* di",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTube.html:13461,Testability,test,test,13461,"ction documentation; TGeoTube(); Default constructor. TGeoTube(Double_t rmin, Double_t rmax, Double_t dz); Default constructor specifying minimum and maximum radius. TGeoTube(const char* name, Double_t rmin, Double_t rmax, Double_t dz); Default constructor specifying minimum and maximum radius. TGeoTube(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = dz. ~TGeoTube(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface",MatchSource.WIKI,root/html530/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTube.html
https://root.cern/root/html530/TGeoTubeEditor.html:4591,Availability,error,error,4591,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeEditor.html
https://root.cern/root/html530/TGeoTubeEditor.html:4675,Availability,error,error,4675,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeEditor.html
https://root.cern/root/html530/TGeoTubeEditor.html:17909,Availability,mask,mask,17909,,MatchSource.WIKI,root/html530/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeEditor.html
https://root.cern/root/html530/TGeoTubeEditor.html:21344,Usability,undo,undoing,21344,"nt_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeEditor.html
https://root.cern/root/html530/TGeoTubeSeg.html:4092,Availability,error,error,4092,"FromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetF",MatchSource.WIKI,root/html530/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html
https://root.cern/root/html530/TGeoTubeSeg.html:4176,Availability,error,error,4176,"dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox",MatchSource.WIKI,root/html530/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html
https://root.cern/root/html530/TGeoTubeSeg.html:2718,Safety,safe,safe,2718,"les = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw",MatchSource.WIKI,root/html530/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html
https://root.cern/root/html530/TGeoTubeSeg.html:3059,Safety,safe,safe,3059,"h(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* metho",MatchSource.WIKI,root/html530/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html
https://root.cern/root/html530/TGeoTubeSeg.html:14841,Safety,safe,safe,14841,"~TGeoTubeSeg(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, ",MatchSource.WIKI,root/html530/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html
https://root.cern/root/html530/TGeoTubeSeg.html:14980,Safety,safe,safe,14980,"bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; cr",MatchSource.WIKI,root/html530/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html
https://root.cern/root/html530/TGeoTubeSeg.html:15073,Safety,safe,safe,15073,"bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; cr",MatchSource.WIKI,root/html530/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html
https://root.cern/root/html530/TGeoTubeSeg.html:15373,Safety,safe,safe,15373,"le_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of ",MatchSource.WIKI,root/html530/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html
https://root.cern/root/html530/TGeoTubeSeg.html:15506,Safety,safe,safe,15506,"y); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) cons",MatchSource.WIKI,root/html530/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html
https://root.cern/root/html530/TGeoTubeSeg.html:1701,Testability,test,testNo,1701," TGeoTubeSeg(); TGeoTubeSeg(Double_t* params); TGeoTubeSeg(const TGeoTubeSeg&); TGeoTubeSeg(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); TGeoTubeSeg(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); virtual~TGeoTubeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtu",MatchSource.WIKI,root/html530/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html
https://root.cern/root/html530/TGeoTubeSeg.html:14373,Testability,test,test,14373,"* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Default constructor specifying minimum and maximum radius. TGeoTubeSeg(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = dz; param[3] = phi1; param[4] = phi2. ~TGeoTubeSeg(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Doubl",MatchSource.WIKI,root/html530/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html
https://root.cern/root/html530/TGeoTubeSegEditor.html:4732,Availability,error,error,4732,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSegEditor.html
https://root.cern/root/html530/TGeoTubeSegEditor.html:4816,Availability,error,error,4816,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSegEditor.html
https://root.cern/root/html530/TGeoTubeSegEditor.html:18281,Availability,mask,mask,18281,,MatchSource.WIKI,root/html530/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSegEditor.html
https://root.cern/root/html530/TGeoTubeSegEditor.html:21919,Usability,undo,undoing,21919,"bMgrtab manager corresponding to ged-editor; TGTextButton*TGeoTubeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube segment editor. ~TGeoTubeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoTubeSegEditor.html
https://root.cern/root/html530/TGeoUniformMagField.html:1457,Availability,error,error,1457,"ormMagField(Double_t Bx, Double_t By, Double_t Bz); virtual~TGeoUniformMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t*, Double_t* B); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*GetFieldValue() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virt",MatchSource.WIKI,root/html530/TGeoUniformMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoUniformMagField.html
https://root.cern/root/html530/TGeoUniformMagField.html:1541,Availability,error,error,1541,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t*, Double_t* B); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*GetFieldValue() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tT",MatchSource.WIKI,root/html530/TGeoUniformMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoUniformMagField.html
https://root.cern/root/html530/TGeoUnion.html:2837,Availability,error,error,2837,"uble_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitl",MatchSource.WIKI,root/html530/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoUnion.html
https://root.cern/root/html530/TGeoUnion.html:2921,Availability,error,error,2921,"nt, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Handle",MatchSource.WIKI,root/html530/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoUnion.html
https://root.cern/root/html530/TGeoUnion.html:2339,Safety,safe,safe,2339,"ight, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); virtual~TGeoUnion(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root/html530/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoUnion.html
https://root.cern/root/html530/TGeoUnion.html:2465,Safety,safe,safe,2465," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::",MatchSource.WIKI,root/html530/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoUnion.html
https://root.cern/root/html530/TGeoUnion.html:8760,Safety,safe,safe,8760,"Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ge",MatchSource.WIKI,root/html530/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoUnion.html
https://root.cern/root/html530/TGeoUnion.html:8950,Safety,safe,safe,8950,"ibraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoUnion.html
https://root.cern/root/html530/TGeoUnion.html:9188,Safety,safe,safety,9188,"ibraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoUnion.html
https://root.cern/root/html530/TGeoVolume.html:10532,Availability,error,error,10532,"l TGeoVolume*CloneVolume() const; virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tExport(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tFindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindOverlaps() const; virtual Int_tGetByteCount() const; virtual Int_tGetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoPatternFinder*GetFinder() const; TGeoManager*GetGeoManager() const; virtual const char*GetIconName() const; I",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:10616,Availability,error,error,10616,"onst; Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tExport(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tFindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindOverlaps() const; virtual Int_tGetByteCount() const; virtual Int_tGetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoPatternFinder*GetFinder() const; TGeoManager*GetGeoManager() const; virtual const char*GetIconName() const; Int_tGetIndex(const TGeoNode* node) const; virtual Color_tTAttLine::GetLineColor() co",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:23411,Availability,down,down,23411,"t ovlp = 0.1, Option_t* option = """") const; Overlap checking tool. Check for illegal overlaps within a limit OVLP.; Use option=""s[number]"" to force overlap checking by sampling volume with; [number] points.; Ex: myVol->CheckOverlaps(0.01, ""s10000000""); // shoot 10000000 points; myVol->CheckOverlaps(0.01, ""s""); // shoot the default value of 1e6 points. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape(). void CleanAll(); Clean data of the volume. void ClearShape(); Clear the shape of this volume from the list held by the current manager. void CheckShapes(); check for negative parameters in shapes.; THIS METHOD LEAVES SOME GARBAGE NODES -> memory leak, to be fixed; printf(""---Checking daughters of volume %s\n"", GetName());. Int_t CountNodes(Int_t nlevels = 1000, Int_t option = 0); Count total number of subnodes starting from this volume, nlevels down; option = 0 (default) - count only once per volume; option = 1 - count every time; option = 2 - count volumes on visible branches; option = 3 - return maximum level counted already with option = 0. Bool_t IsAllInvisible() const; Return TRUE if volume and all daughters are invisible. void InvisibleAll(Bool_t flag = kTRUE); Make volume and each of it daughters (in)visible. Bool_t IsFolder() const; Return TRUE if volume contains nodes; return (GetNdaughters()?kTRUE:kFALSE);. Bool_t IsStyleDefault() const; check if the visibility and attributes are the default ones. Bool_t IsTopVolume() const; True if this is the top volume of the geometry. Bool_t IsRaytracing() const; Check if the painter is currently ray-tracing the content of this volume. void InspectMaterial() const; Inspect the material for this volume. TGeoVolume * Import(const char* filename, const char* name = """", Option_t* option = """"); Import a volume from a file. Int_t Export(const char* filename, const char* name = """", Option_t* option = """"); Export this volume",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:26870,Energy Efficiency,efficient,efficient,26870,"will have medium number NUMED.; If NUMED=0 they will get the medium number of the divided volume (this). If NDIV<=0,; all range of IAXIS will be divided and the resulting number of divisions will be centered on; IAXIS. If STEP<=0, the real STEP will be computed as the full range of IAXIS divided by NDIV.; Options (case insensitive):; N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3); NX - divide range starting with START in NDIV cells (GSDVN2 in G3); S - divide all range with given STEP. NDIV is computed and divisions will be centered; in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3); SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3). Int_t DistancetoPrimitive(Int_t px, Int_t py); compute the closest distance of approach from point px,py to this volume. void Draw(Option_t* option = """"); draw top volume according to option. void DrawOnly(Option_t* option = """"); draw only this volume. Bool_t OptimizeVoxels(); Perform an exensive sampling to find which type of voxelization is; most efficient. void Paint(Option_t* option = """"); paint volume. void PrintVoxels() const; Print the voxels for this volume. void ReplayCreation(const TGeoVolume* other); Recreate the content of the other volume without pointer copying. Voxels are; ignored and supposed to be created in a later step via Voxelize. void PrintNodes() const; print nodes. TH2F * LegoPlot(Int_t ntheta = 20, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 60, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RegisterYourself(Option_t* option = """"); Register the volume and all materials/media/matrices/shapes to the manager. void RandomPoints(Int_t npoints = 1000000, Option_t* option = """"); Draw random points in the bounding box of this volume. void RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t st",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:1913,Modifiability,inherit,inherits,1913,"rent name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium cla",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:27942,Performance,perform,perform,27942,"aint volume. void PrintVoxels() const; Print the voxels for this volume. void ReplayCreation(const TGeoVolume* other); Recreate the content of the other volume without pointer copying. Voxels are; ignored and supposed to be created in a later step via Voxelize. void PrintNodes() const; print nodes. TH2F * LegoPlot(Int_t ntheta = 20, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 60, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RegisterYourself(Option_t* option = """"); Register the volume and all materials/media/matrices/shapes to the manager. void RandomPoints(Int_t npoints = 1000000, Option_t* option = """"); Draw random points in the bounding box of this volume. void RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0); Random raytracing method. void Raytrace(Bool_t flag = kTRUE); Draw this volume with current settings and perform raytracing in the pad. void SaveAs(const char* filename, Option_t* option = """") const; Save geometry having this as top volume as a C++ macro. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void UnmarkSaved(); Reset SavePrimitive bits. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this volume. TGeoNode * FindNode(const char* name) const; search a daughter inside the list of nodes. Int_t GetNodeIndex(const TGeoNode* node, Int_t* check_list, Int_t ncheck) const; Get the index of a daugther within check_list by providing the node pointer. Int_t GetIndex(const TGeoNode* node) const; get index number for a given daughter. char * GetObjectInfo(Int_t px, Int_t py) const; Get volume info for the browser. Bool_t GetOptimalVoxels() const; --- Returns true if cylindrical voxelization is optimal. char * GetPointerName() const; Provide a pointer name containing ui",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:28968,Performance,optimiz,optimization,28968,"acing in the pad. void SaveAs(const char* filename, Option_t* option = """") const; Save geometry having this as top volume as a C++ macro. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void UnmarkSaved(); Reset SavePrimitive bits. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this volume. TGeoNode * FindNode(const char* name) const; search a daughter inside the list of nodes. Int_t GetNodeIndex(const TGeoNode* node, Int_t* check_list, Int_t ncheck) const; Get the index of a daugther within check_list by providing the node pointer. Int_t GetIndex(const TGeoNode* node) const; get index number for a given daughter. char * GetObjectInfo(Int_t px, Int_t py) const; Get volume info for the browser. Bool_t GetOptimalVoxels() const; --- Returns true if cylindrical voxelization is optimal. char * GetPointerName() const; Provide a pointer name containing uid. TGeoVoxelFinder * GetVoxels() const; Getter for optimization structure. void GrabFocus(); Move perspective view focus to this volume. TGeoVolume * CloneVolume() const; Clone this volume.; build a volume with same name, shape and medium. void CloneNodesAndConnect(TGeoVolume* newmother) const; Clone the array of nodes. void MakeCopyNodes(const TGeoVolume* other); make a new list of nodes and copy all nodes of other volume inside. TGeoVolume * MakeCopyVolume(TGeoShape* newshape); make a copy of this volume; build a volume with same name, shape and medium. TGeoVolume * MakeReflectedVolume(const char* newname = """") const; Make a copy of this volume which is reflected with respect to XY plane. void SetAsTopVolume(); Set this volume as the TOP one (the whole geometry starts from here). void SetCurrentPoint(Double_t x, Double_t y, Double_t z); Set the current tracking point. void SetShape(const TGeoShape* shape); set the shape associated with this volume. void SortNodes(); sort nodes by decreasing volume of the bounding box. ON",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:1134,Safety,avoid,avoid,1134,"urce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolume. class TGeoVolume: public TNamed, public TGeoAtt, public TAttLine, public TAttFill, public TAtt3D. TGeoVolume - the base class representing solids. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put togeather a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:9159,Testability,test,testNo,9159,,MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:22825,Testability,test,testNo,22825,"er* b); How to browse a volume. Double_t Capacity() const; Computes the capacity of this [cm^3] as the capacity of its shape.; In case of assemblies, the capacity is computed as the sum of daughter's capacities. void CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const; Shoot nrays with random directions from starting point (startx, starty, startz); in the reference frame of this volume. Track each ray until exiting geometry, then; shoot backwards from exiting point and compare boundary crossing points. void CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """") const; Overlap checking tool. Check for illegal overlaps within a limit OVLP.; Use option=""s[number]"" to force overlap checking by sampling volume with; [number] points.; Ex: myVol->CheckOverlaps(0.01, ""s10000000""); // shoot 10000000 points; myVol->CheckOverlaps(0.01, ""s""); // shoot the default value of 1e6 points. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape(). void CleanAll(); Clean data of the volume. void ClearShape(); Clear the shape of this volume from the list held by the current manager. void CheckShapes(); check for negative parameters in shapes.; THIS METHOD LEAVES SOME GARBAGE NODES -> memory leak, to be fixed; printf(""---Checking daughters of volume %s\n"", GetName());. Int_t CountNodes(Int_t nlevels = 1000, Int_t option = 0); Count total number of subnodes starting from this volume, nlevels down; option = 0 (default) - count only once per volume; option = 1 - count every time; option = 2 - count volumes on visible branches; option = 3 - return maximum level counted already with option = 0. Bool_t IsAllInvisible() const; Return TRUE if volume and all daughters are invisible. void InvisibleAll(Bool_t flag = kTRUE); Make volume and each of it daughters (in)visible. Bool_t IsFolder() const; Return TRUE if volume contains nodes; return (GetNda",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:2731,Usability,simpl,simple,2731,"advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; and a half-length dZ=1cm :. TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);. One may ommit the name for the shape if no retreiving by name is further needed; during geometry building. The same shape can be shared by different volumes; having different names and materials. Now let's make the volume for our wire.; The prototype for volumes constructor looks like :. TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look insi",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:4346,Usability,learn,learned,4346,"ed). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would; have been able to create our wire with a single line :. TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);. The same applies for all primitive shapes, for which there can be found; corresponding MakeSHAPE() methods. Their usage is much more convenient unless; a shape has to be shared between more volumes. Let's make now an aluminium wire; having the same shape, supposing that we have created the copper wire with the; line above :. TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);. Now that we have learned how to create elementary volumes, let's see how we; can create a geometrical hierarchy. Positioning volumes. When creating a volume one does not specify if this will contain or not other; volumes. Adding daughters to a volume implies creating those and adding them; one by one to the list of daughters. Since the volume has to know the position; of all its daughters, we will have to supply at the same time a geometrical; transformation with respect to its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is c",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:5847,Usability,simpl,simplicity,5847,"its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is cleaned; upon destruction. Let's consider positioning now our wire in the middle of a gas chamber. We; need first to define the gas chamber :. TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);. Now we can put the wire inside :. chamber->AddNode(wire_co, 1);. If we inspect now the chamber volume in a browser, we will notice that it has; one daughter. Of course the gas has some container also, but let's keep it like; that for the sake of simplicity. The full prototype of AddNode() is :. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity). Since we did not supplied the third argument, the wire will be positioned with; an identity transformation inside the chamber. One will notice that the inner; radii of the wire and chamber are both zero - therefore, aren't the two volumes; overlapping ? The answer is no, the modeler is even relaying on the fact that; any daughter is fully contained by its mother. On the other hand, neither of; the nodes positioned inside a volume should overlap with each other. We will; see that there are allowed some exceptions to those rules. Overlapping volumes. Positioning volumes that does not overlap their neighbours nor extrude; their container is sometimes quite strong contrain. Some parts of the geometry; might overlap naturally, e.g. two crossing tubes. The modeller supports such; cases only if the overlapping n",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:16546,Usability,clear,clear,16546,"_t startz = 0)MENU ; voidRaytrace(Bool_t flag = kTRUE)TOGGLE GETTER ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRegisterYourself(Option_t* option = """"); voidRemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidSaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidSelectVolume(Bool_t clear = kFALSE); voidSetActiveDaughters(Bool_t flag = kTRUE); voidSetActivity(Bool_t flag = kTRUE); voidSetAdded(); voidSetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidSetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); voidSetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidSetFinder(TGeoPatternFinder* finder); voidSetInvisible(); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidSetLineColor(Color_t lcolor); virtual voidSetLineStyle(Style_t lstyle); virtual voidSetLineWidth(Width_t lwidth); virtual voidSetMedium(TGeoMedium* medium)",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:30996,Usability,clear,clear,30996,"ion nodes. void Streamer(TBuffer& b); Stream an object of class TGeoVolume. void SetOption(const char* option); Set the current options (none implemented). void SetLineColor(Color_t lcolor); Set the line color. void SetLineStyle(Style_t lstyle); Set the line style. void SetLineWidth(Width_t lwidth); Set the line width. TGeoNode * GetNode(const char* name) const; get the pointer to a daughter node. Int_t GetByteCount() const; get the total size in bytes for this volume. void FindOverlaps() const; loop all nodes marked as overlaps and find overlaping brothers. void RemoveNode(TGeoNode* node); Remove an existing daughter. TGeoNode * ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); Replace an existing daughter with a new volume having the same name but; possibly a new shape, position or medium. Not allowed for positioned assemblies.; For division cells, the new shape/matrix are ignored. void SelectVolume(Bool_t clear = kFALSE); Select this volume as matching an arbitrary criteria. The volume is added to; a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; to be reset at the end by calling the method with CLEAR=true. This will also clear; the list. void SetVisibility(Bool_t vis = kTRUE); set visibility of this volume. void SetVisContainers(Bool_t flag = kTRUE); Set visibility for containers. void SetVisLeaves(Bool_t flag = kTRUE); Set visibility for leaves. void SetVisOnly(Bool_t flag = kTRUE); Set visibility for leaves. Bool_t Valid() const; Check if the shape of this volume is valid. Bool_t FindMatrixOfDaughterVolume(TGeoVolume* vol) const; Find a daughter node having VOL as volume and fill TGeoManager::fHMatrix; with its global matrix. void VisibleDaughters(Bool_t vis = kTRUE); set visibility for daughters. void Voxelize(Option_t* option); build the voxels for this volume. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate the weight of a volume (in kg) with ",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolume.html:31247,Usability,clear,clear,31247,"Style_t lstyle); Set the line style. void SetLineWidth(Width_t lwidth); Set the line width. TGeoNode * GetNode(const char* name) const; get the pointer to a daughter node. Int_t GetByteCount() const; get the total size in bytes for this volume. void FindOverlaps() const; loop all nodes marked as overlaps and find overlaping brothers. void RemoveNode(TGeoNode* node); Remove an existing daughter. TGeoNode * ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); Replace an existing daughter with a new volume having the same name but; possibly a new shape, position or medium. Not allowed for positioned assemblies.; For division cells, the new shape/matrix are ignored. void SelectVolume(Bool_t clear = kFALSE); Select this volume as matching an arbitrary criteria. The volume is added to; a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; to be reset at the end by calling the method with CLEAR=true. This will also clear; the list. void SetVisibility(Bool_t vis = kTRUE); set visibility of this volume. void SetVisContainers(Bool_t flag = kTRUE); Set visibility for containers. void SetVisLeaves(Bool_t flag = kTRUE); Set visibility for leaves. void SetVisOnly(Bool_t flag = kTRUE); Set visibility for leaves. Bool_t Valid() const; Check if the shape of this volume is valid. Bool_t FindMatrixOfDaughterVolume(TGeoVolume* vol) const; Find a daughter node having VOL as volume and fill TGeoManager::fHMatrix; with its global matrix. void VisibleDaughters(Bool_t vis = kTRUE); set visibility for daughters. void Voxelize(Option_t* option); build the voxels for this volume. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.; Option can contain : v - verbose, a - analytical (default). Double_t WeightA() const; Analytical computation of the weight. Int_t GetNdaughters() const; {if (!fNodes) return 0; return (fNodes->G",MatchSource.WIKI,root/html530/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolume.html
https://root.cern/root/html530/TGeoVolumeAssembly.html:10778,Availability,error,error,10778,"oint) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoVolume::CountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGeoVolume::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Divide(TGeoVolume* cell, TGeoPatternFinder* pattern, Option_t* option = ""spacedout""); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTGeoVolume::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t*); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoVolume::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tTGeoVolume::Export(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tTGeoVolume::FindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*TGeoVolume::FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTGeoVolume::FindOverlaps() const; virtual Int_tTGeoVolume::GetByteCount() const; virtual Int_tGetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*TGeoVolume::GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoPatternFinder*TGeoVolume:",MatchSource.WIKI,root/html530/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeAssembly.html
https://root.cern/root/html530/TGeoVolumeAssembly.html:10862,Availability,error,error,10862,"odes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGeoVolume::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Divide(TGeoVolume* cell, TGeoPatternFinder* pattern, Option_t* option = ""spacedout""); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTGeoVolume::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t*); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoVolume::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tTGeoVolume::Export(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tTGeoVolume::FindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*TGeoVolume::FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTGeoVolume::FindOverlaps() const; virtual Int_tTGeoVolume::GetByteCount() const; virtual Int_tGetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*TGeoVolume::GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoPatternFinder*TGeoVolume::GetFinder() const; TGeoManager*TGeoVolume::GetGeoManager() const; virtual const cha",MatchSource.WIKI,root/html530/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeAssembly.html
https://root.cern/root/html530/TGeoVolumeAssembly.html:24463,Integrability,depend,depending,24463,"ited Members; Includes; Libraries. Function documentation; TGeoVolumeAssembly(); Default constructor. TGeoVolumeAssembly(const char* name); Constructor. Just the name has to be provided. Assemblies does not have their own; shape or medium. ~TGeoVolumeAssembly(); Destructor. The assembly is owner of its ""shape"". void AddNode(const TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); Add a component to the assembly. void AddNodeOverlap(const TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option); Add an overlapping node - not allowed for assemblies. TGeoVolume * CloneVolume() const; Clone this volume.; build a volume with same name, shape and medium. TGeoVolume * Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Division makes no sense for assemblies. TGeoVolume * Divide(TGeoVolume* cell, TGeoPatternFinder* pattern, Option_t* option = ""spacedout""); Assign to the assembly a collection of identical volumes positioned according; a predefined pattern. The option can be spacedout or touching depending on the empty; space between volumes. TGeoVolumeAssembly * MakeAssemblyFromVolume(TGeoVolume* vol); Make a clone of volume VOL but which is an assembly. Bool_t IsAssembly() const; {return kFALSE;}. void DrawOnly(Option_t* ). Bool_t IsVisible() const; {return TGeoAtt::IsVisible();}. Int_t GetCurrentNodeIndex() const; {return -1;}. Int_t GetNextNodeIndex() const; {return -1;}. TGeoVolumeAssembly(). void SetCurrentNodeIndex(Int_t index); {fCurrent = index;}. void SetNextNodeIndex(Int_t index); {fNext = index;}. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoVolume.h 39018 2011-04-25 09:38:31Z agheata $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeAssembly.html
https://root.cern/root/html530/TGeoVolumeAssembly.html:1876,Modifiability,inherit,inherits,1876,"rent name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium cla",MatchSource.WIKI,root/html530/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeAssembly.html
https://root.cern/root/html530/TGeoVolumeAssembly.html:1097,Safety,avoid,avoid,1097,"s Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolumeAssembly. class TGeoVolumeAssembly: public TGeoVolume. TGeoVolume - the base class representing solids. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put togeather a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root/html530/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeAssembly.html
https://root.cern/root/html530/TGeoVolumeAssembly.html:9217,Testability,test,testNo,9217,,MatchSource.WIKI,root/html530/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeAssembly.html
https://root.cern/root/html530/TGeoVolumeAssembly.html:2694,Usability,simpl,simple,2694,"advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; and a half-length dZ=1cm :. TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);. One may ommit the name for the shape if no retreiving by name is further needed; during geometry building. The same shape can be shared by different volumes; having different names and materials. Now let's make the volume for our wire.; The prototype for volumes constructor looks like :. TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look insi",MatchSource.WIKI,root/html530/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeAssembly.html
https://root.cern/root/html530/TGeoVolumeAssembly.html:4309,Usability,learn,learned,4309,"ed). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would; have been able to create our wire with a single line :. TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);. The same applies for all primitive shapes, for which there can be found; corresponding MakeSHAPE() methods. Their usage is much more convenient unless; a shape has to be shared between more volumes. Let's make now an aluminium wire; having the same shape, supposing that we have created the copper wire with the; line above :. TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);. Now that we have learned how to create elementary volumes, let's see how we; can create a geometrical hierarchy. Positioning volumes. When creating a volume one does not specify if this will contain or not other; volumes. Adding daughters to a volume implies creating those and adding them; one by one to the list of daughters. Since the volume has to know the position; of all its daughters, we will have to supply at the same time a geometrical; transformation with respect to its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is c",MatchSource.WIKI,root/html530/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeAssembly.html
https://root.cern/root/html530/TGeoVolumeAssembly.html:5810,Usability,simpl,simplicity,5810,"its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is cleaned; upon destruction. Let's consider positioning now our wire in the middle of a gas chamber. We; need first to define the gas chamber :. TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);. Now we can put the wire inside :. chamber->AddNode(wire_co, 1);. If we inspect now the chamber volume in a browser, we will notice that it has; one daughter. Of course the gas has some container also, but let's keep it like; that for the sake of simplicity. The full prototype of AddNode() is :. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity). Since we did not supplied the third argument, the wire will be positioned with; an identity transformation inside the chamber. One will notice that the inner; radii of the wire and chamber are both zero - therefore, aren't the two volumes; overlapping ? The answer is no, the modeler is even relaying on the fact that; any daughter is fully contained by its mother. On the other hand, neither of; the nodes positioned inside a volume should overlap with each other. We will; see that there are allowed some exceptions to those rules. Overlapping volumes. Positioning volumes that does not overlap their neighbours nor extrude; their container is sometimes quite strong contrain. Some parts of the geometry; might overlap naturally, e.g. two crossing tubes. The modeller supports such; cases only if the overlapping n",MatchSource.WIKI,root/html530/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeAssembly.html
https://root.cern/root/html530/TGeoVolumeAssembly.html:17699,Usability,clear,clear,17699,"Object::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTGeoVolume::SaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTGeoVolume::SavePrimitive(ostream& out, Option_t* option = """"); voidTGeoVolume::SelectVolume(Bool_t clear = kFALSE); voidTGeoVolume::SetActiveDaughters(Bool_t flag = kTRUE); voidTGeoVolume::SetActivity(Bool_t flag = kTRUE); voidTGeoVolume::SetAdded(); voidTGeoVolume::SetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidTGeoVolume::SetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCurrentNodeIndex(Int_t index); voidTGeoVolume::SetCurrentPoint(Double_t x, Double_t y, Double_t z); voidTGeoVolume::SetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoVolume::SetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidTGeoVolume::SetFinder(TGeoPatternFinder* finder); voidTGeoVolume::SetInvisible(); virtual voidTAttLine::SetLineAttributes()MENU ; virtual v",MatchSource.WIKI,root/html530/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeAssembly.html
https://root.cern/root/html530/TGeoVolumeDialog.html:5132,Availability,error,error,5132,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGeoVolumeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeDialog.html
https://root.cern/root/html530/TGeoVolumeDialog.html:5216,Availability,error,error,5216,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGeoVolumeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeDialog.html
https://root.cern/root/html530/TGeoVolumeDialog.html:19796,Availability,mask,mask,19796,,MatchSource.WIKI,root/html530/TGeoVolumeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeDialog.html
https://root.cern/root/html530/TGeoVolumeEditor.html:1335,Availability,down,down,1335,"ditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; splitted vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGeoVolumeEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual void",MatchSource.WIKI,root/html530/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeEditor.html
https://root.cern/root/html530/TGeoVolumeEditor.html:6488,Availability,error,error,6488,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeEditor.html
https://root.cern/root/html530/TGeoVolumeEditor.html:6572,Availability,error,error,6572,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeEditor.html
https://root.cern/root/html530/TGeoVolumeEditor.html:20564,Availability,mask,mask,20564,,MatchSource.WIKI,root/html530/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeEditor.html
https://root.cern/root/html530/TGeoVolumeEditor.html:875,Performance,perform,performed,875,". TGeoVolumeEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; splitted vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width =",MatchSource.WIKI,root/html530/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeEditor.html
https://root.cern/root/html530/TGeoVolumeEditor.html:1023,Usability,simpl,simply,1023," Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; splitted vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChil",MatchSource.WIKI,root/html530/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeEditor.html
https://root.cern/root/html530/TGeoVolumeEditor.html:1108,Usability,simpl,simply,1108," Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; splitted vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChil",MatchSource.WIKI,root/html530/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeEditor.html
https://root.cern/root/html530/TGeoVolumeMulti.html:10711,Availability,error,error,10711,"re(const TObject* obj) const; Bool_tTGeoVolume::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoVolume::CountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGeoVolume::DistancetoPrimitive(Int_t px, Int_t py); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTGeoVolume::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTGeoVolume::DrawOnly(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoVolume::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tTGeoVolume::Export(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tTGeoVolume::FindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*TGeoVolume::FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTGeoVolume::FindOverlaps() const; Int_tGetAxis() const; virtual Int_tTGeoVolume::GetByteCount() const; virtual Int_tTGeoVolume::GetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*TGeoVolume::GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() co",MatchSource.WIKI,root/html530/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeMulti.html
https://root.cern/root/html530/TGeoVolumeMulti.html:10795,Availability,error,error,10795,"tual voidTNamed::Copy(TObject& named) const; Int_tTGeoVolume::CountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGeoVolume::DistancetoPrimitive(Int_t px, Int_t py); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTGeoVolume::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTGeoVolume::DrawOnly(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoVolume::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tTGeoVolume::Export(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tTGeoVolume::FindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*TGeoVolume::FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTGeoVolume::FindOverlaps() const; Int_tGetAxis() const; virtual Int_tTGeoVolume::GetByteCount() const; virtual Int_tTGeoVolume::GetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*TGeoVolume::GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoPatternFinder*TGeoVolume::GetFinder() const; TGeoManager*TGeoVolume::GetGeo",MatchSource.WIKI,root/html530/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeMulti.html
https://root.cern/root/html530/TGeoVolumeMulti.html:1867,Modifiability,inherit,inherits,1867,"rent name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium cla",MatchSource.WIKI,root/html530/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeMulti.html
https://root.cern/root/html530/TGeoVolumeMulti.html:1088,Safety,avoid,avoid,1088,"; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolumeMulti. class TGeoVolumeMulti: public TGeoVolume. TGeoVolume - the base class representing solids. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put togeather a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root/html530/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeMulti.html
https://root.cern/root/html530/TGeoVolumeMulti.html:9206,Testability,test,testNo,9206,,MatchSource.WIKI,root/html530/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeMulti.html
https://root.cern/root/html530/TGeoVolumeMulti.html:2685,Usability,simpl,simple,2685,"advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; and a half-length dZ=1cm :. TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);. One may ommit the name for the shape if no retreiving by name is further needed; during geometry building. The same shape can be shared by different volumes; having different names and materials. Now let's make the volume for our wire.; The prototype for volumes constructor looks like :. TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look insi",MatchSource.WIKI,root/html530/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeMulti.html
https://root.cern/root/html530/TGeoVolumeMulti.html:4300,Usability,learn,learned,4300,"ed). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would; have been able to create our wire with a single line :. TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);. The same applies for all primitive shapes, for which there can be found; corresponding MakeSHAPE() methods. Their usage is much more convenient unless; a shape has to be shared between more volumes. Let's make now an aluminium wire; having the same shape, supposing that we have created the copper wire with the; line above :. TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);. Now that we have learned how to create elementary volumes, let's see how we; can create a geometrical hierarchy. Positioning volumes. When creating a volume one does not specify if this will contain or not other; volumes. Adding daughters to a volume implies creating those and adding them; one by one to the list of daughters. Since the volume has to know the position; of all its daughters, we will have to supply at the same time a geometrical; transformation with respect to its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is c",MatchSource.WIKI,root/html530/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeMulti.html
https://root.cern/root/html530/TGeoVolumeMulti.html:5801,Usability,simpl,simplicity,5801,"its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is cleaned; upon destruction. Let's consider positioning now our wire in the middle of a gas chamber. We; need first to define the gas chamber :. TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);. Now we can put the wire inside :. chamber->AddNode(wire_co, 1);. If we inspect now the chamber volume in a browser, we will notice that it has; one daughter. Of course the gas has some container also, but let's keep it like; that for the sake of simplicity. The full prototype of AddNode() is :. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity). Since we did not supplied the third argument, the wire will be positioned with; an identity transformation inside the chamber. One will notice that the inner; radii of the wire and chamber are both zero - therefore, aren't the two volumes; overlapping ? The answer is no, the modeler is even relaying on the fact that; any daughter is fully contained by its mother. On the other hand, neither of; the nodes positioned inside a volume should overlap with each other. We will; see that there are allowed some exceptions to those rules. Overlapping volumes. Positioning volumes that does not overlap their neighbours nor extrude; their container is sometimes quite strong contrain. Some parts of the geometry; might overlap naturally, e.g. two crossing tubes. The modeller supports such; cases only if the overlapping n",MatchSource.WIKI,root/html530/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeMulti.html
https://root.cern/root/html530/TGeoVolumeMulti.html:17780,Usability,clear,clear,17780,"Object::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTGeoVolume::SaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTGeoVolume::SavePrimitive(ostream& out, Option_t* option = """"); voidTGeoVolume::SelectVolume(Bool_t clear = kFALSE); voidTGeoVolume::SetActiveDaughters(Bool_t flag = kTRUE); voidTGeoVolume::SetActivity(Bool_t flag = kTRUE); voidTGeoVolume::SetAdded(); voidTGeoVolume::SetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidTGeoVolume::SetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoVolume::SetCurrentPoint(Double_t x, Double_t y, Double_t z); voidTGeoVolume::SetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoVolume::SetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidTGeoVolume::SetFinder(TGeoPatternFinder* finder); voidTGeoVolume::SetInvisible(); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidSetLineColor(Color_t lcolor); virtu",MatchSource.WIKI,root/html530/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVolumeMulti.html
https://root.cern/root/html530/TGeoVoxelFinder.html:1522,Availability,error,error,1522,"onst; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCreateCheckList(); voidDaughterToMother(Int_t id, Double_t* local, Double_t* master) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Double_tEfficiency(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindOverlaps(Int_t inode) const; Double_t*GetBoxes() const; Int_t*GetCheckList(Int_t& nelem) const; virtual Int_t*GetCheckList(Double_t* point, Int_t& nelem); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_t*GetNextCandidates(Double_t* point, Int_t& ncheck); virtual Int_t*GetNextVoxel(Double_t* point, Double_t* dir, Int_t& ncheck); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; vir",MatchSource.WIKI,root/html530/TGeoVoxelFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVoxelFinder.html
https://root.cern/root/html530/TGeoVoxelFinder.html:1606,Availability,error,error,1606,"owse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCreateCheckList(); voidDaughterToMother(Int_t id, Double_t* local, Double_t* master) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Double_tEfficiency(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindOverlaps(Int_t inode) const; Double_t*GetBoxes() const; Int_t*GetCheckList(Int_t& nelem) const; virtual Int_t*GetCheckList(Double_t* point, Int_t& nelem); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_t*GetNextCandidates(Double_t* point, Int_t& ncheck); virtual Int_t*GetNextVoxel(Double_t* point, Double_t* dir, Int_t& ncheck); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() cons",MatchSource.WIKI,root/html530/TGeoVoxelFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoVoxelFinder.html
https://root.cern/root/html530/TGeoXtru.html:4212,Availability,error,error,4212,"px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*TGeoBBox::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(In",MatchSource.WIKI,root/html530/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoXtru.html
https://root.cern/root/html530/TGeoXtru.html:4296,Availability,error,error,4296,"iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*TGeoBBox::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox,",MatchSource.WIKI,root/html530/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoXtru.html
https://root.cern/root/html530/TGeoXtru.html:3353,Safety,safe,safe,3353,,MatchSource.WIKI,root/html530/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoXtru.html
https://root.cern/root/html530/TGeoXtru.html:3494,Safety,safe,safe,3494,,MatchSource.WIKI,root/html530/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoXtru.html
https://root.cern/root/html530/TGeoXtru.html:15493,Safety,safe,safe,15493,"ition of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; Check Z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of Y vertex positions; *NOTE* should be called before DefineSection or ctor with 'param'. void DefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); defines z position of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector t",MatchSource.WIKI,root/html530/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoXtru.html
https://root.cern/root/html530/TGeoXtru.html:15708,Safety,safe,safe,15708," operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; Check Z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of Y vertex positions; *NOTE* should be called before DefineSection or ctor with 'param'. void DefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); defines z position of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz,",MatchSource.WIKI,root/html530/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoXtru.html
https://root.cern/root/html530/TGeoXtru.html:17289,Safety,safe,safety,17289,"n of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz, iz+1); and polygon vertices (ivert, ivert+1). No range check. Bool_t IsPointInsidePlane(Double_t* point, Double_t* vert, Double_t* norm) const; Check if the quadrilateral defined by VERT contains a coplanar POINT. void InspectShape() const; Print actual Xtru parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSector(Double_t* point, Int_t iz, Double_t safmin, Bool_t in); Compute safety to sector iz, returning also the closest segment index. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetCurrentZ(Double_t z, Int_t iz); Recompute current section vertices for a given Z position within range of section iz. void SetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); Set current vertex coordinates according X0, Y0 and SCALE. void SetDimensions(Double_t* param); param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = y",MatchSource.WIKI,root/html530/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoXtru.html
https://root.cern/root/html530/TGeoXtru.html:2324,Testability,test,testNo,2324," for first section; DefineSection(1, z1, x1, y1, scale1); // -''- secons section. DefineSection(nz-1, zn, xn, yn, scalen); // parameters for last section. *NOTES*; Currently navigation functionality not fully implemented (only Contains()).; Decomposition in concave polygons not implemented - drawing in solid mode; within x3d produces incorrect end-faces. Function Members (Methods); public:. TGeoXtru(); TGeoXtru(Int_t nz); TGeoXtru(Double_t* param); virtual~TGeoXtru(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Bool_tDefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); virtual voidDefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeo",MatchSource.WIKI,root/html530/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoXtru.html
https://root.cern/root/html530/TGeoXtru.html:15065,Testability,test,test,15065,"sitions ; Double_tfZcurrentcurrent Z position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoXtru(); dummy ctor. TGeoXtru(Int_t nz); Default constructor. TGeoXtru(Double_t* param); Default constructor in GEANT3 style; param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; Check Z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of ",MatchSource.WIKI,root/html530/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoXtru.html
https://root.cern/root/html530/TGEventHandler.html:3578,Availability,error,error,3578,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tHandleButton(Event_t*); virtua",MatchSource.WIKI,root/html530/TGEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGEventHandler.html
https://root.cern/root/html530/TGEventHandler.html:3662,Availability,error,error,3662,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tHandleButton(Event_t*); virtual Bool_tHandleColormapChange(Event_t*); virtual Bool_tHandleConfigureNotify(Event_t*",MatchSource.WIKI,root/html530/TGEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGEventHandler.html
https://root.cern/root/html530/TGEventHandler.html:10233,Integrability,message,message,10233,"ublic:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active; TObject*fObject; TGWindow*fWindow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleEvent(Event_t* ev); Handle the event. Returns true if the event has been handled,; false otherwise. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. TGEventHandler(const TGEventHandler& ). TGEventHandler& operator=(const TGEventHandler& ). void * GetSender(); { return this; }. TGEventHandler(const char* name, TGWindow* w, TObject* obj, const char* title = """"); { }. virtual ~TGEventHandler(); { }. void Activate(); { fIsActive = kTRUE; }. void DeActivate(); { fIsActive = kFALSE; }. Bool_t IsActive() const; { return fIsActive; }. Bool_t HandleConfigureNotify(Event_t* ); { return kFALSE; }. Bool_t HandleButton(Event_t* ); { return kFALSE; }. Bool_t HandleDoubleClick(Event_t* ); { return kFALSE; }. Bool_t HandleCrossing(Event_t* ); { return kFALSE; }. Bool_t HandleMotion(Event_t* ); { return kFALSE; }. Bool_t HandleKey(Event_t* ); { return kFALSE; }. Bool_t HandleFocusChange(Event_t* ); { return kFALSE; }. Bool_t HandleSelection(Event_t* ); { return kFALSE; }. Bool_t HandleSelectionRequest(",MatchSource.WIKI,root/html530/TGEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGEventHandler.html
https://root.cern/root/html530/TGEventHandler.html:10302,Integrability,message,message,10302,"Pick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active; TObject*fObject; TGWindow*fWindow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleEvent(Event_t* ev); Handle the event. Returns true if the event has been handled,; false otherwise. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. TGEventHandler(const TGEventHandler& ). TGEventHandler& operator=(const TGEventHandler& ). void * GetSender(); { return this; }. TGEventHandler(const char* name, TGWindow* w, TObject* obj, const char* title = """"); { }. virtual ~TGEventHandler(); { }. void Activate(); { fIsActive = kTRUE; }. void DeActivate(); { fIsActive = kFALSE; }. Bool_t IsActive() const; { return fIsActive; }. Bool_t HandleConfigureNotify(Event_t* ); { return kFALSE; }. Bool_t HandleButton(Event_t* ); { return kFALSE; }. Bool_t HandleDoubleClick(Event_t* ); { return kFALSE; }. Bool_t HandleCrossing(Event_t* ); { return kFALSE; }. Bool_t HandleMotion(Event_t* ); { return kFALSE; }. Bool_t HandleKey(Event_t* ); { return kFALSE; }. Bool_t HandleFocusChange(Event_t* ); { return kFALSE; }. Bool_t HandleSelection(Event_t* ); { return kFALSE; }. Bool_t HandleSelectionRequest(Event_t* ); { return kFALSE; }. Bool_t HandleSelectionClear(Event_t* ); { return kFALSE; }. Bool_t HandleColo",MatchSource.WIKI,root/html530/TGEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGEventHandler.html
https://root.cern/root/html530/TGFileBrowser.html:5367,Availability,error,error,5367,"char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tTBrowserImp::ExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTBrowserImp::ExecuteDefaultAction(TObject*); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*FormatFileInfo(const char* fname, Long64_t size, Long_t modtime); TStringFullPathName(TGListTreeItem* item); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClie",MatchSource.WIKI,root/html530/TGFileBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileBrowser.html
https://root.cern/root/html530/TGFileBrowser.html:5451,Availability,error,error,5451," voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tTBrowserImp::ExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTBrowserImp::ExecuteDefaultAction(TObject*); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*FormatFileInfo(const char* fname, Long64_t size, Long_t modtime); TStringFullPathName(TGListTreeItem* item); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTG",MatchSource.WIKI,root/html530/TGFileBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileBrowser.html
https://root.cern/root/html530/TGFileBrowser.html:21078,Availability,mask,mask,21078,"ckgroundframe background color; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TGHorizontalFrame*fBotFrameBottom horizontal frame; TBrowser*TBrowserImp::fBrowserTBrowser associated with this implementation; const TGPicture*fCachedPicCached picture; TStringfCachedPicNameCached picture name; TGCanvas*fCanvasCanvas for the list tree; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; Long_tfCntCounters for keys inside a Root file; TContextMenu*fContextMenupointer to context menu; TGListTreeItem*fCurrentDirCurrent (list tree) directory; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; Bool_tfDblClickkTRUE if user double-clicked on a list tree item; TSystemDirectory*fDirActual (selected) system directory; TGComboBox*fDrawOptionDraw options combobox; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TSystemFile*fFileActual (selected) system file; const TGPicture*fFileIconSystem files icon; TGComboBox*fFileTypeFile type combobox; TRegexp*fFilterRegular expression used to filter files; Int_tfGroupSizetotal number of items when icon box switched to ""global view"" mode; Bool_tfGroupedkTRUE if Root file content (keys) is grouped; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TGListTreeItem*fListLevelCurrent list tree level; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGListTree*fListTreeMain list tree; UInt_tTGMainFrame::fMWMFuncs",MatchSource.WIKI,root/html530/TGFileBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileBrowser.html
https://root.cern/root/html530/TGFileBrowser.html:379,Modifiability,plug-in,plug-in,379,". TGFileBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFileBrowser. class TGFileBrowser: public TGMainFrame, public TBrowserImp. TGFileBrowser. System file browser, used as TRootBrowser plug-in.; This class is the real core of the ROOT browser. Function Members (Methods); public:. TGFileBrowser(const TGWindow* p, TBrowser* b = 0, UInt_t w = 200, UInt_t h = 400); virtual~TGFileBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAdd(TObject* obj, const char* name = 0, Int_t check = -1); virtual voidTBrowserImp::AddCheckBox(TObject*, Bool_t = kFALSE); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidAddFSDirectory(const char* entry, const char* path = 0, Option_t* opt = """"); voidTGFrame::AddInput(UInt_t emask); voidAddKey(TGListTreeItem* itm, TObject* obj, const char* name = 0); voidAddRemoteFile(TObject* obj); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplyFilter(Int_t id); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidBrowseObj(TObject* obj); TBrowser*TBrowserImp::Browser() const; virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); voidChdir(TGListTreeItem* item); voidChecked(TObject* obj, Bool_t check); virtual voidTBrowserImp::CheckObjectItem(TObject*, Bool_t = kFALSE); voidCheckRemote(TGListTreeItem* it",MatchSource.WIKI,root/html530/TGFileBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileBrowser.html
https://root.cern/root/html530/TGFileContainer.html:5402,Availability,error,error,5402,"le_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::Get",MatchSource.WIKI,root/html530/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileContainer.html
https://root.cern/root/html530/TGFileContainer.html:5486,Availability,error,error,5486,"t(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaul",MatchSource.WIKI,root/html530/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileContainer.html
https://root.cern/root/html530/TGFileContainer.html:12532,Availability,mask,mask,12532,") const; voidTObject::InvertBit(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGContainer::KeyPressed(TGFrame*, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidTGContainer::Layout(); virtual voidTGLVContainer::LineDown(Bool_t select = kFALSE); virtual voidTGLVContainer::LineLeft(Bool_t select = kFALSE); virtual voidTGLVContainer::LineRight(Bool_t select = kFALSE); virtual voidTGLVContainer::LineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tT",MatchSource.WIKI,root/html530/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileContainer.html
https://root.cern/root/html530/TGFileContainer.html:22351,Availability,mask,mask,22351,,MatchSource.WIKI,root/html530/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileContainer.html
https://root.cern/root/html530/TGFileContainer.html:24012,Integrability,message,messages,24012,ner::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGListView*TGLVContainer::fListViewlistview which contains this container; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; ULong_tfMtimedirectory modification time; Bool_tTGLVContainer::fMultiSelecttrue = multiple file selection; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TViewUpdateTimer*fRefreshrefresh timer; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*fSlink_sbig symbolic link icon; const TGPicture*fSlink_tsmall symbolic link icon; EFSSortModefSortTypesorting mode of contents; Int_tTGContainer::fTotaltotal items; EListViewModeTGLVContainer::fViewModelist view viewing mode; TGViewPort*TGConta,MatchSource.WIKI,root/html530/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileContainer.html
https://root.cern/root/html530/TGFileDialog.html:5108,Availability,error,error,5108,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGFileDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileDialog.html
https://root.cern/root/html530/TGFileDialog.html:5192,Availability,error,error,5192,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGFileDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileDialog.html
https://root.cern/root/html530/TGFileDialog.html:19690,Availability,mask,mask,19690,,MatchSource.WIKI,root/html530/TGFileDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileDialog.html
https://root.cern/root/html530/TGFileDialog.html:23656,Integrability,message,messages,23656,"ition; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFileDialog(const TGWindow* p = 0, const TGWindow* main = 0, EFileDialogMode dlg_type = kFDOpen, TGFileInfo* file_info = 0); Create a file selection dialog. Depending on the dlg_type it can be; used for opening or saving a file. ~TGFileDialog(); Delete file dialog. void CloseWindow(); Close file dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the user input in the file dialog. TGFileInfo& operator=(const TGFileDialog& ). TGFileDialog(const TGFileDialog& ). » Author: Fons Rademakers 20/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFileDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGFileDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileDialog.html
https://root.cern/root/html530/TGFileItem.html:4540,Availability,error,error,4540,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGLVEntry::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*GetDNDdata(Atom_t); virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFra",MatchSource.WIKI,root/html530/TGFileItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileItem.html
https://root.cern/root/html530/TGFileItem.html:4624,Availability,error,error,4624,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGLVEntry::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*GetDNDdata(Atom_t); virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual In",MatchSource.WIKI,root/html530/TGFileItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileItem.html
https://root.cern/root/html530/TGFileItem.html:17381,Availability,mask,mask,17381,,MatchSource.WIKI,root/html530/TGFileItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFileItem.html
https://root.cern/root/html530/TGFont.html:1918,Availability,error,error,1918,"ject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; TGTextLayout*ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); voidDrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; voidDrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); FontAttributes_tGetFontAttributes() const; FontH_tGetFontHandle() const; voidGetFontMetrics(FontMetrics_t* m) const; FontStruct_tGetFontStruct() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Hand",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFont.html:2002,Availability,error,error,2002,"st TObject* obj) const; TGTextLayout*ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); voidDrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; voidDrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); FontAttributes_tGetFontAttributes() const; FontH_tGetFontHandle() const; voidGetFontMetrics(FontMetrics_t* m) const; FontStruct_tGetFontStruct() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::In",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFont.html:1102,Integrability,wrap,wrapLength,1102," virtual~TGFont(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; TGTextLayout*ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); voidDrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; voidDrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t*",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFont.html:10133,Integrability,wrap,wrapper,10133," the characters. The return value is the number of characters from source that fit into; the span that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Computes how much space the given simple string needs. The return value is the width (in pixels) of the given string. string -- String whose width will be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen(). Int_t XTextWidth(const char* string, Int_t numChars = -1) const; Return text widht in pixels. void UnderlineChars(Drawable_t dst, GContext_t gc, const char* string, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; This procedure draws an underline for a given range of characters in a; given string. It doesn't draw the characters (which are assumed to have; been displayed previously); it just draws the underline. This procedure; would mainly be used to quickly underline a few characters without having; to construct an underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which t",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFont.html:10175,Integrability,interface,interface,10175," the characters. The return value is the number of characters from source that fit into; the span that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Computes how much space the given simple string needs. The return value is the width (in pixels) of the given string. string -- String whose width will be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen(). Int_t XTextWidth(const char* string, Int_t numChars = -1) const; Return text widht in pixels. void UnderlineChars(Drawable_t dst, GContext_t gc, const char* string, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; This procedure draws an underline for a given range of characters in a; given string. It doesn't draw the characters (which are assumed to have; been displayed previously); it just draws the underline. This procedure; would mainly be used to quickly underline a few characters without having; to construct an underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which t",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFont.html:11498,Integrability,wrap,wrapLength,11498,"d UnderlineChars(Drawable_t dst, GContext_t gc, const char* string, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; This procedure draws an underline for a given range of characters in a; given string. It doesn't draw the characters (which are assumed to have; been displayed previously); it just draws the underline. This procedure; would mainly be used to quickly underline a few characters without having; to construct an underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which to draw.; gc -- Graphics context for actually drawing line.; string -- String containing characters to be underlined or overstruck.; x, y -- Coordinates at which first character of string is drawn.; firstChar -- Index of first character.; lastChar -- Index of one after the last character. TGTextLayout * ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; Computes the amount of screen space needed to display a multi-line,; justified string of text. Records all the measurements that were done; to determine to size and positioning of the individual lines of text;; this information can be used by the TGTextLayout::DrawText() procedure; to display the text quickly (without remeasuring it). This procedure is useful for simple widgets that want to display; single-font, multi-line text and want TGFont to handle the details. The return value is a TGTextLayout token that holds the measurement; information for the given string. The token is only valid for the given; string. If the string is freed, the token is no longer valid and must; also be deleted. The dimensions of the screen area needed to display the text are stored; in *width and *height. string -- String whose dimensions are to be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen().; wrapLength -- Longest permissible lin",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFont.html:12509,Integrability,wrap,wrapLength,12509,", UInt_t* width, UInt_t* height) const; Computes the amount of screen space needed to display a multi-line,; justified string of text. Records all the measurements that were done; to determine to size and positioning of the individual lines of text;; this information can be used by the TGTextLayout::DrawText() procedure; to display the text quickly (without remeasuring it). This procedure is useful for simple widgets that want to display; single-font, multi-line text and want TGFont to handle the details. The return value is a TGTextLayout token that holds the measurement; information for the given string. The token is only valid for the given; string. If the string is freed, the token is no longer valid and must; also be deleted. The dimensions of the screen area needed to display the text are stored; in *width and *height. string -- String whose dimensions are to be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen().; wrapLength -- Longest permissible line length, in pixels. <= 0 means no; automatic wrapping: just let lines get as long as needed.; justify -- How to justify lines.; flags -- Flag bits OR-ed together. kTextIgnoreTabs means that tab; characters should not be expanded. kTextIgnoreNewlines; means that newline characters should not cause a line break.; width -- Filled with width of string.; height -- Filled with height of string. LayoutChunk_t * NewChunk(TGTextLayout* layout, int* maxPtr, const char* start, int numChars, int curX, int newX, int y) const; Helper function for ComputeTextLayout(). Encapsulates a measured set of; characters in a chunk that can be quickly drawn. Returns a pointer to the new chunk in the text layout. The text layout is; reallocated to hold more chunks as necessary. Currently, ComputeTextLayout() stores contiguous ranges of ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFont.html:12592,Integrability,wrap,wrapping,12592,"een space needed to display a multi-line,; justified string of text. Records all the measurements that were done; to determine to size and positioning of the individual lines of text;; this information can be used by the TGTextLayout::DrawText() procedure; to display the text quickly (without remeasuring it). This procedure is useful for simple widgets that want to display; single-font, multi-line text and want TGFont to handle the details. The return value is a TGTextLayout token that holds the measurement; information for the given string. The token is only valid for the given; string. If the string is freed, the token is no longer valid and must; also be deleted. The dimensions of the screen area needed to display the text are stored; in *width and *height. string -- String whose dimensions are to be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen().; wrapLength -- Longest permissible line length, in pixels. <= 0 means no; automatic wrapping: just let lines get as long as needed.; justify -- How to justify lines.; flags -- Flag bits OR-ed together. kTextIgnoreTabs means that tab; characters should not be expanded. kTextIgnoreNewlines; means that newline characters should not cause a line break.; width -- Filled with width of string.; height -- Filled with height of string. LayoutChunk_t * NewChunk(TGTextLayout* layout, int* maxPtr, const char* start, int numChars, int curX, int newX, int y) const; Helper function for ComputeTextLayout(). Encapsulates a measured set of; characters in a chunk that can be quickly drawn. Returns a pointer to the new chunk in the text layout. The text layout is; reallocated to hold more chunks as necessary. Currently, ComputeTextLayout() stores contiguous ranges of ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFont.html:9236,Modifiability,extend,extends,9236,"If the font does not exist on the printer, the print job will fail at; print time. Given a ""reasonable"" Postscript printer, the following; TGFont font families should print correctly:. Avant Garde, Arial, Bookman, Courier, Courier New, Geneva,; Helvetica, Monaco, New Century Schoolbook, New York,; Palatino, Symbol, Times, Times New Roman, Zapf Chancery,; and Zapf Dingbats. Any other TGFont font families may not print correctly because the; computed Postscript font name may be incorrect. dst -- Pointer to an initialized TString object to which the name of the; Postscript font that corresponds to the font will be appended. Int_t MeasureChars(const char* source, Int_t numChars, Int_t maxLength, Int_t flags, Int_t* length) const; Determine the number of characters from the string that will fit in the; given horizontal span. The measurement is done under the assumption that; DrawChars() will be used to actually display the characters. The return value is the number of characters from source that fit into; the span that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Comp",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFont.html:14436,Safety,sanity check,sanity check,14436,"""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 35912 2010-09-30 13:43:06Z couet $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFont.html:10237,Usability,simpl,simple,10237,"n that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Computes how much space the given simple string needs. The return value is the width (in pixels) of the given string. string -- String whose width will be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen(). Int_t XTextWidth(const char* string, Int_t numChars = -1) const; Return text widht in pixels. void UnderlineChars(Drawable_t dst, GContext_t gc, const char* string, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; This procedure draws an underline for a given range of characters in a; given string. It doesn't draw the characters (which are assumed to have; been displayed previously); it just draws the underline. This procedure; would mainly be used to quickly underline a few characters without having; to construct an underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which to draw.; gc -- Graphics context for actually drawing line.; string -- String containing charact",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFont.html:11942,Usability,simpl,simple,11942,"n underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which to draw.; gc -- Graphics context for actually drawing line.; string -- String containing characters to be underlined or overstruck.; x, y -- Coordinates at which first character of string is drawn.; firstChar -- Index of first character.; lastChar -- Index of one after the last character. TGTextLayout * ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; Computes the amount of screen space needed to display a multi-line,; justified string of text. Records all the measurements that were done; to determine to size and positioning of the individual lines of text;; this information can be used by the TGTextLayout::DrawText() procedure; to display the text quickly (without remeasuring it). This procedure is useful for simple widgets that want to display; single-font, multi-line text and want TGFont to handle the details. The return value is a TGTextLayout token that holds the measurement; information for the given string. The token is only valid for the given; string. If the string is freed, the token is no longer valid and must; also be deleted. The dimensions of the screen area needed to display the text are stored; in *width and *height. string -- String whose dimensions are to be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen().; wrapLength -- Longest permissible line length, in pixels. <= 0 means no; automatic wrapping: just let lines get as long as needed.; justify -- How to justify lines.; flags -- Flag bits OR-ed together. kTextIgnoreTabs means that tab; characters should not be expanded. kTextIgnoreNewlines; means that newline characters should not cause a line break.; width -- Filled with width of string.; height -- Filled with height of string. LayoutChunk_t * NewChunk(TGTextLayout* l",MatchSource.WIKI,root/html530/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFont.html
https://root.cern/root/html530/TGFontDialog.html:379,Availability,avail,available,379,". TGFontDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontDialog. class TGFontDialog: public TGTransientFrame. TGFontDialog. Font selection dialog, allowing to select one in the list of available fonts; in the system. Function Members (Methods); public:. TGFontDialog(const TGWindow* parent = 0, const TGWindow* t = 0, TGFontDialog::FontProp_t* fontProp = 0, const TString& sample = """", char** fontList = 0, Bool_t wait = kTRUE); virtual~TGFontDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAlignSelected(Int_t a)SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidColorSelected(Pixel_t c)SIGNAL ; virtual Int_tTObject::Compare(const TObject* obj) c",MatchSource.WIKI,root/html530/TGFontDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontDialog.html
https://root.cern/root/html530/TGFontDialog.html:4678,Availability,error,error,4678,"gnal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableAlign(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFontSelected(char* font)SIGNAL ; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const",MatchSource.WIKI,root/html530/TGFontDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontDialog.html
https://root.cern/root/html530/TGFontDialog.html:4762,Availability,error,error,4762,"bject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableAlign(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFontSelected(char* font)SIGNAL ; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompos",MatchSource.WIKI,root/html530/TGFontDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontDialog.html
https://root.cern/root/html530/TGFontDialog.html:19395,Availability,mask,mask,19395,,MatchSource.WIKI,root/html530/TGFontDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontDialog.html
https://root.cern/root/html530/TGFontPool.html:1553,Availability,error,error,1553," TGFontPool(TGClient* client); virtual~TGFontPool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGFont*FindFont(FontStruct_t font) const; TGFont*FindFontByHandle(FontH_t font) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const;",MatchSource.WIKI,root/html530/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontPool.html
https://root.cern/root/html530/TGFontPool.html:1637,Availability,error,error,1637," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGFont*FindFont(FontStruct_t font) const; TGFont*FindFontByHandle(FontH_t font) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeAttributeInfo(char** info); voidFreeFont(const TGFont* font); voidFreeFontFamilies(char** f); char**GetAttributeInfo(const FontAttributes_t* fa); TGClient*TGObject::GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGFont*GetFont(const TGFont* font); TGFont*GetFont(FontStruct_t font); TGFont*GetFont(const char* font, Bool_t fixedDefault = kTRUE); TGFont*GetFont(const char* family, Int_t ptsize, Int_t weight, Int_t slant); char**GetFontFamilies(); virtual const char*TObject::GetIconName() const; Handle_tTGObject::GetId() const; virtual const char*TObject::GetName() cons",MatchSource.WIKI,root/html530/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontPool.html
https://root.cern/root/html530/TGFontPool.html:7173,Availability,error,error,7173,"ontPool& fp). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGClient*TGObject::fClientConnection to display server; Handle_tTGObject::fIdX11/Win32 Window identifier. private:. THashTable*fListTGFont objects pool; THashTable*fNamedTableMap a name to a set of attributes for a font; THashTable*fUidTableHash table for some used string values like family names, etc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFontPool(TGClient* client); Create a font pool. ~TGFontPool(); Cleanup font pool. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get the specified font.; The font can be one of the following forms:; XLFD (see X documentation); ""Family [size [style] [style ...]]""; Returns 0 if error or no font can be found.; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. TGFont * GetFont(const TGFont* font); Use font, i.e. increases ref count of specified font. Returns 0; if font is not found. TGFont * GetFont(FontStruct_t font); Use font, i.e. increases ref count of specified font. TGFont * GetFont(const char* family, Int_t ptsize, Int_t weight, Int_t slant); Returns font specified bay family, pixel/point size, weight and slant; negative value of ptsize means size in pixels; positive value of ptsize means size in points. For example:; TGFont *font = fpool->GetFont(""helvetica"", -9, kFontWeightNormal, kFontSlantRoman);; font->Print();. void FreeFont(const TGFont* font); Free font. If ref count is 0 delete font. TGFont * FindFont(FontStruct_t font) const; Find font based on its font struct. Returns 0 if font is not found. TGFont * FindFontByHandle(FontH_t font) const; Find font based on its font handle. Returns ",MatchSource.WIKI,root/html530/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontPool.html
https://root.cern/root/html530/TGFontPool.html:11407,Availability,avail,available,11407,"he table; if strKey was not equal to any of the string keys in the table. const char * FindStateString(const FontStateMap_t* map, int numKey); Given a lookup table, map a number to a string in the table. If numKey was equal to the numeric key of one of the elements in the; table, returns the string key of that element. Returns NULL if numKey; was not equal to any of the numeric keys in the table. Bool_t FieldSpecified(const char* field); Helper function for ParseXLFD(). Determines if a field in the XLFD was; set to a non-null, non-don't-care value. The return value is kFALSE if the field in the XLFD was not set and; should be ignored, kTRUE otherwise. field -- The field of the XLFD to check. Strictly speaking, only when; the string is ""*"" does it mean don't-care. However, an; unspecified or question mark is also interpreted as don't-care. const char * NameOfFont(TGFont* font); Given a font, return a textual string identifying it. char ** GetFontFamilies(); Return information about the font families that are available on the; current display. An array of strings is returned holding a list of all the available font; families. The array is terminated with a NULL pointer. void FreeFontFamilies(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font ",MatchSource.WIKI,root/html530/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontPool.html
https://root.cern/root/html530/TGFontPool.html:11500,Availability,avail,available,11500,"ing(const FontStateMap_t* map, int numKey); Given a lookup table, map a number to a string in the table. If numKey was equal to the numeric key of one of the elements in the; table, returns the string key of that element. Returns NULL if numKey; was not equal to any of the numeric keys in the table. Bool_t FieldSpecified(const char* field); Helper function for ParseXLFD(). Determines if a field in the XLFD was; set to a non-null, non-don't-care value. The return value is kFALSE if the field in the XLFD was not set and; should be ignored, kTRUE otherwise. field -- The field of the XLFD to check. Strictly speaking, only when; the string is ""*"" does it mean don't-care. However, an; unspecified or question mark is also interpreted as don't-care. const char * NameOfFont(TGFont* font); Given a font, return a textual string identifying it. char ** GetFontFamilies(); Return information about the font families that are available on the; current display. An array of strings is returned holding a list of all the available font; families. The array is terminated with a NULL pointer. void FreeFontFamilies(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font by the given name could not be found,; the return value is NULL. Every call to this procedure retur",MatchSource.WIKI,root/html530/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontPool.html
https://root.cern/root/html530/TGFontPool.html:12955,Deployability,release,released,12955,"Families(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font by the given name could not be found,; the return value is NULL. Every call to this procedure returns a new TGFont object, even if the; name has already been seen before. The caller should call FreeFont; when the font is no longer needed. TGFont * MakeFont(TGFont* font, FontStruct_t fontStruct, const char* fontName); Helper for GetNativeFont() and GetFontFromAttributes(). Creates and; intializes a new TGFont object. font -- If non-NULL, store the information in this existing TGFont; object, rather than creating a new one; the existing; contents of the font will be released. If NULL, a new; TGFont object is created.; fontStruct -- information about font.; fontName -- The string passed to TVirtualX::LoadQueryFont() to construct the; fontStruct. FontAttributes_t& operator=(const TGFontPool& fp). TGFontPool(const TGFontPool& fp). » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 35912 2010-09-30 13:43:06Z couet $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontPool.html
https://root.cern/root/html530/TGFontPool.html:11632,Energy Efficiency,allocate,allocated,11632,"eric key of one of the elements in the; table, returns the string key of that element. Returns NULL if numKey; was not equal to any of the numeric keys in the table. Bool_t FieldSpecified(const char* field); Helper function for ParseXLFD(). Determines if a field in the XLFD was; set to a non-null, non-don't-care value. The return value is kFALSE if the field in the XLFD was not set and; should be ignored, kTRUE otherwise. field -- The field of the XLFD to check. Strictly speaking, only when; the string is ""*"" does it mean don't-care. However, an; unspecified or question mark is also interpreted as don't-care. const char * NameOfFont(TGFont* font); Given a font, return a textual string identifying it. char ** GetFontFamilies(); Return information about the font families that are available on the; current display. An array of strings is returned holding a list of all the available font; families. The array is terminated with a NULL pointer. void FreeFontFamilies(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font by the given name could not be found,; the return value is NULL. Every call to this procedure returns a new TGFont object, even if the; name has already been seen before. The caller should call FreeFont; when the font is no longer need",MatchSource.WIKI,root/html530/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontPool.html
https://root.cern/root/html530/TGFontTypeComboBox.html:378,Availability,down,down,378,". TGFontTypeComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontTypeComboBox. class TGFontTypeComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGFontTypeComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t bask = GetWhitePixel()); virtual~TGFontTypeComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* me",MatchSource.WIKI,root/html530/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontTypeComboBox.html
https://root.cern/root/html530/TGFontTypeComboBox.html:615,Availability,down,down,615,". TGFontTypeComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontTypeComboBox. class TGFontTypeComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGFontTypeComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t bask = GetWhitePixel()); virtual~TGFontTypeComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* me",MatchSource.WIKI,root/html530/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontTypeComboBox.html
https://root.cern/root/html530/TGFontTypeComboBox.html:5150,Availability,error,error,5150," voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDime",MatchSource.WIKI,root/html530/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontTypeComboBox.html
https://root.cern/root/html530/TGFontTypeComboBox.html:5234,Availability,error,error,5234,"* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGComboBox::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultW",MatchSource.WIKI,root/html530/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontTypeComboBox.html
https://root.cern/root/html530/TGFontTypeComboBox.html:19270,Availability,down,down,19270,,MatchSource.WIKI,root/html530/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontTypeComboBox.html
https://root.cern/root/html530/TGFontTypeComboBox.html:19425,Availability,mask,mask,19425,,MatchSource.WIKI,root/html530/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFontTypeComboBox.html
https://root.cern/root/html530/TGFrame.html:5010,Availability,error,error,5010,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tGetBackground() const; static const TGGC&GetBckgndGC(); static const TGGC&GetBlackGC(); static Pixel_tGetBlackPixel(); Int_tGetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tGetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tGetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*GetDNDData(Atom_t); virtual Int_tGetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tGetDropType() const; static Long_tTObject::GetDtorOnly(); vi",MatchSource.WIKI,root/html530/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrame.html
https://root.cern/root/html530/TGFrame.html:5094,Availability,error,error,5094,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tGetBackground() const; static const TGGC&GetBckgndGC(); static const TGGC&GetBlackGC(); static Pixel_tGetBlackPixel(); Int_tGetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tGetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tGetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*GetDNDData(Atom_t); virtual Int_tGetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tGetDropType() const; static Long_tTObject::GetDtorOnly(); virtual UInt_tTGWindow::GetEditDisabled() const; UInt_tGetEventMask() const; virtual P",MatchSource.WIKI,root/html530/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrame.html
https://root.cern/root/html530/TGFrame.html:15140,Availability,mask,mask,15140,"ed; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Pixel_tfBackgroundframe background color; Int_tfBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tfDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tfEventMaskcurrenty active event mask; TGFrameElement*fFEpointer to frame element; UInt_tfHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tfMaxHeightmaximal frame height; UInt_tfMaxWidthmaximal frame width; UInt_tfMinHeightminimal frame height; UInt_tfMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tfOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tfWidthframe width; Int_tfXframe x position; Int_tfYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*fgBckgndGC; static const TGGC*fgBlackGC; static Pixel_tfgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tfgDbw; static Int_tfgDbx; static Int_tfgDby; static Pixel_tfgDefaultFrameBackground; static Pixel_tfgDefaultSelectedBackground; static const TGGC*fgHilightGC; static Bool_tfgInit; static UInt_tfgLastButton; static Time_tfgLastClick; static const TGGC*fgShadowGC; static UInt_tfgUserColor; static const TGGC*fgWhiteGC; static Pixel_tfgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back =",MatchSource.WIKI,root/html530/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrame.html
https://root.cern/root/html530/TGFrame.html:23808,Deployability,update,update,23808,"Bool_t = kTRUE); {}. Bool_t IsLayoutBroken() const; { return kFALSE; }. void SetCleanup(Int_t = kLocalCleanup); { /* backward compatebility */ }. UInt_t GetWidth() const; { return fWidth; }. UInt_t GetHeight() const; { return fHeight; }. UInt_t GetMinWidth() const; { return fMinWidth; }. UInt_t GetMinHeight() const; { return fMinHeight; }. UInt_t GetMaxWidth() const; { return fMaxWidth; }. UInt_t GetMaxHeight() const; { return fMaxHeight; }. TGDimension GetSize() const; { return TGDimension(fWidth, fHeight); }. Int_t GetX() const; { return fX; }. Int_t GetY() const; { return fY; }. Int_t GetBorderWidth() const; { return fBorderWidth; }. TGFrameElement * GetFrameElement() const; { return fFE; }. void SetFrameElement(TGFrameElement* fe); { fFE = fe; }. Bool_t Contains(Int_t x, Int_t y) const; { return ((x >= 0) && (x < (Int_t)fWidth) && (y >= 0) && (y < (Int_t)fHeight)); }. TGFrame * GetFrameFromPoint(Int_t x, Int_t y); { return (Contains(x, y) ? this : 0); }. void SetX(Int_t x); Modifiers (without graphic update). { fX = x; }. void SetY(Int_t y); { fY = y; }. void SetWidth(UInt_t w); { fWidth = w; }. void SetHeight(UInt_t h); { fHeight = h; }. void SetMinWidth(UInt_t w); { fMinWidth = w; }. void SetMinHeight(UInt_t h); { fMinHeight = h; }. void SetMaxWidth(UInt_t w); { fMaxWidth = w; }. void SetMaxHeight(UInt_t h); { fMaxHeight = h; }. void SetSize(const TGDimension& s); { fWidth = s.fWidth; fHeight = s.fHeight; }. void Delete(Option_t* = """"); dummy to remove from context menu. { }. TObject * DrawClone(Option_t* = """") const; { return 0; }. void DrawClass() const; { }. void Dump() const; { }. void Inspect() const; { }. void SetDrawOption(Option_t* = """"); { }. void SetDNDSource(Bool_t onoff); drag and drop... { if (onoff) fDNDState |= kIsDNDSource; else fDNDState &= ~kIsDNDSource; }. void SetDNDTarget(Bool_t onoff); { if (onoff) fDNDState |= kIsDNDTarget; else fDNDState &= ~kIsDNDTarget; }. Bool_t IsDNDSource() const; { return fDNDState & kIsDNDSource; }. Bool_t IsDNDT",MatchSource.WIKI,root/html530/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrame.html
https://root.cern/root/html530/TGFrame.html:18834,Integrability,message,message,18834," the events the frame should handle. void RemoveInput(UInt_t emask); Remove events specified in emask from the events the frame should handle. void Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); Draw 3D rectangle on the frame border. void DrawBorder(); Draw frame border. void DoRedraw(); Redraw the frame. Bool_t HandleConfigureNotify(Event_t* event); This event is generated when the frame is resized. Bool_t HandleEvent(Event_t* event); Handle all frame events. Events are dispatched to the specific; event handlers. TGDimension GetDefaultSize() const; std::cout << fWidth << ""x"" << fHeight << std::endl;. void Move(Int_t x, Int_t y); Move frame. void Resize(UInt_t w = 0, UInt_t h = 0); Resize the frame.; If w=0 && h=0 - Resize to deafult size. void Resize(TGDimension size); Resize the frame. void MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); Move and/or resize the frame.; If w=0 && h=0 - Resize to deafult size. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. Bool_t HandleClientMessage(Event_t* event); Handle a client message. Client messages are the ones sent via; TGFrame::SendMessage (typically by widgets). ULong_t GetDefaultFrameBackground(); Get default frame background. ULong_t GetDefaultSelectedBackground(); Get default selected frame background. ULong_t GetWhitePixel(); Get white pixel value. ULong_t GetBlackPixel(); Get black pixel value. const TGGC & GetBlackGC(); Get black graphics context. const TGGC & GetWhiteGC(); Get white graphics context. const TGGC & GetHilightGC(); Get highlight color graphics context. const TGGC & GetShadowGC(); Get shadow color graphics context. const TGGC & GetBckgndGC(); Get background color graphics context. Time_t GetLastClick(); Get time of last mouse click. void Print(Option_t* option = """") const; Print window id. void SetDragType(Int_t type); SetDragT",MatchSource.WIKI,root/html530/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrame.html
https://root.cern/root/html530/TGFrame.html:18903,Integrability,message,message,18903,"he events the frame should handle. void Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); Draw 3D rectangle on the frame border. void DrawBorder(); Draw frame border. void DoRedraw(); Redraw the frame. Bool_t HandleConfigureNotify(Event_t* event); This event is generated when the frame is resized. Bool_t HandleEvent(Event_t* event); Handle all frame events. Events are dispatched to the specific; event handlers. TGDimension GetDefaultSize() const; std::cout << fWidth << ""x"" << fHeight << std::endl;. void Move(Int_t x, Int_t y); Move frame. void Resize(UInt_t w = 0, UInt_t h = 0); Resize the frame.; If w=0 && h=0 - Resize to deafult size. void Resize(TGDimension size); Resize the frame. void MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); Move and/or resize the frame.; If w=0 && h=0 - Resize to deafult size. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. Bool_t HandleClientMessage(Event_t* event); Handle a client message. Client messages are the ones sent via; TGFrame::SendMessage (typically by widgets). ULong_t GetDefaultFrameBackground(); Get default frame background. ULong_t GetDefaultSelectedBackground(); Get default selected frame background. ULong_t GetWhitePixel(); Get white pixel value. ULong_t GetBlackPixel(); Get black pixel value. const TGGC & GetBlackGC(); Get black graphics context. const TGGC & GetWhiteGC(); Get white graphics context. const TGGC & GetHilightGC(); Get highlight color graphics context. const TGGC & GetShadowGC(); Get shadow color graphics context. const TGGC & GetBckgndGC(); Get background color graphics context. Time_t GetLastClick(); Get time of last mouse click. void Print(Option_t* option = """") const; Print window id. void SetDragType(Int_t type); SetDragType. void SetDropType(Int_t type); SetDropType. Int_t GetDragType() const; Returns drag source type.; If fram",MatchSource.WIKI,root/html530/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrame.html
https://root.cern/root/html530/TGFrame.html:19007,Integrability,message,message,19007," x, Int_t y, UInt_t w, UInt_t h); Draw 3D rectangle on the frame border. void DrawBorder(); Draw frame border. void DoRedraw(); Redraw the frame. Bool_t HandleConfigureNotify(Event_t* event); This event is generated when the frame is resized. Bool_t HandleEvent(Event_t* event); Handle all frame events. Events are dispatched to the specific; event handlers. TGDimension GetDefaultSize() const; std::cout << fWidth << ""x"" << fHeight << std::endl;. void Move(Int_t x, Int_t y); Move frame. void Resize(UInt_t w = 0, UInt_t h = 0); Resize the frame.; If w=0 && h=0 - Resize to deafult size. void Resize(TGDimension size); Resize the frame. void MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); Move and/or resize the frame.; If w=0 && h=0 - Resize to deafult size. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. Bool_t HandleClientMessage(Event_t* event); Handle a client message. Client messages are the ones sent via; TGFrame::SendMessage (typically by widgets). ULong_t GetDefaultFrameBackground(); Get default frame background. ULong_t GetDefaultSelectedBackground(); Get default selected frame background. ULong_t GetWhitePixel(); Get white pixel value. ULong_t GetBlackPixel(); Get black pixel value. const TGGC & GetBlackGC(); Get black graphics context. const TGGC & GetWhiteGC(); Get white graphics context. const TGGC & GetHilightGC(); Get highlight color graphics context. const TGGC & GetShadowGC(); Get shadow color graphics context. const TGGC & GetBckgndGC(); Get background color graphics context. Time_t GetLastClick(); Get time of last mouse click. void Print(Option_t* option = """") const; Print window id. void SetDragType(Int_t type); SetDragType. void SetDropType(Int_t type); SetDropType. Int_t GetDragType() const; Returns drag source type.; If frame is not ""draggable"" - return zero. Int_t GetDropType() const; Returns dro",MatchSource.WIKI,root/html530/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrame.html
https://root.cern/root/html530/TGFrame.html:19023,Integrability,message,messages,19023," DrawBorder(); Draw frame border. void DoRedraw(); Redraw the frame. Bool_t HandleConfigureNotify(Event_t* event); This event is generated when the frame is resized. Bool_t HandleEvent(Event_t* event); Handle all frame events. Events are dispatched to the specific; event handlers. TGDimension GetDefaultSize() const; std::cout << fWidth << ""x"" << fHeight << std::endl;. void Move(Int_t x, Int_t y); Move frame. void Resize(UInt_t w = 0, UInt_t h = 0); Resize the frame.; If w=0 && h=0 - Resize to deafult size. void Resize(TGDimension size); Resize the frame. void MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); Move and/or resize the frame.; If w=0 && h=0 - Resize to deafult size. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. Bool_t HandleClientMessage(Event_t* event); Handle a client message. Client messages are the ones sent via; TGFrame::SendMessage (typically by widgets). ULong_t GetDefaultFrameBackground(); Get default frame background. ULong_t GetDefaultSelectedBackground(); Get default selected frame background. ULong_t GetWhitePixel(); Get white pixel value. ULong_t GetBlackPixel(); Get black pixel value. const TGGC & GetBlackGC(); Get black graphics context. const TGGC & GetWhiteGC(); Get white graphics context. const TGGC & GetHilightGC(); Get highlight color graphics context. const TGGC & GetShadowGC(); Get shadow color graphics context. const TGGC & GetBckgndGC(); Get background color graphics context. Time_t GetLastClick(); Get time of last mouse click. void Print(Option_t* option = """") const; Print window id. void SetDragType(Int_t type); SetDragType. void SetDropType(Int_t type); SetDropType. Int_t GetDragType() const; Returns drag source type.; If frame is not ""draggable"" - return zero. Int_t GetDropType() const; Returns drop target type.; If frame cannot accept drop - return zero. void StartGuiBuil",MatchSource.WIKI,root/html530/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrame.html
https://root.cern/root/html530/TGFrame.html:1355,Testability,log,logically,1355,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); voidAddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = ",MatchSource.WIKI,root/html530/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrame.html
https://root.cern/root/html530/TGFrame.html:557,Usability,simpl,simple,557,". TGFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFrame. class TGFrame: public TGWindow, public TQObject. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); voidAddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); v",MatchSource.WIKI,root/html530/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrame.html
https://root.cern/root/html530/TGFrameElement.html:1432,Availability,error,error,1432,"meElement(); TGFrameElement(TGFrame* f, TGLayoutHints* l); virtual~TGFrameElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/TGFrameElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrameElement.html
https://root.cern/root/html530/TGFrameElement.html:1516,Availability,error,error,1516," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html530/TGFrameElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrameElement.html
https://root.cern/root/html530/TGFrameElementPack.html:1347,Availability,error,error,1347,"k(TGFrame* frame, TGLayoutHints* lh = 0, Float_t weight = 1); ~TGFrameElementPack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/TGFrameElementPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrameElementPack.html
https://root.cern/root/html530/TGFrameElementPack.html:1431,Availability,error,error,1431," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html530/TGFrameElementPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrameElementPack.html
https://root.cern/root/html530/TGFrameElementPack.html:5336,Performance,cache,cached,5336,"Members(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGFrameElementPack(const TGFrameElementPack&); TGFrameElementPack&operator=(const TGFrameElementPack&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TGFrame*TGFrameElement::fFrameframe used in layout; TGLayoutHints*TGFrameElement::fLayoutlayout hints used in layout; TGFrameElementPack*fSplitFE! cached varaible for optimisation; Int_tTGFrameElement::fStateEFrameState defined in TGFrame.h; Float_tfWeightrelative weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFrameElementPack(const TGFrameElementPack& ). TGFrameElementPack& operator=(const TGFrameElementPack& ). TGFrameElementPack(TGFrame* frame, TGLayoutHints* lh = 0, Float_t weight = 1); { }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TGPack.h 29129 2009-06-22 09:39:20Z brun $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGFrameElementPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFrameElementPack.html
https://root.cern/root/html530/TGFSComboBox.html:4605,Availability,error,error,4605," voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDime",MatchSource.WIKI,root/html530/TGFSComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFSComboBox.html
https://root.cern/root/html530/TGFSComboBox.html:4689,Availability,error,error,4689,"* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGComboBox::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultW",MatchSource.WIKI,root/html530/TGFSComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFSComboBox.html
https://root.cern/root/html530/TGFSComboBox.html:18751,Availability,down,down,18751,,MatchSource.WIKI,root/html530/TGFSComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFSComboBox.html
https://root.cern/root/html530/TGFSComboBox.html:18906,Availability,mask,mask,18906,,MatchSource.WIKI,root/html530/TGFSComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGFSComboBox.html
https://root.cern/root/html530/TGGC.html:1462,Availability,error,error,1462,"es_t* values = 0); TGGC(const TGGC& g); virtual~TGGC(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArcMode() const; const GCValues_t*GetAttributes() const; Pixel_tGetBackground() const; Int_tGetCapStyle() const; Pixmap_tGetClipMask() const; Int_tGetClipXOrigin() const; Int_tGetClipYOrigin() const; const char*GetDashes() const; Int_tGetDashLen() const; Int_tGetDashOffset() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFillRule() const; Int_tGetFillStyle() const; FontH_tGetFont() const; Pixel_tGetForeground() const; EGraphicsFunctionGetFunction() const; GContext_tGetGC() const; Bool_tGetGraphicsExposures() const; virtual const char*TObject::GetIconName() const; Int_tGetJ",MatchSource.WIKI,root/html530/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGC.html
https://root.cern/root/html530/TGGC.html:1546,Availability,error,error,1546,"const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArcMode() const; const GCValues_t*GetAttributes() const; Pixel_tGetBackground() const; Int_tGetCapStyle() const; Pixmap_tGetClipMask() const; Int_tGetClipXOrigin() const; Int_tGetClipYOrigin() const; const char*GetDashes() const; Int_tGetDashLen() const; Int_tGetDashOffset() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFillRule() const; Int_tGetFillStyle() const; FontH_tGetFont() const; Pixel_tGetForeground() const; EGraphicsFunctionGetFunction() const; GContext_tGetGC() const; Bool_tGetGraphicsExposures() const; virtual const char*TObject::GetIconName() const; Int_tGetJoinStyle() const; Int_tGetLineStyle() const; Int_tGetLineWidth() const; Mask_tGetMas",MatchSource.WIKI,root/html530/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGC.html
https://root.cern/root/html530/TGGC.html:7130,Availability,mask,mask,7130,"st; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGGC(GCValues_t* values, Bool_t calledByGCPool); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TStringGetMaskString() const; voidTObject::MakeZombie(); voidUpdateValues(GCValues_t* v). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TRefCnt::EReferenceFlag { kStaticInit; };. protected:. GContext_tfContextgraphics context handle; UInt_tTRefCnt::fRefs(1 less than) number of references; GCValues_tfValuesgraphics context values + mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGC(GCValues_t* values, Bool_t calledByGCPool); Create a graphics context (only called via TGGCPool::GetGC()). TGGC(GCValues_t* values = 0); Create a graphics context, registers GC in GCPool. TGGC(const TGGC& g); Copy a graphics context. ~TGGC(); Delete graphics context. TGGC & operator=(const TGGC& rhs); Graphics context assignment operator. GContext_t operator()() const; Not inline due to a bug in g++ 2.96 20000731 (Red Hat Linux 7.0). void UpdateValues(GCValues_t* v); Update values + mask. void SetAttributes(GCValues_t* values); Set attributes as specified in the values structure. void SetFunction(EGraphicsFunction v); Set graphics context drawing function. void SetPlaneMask(ULong_t v); Set plane mask. void SetForeground(Pixel_t v); Set foreground color. void SetBackground(Pixel_t v); Set background color. void SetLine",MatchSource.WIKI,root/html530/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGC.html
https://root.cern/root/html530/TGGC.html:7720,Availability,mask,mask,7720,"its { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TRefCnt::EReferenceFlag { kStaticInit; };. protected:. GContext_tfContextgraphics context handle; UInt_tTRefCnt::fRefs(1 less than) number of references; GCValues_tfValuesgraphics context values + mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGC(GCValues_t* values, Bool_t calledByGCPool); Create a graphics context (only called via TGGCPool::GetGC()). TGGC(GCValues_t* values = 0); Create a graphics context, registers GC in GCPool. TGGC(const TGGC& g); Copy a graphics context. ~TGGC(); Delete graphics context. TGGC & operator=(const TGGC& rhs); Graphics context assignment operator. GContext_t operator()() const; Not inline due to a bug in g++ 2.96 20000731 (Red Hat Linux 7.0). void UpdateValues(GCValues_t* v); Update values + mask. void SetAttributes(GCValues_t* values); Set attributes as specified in the values structure. void SetFunction(EGraphicsFunction v); Set graphics context drawing function. void SetPlaneMask(ULong_t v); Set plane mask. void SetForeground(Pixel_t v); Set foreground color. void SetBackground(Pixel_t v); Set background color. void SetLineWidth(Int_t v); Set line width. void SetLineStyle(Int_t v); Set line style (kLineSolid, kLineOnOffDash, kLineDoubleDash). void SetCapStyle(Int_t v); Set cap style (kCapNotLast, kCapButt, kCapRound, kCapProjecting). void SetJoinStyle(Int_t v); Set line join style (kJoinMiter, kJoinRound, kJoinBevel). void SetFillStyle(Int_t v); Set fill style (kFillSolid, kFillTiled, kFillStippled,; kFillOpaeueStippled). void SetFillRule(Int_t v); Set fill rule (kEvenOddRule, kWindingRule). void SetTile(Pixmap_t v); Set tile pixmap for tiling operations. void SetStipple(Pixmap_t v); Set 1 plane pixmap for stippling. void SetTileStipXOrigin(Int_t ",MatchSource.WIKI,root/html530/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGC.html
https://root.cern/root/html530/TGGC.html:7937,Availability,mask,mask,7937,"ete; };; enum TRefCnt::EReferenceFlag { kStaticInit; };. protected:. GContext_tfContextgraphics context handle; UInt_tTRefCnt::fRefs(1 less than) number of references; GCValues_tfValuesgraphics context values + mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGC(GCValues_t* values, Bool_t calledByGCPool); Create a graphics context (only called via TGGCPool::GetGC()). TGGC(GCValues_t* values = 0); Create a graphics context, registers GC in GCPool. TGGC(const TGGC& g); Copy a graphics context. ~TGGC(); Delete graphics context. TGGC & operator=(const TGGC& rhs); Graphics context assignment operator. GContext_t operator()() const; Not inline due to a bug in g++ 2.96 20000731 (Red Hat Linux 7.0). void UpdateValues(GCValues_t* v); Update values + mask. void SetAttributes(GCValues_t* values); Set attributes as specified in the values structure. void SetFunction(EGraphicsFunction v); Set graphics context drawing function. void SetPlaneMask(ULong_t v); Set plane mask. void SetForeground(Pixel_t v); Set foreground color. void SetBackground(Pixel_t v); Set background color. void SetLineWidth(Int_t v); Set line width. void SetLineStyle(Int_t v); Set line style (kLineSolid, kLineOnOffDash, kLineDoubleDash). void SetCapStyle(Int_t v); Set cap style (kCapNotLast, kCapButt, kCapRound, kCapProjecting). void SetJoinStyle(Int_t v); Set line join style (kJoinMiter, kJoinRound, kJoinBevel). void SetFillStyle(Int_t v); Set fill style (kFillSolid, kFillTiled, kFillStippled,; kFillOpaeueStippled). void SetFillRule(Int_t v); Set fill rule (kEvenOddRule, kWindingRule). void SetTile(Pixmap_t v); Set tile pixmap for tiling operations. void SetStipple(Pixmap_t v); Set 1 plane pixmap for stippling. void SetTileStipXOrigin(Int_t v); X offset for tile or stipple operations. void SetTileStipYOrigin(Int_t v); Y offset for tile or stipple operations. void SetFont(FontH_t v); Set font. void SetSubwindowMode(Int_t v); Set sub window mode (kClipByChildre",MatchSource.WIKI,root/html530/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGC.html
https://root.cern/root/html530/TGGC.html:9519,Availability,mask,mask,9519,"ule, kWindingRule). void SetTile(Pixmap_t v); Set tile pixmap for tiling operations. void SetStipple(Pixmap_t v); Set 1 plane pixmap for stippling. void SetTileStipXOrigin(Int_t v); X offset for tile or stipple operations. void SetTileStipYOrigin(Int_t v); Y offset for tile or stipple operations. void SetFont(FontH_t v); Set font. void SetSubwindowMode(Int_t v); Set sub window mode (kClipByChildren, kIncludeInferiors). void SetGraphicsExposures(Bool_t v); True if graphics exposure should be generated. void SetClipXOrigin(Int_t v); X origin for clipping. void SetClipYOrigin(Int_t v); Y origin for clipping. void SetClipMask(Pixmap_t v); Bitmap for clipping. void SetDashOffset(Int_t v); Patterned/dashed line offset. void SetDashList(const char* v, Int_t len); Set dash pattern. First use SetDashOffset() if not 0. void SetArcMode(Int_t v); Set arc mode (kArcChord, kArcPieSlice). void Print(Option_t* option = """") const; Print graphics contexts info. TString GetMaskString() const; Returns GC mask as a string - used in SavePrimitive(). void SavePrimitive(ostream& out, Option_t* option = """"); Save graphics context info as a C++ statement(s) on output stream out. GContext_t GetGC() const; { return fContext; }. const GCValues_t * GetAttributes() const; { return &fValues; }. Mask_t GetMask() const; { return fValues.fMask; }. EGraphicsFunction GetFunction() const; { return fValues.fFunction; }. ULong_t GetPlaneMask() const; { return fValues.fPlaneMask; }. Pixel_t GetForeground() const; { return fValues.fForeground; }. Pixel_t GetBackground() const; { return fValues.fBackground; }. Int_t GetLineWidth() const; { return fValues.fLineWidth; }. Int_t GetLineStyle() const; { return fValues.fLineStyle; }. Pixmap_t GetTile() const; { return fValues.fTile; }. Pixmap_t GetStipple() const; { return fValues.fStipple; }. Int_t GetTileStipXOrigin() const; { return fValues.fTsXOrigin; }. Int_t GetTileStipYOrigin() const; { return fValues.fTsYOrigin; }. Int_t GetSubwindowMode() const; { return ",MatchSource.WIKI,root/html530/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGC.html
https://root.cern/root/html530/TGGCPool.html:1411,Availability,error,error,1411," TGGCPool(TGClient* client); virtual~TGGCPool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGGC*FindGC(const TGGC* gc); TGGC*FindGC(GContext_t gc); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); TGClient*TGObject::GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtor",MatchSource.WIKI,root/html530/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGCPool.html
https://root.cern/root/html530/TGGCPool.html:1495,Availability,error,error,1495," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGGC*FindGC(const TGGC* gc); TGGC*FindGC(GContext_t gc); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); TGClient*TGObject::GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGGC*GetGC(GContext_t gct); TGGC*GetGC(GCValues_t* values, Bool_t rw = kFALSE); virtual const char*TObject::GetIconName() const; Handle_tTGObject::GetId() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* ti",MatchSource.WIKI,root/html530/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGCPool.html
https://root.cern/root/html530/TGGCPool.html:6925,Availability,mask,masks,6925,"ndle_tTGObject::fIdX11/Win32 Window identifier. private:. THashTable*fListhash table of graphics contexts in pool. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGCPool(TGClient* client); Create graphics context pool. ~TGGCPool(); Delete graphics context pool. void ForceFreeGC(const TGGC* gc); Force remove graphics context from list. Is only called via ~TGGC(). void FreeGC(const TGGC* gc); Delete graphics context if it is not used anymore. void FreeGC(GContext_t gc); Delete graphics context if it is not used anymore. TGGC * FindGC(const TGGC* gc); Find graphics context. Returns 0 in case gc is not found. TGGC * FindGC(GContext_t gc); Find graphics context based on its GContext_t handle. Returns 0; in case gc is not found. TGGC * GetGC(GContext_t gct); returns graphics context based on its GContext_t handle. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get the best matching graphics context depending on values.; If rw is false only a readonly, not modifiable graphics context; is returned. If rw is true a new modifiable graphics context is; returned. Int_t MatchGC(const TGGC* gc, GCValues_t* values); Try to find matching graphics context. On success returns the amount; of matching bits (which may be zero if masks have no common bits),; -1 on failure (when there are common bits but not a single match). void UpdateGC(TGGC* gc, GCValues_t* values); Update graphics context with the values spcified in values->fMask. void Print(Option_t* option = """") const; List all graphics contexts in the pool. TGGC & operator=(const TGGCPool& gp). TGGCPool(const TGGCPool& gp); { }. » Author: Fons Rademakers 20/9/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGGC.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGCPool.html
https://root.cern/root/html530/TGGCPool.html:6960,Availability,failure,failure,6960,"ndle_tTGObject::fIdX11/Win32 Window identifier. private:. THashTable*fListhash table of graphics contexts in pool. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGCPool(TGClient* client); Create graphics context pool. ~TGGCPool(); Delete graphics context pool. void ForceFreeGC(const TGGC* gc); Force remove graphics context from list. Is only called via ~TGGC(). void FreeGC(const TGGC* gc); Delete graphics context if it is not used anymore. void FreeGC(GContext_t gc); Delete graphics context if it is not used anymore. TGGC * FindGC(const TGGC* gc); Find graphics context. Returns 0 in case gc is not found. TGGC * FindGC(GContext_t gc); Find graphics context based on its GContext_t handle. Returns 0; in case gc is not found. TGGC * GetGC(GContext_t gct); returns graphics context based on its GContext_t handle. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get the best matching graphics context depending on values.; If rw is false only a readonly, not modifiable graphics context; is returned. If rw is true a new modifiable graphics context is; returned. Int_t MatchGC(const TGGC* gc, GCValues_t* values); Try to find matching graphics context. On success returns the amount; of matching bits (which may be zero if masks have no common bits),; -1 on failure (when there are common bits but not a single match). void UpdateGC(TGGC* gc, GCValues_t* values); Update graphics context with the values spcified in values->fMask. void Print(Option_t* option = """") const; List all graphics contexts in the pool. TGGC & operator=(const TGGCPool& gp). TGGCPool(const TGGCPool& gp); { }. » Author: Fons Rademakers 20/9/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGGC.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGCPool.html
https://root.cern/root/html530/TGGCPool.html:6603,Integrability,depend,depending,6603,"ete; };. protected:. TGClient*TGObject::fClientConnection to display server; Handle_tTGObject::fIdX11/Win32 Window identifier. private:. THashTable*fListhash table of graphics contexts in pool. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGCPool(TGClient* client); Create graphics context pool. ~TGGCPool(); Delete graphics context pool. void ForceFreeGC(const TGGC* gc); Force remove graphics context from list. Is only called via ~TGGC(). void FreeGC(const TGGC* gc); Delete graphics context if it is not used anymore. void FreeGC(GContext_t gc); Delete graphics context if it is not used anymore. TGGC * FindGC(const TGGC* gc); Find graphics context. Returns 0 in case gc is not found. TGGC * FindGC(GContext_t gc); Find graphics context based on its GContext_t handle. Returns 0; in case gc is not found. TGGC * GetGC(GContext_t gct); returns graphics context based on its GContext_t handle. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get the best matching graphics context depending on values.; If rw is false only a readonly, not modifiable graphics context; is returned. If rw is true a new modifiable graphics context is; returned. Int_t MatchGC(const TGGC* gc, GCValues_t* values); Try to find matching graphics context. On success returns the amount; of matching bits (which may be zero if masks have no common bits),; -1 on failure (when there are common bits but not a single match). void UpdateGC(TGGC* gc, GCValues_t* values); Update graphics context with the values spcified in values->fMask. void Print(Option_t* option = """") const; List all graphics contexts in the pool. TGGC & operator=(const TGGCPool& gp). TGGCPool(const TGGCPool& gp); { }. » Author: Fons Rademakers 20/9/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGGC.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root/html530/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGCPool.html
https://root.cern/root/html530/TGGotoDialog.html:463,Availability,avail,available,463,". TGGotoDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGGotoDialog. class TGGotoDialog: public TGTransientFrame. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. TGGotoDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, Long_t* ret_code = 0, UInt_t options = kVerticalFrame); virtual~TGGotoDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare",MatchSource.WIKI,root/html530/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGotoDialog.html
https://root.cern/root/html530/TGGotoDialog.html:4656,Availability,error,error,4656,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGotoDialog.html
https://root.cern/root/html530/TGGotoDialog.html:4740,Availability,error,error,4740,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGotoDialog.html
https://root.cern/root/html530/TGGotoDialog.html:19099,Availability,mask,mask,19099,,MatchSource.WIKI,root/html530/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGotoDialog.html
https://root.cern/root/html530/TGGotoDialog.html:22957,Integrability,message,messages,22957,"WindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGotoDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, Long_t* ret_code = 0, UInt_t options = kVerticalFrame); Create a dialog to GoTo a specific line number. Returns -1 in; ret_code in case no valid line number was given or in case; cancel was pressed. If on input *ret_code is > 0 then this value; will be used as default value. ~TGGotoDialog(); Clean up goto dialog. void CloseWindow(); Close the dialog. On close the dialog will be deleted and cannot be; re-used. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process goto dialog widget messages. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGTextEditDialogs.h 25499 2008-09-22 19:54:46Z bellenot $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGotoDialog.html
https://root.cern/root/html530/TGGroupFrame.html:5552,Availability,error,error,5552,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() cons",MatchSource.WIKI,root/html530/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGroupFrame.html
https://root.cern/root/html530/TGGroupFrame.html:5636,Availability,error,error,5636,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame",MatchSource.WIKI,root/html530/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGroupFrame.html
https://root.cern/root/html530/TGGroupFrame.html:18519,Availability,mask,mask,18519,,MatchSource.WIKI,root/html530/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGroupFrame.html
https://root.cern/root/html530/TGGroupFrame.html:1361,Testability,log,logically,1361,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGGroupFrame(const TGWindow* p, TGString* title, UInt_t options = kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGGroupFrame(const TGWindow* p = 0, const char* title = 0, UInt_t options = kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGGroupFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::B",MatchSource.WIKI,root/html530/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGroupFrame.html
https://root.cern/root/html530/TGGroupFrame.html:563,Usability,simpl,simple,563,". TGGroupFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGGroupFrame. class TGGroupFrame: public TGCompositeFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGGroupFrame(const TGWindow* p, TGString* title, UInt_t options = kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGGroupFrame(const TGWindow* p = 0, const char* title = 0, UInt_t options = kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGGroupFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual",MatchSource.WIKI,root/html530/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGGroupFrame.html
https://root.cern/root/html530/TGHButtonGroup.html:2051,Availability,down,down,2051," ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGHButtonGroup(const TGWindow* parent, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGHButtonGroup",MatchSource.WIKI,root/html530/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHButtonGroup.html
https://root.cern/root/html530/TGHButtonGroup.html:6874,Availability,error,error,6874,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGButton*TGButtonGroup::Find(Int_t id) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGButton*TGButtonGroup::GetButton(Int_t id) const; TGClient*TGObject::GetClient() const; Int_tTGButtonGroup::GetCount() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGGroupFrame::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGGr",MatchSource.WIKI,root/html530/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHButtonGroup.html
https://root.cern/root/html530/TGHButtonGroup.html:6958,Availability,error,error,6958,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGButton*TGButtonGroup::Find(Int_t id) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGButton*TGButtonGroup::GetButton(Int_t id) const; TGClient*TGObject::GetClient() const; Int_tTGButtonGroup::GetCount() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGGroupFrame::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGGroupFrame::GetDefaultGC(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; ",MatchSource.WIKI,root/html530/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHButtonGroup.html
https://root.cern/root/html530/TGHButtonGroup.html:16345,Availability,down,down,16345,"GGroupFrame::Rename(const char* title)MENU ; virtual voidTGFrame::ReparentWindow(const TGWindow* p, Int_t x = 0, Int_t y = 0); virtual voidTGWindow::RequestFocus(); voidTObject::ResetBit(UInt_t f); virtual voidTGFrame::Resize(TGDimension size); virtual voidTGFrame::Resize(UInt_t w = 0, UInt_t h = 0); virtual voidTGObject::SaveAs(const char* filename = """", Option_t* option = """") const; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); virtual voidTGCompositeFrame::SavePrimitiveSubframes(ostream& out, Option_t* option = """"); voidTGFrame::SaveUserColor(ostream& out, Option_t*); virtual voidTGFrame::SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); virtual voidTGFrame::SetBackgroundColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTGButtonGroup::SetBorderDrawn(Bool_t enable = kTRUE); virtual voidTGButtonGroup::SetButton(Int_t id, Bool_t down = kTRUE); virtual voidTGCompositeFrame::SetCleanup(Int_t mode = kLocalCleanup); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidTGButtonGroup::SetExclusive(Bool_t flag = kTRUE); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGButtonGroup::SetLayoutHints(TGLayoutHints* l, TGButton* button = 0); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h);",MatchSource.WIKI,root/html530/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHButtonGroup.html
https://root.cern/root/html530/TGHButtonGroup.html:21241,Availability,mask,mask,21241,,MatchSource.WIKI,root/html530/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHButtonGroup.html
https://root.cern/root/html530/TGHButtonGroup.html:802,Deployability,toggle,toggle,802,". TGHButtonGroup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHButtonGroup. class TGHButtonGroup: public TGButtonGroup. The TGButtonGroup widget organizes TGButton widgets in a group. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> ",MatchSource.WIKI,root/html530/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHButtonGroup.html
https://root.cern/root/html530/TGHButtonGroup.html:2168,Deployability,release,released,2168,"parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGHButtonGroup(const TGWindow* parent, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGHButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeF",MatchSource.WIKI,root/html530/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHButtonGroup.html
https://root.cern/root/html530/TGHButtonGroup.html:1382,Modifiability,inherit,inherits,1382,"roup. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widg",MatchSource.WIKI,root/html530/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHButtonGroup.html
https://root.cern/root/html530/TGHButtonGroup.html:2524,Modifiability,inherit,inherits,2524,"th id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGHButtonGroup(const TGWindow* parent, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGHButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGButtonGroup::ButtonC",MatchSource.WIKI,root/html530/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHButtonGroup.html
https://root.cern/root/html530/TGHButtonGroup.html:2737,Modifiability,inherit,inherits,2737,"no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGHButtonGroup(const TGWindow* parent, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGHButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGButtonGroup::ButtonClicked(); virtual voidTGButtonGroup::ButtonPressed(); virtual voidTGButtonGroup::ButtonReleased(); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; v",MatchSource.WIKI,root/html530/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHButtonGroup.html
https://root.cern/root/html530/TGHeaderFrame.html:5275,Availability,error,error,5275,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHeaderFrame.html
https://root.cern/root/html530/TGHeaderFrame.html:5359,Availability,error,error,5359,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHeaderFrame.html
https://root.cern/root/html530/TGHeaderFrame.html:17797,Availability,mask,mask,17797,,MatchSource.WIKI,root/html530/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHeaderFrame.html
https://root.cern/root/html530/TGHeaderFrame.html:1365,Testability,log,logically,1365,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGHeaderFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGHeaderFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); vi",MatchSource.WIKI,root/html530/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHeaderFrame.html
https://root.cern/root/html530/TGHeaderFrame.html:567,Usability,simpl,simple,567,". TGHeaderFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHeaderFrame. class TGHeaderFrame: public TGHorizontalFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGHeaderFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGHeaderFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignal",MatchSource.WIKI,root/html530/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHeaderFrame.html
https://root.cern/root/html530/TGHorizontal3DLine.html:4180,Availability,error,error,4180,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html530/TGHorizontal3DLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHorizontal3DLine.html
https://root.cern/root/html530/TGHorizontal3DLine.html:4264,Availability,error,error,4264,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static",MatchSource.WIKI,root/html530/TGHorizontal3DLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHorizontal3DLine.html
https://root.cern/root/html530/TGHorizontal3DLine.html:15291,Availability,mask,mask,15291,"ngleKey; kOverwrite; kWriteDelete; };. protected:. Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Inc",MatchSource.WIKI,root/html530/TGHorizontal3DLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHorizontal3DLine.html
https://root.cern/root/html530/TGHorizontalFrame.html:5294,Availability,error,error,5294,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHorizontalFrame.html
https://root.cern/root/html530/TGHorizontalFrame.html:5378,Availability,error,error,5378,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHorizontalFrame.html
https://root.cern/root/html530/TGHorizontalFrame.html:17636,Availability,mask,mask,17636,,MatchSource.WIKI,root/html530/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHorizontalFrame.html
https://root.cern/root/html530/TGHorizontalFrame.html:1376,Testability,log,logically,1376,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGHorizontalFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGHorizontalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Cla",MatchSource.WIKI,root/html530/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHorizontalFrame.html
https://root.cern/root/html530/TGHorizontalFrame.html:578,Usability,simpl,simple,578,". TGHorizontalFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHorizontalFrame. class TGHorizontalFrame: public TGCompositeFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGHorizontalFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGHorizontalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObj",MatchSource.WIKI,root/html530/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHorizontalFrame.html
https://root.cern/root/html530/TGHorizontalLayout.html:804,Availability,down,downward,804,". TGHorizontalLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHorizontalLayout. class TGHorizontalLayout: public TGVerticalLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGHorizontalLayout(TGCompositeFrame* main); TGHorizontalLayout(const TGHorizontalLayout&); ~TGHorizontalLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual",MatchSource.WIKI,root/html530/TGHorizontalLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHorizontalLayout.html
https://root.cern/root/html530/TGHorizontalLayout.html:2349,Availability,error,error,2349,"eFrame* main); TGHorizontalLayout(const TGHorizontalLayout&); ~TGHorizontalLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root/html530/TGHorizontalLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHorizontalLayout.html
https://root.cern/root/html530/TGHorizontalLayout.html:2433,Availability,error,error,2433," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html530/TGHorizontalLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHorizontalLayout.html
https://root.cern/root/html530/TGHotString.html:328,Integrability,wrap,wraps,328,". TGHotString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHotString. class TGHotString: public TGString. TGString and TGHotString. TGString wraps a TString and adds some graphics routines like; drawing, size of string on screen depending on font, etc.; TGHotString is a string with a ""hot"" character unerlined. Function Members (Methods); public:. TGHotString(const char* s); TGHotString(const TGHotString&); ~TGHotString(); TString&TString::Append(const char* cs); TString&TString::Append(const TString& s); TString&TString::Append(const char* cs, Ssiz_t n); TString&TString::Append(const TString& s, Ssiz_t n); TString&TString::Append(char c, Ssiz_t rep = 1); Double_tTString::Atof() const; Int_tTString::Atoi() const; Long64_tTString::Atoll() const; Bool_tTString::BeginsWith(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::BeginsWith(const TString& pat, TString::ECaseCompare cmp = kExact) const; Ssiz_tTString::Capacity() const; Ssiz_tTString::Capacity(Ssiz_t n); TString&TString::Chop(); static TClass*Class(); voidTString::Clear(); intTString::CompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; intTString::CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TRegexp& pat) const; Bool_tTString::Contains(TPRegexp& pat) const; Bool_tTString::Contains(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TString& pat, TString::ECaseCompare cmp = kExact) const; TStringTString::Copy() const; Int_tTString::CountChar(Int_t c) const; const char*TString::Data() const; virtual voidDraw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); virtual voidDrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Bool_tTString::EndsWith(const char* pat, TStri",MatchSource.WIKI,root/html530/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHotString.html
https://root.cern/root/html530/TGHotString.html:367,Integrability,rout,routines,367,". TGHotString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHotString. class TGHotString: public TGString. TGString and TGHotString. TGString wraps a TString and adds some graphics routines like; drawing, size of string on screen depending on font, etc.; TGHotString is a string with a ""hot"" character unerlined. Function Members (Methods); public:. TGHotString(const char* s); TGHotString(const TGHotString&); ~TGHotString(); TString&TString::Append(const char* cs); TString&TString::Append(const TString& s); TString&TString::Append(const char* cs, Ssiz_t n); TString&TString::Append(const TString& s, Ssiz_t n); TString&TString::Append(char c, Ssiz_t rep = 1); Double_tTString::Atof() const; Int_tTString::Atoi() const; Long64_tTString::Atoll() const; Bool_tTString::BeginsWith(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::BeginsWith(const TString& pat, TString::ECaseCompare cmp = kExact) const; Ssiz_tTString::Capacity() const; Ssiz_tTString::Capacity(Ssiz_t n); TString&TString::Chop(); static TClass*Class(); voidTString::Clear(); intTString::CompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; intTString::CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TRegexp& pat) const; Bool_tTString::Contains(TPRegexp& pat) const; Bool_tTString::Contains(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TString& pat, TString::ECaseCompare cmp = kExact) const; TStringTString::Copy() const; Int_tTString::CountChar(Int_t c) const; const char*TString::Data() const; virtual voidDraw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); virtual voidDrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Bool_tTString::EndsWith(const char* pat, TStri",MatchSource.WIKI,root/html530/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHotString.html
https://root.cern/root/html530/TGHotString.html:416,Integrability,depend,depending,416,". TGHotString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHotString. class TGHotString: public TGString. TGString and TGHotString. TGString wraps a TString and adds some graphics routines like; drawing, size of string on screen depending on font, etc.; TGHotString is a string with a ""hot"" character unerlined. Function Members (Methods); public:. TGHotString(const char* s); TGHotString(const TGHotString&); ~TGHotString(); TString&TString::Append(const char* cs); TString&TString::Append(const TString& s); TString&TString::Append(const char* cs, Ssiz_t n); TString&TString::Append(const TString& s, Ssiz_t n); TString&TString::Append(char c, Ssiz_t rep = 1); Double_tTString::Atof() const; Int_tTString::Atoi() const; Long64_tTString::Atoll() const; Bool_tTString::BeginsWith(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::BeginsWith(const TString& pat, TString::ECaseCompare cmp = kExact) const; Ssiz_tTString::Capacity() const; Ssiz_tTString::Capacity(Ssiz_t n); TString&TString::Chop(); static TClass*Class(); voidTString::Clear(); intTString::CompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; intTString::CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TRegexp& pat) const; Bool_tTString::Contains(TPRegexp& pat) const; Bool_tTString::Contains(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TString& pat, TString::ECaseCompare cmp = kExact) const; TStringTString::Copy() const; Int_tTString::CountChar(Int_t c) const; const char*TString::Data() const; virtual voidDraw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); virtual voidDrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Bool_tTString::EndsWith(const char* pat, TStri",MatchSource.WIKI,root/html530/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHotString.html
https://root.cern/root/html530/TGHotString.html:8690,Integrability,wrap,wrap,8690,"nize(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); static Ssiz_tTString::Align(Ssiz_t s); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); static Ssiz_tTString::Recommend(Ssiz_t s). Data Members; public:. enum TString::[unnamed] { kAlignment; };; enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. protected:. charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next line. void DrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw the underline under the hot character. TGHotString(const char* s). Int_t GetHotChar() const; { return fHotChar; }. Int_t GetHotPos() const; { return fHotPos; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGString.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHotString.html
https://root.cern/root/html530/TGHotString.html:8217,Performance,cache,cache,8217,"') const; TSubStringTString::SubString(const char* pat, Ssiz_t start = 0, TString::ECaseCompare cmp = kExact) const; TObjArray*TString::Tokenize(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); static Ssiz_tTString::Align(Ssiz_t s); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); static Ssiz_tTString::Recommend(Ssiz_t s). Data Members; public:. enum TString::[unnamed] { kAlignment; };; enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. protected:. charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next line. void DrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw the underline under the hot character. TGHotString(const char* s). Int_t GetHotChar() const; { return fHotChar; }. Int_t GetHotPos() const; { return fHotPos; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGString.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has be",MatchSource.WIKI,root/html530/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHotString.html
https://root.cern/root/html530/TGHotString.html:8265,Performance,cache,cache,8265,"') const; TSubStringTString::SubString(const char* pat, Ssiz_t start = 0, TString::ECaseCompare cmp = kExact) const; TObjArray*TString::Tokenize(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); static Ssiz_tTString::Align(Ssiz_t s); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); static Ssiz_tTString::Recommend(Ssiz_t s). Data Members; public:. enum TString::[unnamed] { kAlignment; };; enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. protected:. charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next line. void DrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw the underline under the hot character. TGHotString(const char* s). Int_t GetHotChar() const; { return fHotChar; }. Int_t GetHotPos() const; { return fHotPos; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGString.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has be",MatchSource.WIKI,root/html530/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHotString.html
https://root.cern/root/html530/TGHProgressBar.html:4549,Availability,error,error,4549," signal, void* receiver = 0, const char* slot = 0); virtual voidTQObject::Disconnected(const char*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTGFrame::DrawBorder(); virtual voidTGFrame::DrawClass() const; virtual TObject*TGFrame::DrawClone(Option_t* = """") const; virtual voidTGFrame::DrawCopy(Handle_t, Int_t, Int_t); virtual voidTGFrame::Dump() const; voidTQObject::Emit(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTGProgressBar::Format(const char* format = ""%.",MatchSource.WIKI,root/html530/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHProgressBar.html
https://root.cern/root/html530/TGHProgressBar.html:4633,Availability,error,error,4633," signal, void* receiver = 0, const char* slot = 0); virtual voidTQObject::Disconnected(const char*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTGFrame::DrawBorder(); virtual voidTGFrame::DrawClass() const; virtual TObject*TGFrame::DrawClone(Option_t* = """") const; virtual voidTGFrame::DrawCopy(Handle_t, Int_t, Int_t); virtual voidTGFrame::Dump() const; voidTQObject::Emit(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTGProgressBar::Format(const char* format = ""%.",MatchSource.WIKI,root/html530/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHProgressBar.html
https://root.cern/root/html530/TGHProgressBar.html:17665,Availability,mask,mask,17665,,MatchSource.WIKI,root/html530/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHProgressBar.html
https://root.cern/root/html530/TGHProgressBar.html:392,Usability,progress bar,progress bars,392,". TGHProgressBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHProgressBar. class TGHProgressBar: public TGProgressBar. TGProgressBar, TGHProgressBar and TGVProgressBar. The classes in this file implement progress bars. Progress bars can; be used to show progress of tasks taking more then a few seconds.; TGProgressBar is an abstract base class, use either TGHProgressBar; or TGVProgressBar. TGHProgressBar can in addition show the position; as text in the bar. Function Members (Methods); public:. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); virtual~TGHProgressBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, c",MatchSource.WIKI,root/html530/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHProgressBar.html
https://root.cern/root/html530/TGHProgressBar.html:18997,Usability,progress bar,progress bar,18997,"on not in percent; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Float_tTGProgressBar::fMaxlogical maximum value (default 100); UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; Float_tTGProgressBar::fMinlogical minimum value (default 0); UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGProgressBar::fNormGCtext drawing graphics context; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTGProgressBar::fPercentshow position in percent (default true); Float_tTGProgressBar::fPoslogical position [fMin,fMax]; Int_tTGProgressBar::fPosPixposition of progress bar in pixel coordinates; Bool_tTGProgressBar::fShowPosshow position value (default false); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; s",MatchSource.WIKI,root/html530/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHProgressBar.html
https://root.cern/root/html530/TGHProgressBar.html:20510,Usability,progress bar,progress bar,20510,"atic const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fo",MatchSource.WIKI,root/html530/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHProgressBar.html
https://root.cern/root/html530/TGHProgressBar.html:20699,Usability,progress bar,progress bar,20699,"TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHProgressBar.html
https://root.cern/root/html530/TGHProgressBar.html:21019,Usability,progress bar,progress bar,21019,"TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHProgressBar.html
https://root.cern/root/html530/TGHProgressBar.html:21108,Usability,progress bar,progress bar,21108,"TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHProgressBar.html
https://root.cern/root/html530/TGHScrollBar.html:4620,Availability,error,error,4620,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static Pixmap_tTGScrollBar::GetBckgndPixmap(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame",MatchSource.WIKI,root/html530/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHScrollBar.html
https://root.cern/root/html530/TGHScrollBar.html:4704,Availability,error,error,4704,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static Pixmap_tTGScrollBar::GetBckgndPixmap(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TO",MatchSource.WIKI,root/html530/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHScrollBar.html
https://root.cern/root/html530/TGHScrollBar.html:17180,Availability,mask,mask,17180,,MatchSource.WIKI,root/html530/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHScrollBar.html
https://root.cern/root/html530/TGHScrollBar.html:18880,Availability,down,down,18880,width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tTGScrollBar::fPoslogical current position; Int_tTGScrollBar::fPsizelogical page size of scrollbar; Int_tTGScrollBar::fRangelogical upper range of scrollbar; TTimer*TGScrollBar::fRepeatrepeat rate timer (when mouse stays pressed); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGScrollBarElement*TGScrollBar::fSliderslider; Int_tTGScrollBar::fSliderRangelogical slider range; Int_tTGScrollBar::fSliderSizelogical slider size; Int_tTGScrollBar::fSmallIncSmall Increment in the sliding algorithm; Window_tTGScrollBar::fSubwsub window in which mouse is pressed; TGScrollBarElement*TGScrollBar::fTailtail button of scrollbar; const TGPicture*TGScrollBar::fTailPicpicture in tail (down or right arrow); Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGScrollBar::fX0; Int_tTGScrollBar::fXp; Int_tTGFrame::fYframe y position; Int_tTGScrollBar::fY0current slider position in pixels; Int_tTGScrollBar::fYpprevious slider position in pixels; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static Pixmap_tTGScrollBar::fgBckgndPixmap; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static ,MatchSource.WIKI,root/html530/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHScrollBar.html
https://root.cern/root/html530/TGHScrollBar.html:652,Integrability,message,messages,652,". TGHScrollBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHScrollBar. class TGHScrollBar: public TGScrollBar. TGScrollBar and TGScrollBarElement. The classes in this file implement scrollbars. Scrollbars can be; either placed horizontal or vertical. A scrollbar contains three; TGScrollBarElements: The ""head"", ""tail"" and ""slider"". The head and; tail are fixed at either end and have the typical arrows in them. The TGHScrollBar will generate the following event messages:; kC_HSCROLL, kSB_SLIDERPOS, position, 0; kC_HSCROLL, kSB_SLIDERTRACK, position, 0. The TGVScrollBar will generate the following event messages:; kC_VSCROLL, kSB_SLIDERPOS, position, 0; kC_VSCROLL, kSB_SLIDERTRACK, position, 0. Function Members (Methods); public:. TGHScrollBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = 2, UInt_t options = kHorizontalFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGHScrollBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGScrollBar::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const",MatchSource.WIKI,root/html530/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHScrollBar.html
https://root.cern/root/html530/TGHScrollBar.html:796,Integrability,message,messages,796,". TGHScrollBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHScrollBar. class TGHScrollBar: public TGScrollBar. TGScrollBar and TGScrollBarElement. The classes in this file implement scrollbars. Scrollbars can be; either placed horizontal or vertical. A scrollbar contains three; TGScrollBarElements: The ""head"", ""tail"" and ""slider"". The head and; tail are fixed at either end and have the typical arrows in them. The TGHScrollBar will generate the following event messages:; kC_HSCROLL, kSB_SLIDERPOS, position, 0; kC_HSCROLL, kSB_SLIDERTRACK, position, 0. The TGVScrollBar will generate the following event messages:; kC_VSCROLL, kSB_SLIDERPOS, position, 0; kC_VSCROLL, kSB_SLIDERTRACK, position, 0. Function Members (Methods); public:. TGHScrollBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = 2, UInt_t options = kHorizontalFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGHScrollBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGScrollBar::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const",MatchSource.WIKI,root/html530/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHScrollBar.html
https://root.cern/root/html530/TGHScrollBar.html:20770,Testability,log,logical,20770,"TGScrollBar::fgBckgndPixmap; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Int_tTGScrollBar::fgScrollBarWidth; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHScrollBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = 2, UInt_t options = kHorizontalFrame, Pixel_t back = GetDefaultFrameBackground()); Create a horizontal scrollbar widget. void Layout(); Layout and move horizontal scrollbar components. Bool_t HandleButton(Event_t* event); Handle a mouse button event in a horizontal scrolbar. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in a horizontal scrollbar. void SetRange(Int_t range, Int_t page_size); Set range of horizontal scrollbar. void SetPosition(Int_t pos); Set logical slider position of horizontal scrollbar. void SavePrimitive(ostream& out, Option_t* option = """"); Save an horizontal scrollbar as a C++ statement(s) on output stream out. virtual ~TGHScrollBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, GetScrollBarWidth()); }. » Author: Fons Rademakers 10/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGScrollBar.h 38845 2011-04-14 12:47:50Z bellenot $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHScrollBar.html
https://root.cern/root/html530/TGHSlider.html:4921,Availability,error,error,4921,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html530/TGHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHSlider.html
https://root.cern/root/html530/TGHSlider.html:5005,Availability,error,error,5005,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFr",MatchSource.WIKI,root/html530/TGHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHSlider.html
https://root.cern/root/html530/TGHSlider.html:17135,Availability,mask,mask,17135,,MatchSource.WIKI,root/html530/TGHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHSlider.html
https://root.cern/root/html530/TGHSplitter.html:4264,Availability,error,error,4264,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAbove() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType",MatchSource.WIKI,root/html530/TGHSplitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHSplitter.html
https://root.cern/root/html530/TGHSplitter.html:4348,Availability,error,error,4348,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAbove() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html530/TGHSplitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHSplitter.html
https://root.cern/root/html530/TGHSplitter.html:15769,Availability,mask,mask,15769,,MatchSource.WIKI,root/html530/TGHSplitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHSplitter.html
https://root.cern/root/html530/TGHtml.html:4594,Availability,error,error,4594,"al, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEncodeText(TGString* str, const char* z); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGHtmlElement*FindEndNest(TGHtmlElement* sp, int en, TGHtmlElement* lp); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual intFormAction(TGHtmlForm*, int); virtual intFormCreate(TGHtmlForm*, const char*, const char*); virtual Pixel_tTGFrame::GetBackground() const; const char*GetBaseUri() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGViewFrame*TGView::GetCanvas() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounte",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:4678,Availability,error,error,4678,"ect::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEncodeText(TGString* str, const char* z); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGHtmlElement*FindEndNest(TGHtmlElement* sp, int en, TGHtmlElement* lp); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual intFormAction(TGHtmlForm*, int); virtual intFormCreate(TGHtmlForm*, const char*, const char*); virtual Pixel_tTGFrame::GetBackground() const; const char*GetBaseUri() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGViewFrame*TGView::GetCanvas() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFr",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:24634,Availability,mask,mask,24634,"...</A>; TGHtmlAnchor*fAnchorStartMost recent <a href=...>; ColorStruct_t*fApColor[32]Information about all colors; Pixel_tTGFrame::fBackgroundframe background color; ColorStruct_t*fBgColorBackground color of the HTML document; TImage*fBgImageBackground image; Int_tTGFrame::fBorderWidthframe border width; TGViewFrame*TGView::fCanvasframe containing the text; TGClient*TGObject::fClientConnection to display server; Atom_tTGView::fClipboardclipboard property; Long_tfColorUsedbit N is 1 if color N is in use. Only; TStringTGWidget::fCommandcommand to be executed; Cursor_tfCursorCurrent cursor for window, or None.; Int_tTGFrame::fDNDStateEDNDFlags; intfDirtyBottomBottom right corner of region to redraw; intfDirtyLeft; intfDirtyRight; intfDirtyTopTop left corner of region to redraw. These; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; intfExitingTrue if the widget is being destroyed; intfExportSelectionTrue if the selection is automatically; TGRectangleTGView::fExposedRegionexposed area ; SHtmlExtensions_t*fExtsPointer to user extension data; TGFrameElement*TGFrame::fFEpointer to frame element; ColorStruct_t*fFgColorColor of normal text. apColor[0]; TGHtmlBlock*fFirstBlockList of all TGHtmlBlock tokens; TGHtmlInput*fFirstInputFirst <INPUT> element; intfFlagsVarious flags; see below for definitions.; charfFontValid[9]If bit N%8 of work N/8 of this field is 0; TGHtmlInput*fFormElemLastMost recent <input>, <textarea> or <select>; TGHtmlInput*fFormElemStartMost recent <textarea> or <select>; intfFormPaddingAmount to pad form elements by; TGHtmlForm*fFormStartMost recent <form>; intfGcNextToFree; intfHasFramesTRUE if we can do frames for this page; intfHasScriptTRUE if we can do scripts for this page; UInt_tTGFrame::fHeightframe height; ColorStruct_t*fHighlightBgColorPtrColor for drawing traversal highlight; ColorStruct_t*fHighlightColorPtrColor for drawing traversal highlight.; intfHighlightWidthWidth in pixels ",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:32511,Availability,avail,available,32511,"fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the ca",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:26207,Deployability,update,update,26207,">, <textarea> or <select>; TGHtmlInput*fFormElemStartMost recent <textarea> or <select>; intfFormPaddingAmount to pad form elements by; TGHtmlForm*fFormStartMost recent <form>; intfGcNextToFree; intfHasFramesTRUE if we can do frames for this page; intfHasScriptTRUE if we can do scripts for this page; UInt_tTGFrame::fHeightframe height; ColorStruct_t*fHighlightBgColorPtrColor for drawing traversal highlight; ColorStruct_t*fHighlightColorPtrColor for drawing traversal highlight.; intfHighlightWidthWidth in pixels of highlight to draw; TGHScrollBar*TGView::fHsbhorizontal scrollbar; intfIColThe column in which zText[nComplete]; intfIDark[32]Dark 3D shadow of color K is iDark[K]; intfILight[32]Light 3D shadow of color K is iLight[K]; intfIPlaintextIf not zero, this is the token type that; Handle_tTGObject::fIdX11/Win32 Window identifier; intfIdind; TGIdleHandler*fIdle; TGHtmlImage*fImageListA list of all images; intfInDtStyle flags associated with <DT>...</DT>; intfInParsePrevent update if parsing; intfInTdTrue if within <td>..</td> or <th>..</th>; intfInTrTrue if within <tr>..</tr>; TGHtmlListStart*fInnerListThe inner most <OL> or <UL>; intfInputIdxUnique input index; SHtmlIndex_tfInsThe insertion cursor position; intfInsIndexIndex in pInsBlock of the cursor; intfInsOffTimeHow long it is off (milliseconds); intfInsOnTimeHow long the cursor states one (millisec); intfInsStatusIs it visible?; TTimer*fInsTimerTimer used to flash the insertion cursor; TGHtmlBlock*fLastBlockLast TGHtmlBlock in the list; intfLastGCIndex of recently used GC; TGHtmlInput*fLastInputLast <INPUT> element; TGHtmlElement*fLastSizedLast HTML element that has been sized; const char*fLastUriUsed in HandleMotion; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGHtmlLayoutContextfLayoutContext; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TLi",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:31842,Deployability,update,update,31842," all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:32537,Deployability,update,updated,32537,"::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in t",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:38382,Deployability,update,update,38382,"iate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to see if the given color is too light to be easily distinguished; from white. int GetLightShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the bright part of the 3D shadow. int GetColorByValue(ColorStruct_t* pRef); Find a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. void LostSelection(); Clear selection. int SelectionSet(const char* startIx, const char* endIx); Set selection. void UpdateInsert(); Recompute the position of the insertion cursor based on the; position in fIns. int SetInsert(const char* insIx); Set the position of the insertion cursor. void SavePrimitive(ostream& out, Option_t* = """"); Save a html widget as a C++ statement(s) on output stream out. Bool_t ProcessMessage(Long_t , Long_t , Long_t ). int GetTableRelief() ",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:27943,Energy Efficiency,allocate,allocated,27943,"ithin <td>..</td> or <th>..</th>; intfInTrTrue if within <tr>..</tr>; TGHtmlListStart*fInnerListThe inner most <OL> or <UL>; intfInputIdxUnique input index; SHtmlIndex_tfInsThe insertion cursor position; intfInsIndexIndex in pInsBlock of the cursor; intfInsOffTimeHow long it is off (milliseconds); intfInsOnTimeHow long the cursor states one (millisec); intfInsStatusIs it visible?; TTimer*fInsTimerTimer used to flash the insertion cursor; TGHtmlBlock*fLastBlockLast TGHtmlBlock in the list; intfLastGCIndex of recently used GC; TGHtmlInput*fLastInputLast <INPUT> element; TGHtmlElement*fLastSizedLast HTML element that has been sized; const char*fLastUriUsed in HandleMotion; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGHtmlLayoutContextfLayoutContext; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGHtmlElement*fLoEndPtrHow far AddStyle has gone to; TGHtmlForm*fLoFormStartFor AddStyle; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; TGInsetsfMarginsdocument margins (separation between the; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; intfMaxX; intfMaxYMaximum extent of any ""paint"" that appears; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TGLongPositionTGView::fMousePosposition of mouse; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); intfNAllocSpace allocated for zText; intfNCompleteHow much of zText has actually been; intfNFormThe number of <FORM> elements; intfNInputThe number of <INPUT> elements; intfNTextNumber of characters in zText; intfNTokenNumber of HTML tokens on the list.; TStringTGWindow::fNamename of the window used in SavePrimitiv",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:34250,Energy Efficiency,schedul,schedule,34250,"me; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:36543,Energy Efficiency,allocate,allocated,36543,"k. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, checkbox, ...) event. Bool_t HandleRadioButton(TGHtmlInput* p); Handle radio button event. void ButtonClicked(const char* name, const char* val); Emit ButtonClicked() signal. void CheckToggled(const char* name, Bool_t on, const char* val); Emit CheckToggled() signal. void RadioChanged(const char* name, const char* val); Emit RadioChanged() signal. void InputSelected(const char* name, const char* val); Emit Selected() signal. void SubmitClicked(const char* val); Emit SubmitClicked() signal. Bool_t HandleButton(Event_t* event); Handle mouse button event. Bool_t HandleMotion(Event_t* event); handle mouse motion events. TGFont * GetFont(int iFont); The rendering and layout routines should call this routine in order to; get a font structure. The iFont parameter specifies which of the N_FONT; fonts should be obtained. The font is allocated if necessary. int InArea(TGHtmlMapArea* p, int left, int top, int x, int y); Only support rect and circles for now. TGHtmlElement * GetMap(const char* name); Returns html map element. float ColorDistance(ColorStruct_t* pA, ColorStruct_t* pB); Compute the squared distance between two colors. int GetColorByName(const char* zColor); This routine returns an index between 0 and N_COLOR-1 which indicates; which ColorStruct_t structure in the fApColor[] array should be used to describe; the color specified by the given name. int IsDarkColor(ColorStruct_t* p); Check to see if the given color is too dark to be easily distinguished; from black. int GetDarkShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to see if the given color is too light to be easily distinguished; from white. int GetLightShadowColor(int iBgColor); Given that the background color is iBgColo",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:33654,Integrability,rout,routine,33654,"html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this rout",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:33839,Integrability,rout,routine,33839,"chor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it b",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:33939,Integrability,rout,routine,33939," procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer even",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:34147,Integrability,rout,routine,34147,"ill return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU alg",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:34237,Integrability,rout,routine,34237,"me; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:34591,Integrability,rout,routine,34591," or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don't matter since the; GC will only be used for copying. Bool_t HandleFocusChange(Event_t* event); Handle focus change event. TGHtmlInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] f",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:34675,Integrability,rout,routine,34675," HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don't matter since the; GC will only be used for copying. Bool_t HandleFocusChange(Event_t* event); Handle focus change event. TGHtmlInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, chec",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:35436,Integrability,rout,routine,35436,"t(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don't matter since the; GC will only be used for copying. Bool_t HandleFocusChange(Event_t* event); Handle focus change event. TGHtmlInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, checkbox, ...) event. Bool_t HandleRadioButton(TGHtmlInput* p); Handle radio button event. void ButtonClicked(const char* name, const char* val); Emit ButtonClicked() signal. void CheckToggled(const char* name, Bool_t on, const char* val); Emit CheckToggled() signal. void RadioChanged(const char* name, const char* val); Emit RadioChanged() signal. void InputSelected(const char* name, const char* val); Emit Selected() signal. void SubmitClicked(const char* val); Emit SubmitClicked() signal. Bool_t HandleButton(Event_t* event); Handle mouse button event. Bool_t HandleMotion(Event_t* event); handle mouse motion events. TGFont * GetFont(int iFont); The rendering and layout routines should call this routine in order to; get a font structure. The iFont para",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:36385,Integrability,rout,routines,36385,"lInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, checkbox, ...) event. Bool_t HandleRadioButton(TGHtmlInput* p); Handle radio button event. void ButtonClicked(const char* name, const char* val); Emit ButtonClicked() signal. void CheckToggled(const char* name, Bool_t on, const char* val); Emit CheckToggled() signal. void RadioChanged(const char* name, const char* val); Emit RadioChanged() signal. void InputSelected(const char* name, const char* val); Emit Selected() signal. void SubmitClicked(const char* val); Emit SubmitClicked() signal. Bool_t HandleButton(Event_t* event); Handle mouse button event. Bool_t HandleMotion(Event_t* event); handle mouse motion events. TGFont * GetFont(int iFont); The rendering and layout routines should call this routine in order to; get a font structure. The iFont parameter specifies which of the N_FONT; fonts should be obtained. The font is allocated if necessary. int InArea(TGHtmlMapArea* p, int left, int top, int x, int y); Only support rect and circles for now. TGHtmlElement * GetMap(const char* name); Returns html map element. float ColorDistance(ColorStruct_t* pA, ColorStruct_t* pB); Compute the squared distance between two colors. int GetColorByName(const char* zColor); This routine returns an index between 0 and N_COLOR-1 which indicates; which ColorStruct_t structure in the fApColor[] array should be used to describe; the color specified by the given name. int IsDarkColor(ColorStruct_t* p); Check to see if the given color is too dark to be easily distinguished; from black. int GetDarkShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to s",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:36411,Integrability,rout,routine,36411,"lInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, checkbox, ...) event. Bool_t HandleRadioButton(TGHtmlInput* p); Handle radio button event. void ButtonClicked(const char* name, const char* val); Emit ButtonClicked() signal. void CheckToggled(const char* name, Bool_t on, const char* val); Emit CheckToggled() signal. void RadioChanged(const char* name, const char* val); Emit RadioChanged() signal. void InputSelected(const char* name, const char* val); Emit Selected() signal. void SubmitClicked(const char* val); Emit SubmitClicked() signal. Bool_t HandleButton(Event_t* event); Handle mouse button event. Bool_t HandleMotion(Event_t* event); handle mouse motion events. TGFont * GetFont(int iFont); The rendering and layout routines should call this routine in order to; get a font structure. The iFont parameter specifies which of the N_FONT; fonts should be obtained. The font is allocated if necessary. int InArea(TGHtmlMapArea* p, int left, int top, int x, int y); Only support rect and circles for now. TGHtmlElement * GetMap(const char* name); Returns html map element. float ColorDistance(ColorStruct_t* pA, ColorStruct_t* pB); Compute the squared distance between two colors. int GetColorByName(const char* zColor); This routine returns an index between 0 and N_COLOR-1 which indicates; which ColorStruct_t structure in the fApColor[] array should be used to describe; the color specified by the given name. int IsDarkColor(ColorStruct_t* p); Check to see if the given color is too dark to be easily distinguished; from black. int GetDarkShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to s",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:36890,Integrability,rout,routine,36890,"gled() signal. void RadioChanged(const char* name, const char* val); Emit RadioChanged() signal. void InputSelected(const char* name, const char* val); Emit Selected() signal. void SubmitClicked(const char* val); Emit SubmitClicked() signal. Bool_t HandleButton(Event_t* event); Handle mouse button event. Bool_t HandleMotion(Event_t* event); handle mouse motion events. TGFont * GetFont(int iFont); The rendering and layout routines should call this routine in order to; get a font structure. The iFont parameter specifies which of the N_FONT; fonts should be obtained. The font is allocated if necessary. int InArea(TGHtmlMapArea* p, int left, int top, int x, int y); Only support rect and circles for now. TGHtmlElement * GetMap(const char* name); Returns html map element. float ColorDistance(ColorStruct_t* pA, ColorStruct_t* pB); Compute the squared distance between two colors. int GetColorByName(const char* zColor); This routine returns an index between 0 and N_COLOR-1 which indicates; which ColorStruct_t structure in the fApColor[] array should be used to describe; the color specified by the given name. int IsDarkColor(ColorStruct_t* p); Check to see if the given color is too dark to be easily distinguished; from black. int GetDarkShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to see if the given color is too light to be easily distinguished; from white. int GetLightShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the bright part of the 3D shadow. int GetColorByValue(ColorStruct_t* pRef); Find a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the marku",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:37808,Integrability,rout,routine,37808,"n two colors. int GetColorByName(const char* zColor); This routine returns an index between 0 and N_COLOR-1 which indicates; which ColorStruct_t structure in the fApColor[] array should be used to describe; the color specified by the given name. int IsDarkColor(ColorStruct_t* p); Check to see if the given color is too dark to be easily distinguished; from black. int GetDarkShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to see if the given color is too light to be easily distinguished; from white. int GetLightShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the bright part of the 3D shadow. int GetColorByValue(ColorStruct_t* pRef); Find a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. voi",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:38407,Integrability,rout,routine,38407," white. int GetLightShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the bright part of the 3D shadow. int GetColorByValue(ColorStruct_t* pRef); Find a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. void LostSelection(); Clear selection. int SelectionSet(const char* startIx, const char* endIx); Set selection. void UpdateInsert(); Recompute the position of the insertion cursor based on the; position in fIns. int SetInsert(const char* insIx); Set the position of the insertion cursor. void SavePrimitive(ostream& out, Option_t* = """"); Save a html widget as a C++ statement(s) on output stream out. Bool_t ProcessMessage(Long_t , Long_t , Long_t ). int GetTableRelief() const; { return fTableRelief; }. int GetRuleRelief() const; { return fRuleRelief; }. int GetRulePadding() const; { return fRulePadding; }. const char * GetBas",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:38619,Integrability,rout,routine,38619,"d a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. void LostSelection(); Clear selection. int SelectionSet(const char* startIx, const char* endIx); Set selection. void UpdateInsert(); Recompute the position of the insertion cursor based on the; position in fIns. int SetInsert(const char* insIx); Set the position of the insertion cursor. void SavePrimitive(ostream& out, Option_t* = """"); Save a html widget as a C++ statement(s) on output stream out. Bool_t ProcessMessage(Long_t , Long_t , Long_t ). int GetTableRelief() const; { return fTableRelief; }. int GetRuleRelief() const; { return fRuleRelief; }. int GetRulePadding() const; { return fRulePadding; }. const char * GetBaseUri() const; { return fZBase; }. char * ResolveUri(const char* uri); User function to resolve URIs. TImage * LoadImage(const char* uri, int w = 0, int h = 0); User function to get an image from a URL. int Is",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:23619,Performance,cache,cache,23619,"p); const char*TypeToName(int type); voidUnlinkAndFreeBlock(TGHtmlBlock* pBlock); voidUnmapControls(); virtual voidUpdateBackgroundStart(); voidUpdateInsert(); virtual voidTGView::UpdateRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); voidUpdateSelection(int forceUpdate); voidUpdateSelectionDisplay(). Data Members; public:. enum TGView::[unnamed] { kNoHSB; kNoVSB; kHorizontal; kVertical; };; enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGFont*fAFont[71]Information about all screen fonts; GcCache_tfAGcCache[32]A cache of GCs for general use; intfAddEndTagsTRUE if we add /LI etc.; intfAnchorFlagsStyle flags associated with <A>...</A>; TGHtmlAnchor*fAnchorStartMost recent <a href=...>; ColorStruct_t*fApColor[32]Information about all colors; Pixel_tTGFrame::fBackgroundframe background color; ColorStruct_t*fBgColorBackground color of the HTML document; TImage*fBgImageBackground image; Int_tTGFrame::fBorderWidthframe border width; TGViewFrame*TGView::fCanvasframe containing the text; TGClient*TGObject::fClientConnection to display server; Atom_tTGView::fClipboardclipboard property; Long_tfColorUsedbit N is 1 if color N is in use. Only; TStringTGWidget::fCommandcommand to be executed; Cursor_tfCursorCurrent cursor for window, or None.; Int_tTGFrame::fDNDStateEDNDFlags; intfDirtyBottomBottom right corner of region to redraw; intfDirtyLeft; intfDirtyRight; intfDirtyTopTop left corner of region to redraw. These; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcu",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:32186,Performance,load,loading,32186,"*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other call",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:33466,Performance,cache,cache,33466,"ayout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:33956,Performance,queue,queued,33956," procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer even",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:35031,Performance,cache,cache,35031,"); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don't matter since the; GC will only be used for copying. Bool_t HandleFocusChange(Event_t* event); Handle focus change event. TGHtmlInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, checkbox, ...) event. Bool_t HandleRadioButton(TGHtmlInput* p); Handle radio button event. void ButtonClicked(const char* name, const char* val); Emit ButtonClicked() signal. void CheckToggled(const char* name, Bool_t on, const char* val); Emit CheckToggled() signal. void RadioChanged(const char*",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:33798,Security,expose,expose,33798,"i(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond t",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:32137,Usability,clear,clear,32137,"tatic Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to st",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtml.html:38685,Usability,clear,clear,38685,"d a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. void LostSelection(); Clear selection. int SelectionSet(const char* startIx, const char* endIx); Set selection. void UpdateInsert(); Recompute the position of the insertion cursor based on the; position in fIns. int SetInsert(const char* insIx); Set the position of the insertion cursor. void SavePrimitive(ostream& out, Option_t* = """"); Save a html widget as a C++ statement(s) on output stream out. Bool_t ProcessMessage(Long_t , Long_t , Long_t ). int GetTableRelief() const; { return fTableRelief; }. int GetRuleRelief() const; { return fRuleRelief; }. int GetRulePadding() const; { return fRulePadding; }. const char * GetBaseUri() const; { return fZBase; }. char * ResolveUri(const char* uri); User function to resolve URIs. TImage * LoadImage(const char* uri, int w = 0, int h = 0); User function to get an image from a URL. int Is",MatchSource.WIKI,root/html530/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtml.html
https://root.cern/root/html530/TGHtmlBrowser.html:4417,Availability,error,error,4417,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForward(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDe",MatchSource.WIKI,root/html530/TGHtmlBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtmlBrowser.html
https://root.cern/root/html530/TGHtmlBrowser.html:4501,Availability,error,error,4501,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForward(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() con",MatchSource.WIKI,root/html530/TGHtmlBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtmlBrowser.html
https://root.cern/root/html530/TGHtmlBrowser.html:18819,Availability,mask,mask,18819,,MatchSource.WIKI,root/html530/TGHtmlBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtmlBrowser.html
https://root.cern/root/html530/TGHtmlBrowser.html:328,Usability,simpl,simple,328,". TGHtmlBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUIHTML; » TGHtmlBrowser. class TGHtmlBrowser: public TGMainFrame. TGHtmlBrowser. A very simple HTML browser. Function Members (Methods); public:. TGHtmlBrowser(const char* filename = 0, const TGWindow* p = 0, UInt_t w = 900, UInt_t h = 600); virtual~TGHtmlBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidBack(); virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); Bool_tCheckAnchors(const char*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClicked(char* uri)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* r",MatchSource.WIKI,root/html530/TGHtmlBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGHtmlBrowser.html
https://root.cern/root/html530/TGIcon.html:4070,Availability,error,error,4070,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html530/TGIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGIcon.html
https://root.cern/root/html530/TGIcon.html:4154,Availability,error,error,4154,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static Long_tTO",MatchSource.WIKI,root/html530/TGIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGIcon.html
https://root.cern/root/html530/TGIcon.html:15402,Availability,mask,mask,15402,"ected:. Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TImage*fImageimage; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TStringfPathdirectory of image; const TGPicture*fPicicon picture; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class ",MatchSource.WIKI,root/html530/TGIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGIcon.html
https://root.cern/root/html530/TGIconLBEntry.html:4660,Availability,error,error,4660,"st char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGTextLBEntry::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTextLBEntry::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtu",MatchSource.WIKI,root/html530/TGIconLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGIconLBEntry.html
https://root.cern/root/html530/TGIconLBEntry.html:4744,Availability,error,error,4744,"m); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGTextLBEntry::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTextLBEntry::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; ",MatchSource.WIKI,root/html530/TGIconLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGIconLBEntry.html
https://root.cern/root/html530/TGIconLBEntry.html:16468,Availability,mask,mask,16468,,MatchSource.WIKI,root/html530/TGIconLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGIconLBEntry.html
https://root.cern/root/html530/TGIconLBEntry.html:423,Usability,simpl,simple,423,". TGIconLBEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGIconLBEntry. class TGIconLBEntry: public TGTextLBEntry. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. TGIconLBEntry(const TGWindow* p = 0, Int_t id = -1, const char* str = 0, const TGPicture* pic = 0, UInt_t w = 0, Style_t s = 0, UInt_t options = kHorizontalFrame, Pixel_t back = GetWhitePixel()); virtual~TGIconLBEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLBEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::",MatchSource.WIKI,root/html530/TGIconLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGIconLBEntry.html
https://root.cern/root/html530/TGIdleHandler.html:1440,Availability,error,error,1440,"eHandler(TGWindow* w); TGIdleHandler(const TGIdleHandler&); virtual~TGIdleHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tHandleEvent(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFr",MatchSource.WIKI,root/html530/TGIdleHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGIdleHandler.html
https://root.cern/root/html530/TGIdleHandler.html:1524,Availability,error,error,1524," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tHandleEvent(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* c",MatchSource.WIKI,root/html530/TGIdleHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGIdleHandler.html
https://root.cern/root/html530/TGImageMap.html:4417,Availability,error,error,4417,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; const TGPicture*TG",MatchSource.WIKI,root/html530/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGImageMap.html
https://root.cern/root/html530/TGImageMap.html:4501,Availability,error,error,4501,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; const TGPicture*TGPictureButton::GetDisabledPicture() const; virtual TDNDData*TGFrame::GetDNDData(Atom",MatchSource.WIKI,root/html530/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGImageMap.html
https://root.cern/root/html530/TGImageMap.html:18078,Availability,mask,mask,18078,,MatchSource.WIKI,root/html530/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGImageMap.html
https://root.cern/root/html530/TGImageMap.html:19577,Availability,down,down,19577,tip text for main region; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); TGImageMap::ENavModefNavModenavigation mode; Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; Bool_tTGPictureButton::fOwnDisabledPickTRUE if disabled picture was autogenerated; const TGWindow*TGWindow::fParentParent window; const TGPicture*TGPictureButton::fPicpicture to be put in button; const TGPicture*TGPictureButton::fPicDpicture shown when button disabled; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; TList*fTrashcollect all objects that need to be cleaned up; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; st,MatchSource.WIKI,root/html530/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGImageMap.html
https://root.cern/root/html530/TGImageMap.html:20859,Deployability,release,released,20859,be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; Bool_tTGPictureButton::fOwnDisabledPickTRUE if disabled picture was autogenerated; const TGWindow*TGWindow::fParentParent window; const TGPicture*TGPictureButton::fPicpicture to be put in button; const TGPicture*TGPictureButton::fPicDpicture shown when button disabled; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; TList*fTrashcollect all objects that need to be cleaned up; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html530/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGImageMap.html
https://root.cern/root/html530/TGInputDialog.html:4520,Availability,error,error,4520,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGInputDialog.html
https://root.cern/root/html530/TGInputDialog.html:4604,Availability,error,error,4604,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGInputDialog.html
https://root.cern/root/html530/TGInputDialog.html:18914,Availability,mask,mask,18914,,MatchSource.WIKI,root/html530/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGInputDialog.html
https://root.cern/root/html530/TGInputDialog.html:22741,Energy Efficiency,allocate,allocated,22741,"kground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Maline 19/07/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGInputDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGInputDialog.html
https://root.cern/root/html530/TGInputDialog.html:22352,Modifiability,variab,variables,22352,"ameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Maline 19/07/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGInputDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:29; This page ",MatchSource.WIKI,root/html530/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGInputDialog.html
https://root.cern/root/html530/TGInputDialog.html:22485,Modifiability,variab,variable,22485,"gDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Maline 19/07/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGInputDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mai",MatchSource.WIKI,root/html530/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGInputDialog.html
https://root.cern/root/html530/TGInputDialog.html:22899,Testability,test,testInputDialog,22899,"kground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Maline 19/07/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGInputDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGInputDialog.html
https://root.cern/root/html530/TGInputDialog.html:22253,Usability,simpl,simple,22253,"el; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Mali",MatchSource.WIKI,root/html530/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGInputDialog.html
https://root.cern/root/html530/TGItemContext.html:1467,Availability,error,error,1467,"ext&); virtual~TGItemContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidAssociate(TTVLVEntry* item); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t*)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEditExpression()MENU ; voidEmpty()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/TGItemContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGItemContext.html
https://root.cern/root/html530/TGItemContext.html:1551,Availability,error,error,1551,"t; virtual voidTObject::AppendPad(Option_t* option = """"); voidAssociate(TTVLVEntry* item); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t*)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEditExpression()MENU ; voidEmpty()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html530/TGItemContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGItemContext.html
https://root.cern/root/html530/TGL5DDataSet.html:1287,Availability,error,error,1287," TGL5DDataSet(TTree* inputData); ~TGL5DDataSet(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() cons",MatchSource.WIKI,root/html530/TGL5DDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGL5DDataSet.html
https://root.cern/root/html530/TGL5DDataSet.html:1371,Availability,error,error,1371,"aSet(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGL5DPainter*GetRealPainter() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const Rgl::Range_t&GetV4Range() const; TAxis*GetXAxis() const; const Rgl::Range_t&GetXRange() const; TAxis*GetYAxis() const; const Rgl::Range_t&GetYRange() const; TAxis*GetZAxis() const; const Rgl::Range_t&GetZRange() const; virtual Bool_tTObje",MatchSource.WIKI,root/html530/TGL5DDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGL5DDataSet.html
https://root.cern/root/html530/TGL5DDataSet.html:7034,Security,access,access,7034,"g64_tfNPNumber of entries.; auto_ptr<TGLHistPainter>fPainter; const Double_t*fV1V1.; pair<double,double>fV1MinMaxV1 range.; Double_tfV1Rangemax - min.; const Double_t*fV2V2.; pair<double,double>fV2MinMaxV2 range.; Double_tfV2Rangemax - min.; const Double_t*fV3V3.; pair<double,double>fV3MinMaxV3 range.; Double_tfV3Rangemax - min.; const Double_t*fV4V4.; Bool_tfV4IsString; pair<double,double>fV4MinMaxV4 range.; const Double_t*fV5V5.; pair<double,double>fV5MinMaxV5 range.; TAxisfXAxis; TAxisfYAxis; TAxisfZAxis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGL5DDataSet(TTree* inputData); Constructor. Reads data from TTree,; estimates ranges, creates a painter. Int_t DistancetoPrimitive(Int_t px, Int_t py); Check, if the object is under cursor. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Action. char * GetObjectInfo(Int_t px, Int_t py) const; Info for status bar. void Paint(Option_t* option); Paint. TGL5DPainter * GetRealPainter() const; Get access to painter (for GUI-editor). void SelectPoints(Double_t v4Level, Double_t range); ""Select"" sub-range from source data; - remember indices of ""good"" points. UInt_t SelectedSize() const; Size of selected sub-range. Double_t V1(UInt_t ind) const; V1 from sub-range, converted to unit cube. Double_t V2(UInt_t ind) const; V2 from sub-range, converted to unit cube. Double_t V3(UInt_t ind) const; V3 from sub-range, converted to unit cube. TAxis * GetXAxis() const; X axis for plot. TAxis * GetYAxis() const; Y axis for plot. TAxis * GetZAxis() const; Z axis for plot. const Rgl::Range_t & GetXRange() const; V1 range (X). const Rgl::Range_t & GetYRange() const; V2 range (Y). const Rgl::Range_t & GetZRange() const; V3 range (Z). const Rgl::Range_t & GetV4Range() const; V4 range. Double_t V1ToUnitCube(Double_t v1) const; V1 to unit cube. Double_t V2ToUnitCube(Double_t v2) const; V2 to unit cube. Double_t V3ToUnitCube(Double_t v3) const; V3 to unit cube. TGL5DDataSet(TTree* inputData). » A",MatchSource.WIKI,root/html530/TGL5DDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGL5DDataSet.html
https://root.cern/root/html530/TGL5DDataSetEditor.html:4777,Availability,error,error,4777,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGL5DDataSetEditor.html
https://root.cern/root/html530/TGL5DDataSetEditor.html:4861,Availability,error,error,4861,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGL5DDataSetEditor.html
https://root.cern/root/html530/TGL5DDataSetEditor.html:18324,Availability,mask,mask,18324,,MatchSource.WIKI,root/html530/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGL5DDataSetEditor.html
https://root.cern/root/html530/TGL5DDataSetEditor.html:20835,Energy Efficiency,adapt,adapter,20835,"edflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fAddNewIsoBtnButton to add new iso.; TGNumberEntry*fAlpha; TGTextButton*fApplyAlpha; TGTextButton*fApplyPlanes; TGTextButton*fCancelGridBtn""Cancel"" button.; TGL5DDataSet*fDataSetData adapter for TTree.; TGL5DDataSetEditor::TGL5DEditorPrivate*fHidden; TGCheckButton*fHighlightCheckHighlight selected surface.; TGListBox*fIsoListList box to select surface.; TGCheckButton*fLogScale; TGNumberEntry*fNCellsXEntryNumber of cells along X.; TGNumberEntry*fNCellsYEntryNumber of cells along Y.; TGNumberEntry*fNCellsZEntryNumber of cells along Z.; TGNumberEntry*fNewIsoEntrySet the iso-level for new surface.; TGNumberEntry*fNumberOfPlanes; TGTextButton*fOkGridBtn""Apply"" button.; TGL5DPainter*fPainterPainter.; Int_tfSelectedSurface; TGCheckButton*fShowBoxCut; TGCheckButton*fShowCloudShow/hide points for surface.; TGDoubleHSlider*fSlideRange; TGHSlider*fSurfAlphaSliderSlider to control transparency.; TGColorSelect*fSurfColorSelectOpen color dialog.; TGTextButton*fSurfRemoveBtnRemove selected surface.; TGNumberEntryField*fV4MaxEntryRead only widget.; TGNumberEntryField*fV4MinEntryRead only widget.; TGCheckButton*fVisibleCheckShow/hide surface.; TGDoubleHSlider*fXRangeSliderSlid",MatchSource.WIKI,root/html530/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGL5DDataSetEditor.html
https://root.cern/root/html530/TGL5DDataSetEditor.html:20835,Integrability,adapter,adapter,20835,"edflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fAddNewIsoBtnButton to add new iso.; TGNumberEntry*fAlpha; TGTextButton*fApplyAlpha; TGTextButton*fApplyPlanes; TGTextButton*fCancelGridBtn""Cancel"" button.; TGL5DDataSet*fDataSetData adapter for TTree.; TGL5DDataSetEditor::TGL5DEditorPrivate*fHidden; TGCheckButton*fHighlightCheckHighlight selected surface.; TGListBox*fIsoListList box to select surface.; TGCheckButton*fLogScale; TGNumberEntry*fNCellsXEntryNumber of cells along X.; TGNumberEntry*fNCellsYEntryNumber of cells along Y.; TGNumberEntry*fNCellsZEntryNumber of cells along Z.; TGNumberEntry*fNewIsoEntrySet the iso-level for new surface.; TGNumberEntry*fNumberOfPlanes; TGTextButton*fOkGridBtn""Apply"" button.; TGL5DPainter*fPainterPainter.; Int_tfSelectedSurface; TGCheckButton*fShowBoxCut; TGCheckButton*fShowCloudShow/hide points for surface.; TGDoubleHSlider*fSlideRange; TGHSlider*fSurfAlphaSliderSlider to control transparency.; TGColorSelect*fSurfColorSelectOpen color dialog.; TGTextButton*fSurfRemoveBtnRemove selected surface.; TGNumberEntryField*fV4MaxEntryRead only widget.; TGNumberEntryField*fV4MinEntryRead only widget.; TGCheckButton*fVisibleCheckShow/hide surface.; TGDoubleHSlider*fXRangeSliderSlid",MatchSource.WIKI,root/html530/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGL5DDataSetEditor.html
https://root.cern/root/html530/TGL5DDataSetEditor.html:20835,Modifiability,adapt,adapter,20835,"edflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fAddNewIsoBtnButton to add new iso.; TGNumberEntry*fAlpha; TGTextButton*fApplyAlpha; TGTextButton*fApplyPlanes; TGTextButton*fCancelGridBtn""Cancel"" button.; TGL5DDataSet*fDataSetData adapter for TTree.; TGL5DDataSetEditor::TGL5DEditorPrivate*fHidden; TGCheckButton*fHighlightCheckHighlight selected surface.; TGListBox*fIsoListList box to select surface.; TGCheckButton*fLogScale; TGNumberEntry*fNCellsXEntryNumber of cells along X.; TGNumberEntry*fNCellsYEntryNumber of cells along Y.; TGNumberEntry*fNCellsZEntryNumber of cells along Z.; TGNumberEntry*fNewIsoEntrySet the iso-level for new surface.; TGNumberEntry*fNumberOfPlanes; TGTextButton*fOkGridBtn""Apply"" button.; TGL5DPainter*fPainterPainter.; Int_tfSelectedSurface; TGCheckButton*fShowBoxCut; TGCheckButton*fShowCloudShow/hide points for surface.; TGDoubleHSlider*fSlideRange; TGHSlider*fSurfAlphaSliderSlider to control transparency.; TGColorSelect*fSurfColorSelectOpen color dialog.; TGTextButton*fSurfRemoveBtnRemove selected surface.; TGNumberEntryField*fV4MaxEntryRead only widget.; TGNumberEntryField*fV4MinEntryRead only widget.; TGCheckButton*fVisibleCheckShow/hide surface.; TGDoubleHSlider*fXRangeSliderSlid",MatchSource.WIKI,root/html530/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGL5DDataSetEditor.html
https://root.cern/root/html530/TGL5DDataSetEditor.html:362,Safety,safe,safety,362,". TGL5DDataSetEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGL5DDataSetEditor. class TGL5DDataSetEditor: public TGedFrame. GUI editor for OpenGL 5D Painter.; Exception safety and ROOT's GUI are two; mutually exclusive things. So,; only ROOT's GUI here. Function Members (Methods); public:. TGL5DDataSetEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGL5DDataSetEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); voidAddNewSurface(); voidAlphaChanged(); voidAlphaChanged(Int_t alpha); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplyAlpha(); voidApplyGridParameters(); voidApplyPlanes(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBoxCutToggled(); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TCla",MatchSource.WIKI,root/html530/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGL5DDataSetEditor.html
https://root.cern/root/html530/TGLabel.html:4374,Availability,error,error,4374,"t::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGet3DStyle() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tGetBottomMargin() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDe",MatchSource.WIKI,root/html530/TGLabel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLabel.html
https://root.cern/root/html530/TGLabel.html:4458,Availability,error,error,4458,"Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGet3DStyle() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tGetBottomMargin() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFra",MatchSource.WIKI,root/html530/TGLabel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLabel.html
https://root.cern/root/html530/TGLabel.html:16753,Availability,mask,mask,16753," TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tf3DStyle3D style (0 - normal, kRaisedFrame - raised, kSunkenFrame - sunken); Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; Bool_tfDisabledif kTRUE label looks disabled (shaded text); UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGFont*fFontfont to draw label; Bool_tfHasOwnFontkTRUE - font defined locally, kFALSE - globally; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMBottommargin bottom; Int_tfMLeftmargin left; Int_tfMRightmargin right; Int_tfMTopmargin top; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tfNormGCgraphics context used for drawing label; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfTFlagstext flags (see TGFont.h ETextLayoutFlags); UInt_tfTHeighttext height; TGTextLayout*fTLayouttext layout ; Int_tfTModetext alignment; UInt_tfTWidthtext width; TGString*fTextlabel text; Bool_tfTextChangedhas text changed; UInt_tTGFrame::fWidthframe width; Int_tfWrapLengthwrap length; ",MatchSource.WIKI,root/html530/TGLabel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLabel.html
https://root.cern/root/html530/TGLAutoRotator.html:1508,Availability,error,error,1508," TGLAutoRotator(TGLViewer* v); virtual~TGLAutoRotator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetADolly() const; Double_tGetATheta() const; TGLCamera*GetCamera() const; virtual Option_t*TObject::GetDrawOption() const;",MatchSource.WIKI,root/html530/TGLAutoRotator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLAutoRotator.html
https://root.cern/root/html530/TGLAutoRotator.html:1592,Availability,error,error,1592," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetADolly() const; Double_tGetATheta() const; TGLCamera*GetCamera() const; virtual Option_t*TObject::GetDrawOption() const; Double_tGetDt() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Bool_tGetImageAutoSave() const; Int_tGetImageCount() const; TStringGetImageGUIBaseName() const; Int_tGetImageGUIOutMode() const; TStringGetImageName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TGLViewer*GetViewer() const; Double_tGetWDol",MatchSource.WIKI,root/html530/TGLAutoRotator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLAutoRotator.html
https://root.cern/root/html530/TGLAutoRotator.html:7173,Safety,timeout,timeout,7173,"ject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfADolly; Double_tfATheta; TGLCamera*fCamera; Double_tfDollyA0; Double_tfDt; Bool_tfImageAutoSave; Int_tfImageCount; TStringfImageGUIBaseName; Int_tfImageGUIOutMode; TStringfImageName; Double_tfThetaA0; TTimer*fTimer; Bool_tfTimerRunning; TGLViewer*fViewer; Double_tfWDolly; Double_tfWPhi; Double_tfWTheta; TStopwatch*fWatch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAutoRotator(TGLViewer* v); Constructor. ~TGLAutoRotator(); Destructor. void SetDt(Double_t dt); Set time between two redraws in seconds.; Range: 0.001 -> 1. void SetATheta(Double_t a); Set relative amplitude of theta oscilation.; Value range: 0.01 -> 1. void SetADolly(Double_t a); Set relative amplitude of forward/backward oscilation.; Value range: 0.01 -> 1. void Start(); Start the auto-rotator. void Stop(); Stop the auto-rotator. void Timeout(); Called on every timer timeout. Moves / rotates the camera and optionally; produces a screenshot. void StartImageAutoSaveAnimatedGif(const TString& filename); Start saving into animated gif. The provided name will be used as it is,; so make sure to end it with '.gif+'.; Use convert tool from ImageMagic if you want to set a different delay or; enable looping. void StartImageAutoSave(const TString& filename); Start saving into a set of images. The provided name will be used as a; format to insert additional image sequence number so it should include; an '%' character. A good name would be something like:; ""image-%04d.png""; On GNU/Linux use mencoder and/or ffmpeg to bundle images into a movie. void StopImageAutoSave(); Stops automatic saving of images. void SetImageGUIOutMode(Int_t m); Set output mode for GUI operation:; 1 - animated gif;; 2 - a series of pngs. void StartImageAutoSaveWithGUISettings(); Start auto-saving images as set-up via GUI. TGLAutoRotator(const TGLAutoRotator& ). TGLAutoRota",MatchSource.WIKI,root/html530/TGLAutoRotator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLAutoRotator.html
https://root.cern/root/html530/TGLAxis.html:4282,Performance,optimiz,optimized,4282,"uble_tfAxisLength; Double_tfGridLength; TString*fLabels; Double_tfLabelsOffset; Double_tfLabelsSize; Int_tfNDiv; Int_tfNDiv1; Int_tfNDiv2; Int_tfNDiv3; Int_tfNTicks1; Int_tfNTicks2; TGLText*fText; Double_tfTickMarksLength; Int_tfTickMarksOrientation; Double_t*fTicks1; Double_t*fTicks2; Double_tfWmax; Double_tfWmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGr",MatchSource.WIKI,root/html530/TGLAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLAxis.html
https://root.cern/root/html530/TGLAxis.html:4375,Performance,optimiz,optimized,4375,"fset; Double_tfLabelsSize; Int_tfNDiv; Int_tfNDiv1; Int_tfNDiv2; Int_tfNDiv3; Int_tfNTicks1; Int_tfNTicks2; TGLText*fText; Double_tfTickMarksLength; Int_tfTickMarksOrientation; Double_t*fTicks1; Double_t*fTicks2; Double_tfWmax; Double_tfWmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-",MatchSource.WIKI,root/html530/TGLAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLAxis.html
https://root.cern/root/html530/TGLAxis.html:4712,Performance,optimiz,optimized,4712,"s. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLAxis.h 21794 2008-01-21 21:11:46Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLAxis.html
https://root.cern/root/html530/TGLAxis.html:4785,Performance,optimiz,optimized,4785,"s. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLAxis.h 21794 2008-01-21 21:11:46Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLAxis.html
https://root.cern/root/html530/TGLAxisPainter.html:3441,Integrability,depend,depends,3441,"tfTitle3DFontSize; Int_tfTitlePixelFontSize; TGLVector3fTitlePos; Bool_tfUseAxisColorsUse colors from axes or from GL-rnr-ctx. private:. Int_tfDecimals; Int_tfExp; TStringfFormat; TGLFontfLabelFont; Int_tfMaxDigits; TGLFontfTitleFont. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAxisPainter(); Constructor. ~TGLAxisPainter(); Destructor. void SetLabelAlign(TGLFont::ETextAlignH_e , TGLFont::ETextAlignV_e ); Set label align. void LabelsLimits(const char* label, Int_t& first, Int_t& last) const; Find first and last character of a label. void FormAxisValue(Double_t x, TString& s) const; Returns formatted text suitable for display of value. void SetTextFormat(Double_t min, Double_t max, Double_t binWidth); Construct print format from given primary bin width. void RnrText(const TString& txt, const TGLVector3& pos, TGLFont::ETextAlignH_e aH, TGLFont::ETextAlignV_e aV, const TGLFont& font) const; Render text at the given position. Offset depends of text aligment. void SetLabelFont(TGLRnrCtx& rnrCtx, const char* fontName, Int_t pixelSize = 64, Double_t font3DSize = -1); Set label font derived from TAttAxis. void RnrLabels() const; Render label reading prepared list ov value-pos pairs. void SetTitleFont(TGLRnrCtx& rnrCtx, const char* fontName, Int_t pixelSize = 64, Double_t font3DSize = -1); Set title font derived from TAttAxis. void RnrTitle(const TString& title, TGLVector3& pos, TGLFont::ETextAlignH_e aH, TGLFont::ETextAlignV_e aV) const; Draw title at given position. void RnrLines() const; Render axis main line and tickmarks. void PaintAxis(TGLRnrCtx& ctx, TAxis* ax); GL render TAxis. TGLAxisPainter(const TGLAxisPainter& ). TGLAxisPainter& operator=(const TGLAxisPainter& ). Int_t GetTMNDim() const; GetSets. { return fTMNDim; }. void SetTMNDim(Int_t x); { fTMNDim = x; }. TGLVector3& RefDir(); { return fDir; }. TGLVector3& RefTMOff(Int_t i); { return fTMOff[i]; }. TGLFont::EMode GetFontMode() const; { return fFontMode; }. void S",MatchSource.WIKI,root/html530/TGLAxisPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLAxisPainter.html
https://root.cern/root/html530/TGLayoutHints.html:796,Availability,down,downward,796,". TGLayoutHints. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLayoutHints. class TGLayoutHints: public TObject, public TRefCnt. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGLayoutHints(const TGLayoutHints& lh); TGLayoutHints(ULong_t hints = kLHintsNormal, Int_t padleft = 0, Int_t padright = 0, Int_t padtop = 0, Int_t padbottom = 0); virtual~TGLayoutHints(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Opt",MatchSource.WIKI,root/html530/TGLayoutHints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLayoutHints.html
https://root.cern/root/html530/TGLayoutHints.html:2445,Availability,error,error,2445,"top = 0, Int_t padbottom = 0); virtual~TGLayoutHints(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; ULong_tGetLayoutHints() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPadBottom() const; Int_tGetPadLeft() const; Int_tGetPadRight() const; Int_tGetPadTop() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; vi",MatchSource.WIKI,root/html530/TGLayoutHints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLayoutHints.html
https://root.cern/root/html530/TGLayoutHints.html:2529,Availability,error,error,2529,"const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; ULong_tGetLayoutHints() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPadBottom() const; Int_tGetPadLeft() const; Int_tGetPadRight() const; Int_tGetPadTop() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_",MatchSource.WIKI,root/html530/TGLayoutHints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLayoutHints.html
https://root.cern/root/html530/TGLayoutManager.html:786,Availability,down,downward,786,". TGLayoutManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLayoutManager. class TGLayoutManager: public TObject. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLayoutManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px,",MatchSource.WIKI,root/html530/TGLayoutManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLayoutManager.html
https://root.cern/root/html530/TGLayoutManager.html:1402,Availability,avail,available,1402,"ut, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLayoutManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html530/TGLayoutManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLayoutManager.html
https://root.cern/root/html530/TGLayoutManager.html:2368,Availability,error,error,2368," ~TGLayoutManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px,",MatchSource.WIKI,root/html530/TGLayoutManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLayoutManager.html
https://root.cern/root/html530/TGLayoutManager.html:2452,Availability,error,error,2452," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html530/TGLayoutManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLayoutManager.html
https://root.cern/root/html530/TGLBContainer.html:5645,Availability,error,error,5645,"le_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::Get",MatchSource.WIKI,root/html530/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBContainer.html
https://root.cern/root/html530/TGLBContainer.html:5729,Availability,error,error,5729,"t(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaul",MatchSource.WIKI,root/html530/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBContainer.html
https://root.cern/root/html530/TGLBContainer.html:12489,Availability,mask,mask,12489,") const; voidTObject::InvertBit(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGContainer::KeyPressed(TGFrame*, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidLayout(); virtual voidTGContainer::LineDown(Bool_t select = kFALSE); virtual voidTGContainer::LineLeft(Bool_t select = kFALSE); virtual voidTGContainer::LineRight(Bool_t select = kFALSE); virtual voidTGContainer::LineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSign",MatchSource.WIKI,root/html530/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBContainer.html
https://root.cern/root/html530/TGLBContainer.html:21166,Availability,mask,mask,21166,,MatchSource.WIKI,root/html530/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBContainer.html
https://root.cern/root/html530/TGLBContainer.html:25611,Deployability,update,update,25611," Inherited Members; Includes; Libraries. Function documentation; TGLBContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a listbox container. ~TGLBContainer(); Delete the listbox container. void Layout(); Layout container. void DoRedraw(); redraw. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add listbox entry with hints to container. To show entry call; MapSubwindows() and Layout(). void InsertEntry(TGLBEntry* lbe, TGLayoutHints* lhints, Int_t afterID); Insert listbox entry after specified entry with id afterID. If afterID = -1; then add entry at head of list. To show entry call MapSubwindows() and; Layout(). void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Insert listbox entry before the list box entry with a higher id.; To show entry call MapSubwindows() and Layout(). void RemoveEntry(Int_t id); Remove the entry with specified id from the listbox container.; To update the listbox call Layout(). void RemoveEntries(Int_t from_ID, Int_t to_ID); Remove entries from from_ID to to_ID (including).; To update the listbox call Layout(). void RemoveAll(); Remove all entries in this container. TGLBEntry * Select(Int_t id); Select the entry with the specified id.; Returns the selected TGLBEntry. TGLBEntry * Select(Int_t id, Bool_t sel); Select / deselect the entry with the specified id.; Returns the selected TGLBEntry. Int_t GetSelected() const; Returns id of selected entry. In case of no selected entry or; if multi selection is switched on returns -1. Bool_t GetSelection(Int_t id); Returns kTrue if entry id is selected. void GetSelectedEntries(TList* selected); Adds all selected entries (TGLBEntry) of the list box into; the list selected. void SetMultipleSelections(Bool_t multi); Enables and disables multiple selections of entries. TGVScrollBar * GetVScrollbar() const; Return a pointer to vertical scroll bar. void SetVsbPosition(Int_t newPos); Set new vertical scroll",MatchSource.WIKI,root/html530/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBContainer.html
https://root.cern/root/html530/TGLBContainer.html:25747,Deployability,update,update,25747," options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a listbox container. ~TGLBContainer(); Delete the listbox container. void Layout(); Layout container. void DoRedraw(); redraw. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add listbox entry with hints to container. To show entry call; MapSubwindows() and Layout(). void InsertEntry(TGLBEntry* lbe, TGLayoutHints* lhints, Int_t afterID); Insert listbox entry after specified entry with id afterID. If afterID = -1; then add entry at head of list. To show entry call MapSubwindows() and; Layout(). void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Insert listbox entry before the list box entry with a higher id.; To show entry call MapSubwindows() and Layout(). void RemoveEntry(Int_t id); Remove the entry with specified id from the listbox container.; To update the listbox call Layout(). void RemoveEntries(Int_t from_ID, Int_t to_ID); Remove entries from from_ID to to_ID (including).; To update the listbox call Layout(). void RemoveAll(); Remove all entries in this container. TGLBEntry * Select(Int_t id); Select the entry with the specified id.; Returns the selected TGLBEntry. TGLBEntry * Select(Int_t id, Bool_t sel); Select / deselect the entry with the specified id.; Returns the selected TGLBEntry. Int_t GetSelected() const; Returns id of selected entry. In case of no selected entry or; if multi selection is switched on returns -1. Bool_t GetSelection(Int_t id); Returns kTrue if entry id is selected. void GetSelectedEntries(TList* selected); Adds all selected entries (TGLBEntry) of the list box into; the list selected. void SetMultipleSelections(Bool_t multi); Enables and disables multiple selections of entries. TGVScrollBar * GetVScrollbar() const; Return a pointer to vertical scroll bar. void SetVsbPosition(Int_t newPos); Set new vertical scroll bar position. Bool_t HandleButton(Event_t* event); Handle mouse button event in the listbox container. Bool_t HandleDoubleClick(Event_t",MatchSource.WIKI,root/html530/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBContainer.html
https://root.cern/root/html530/TGLBContainer.html:22608,Integrability,message,messages,22608,eElement*TGContainer::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TGListBox*fListBoxlist box which contains this container; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; Bool_tfMultiSelecttrue if multi selection is switched on; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTGContainer::fTotaltotal items; TGViewPort*TGContainer::fViewPortcontainer viewport; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGContainer::fX0; Int_tTGContainer::fXDND; Int_tTGContainer::fXf; Int_tTGContainer::fXp; Int_tTGFrame::fYframe y position; Int_tTGContainer::fY0corner of rubber band box; Int_tTGContaine,MatchSource.WIKI,root/html530/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBContainer.html
https://root.cern/root/html530/TGLBContainer.html:445,Usability,simpl,simple,445,". TGLBContainer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLBContainer. class TGLBContainer: public TGContainer. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. TGLBContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGLBContainer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidActivateItem(TGFrameElement* el); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidAddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidAssociate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGComposite",MatchSource.WIKI,root/html530/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBContainer.html
https://root.cern/root/html530/TGLBEntry.html:4555,Availability,error,error,4555,"t::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tEntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html530/TGLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBEntry.html
https://root.cern/root/html530/TGLBEntry.html:4639,Availability,error,error,4639,"Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tEntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static",MatchSource.WIKI,root/html530/TGLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBEntry.html
https://root.cern/root/html530/TGLBEntry.html:15820,Availability,mask,mask,15820,,MatchSource.WIKI,root/html530/TGLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBEntry.html
https://root.cern/root/html530/TGLBEntry.html:429,Usability,simpl,simple,429,". TGLBEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLBEntry. class TGLBEntry: public TGFrame. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. TGLBEntry(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame, Pixel_t back = GetWhitePixel()); ~TGLBEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* recei",MatchSource.WIKI,root/html530/TGLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBEntry.html
https://root.cern/root/html530/TGLBoundingBox.html:2773,Performance,cache,cached,2773," other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double_t* pnts); voidSetEmpty(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTransform(const TGLMatrix& matrix); voidTranslate(const TGLVector3& offset); const TGLVertex3&Vertex(UInt_t index) const; const TGLVertex3*Vertices() const; Double_tVolume() const; Double_tXMax() const; Double_tXMin() const; Double_tYMax() const; Double_tYMin() const; Double_tZMax() const; Double_tZMin() const. private:. Double_tMax(UInt_t index) const; Double_tMin(UInt_t index) const; voidUpdateCache(); Bool_tValidIndex(UInt_t index) const. Data Members; public:. enum EFace { kFaceLowX; kFaceHighX; kFaceLowY; kFaceHighY; kFaceLowZ; kFaceHighZ; kFaceCount; };. private:. TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 ve",MatchSource.WIKI,root/html530/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBoundingBox.html
https://root.cern/root/html530/TGLBoundingBox.html:2853,Performance,cache,cached,2853," other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double_t* pnts); voidSetEmpty(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTransform(const TGLMatrix& matrix); voidTranslate(const TGLVector3& offset); const TGLVertex3&Vertex(UInt_t index) const; const TGLVertex3*Vertices() const; Double_tVolume() const; Double_tXMax() const; Double_tXMin() const; Double_tYMax() const; Double_tYMin() const; Double_tZMax() const; Double_tZMin() const. private:. Double_tMax(UInt_t index) const; Double_tMin(UInt_t index) const; voidUpdateCache(); Bool_tValidIndex(UInt_t index) const. Data Members; public:. enum EFace { kFaceLowX; kFaceHighX; kFaceLowY; kFaceHighY; kFaceLowZ; kFaceHighZ; kFaceCount; };. private:. TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 ve",MatchSource.WIKI,root/html530/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBoundingBox.html
https://root.cern/root/html530/TGLBoundingBox.html:2909,Performance,cache,cached,2909," other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double_t* pnts); voidSetEmpty(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTransform(const TGLMatrix& matrix); voidTranslate(const TGLVector3& offset); const TGLVertex3&Vertex(UInt_t index) const; const TGLVertex3*Vertices() const; Double_tVolume() const; Double_tXMax() const; Double_tXMin() const; Double_tYMax() const; Double_tYMin() const; Double_tZMax() const; Double_tZMin() const. private:. Double_tMax(UInt_t index) const; Double_tMin(UInt_t index) const; voidUpdateCache(); Bool_tValidIndex(UInt_t index) const. Data Members; public:. enum EFace { kFaceLowX; kFaceHighX; kFaceLowY; kFaceHighY; kFaceLowZ; kFaceHighZ; kFaceCount; };. private:. TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 ve",MatchSource.WIKI,root/html530/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBoundingBox.html
https://root.cern/root/html530/TGLBoundingBox.html:3008,Performance,cache,cached,3008," other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double_t* pnts); voidSetEmpty(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTransform(const TGLMatrix& matrix); voidTranslate(const TGLVector3& offset); const TGLVertex3&Vertex(UInt_t index) const; const TGLVertex3*Vertices() const; Double_tVolume() const; Double_tXMax() const; Double_tXMin() const; Double_tYMax() const; Double_tYMin() const; Double_tZMax() const; Double_tZMin() const. private:. Double_tMax(UInt_t index) const; Double_tMin(UInt_t index) const; voidUpdateCache(); Bool_tValidIndex(UInt_t index) const. Data Members; public:. enum EFace { kFaceLowX; kFaceHighX; kFaceLowY; kFaceHighY; kFaceLowZ; kFaceHighZ; kFaceCount; };. private:. TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 ve",MatchSource.WIKI,root/html530/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBoundingBox.html
https://root.cern/root/html530/TGLBoundingBox.html:3694,Performance,cache,cached,3694," TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 vertices. void Set(const Double_t vertex[8][3]); Set a bounding box from provided 8 vertices. void Set(const TGLBoundingBox& other); Set a bounding box from vertices of other. void SetEmpty(); Set bounding box empty - all vertices at (0,0,0). void SetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Set ALIGNED box from two low/high vertices. Box axes are aligned with; global frame axes that vertices are specified in. void SetAligned(UInt_t nbPnts, const Double_t* pnts); Set ALIGNED box from one or more points. Box axes are aligned with; global frame axes that points are specified in. void MergeAligned(const TGLBoundingBox& other); Expand current bbox so that it includes other's bbox.; This make the bbox axis-aligned. void ExpandAligned(const TGLVertex3& point); Expand current bbox so that it includes the point.; This make",MatchSource.WIKI,root/html530/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBoundingBox.html
https://root.cern/root/html530/TGLBoundingBox.html:506,Testability,test,tests,506,". TGLBoundingBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLBoundingBox. class TGLBoundingBox. TGLBoundingBox. Concrete class describing an orientated (free) or axis aligned box; of 8 verticies. Supports methods for setting aligned or orientated; boxes, find volume, axes, extents, centers, face planes etc.; Also tests for overlap testing of planes and other bounding boxes,; with fast sphere approximation. Function Members (Methods); public:. TGLBoundingBox(); TGLBoundingBox(const TGLVertex3* vertex); TGLBoundingBox(const Double_t** vertex); TGLBoundingBox(const TGLBoundingBox& other); TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); virtual~TGLBoundingBox(); const TGLVector3&Axis(UInt_t i, Bool_t normalised = kTRUE) const; TGLVertex3Center() const; static TClass*Class(); Double_tDiagonal() const; voidDraw(Bool_t solid = kFALSE) const; voidDump() const; voidExpandAligned(const TGLVertex3& point); TGLVector3Extents() const; const vector<UInt_t>&FaceVertices(TGLBoundingBox::EFace face) const; TGLPlaneGetNearPlane() const; virtual TClass*IsA() const; Bool_tIsEmpty() const; TGLVertex3MaxAAVertex() const; voidMergeAligned(const TGLBoundingBox& other); TGLVertex3MinAAVertex() const; Int_tNumVertices() const; TGLBoundingBox&operator=(const TGLBoundingBox& other); const TGLVertex3&operator[](UInt_t index) const; EOverlapOverlap(const TGLPlane& plane) const; EOverlapOverlap(const TGLBoundingBox& box) const; voidPlaneSet(TGLPlaneSet_t& planeSet) const; voidScale(Double_t factor); voidScale(Double_t xFactor, Double_t yFactor, Double_t zFactor); voidSet(const TGLVertex3* vertex); voidSet(const Double_t** vertex); voidSet(const TGLBoundingBox& other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double",MatchSource.WIKI,root/html530/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBoundingBox.html
https://root.cern/root/html530/TGLBoundingBox.html:524,Testability,test,testing,524,". TGLBoundingBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLBoundingBox. class TGLBoundingBox. TGLBoundingBox. Concrete class describing an orientated (free) or axis aligned box; of 8 verticies. Supports methods for setting aligned or orientated; boxes, find volume, axes, extents, centers, face planes etc.; Also tests for overlap testing of planes and other bounding boxes,; with fast sphere approximation. Function Members (Methods); public:. TGLBoundingBox(); TGLBoundingBox(const TGLVertex3* vertex); TGLBoundingBox(const Double_t** vertex); TGLBoundingBox(const TGLBoundingBox& other); TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); virtual~TGLBoundingBox(); const TGLVector3&Axis(UInt_t i, Bool_t normalised = kTRUE) const; TGLVertex3Center() const; static TClass*Class(); Double_tDiagonal() const; voidDraw(Bool_t solid = kFALSE) const; voidDump() const; voidExpandAligned(const TGLVertex3& point); TGLVector3Extents() const; const vector<UInt_t>&FaceVertices(TGLBoundingBox::EFace face) const; TGLPlaneGetNearPlane() const; virtual TClass*IsA() const; Bool_tIsEmpty() const; TGLVertex3MaxAAVertex() const; voidMergeAligned(const TGLBoundingBox& other); TGLVertex3MinAAVertex() const; Int_tNumVertices() const; TGLBoundingBox&operator=(const TGLBoundingBox& other); const TGLVertex3&operator[](UInt_t index) const; EOverlapOverlap(const TGLPlane& plane) const; EOverlapOverlap(const TGLBoundingBox& box) const; voidPlaneSet(TGLPlaneSet_t& planeSet) const; voidScale(Double_t factor); voidScale(Double_t xFactor, Double_t yFactor, Double_t zFactor); voidSet(const TGLVertex3* vertex); voidSet(const Double_t** vertex); voidSet(const TGLBoundingBox& other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double",MatchSource.WIKI,root/html530/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBoundingBox.html
https://root.cern/root/html530/TGLBoxPainter.html:342,Modifiability,variab,variable-sized,342,". TGLBoxPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLBoxPainter. class TGLBoxPainter: public TGLPlotPainter. Paints TH3 histograms by rendering variable-sized bozes matching the; bin contents. Function Members (Methods); public:. TGLBoxPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); TGLBoxPainter(TH1* hist, TPolyMarker3D* pm, TGLPlotCamera* camera, TGLPlotCoordinates* coord); ~TGLBoxPainter(); virtual voidAddOption(const TString& stringOption); static TClass*Class(); Bool_tTGLPlotPainter::CutAxisSelected() const; virtual char*GetPlotInfo(Int_t px, Int_t py); virtual Bool_tInitGeometry(); voidTGLPlotPainter::InvalidateSelection(); virtual TClass*IsA() const; virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. TGLBoxPainter(const TGLBoxPainter&); virtual voidDeInitGL()",MatchSource.WIKI,root/html530/TGLBoxPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBoxPainter.html
https://root.cern/root/html530/TGLBoxPainter.html:4600,Modifiability,variab,variables,4600,"s.; TStringfPlotInfo; const TPolyMarker3D*fPolymarkerPolymarker from TTree.; TGLQuadricfQuadric; TGLBoxPainter::EBoxTypefType; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoxPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Normal constructor. TGLBoxPainter(TH1* hist, TPolyMarker3D* pm, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Normal constructor. char * GetPlotInfo(Int_t px, Int_t py); Show box info (i, j, k, binContent). Bool_t InitGeometry(); Set ranges, find min and max bin content. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); Box1 == spheres. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove sections. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return back some gl state variables. void DrawPlot() const. void DrawCloud() const; Draw a frame and a polymarker inside. void SetPlotColor() const; Set boxes color. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. Bool_t HasSections() const; Check, if any section exists. void DrawPalette() const; Draw. Palette.; Originally, fCamera was never null.; It can be a null now because of gl-viewer. void DrawPaletteAxis() const; Draw. Palette. Axis. TGLBoxPainter(const TGLBoxPainter& ). » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLBoxPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBoxPainter.html
https://root.cern/root/html530/TGLBoxPainter.html:4660,Modifiability,variab,variables,4660,"s.; TStringfPlotInfo; const TPolyMarker3D*fPolymarkerPolymarker from TTree.; TGLQuadricfQuadric; TGLBoxPainter::EBoxTypefType; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoxPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Normal constructor. TGLBoxPainter(TH1* hist, TPolyMarker3D* pm, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Normal constructor. char * GetPlotInfo(Int_t px, Int_t py); Show box info (i, j, k, binContent). Bool_t InitGeometry(); Set ranges, find min and max bin content. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); Box1 == spheres. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove sections. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return back some gl state variables. void DrawPlot() const. void DrawCloud() const; Draw a frame and a polymarker inside. void SetPlotColor() const; Set boxes color. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. Bool_t HasSections() const; Check, if any section exists. void DrawPalette() const; Draw. Palette.; Originally, fCamera was never null.; It can be a null now because of gl-viewer. void DrawPaletteAxis() const; Draw. Palette. Axis. TGLBoxPainter(const TGLBoxPainter& ). » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLBoxPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLBoxPainter.html
https://root.cern/root/html530/TGLCamera.html:1043,Availability,avail,available,1043,"epage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLCamera. class TGLCamera. TGLCamera. Abstract base camera class - concrete classes for orthographic and; persepctive cameras derive from it. This class maintains values for; the current:; i) Viewport; ii) Projection, modelview and clip matricies - extracted from GL; iii) The 6 frustum planes; iv) Expanded frustum interest box. It provides methods for various projection, overlap and intersection; tests for viewport and world locations, against the true frustum and; expanded interest box, and for extracting eye position and direction. It also defines the pure virtual manipulation interface methods the; concrete ortho and prespective classes must implement. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLCamera(); Bool_tAdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tAdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidDrawDebugAids() const; TGLVector3EyeDirection() const; TGLVertex3EyePoint() const; TGLVertex3FrustumCenter() const; EOverlapFrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&GetCamBase() const; const TGLMatrix&GetCamTrans() const; Double_t*GetCenterVec(); Bool_tGetExternalCenter(); Double_tGetFarClip() const; Double_t*GetFixDefCenter",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:14130,Deployability,configurat,configuration,14130,"er last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Doub",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:14743,Deployability,update,updated,14743,") having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ) for sensitivity:. mod1 = kFALSE, mod2 = kFALSE : normal sensitivity (screenShift/screenShiftRange); mod1 = kTRUE, mod2 = kFALSE : 0.1x sensitivity; mod1 = kTRUE, mod2 = kTRUE : 0.01x sensitivity; mod1 = kFALSE, mod2 = kTRUE : 10.0x sensitivity. 'val' is modified and clamped to 'min' / 'max' range.; Return bool kTRUE if val actually changed. Used as common interaction function for adjusting zoom/dolly etc. Double_t AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; Adjust ",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:14964,Deployability,update,updated,14964,"LCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ) for sensitivity:. mod1 = kFALSE, mod2 = kFALSE : normal sensitivity (screenShift/screenShiftRange); mod1 = kTRUE, mod2 = kFALSE : 0.1x sensitivity; mod1 = kTRUE, mod2 = kTRUE : 0.01x sensitivity; mod1 = kFALSE, mod2 = kTRUE : 10.0x sensitivity. 'val' is modified and clamped to 'min' / 'max' range.; Return bool kTRUE if val actually changed. Used as common interaction function for adjusting zoom/dolly etc. Double_t AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; Adjust a passed screen value and apply modifiers.; See AdjustAndClampVal() for details. void DrawDebugAids() const; Draw out some debugging aids for t",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:831,Integrability,interface,interface,831,". TGLCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLCamera. class TGLCamera. TGLCamera. Abstract base camera class - concrete classes for orthographic and; persepctive cameras derive from it. This class maintains values for; the current:; i) Viewport; ii) Projection, modelview and clip matricies - extracted from GL; iii) The 6 frustum planes; iv) Expanded frustum interest box. It provides methods for various projection, overlap and intersection; tests for viewport and world locations, against the true frustum and; expanded interest box, and for extracting eye position and direction. It also defines the pure virtual manipulation interface methods the; concrete ortho and prespective classes must implement. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLCamera(); Bool_tAdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tAdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidDrawDebugAids() const; TGLVector3EyeDirection() const; TGLVertex3EyePoint() const; TGLVertex3FrustumCenter() const; EOverlapFrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&GetCamBase() const; const TGLMatrix&GetCamTrans() const; Double_t*GetCenterVec(); Bool_tGetExternalCenter(); Double_tGetFarCli",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:14072,Integrability,depend,dependent,14072,"er last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Doub",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:18194,Integrability,interface,interface,18194,"l_t mod1, Bool_t mod2); Dolly the camera - 'move camera along eye line, retaining lens focal length'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive dolly in, -ive dolly out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. const TGLPlane & FrustumPlane(TGLCamera::EFrustumPlane plane) const; Return one of the planes forming the camera frustum. TGLCamera & operator=(const TGLCamera& ). Bool_t IsOrthographic() const; { return kFALSE; }. Bool_t IsPerspective() const; { return kFALSE; }. const TGLMatrix& RefModelViewMatrix() const; { return fModVM; }. Bool_t IsCacheDirty() const; { return fCacheDirty; }. void IncTimeStamp(); { fCacheDirty = kTRUE; ++fTimeStamp; }. UInt_t TimeStamp() const; { return fTimeStamp; }. TGLRect& RefViewport(); { return fViewport; }. const TGLRect& RefViewport() const; { return fViewport; }. void Setup(const TGLBoundingBox& box, Bool_t reset = kTRUE); Camera manipulation interface (GL coord - origin bottom left). void Reset(). Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2). Bool_t Truck(Double_t xDelta, Double_t yDelta). void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const. Bool_t GetExternalCenter(); { return fExternalCenter; }. Double_t* GetCenterVec(); { return fCenter->Arr(); }. void SetFixDefCenter(Bool_t x); { fFixDefCenter = x; }. void SetFixDefCenterVec(Double_t x, Double_t y, Double_t z); { fFDCenter.Set(x, y, z); }. Double_t* GetFixDefCenterVec(); { return fFDCenter.Arr(); }. Double_t GetNearClip() const; { return fNearClip; }. Double_t GetFarClip() const; { return fFarClip; }. const TGLMatrix& GetCamBase() const; { return fCamBase; }. const TGLMatrix& GetCamTrans() const; If you manipulate camera ... also call IncTimeStamp() before redraw. { return fCamTrans; }. TGLMatrix& RefCamBase(); { return fCamBase; }. TGLMatrix& RefCamTrans(); { return fCamTrans; }. TGLMatrix& RefLastNoPickProjM() const",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:12529,Modifiability,extend,extended,12529,"near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:14130,Modifiability,config,configuration,14130,"er last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Doub",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:4933,Performance,cache,cached,4933,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:5175,Performance,cache,cached,5175,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:5663,Performance,cache,cached,5663,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:5879,Performance,cache,cached,5879,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:5923,Performance,cache,cached,5923,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:6011,Performance,cache,cached,6011,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:6842,Performance,cache,cached,6842,"trixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frustum box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:7178,Performance,cache,cache,7178,"tatic UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frustum box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum c",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:7476,Performance,cache,cache,7476,"estBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frustum box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have vali",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:7667,Performance,cache,cache,7667,"s; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle w",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:7965,Performance,cache,cache,7965,"ngBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TGLBoundingB",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:8190,Performance,cache,cache,8190,"near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TGLBoundingBox::EFace* face = 0) const; Calculate viewport rectangle which just contains projection of; world frame bounding box 'box' onto the viewport. If face is; null the rect contains the whole bounding box (8 vertices/6; faces). If face is non-null it indicates a box ",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:8458,Performance,cache,cache,8458,"ustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TGLBoundingBox::EFace* face = 0) const; Calculate viewport rectangle which just contains projection of; world frame bounding box 'box' onto the viewport. If face is; null the rect contains the whole bounding box (8 vertices/6; faces). If face is non-null it indicates a box face, and the; rect contains the single face (4 vertices). Note use other; version of ViewportRect() if you wish to just pass a static; EFace enum member (e.g. kFaceLowX). Note:; i) Rectangle is NOT clipped by viewport limits - so can result; in rect with corners outside viewport - negative etc; ii) TGLRect provides int (pixel based)",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:9540,Performance,cache,cache,9540,"tum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TGLBoundingBox::EFace* face = 0) const; Calculate viewport rectangle which just contains projection of; world frame bounding box 'box' onto the viewport. If face is; null the rect contains the whole bounding box (8 vertices/6; faces). If face is non-null it indicates a box face, and the; rect contains the single face (4 vertices). Note use other; version of ViewportRect() if you wish to just pass a static; EFace enum member (e.g. kFaceLowX). Note:; i) Rectangle is NOT clipped by viewport limits - so can result; in rect with corners outside viewport - negative etc; ii) TGLRect provides int (pixel based) values - not subpxiel accurate; iii) Camera must have valid frustum cache - call Apply() after last; modifcation, before calling. TGLVertex3 WorldToViewport(const TGLVertex3& worldVertex, TGLMatrix* modviewMat = 0) const; Convert a 3D world vertex to '3D' viewport (screen) one. The X()/Y(); components of the viewport vertex are the horizontal/vertical pixel; positions. The Z() component is the viewport depth value - for a; default depth range this is 0.0 (at near clip plane) to 1.0 (at far; clip plane). See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 WorldDeltaToViewport(const TGLVertex3& worldRef, const TGLVector3& worldDelta) const; Convert a 3D vector worldDelta (shift) about vertex worldRef to a viewport; (screen) '3D' vector. The X()/Y() components of the vector are the horizontal; vertical pixel deltas. The Z() component is the viewport depth delta - for a; defaul",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:10059,Performance,cache,cache,10059,"x (8 vertices/6; faces). If face is non-null it indicates a box face, and the; rect contains the single face (4 vertices). Note use other; version of ViewportRect() if you wish to just pass a static; EFace enum member (e.g. kFaceLowX). Note:; i) Rectangle is NOT clipped by viewport limits - so can result; in rect with corners outside viewport - negative etc; ii) TGLRect provides int (pixel based) values - not subpxiel accurate; iii) Camera must have valid frustum cache - call Apply() after last; modifcation, before calling. TGLVertex3 WorldToViewport(const TGLVertex3& worldVertex, TGLMatrix* modviewMat = 0) const; Convert a 3D world vertex to '3D' viewport (screen) one. The X()/Y(); components of the viewport vertex are the horizontal/vertical pixel; positions. The Z() component is the viewport depth value - for a; default depth range this is 0.0 (at near clip plane) to 1.0 (at far; clip plane). See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 WorldDeltaToViewport(const TGLVertex3& worldRef, const TGLVector3& worldDelta) const; Convert a 3D vector worldDelta (shift) about vertex worldRef to a viewport; (screen) '3D' vector. The X()/Y() components of the vector are the horizontal; vertical pixel deltas. The Z() component is the viewport depth delta - for a; default depth range between 0.0 (at near clip plane) to 1.0 (at far clip plane); See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply(). TGLVertex3 ViewportToWorld(const TGLVertex3& viewportVertex, TGLMatrix* modviewMat = 0) const; Convert a '3D' viewport vertex to 3D world one. The X()/Y() components; of viewportVertex are the horizontal/vertical pixel position. TGLLine3 ViewportToWorld(Double_t viewportX, Double_t viewportY) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip ",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:10607,Performance,cache,cache,10607," TGLVertex3 WorldToViewport(const TGLVertex3& worldVertex, TGLMatrix* modviewMat = 0) const; Convert a 3D world vertex to '3D' viewport (screen) one. The X()/Y(); components of the viewport vertex are the horizontal/vertical pixel; positions. The Z() component is the viewport depth value - for a; default depth range this is 0.0 (at near clip plane) to 1.0 (at far; clip plane). See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 WorldDeltaToViewport(const TGLVertex3& worldRef, const TGLVector3& worldDelta) const; Convert a 3D vector worldDelta (shift) about vertex worldRef to a viewport; (screen) '3D' vector. The X()/Y() components of the vector are the horizontal; vertical pixel deltas. The Z() component is the viewport depth delta - for a; default depth range between 0.0 (at near clip plane) to 1.0 (at far clip plane); See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply(). TGLVertex3 ViewportToWorld(const TGLVertex3& viewportVertex, TGLMatrix* modviewMat = 0) const; Convert a '3D' viewport vertex to 3D world one. The X()/Y() components; of viewportVertex are the horizontal/vertical pixel position. TGLLine3 ViewportToWorld(Double_t viewportX, Double_t viewportY) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLLine3 ViewportToWorld(const TPoint& viewport) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip ",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:11345,Performance,cache,cache,11345,"horizontal; vertical pixel deltas. The Z() component is the viewport depth delta - for a; default depth range between 0.0 (at near clip plane) to 1.0 (at far clip plane); See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply(). TGLVertex3 ViewportToWorld(const TGLVertex3& viewportVertex, TGLMatrix* modviewMat = 0) const; Convert a '3D' viewport vertex to 3D world one. The X()/Y() components; of viewportVertex are the horizontal/vertical pixel position. TGLLine3 ViewportToWorld(Double_t viewportX, Double_t viewportY) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLLine3 ViewportToWorld(const TPoint& viewport) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection ver",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:11875,Performance,cache,cache,11875,"e_t viewportX, Double_t viewportY) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLLine3 ViewportToWorld(const TPoint& viewport) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:12690,Performance,cache,cache,12690,"t TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. T",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:13086,Performance,cache,cache,13086,"n of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected ",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:13513,Performance,cache,cache,13513,"e projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bou",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:14334,Security,access,accessor,14334,"(shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:645,Testability,test,tests,645,". TGLCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLCamera. class TGLCamera. TGLCamera. Abstract base camera class - concrete classes for orthographic and; persepctive cameras derive from it. This class maintains values for; the current:; i) Viewport; ii) Projection, modelview and clip matricies - extracted from GL; iii) The 6 frustum planes; iv) Expanded frustum interest box. It provides methods for various projection, overlap and intersection; tests for viewport and world locations, against the true frustum and; expanded interest box, and for extracting eye position and direction. It also defines the pure virtual manipulation interface methods the; concrete ortho and prespective classes must implement. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLCamera(); Bool_tAdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tAdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidDrawDebugAids() const; TGLVector3EyeDirection() const; TGLVertex3EyePoint() const; TGLVertex3FrustumCenter() const; EOverlapFrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&GetCamBase() const; const TGLMatrix&GetCamTrans() const; Double_t*GetCenterVec(); Bool_tGetExternalCenter(); Double_tGetFarCli",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:12565,Testability,test,test,12565,"near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:14282,Testability,log,logical,14282,"(shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:14303,Testability,test,test,14303,"(shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLCamera.html:14589,Testability,test,test,14589,"d frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ) for sensitivity:. mod1 = kFALSE, mod2 = kFALSE : normal sensitivity (screenShift/screenShiftRange); mod1 = kTRUE, mod2 = kFALSE : 0.1x sensitivity; mod1 = kTRUE, mod2 = kTRUE : 0.01x sensitivity; mod1 = kFALSE, mod2 = kTRUE : 10.0x sensitivity. 'val' is modified and clamped to 'min' / 'max' range.; Return bool kTRUE if val actual",MatchSource.WIKI,root/html530/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCamera.html
https://root.cern/root/html530/TGLClip.html:669,Availability,avail,available,669,". TGLClip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLClip. class TGLClip: public TGLPhysicalShape. TGLClip. Abstract clipping shape - derives from TGLPhysicalShape; Adds clip mode (inside/outside) and pure virtual method to; approximate shape as set of planes. This plane set is used to perform; interactive clipping using OpenGL clip planes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLClip(); voidTGLPhysicalShape::AddReference(TGLPShapeRef* ref); const TGLBoundingBox&TGLPhysicalShape::BoundingBox() const; virtual voidTGLPhysicalShape::CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*TGLPhysicalShape::Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*TGLPhysicalShape::GetLogical() const; TGLPhysicalShape::EManipTGLPhysicalShape::GetManip() const; TGLClip::EModeGetMode() const; const TGLPhysicalShape*TGLPhysicalShape::GetNextPhysical() const; TGLVector3TGLPhysicalShape::GetScale() const; UChar_tTGLPhysicalShape::GetSelected() const; TGLVertex3TGLPhysicalShape::GetTranslation() const; UInt_tTGLPhysicalShape::ID() const; voidIncTimeStamp(); voidInvalidate(); voidTGLPhysicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tTGLPhysicalShape::IsInvisible() const; Bool_tTGLPhysicalShape::IsModified() const; Bool_tTGLPhysicalShape::IsSelected() const; Bool_tTGLPhysicalShape::IsTransparent() const; Bool_tIsValid() const; virtual voidModified(); virtual voidPlaneSet(TGLPlaneSet_t& set) const; virtual voidTGLPhysicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidTG",MatchSource.WIKI,root/html530/TGLClip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLClip.html
https://root.cern/root/html530/TGLClip.html:479,Performance,perform,perform,479,". TGLClip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLClip. class TGLClip: public TGLPhysicalShape. TGLClip. Abstract clipping shape - derives from TGLPhysicalShape; Adds clip mode (inside/outside) and pure virtual method to; approximate shape as set of planes. This plane set is used to perform; interactive clipping using OpenGL clip planes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLClip(); voidTGLPhysicalShape::AddReference(TGLPShapeRef* ref); const TGLBoundingBox&TGLPhysicalShape::BoundingBox() const; virtual voidTGLPhysicalShape::CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*TGLPhysicalShape::Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*TGLPhysicalShape::GetLogical() const; TGLPhysicalShape::EManipTGLPhysicalShape::GetManip() const; TGLClip::EModeGetMode() const; const TGLPhysicalShape*TGLPhysicalShape::GetNextPhysical() const; TGLVector3TGLPhysicalShape::GetScale() const; UChar_tTGLPhysicalShape::GetSelected() const; TGLVertex3TGLPhysicalShape::GetTranslation() const; UInt_tTGLPhysicalShape::ID() const; voidIncTimeStamp(); voidInvalidate(); voidTGLPhysicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tTGLPhysicalShape::IsInvisible() const; Bool_tTGLPhysicalShape::IsModified() const; Bool_tTGLPhysicalShape::IsSelected() const; Bool_tTGLPhysicalShape::IsTransparent() const; Bool_tIsValid() const; virtual voidModified(); virtual voidPlaneSet(TGLPlaneSet_t& set) const; virtual voidTGLPhysicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidTG",MatchSource.WIKI,root/html530/TGLClip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLClip.html
https://root.cern/root/html530/TGLClipBox.html:4093,Deployability,update,update,4093,"ctor3& min_point, const TGLVector3& max_point); voidTGLPhysicalShape::SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); UInt_tTGLClip::TimeStamp() const; voidTGLPhysicalShape::Translate(const TGLVector3& vect). Data Members; public:. enum TGLClip::EMode { kOutside; kInside; };; enum TGLPhysicalShape::EManip { kTranslateX; kTranslateY; kTranslateZ; kTranslateAll; kScaleX; kScaleY; kScaleZ; kScaleAll; kRotateX; kRotateY; kRotateZ; kRotateAll; kManipAll; };. protected:. TGLClip::EModeTGLClip::fMode; UInt_tTGLClip::fTimeStamp; Bool_tTGLClip::fValid. private:. static const floatfgColor[4]! Fixed color of clip box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipBox(); Construct an (initially) axis aligned clip pbox object, extents; 'halfLengths', centered on 'center' vertex.; Box can be translated, rotated and scaled in all (xyz) local axes. ~TGLClipBox(); Destroy clip box object. void Setup(const TGLBoundingBox& bbox); Setup the clip object for scene encompassed by bbox. void Setup(const TGLVector3& min_point, const TGLVector3& max_point); Setup the clip box with min/max points directly. This only makes sense if you disable auto-update of the; clip-object:; gl_viewer->SetClipAutoUpdate(kFALSE).; After calling this also call gl_viewer->RefreshPadEditor(gl_viewer); and gl_viewer->RequestDraw(). void PlaneSet(TGLPlaneSet_t& set) const; Return set of 6 planes describing faces of the box but invert them; so that they point inside of box. » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLClip.h 32465 2010-03-04 20:29:52Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLClipBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLClipBox.html
https://root.cern/root/html530/TGLClipPlane.html:4645,Deployability,update,update,4645,"TGLClip::fMode; UInt_tTGLClip::fTimeStamp; Bool_tTGLClip::fValid. private:. static const floatfgColor[4]! Fixed color of clip plane. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipPlane(); Construct a clip plane object, based on supplied 'plane', with; initial manipulation pivot at 'center', with drawn extents (in; local x/y axes) of 'extents'. Plane can have center pivot translated in all directions, and; rotated round center in X/Y axes , the in-plane axes. It cannot; be scaled. Note theorectically a plane is of course infinite - however we; want to draw the object in viewer - so we fake it with a single; GL face (polygon) - extents defines the width/depth of this -; should be several times scene extents - see Setup(). ~TGLClipPlane(); Destroy clip plane object. void Setup(const TGLBoundingBox& bbox); Setup the clip object for scene encompassed by bbox. void Setup(const TGLVector3& point, const TGLVector3& normal); Setup the clipping plane by point and normal.; Length of the normal determines the size of the plane drawn in; GL viewer. The normal points into the direction of visible half-plane. This only makes sense if you disable auto-update of the; clip-object:; gl_viewer->SetClipAutoUpdate(kFALSE).; After calling this also call gl_viewer->RefreshPadEditor(gl_viewer); and gl_viewer->RequestDraw(). void Set(const TGLPlane& plane); Update clip plane object to follow passed 'plane' equation. Center pivot; is shifted to nearest point on new plane. void PlaneSet(TGLPlaneSet_t& set) const; Return set of planes (actually a single one) describing this clip plane. » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLClip.h 32465 2010-03-04 20:29:52Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLClipPlane.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLClipPlane.html
https://root.cern/root/html530/TGLClipSetEditor.html:4469,Availability,error,error,4469,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGLClipSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLClipSetEditor.html
https://root.cern/root/html530/TGLClipSetEditor.html:4553,Availability,error,error,4553,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGLClipSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLClipSetEditor.html
https://root.cern/root/html530/TGLClipSetEditor.html:17353,Availability,mask,mask,17353,,MatchSource.WIKI,root/html530/TGLClipSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLClipSetEditor.html
https://root.cern/root/html530/TGLClipSetSubEditor.html:4200,Availability,error,error,4200,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGLClipSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLClipSetSubEditor.html
https://root.cern/root/html530/TGLClipSetSubEditor.html:4284,Availability,error,error,4284,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGLClipSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLClipSetSubEditor.html
https://root.cern/root/html530/TGLClipSetSubEditor.html:16911,Availability,mask,mask,16911,,MatchSource.WIKI,root/html530/TGLClipSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLClipSetSubEditor.html
https://root.cern/root/html530/TGLClipSetSubEditor.html:19403,Deployability,update,update,19403,"used for suppression of signals; TGButtonGroup*fTypeButtons; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipSetSubEditor(const TGWindow* p); Constructor. void SetModel(TGLClipSet* m); Set model object. void Changed(); Emit Changed signal. void ClipValueChanged(); One of number entries was changed. void ClipTypeChanged(Int_t ); Clip type radio button changed - update viewer. void UpdateViewerClip(); Change clipping volume. void ResetViewerClip(); Reset transformation of the current clip. TGLClipSetSubEditor(const TGLClipSetSubEditor& ). TGLClipSetSubEditor& operator=(const TGLClipSetSubEditor& ). virtual ~TGLClipSetSubEditor(); {}. » Author: Matevz Tadel, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLClipSetEditor.h 32338 2010-02-12 17:11:34Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLClipSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLClipSetSubEditor.html
https://root.cern/root/html530/TGLColor.html:387,Performance,cache,cached,387,". TGLColor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLColor. class TGLColor. Class encapsulating color information in preferred GL format - an; array of four unsigned bytes.; Color index is also cached for easier interfacing with the; traditional ROOT graphics. Function Members (Methods); public:. TGLColor(); TGLColor(const TGLColor&); TGLColor(Color_t color_index, Char_t transparency = 0); TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); virtual~TGLColor(); UChar_t*Arr(); TStringAsString() const; const UChar_t*CArr() const; static TClass*Class(); UChar_tGetAlpha() const; UChar_tGetBlue() const; Color_tGetColorIndex() const; UChar_tGetGreen() const; UChar_tGetRed() const; Char_tGetTransparency() const; virtual TClass*IsA() const; TGLColor&operator=(const TGLColor& c); voidSetAlpha(Int_t v); voidSetBlue(Int_t v); voidSetColor(Color_t color_index); voidSetColor(Color_t color_index, Char_t transparency); voidSetColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); voidSetColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); voidSetGreen(Int_t v); voidSetRed(Int_t v); voidSetTransparency(Char_t transparency); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Short_tfIndex; UChar_tfRGBA[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor(); Default constructor. Color is initialized to black. TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); Constructor from Int_t values. TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); Constructor from Float_t values. TGLColor(Color_t color_index, Char_t transparency = 0); Constructor from color-index and transparency. ~TGLColor(); Dectructo",MatchSource.WIKI,root/html530/TGLColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLColor.html
https://root.cern/root/html530/TGLContextIdentity.html:2461,Energy Efficiency,reduce,reduced,2461,"ient(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. voidCheckDestroy(). Data Members; protected:. TGLFontManager*fFontManagerFreeType font manager. private:. Int_tfClientCnt; Int_tfCnt; list<TGLContext*>fCtxs; list<pair<unsigned int,int> >fDLTrash; static TGLContextIdentity*fgDefaultIdentity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLContextIdentity(); Constructor. ~TGLContextIdentity(); Destructor. void AddRef(TGLContext* ctx); Add context ctx to the list of references. void Release(TGLContext* ctx); Remove context ctx from the list of references. void RegisterDLNameRangeToWipe(UInt_t base, Int_t size); Remember dl range for deletion in next MakeCurrent or dtor execution. void DeleteGLResources(); Delete GL resources registered for destruction. TGLContextIdentity* GetCurrent(); Find identitfy of current context. Static. TGLContextIdentity* GetDefaultIdentity(); Get identity of a default Gl context. Static. TGLContext* GetDefaultContextAny(); Get the first GL context with the default identity.; Can return zero, but that's OK, too. Static. TGLFontManager* GetFontManager(); Get the free-type font-manager associated with this context-identity. void CheckDestroy(); Private function called when reference count is reduced. Bool_t IsValid() const; { return fValid; }. TGLContextIdentity(). void AddClientRef(); { ++fClientCnt; }. void ReleaseClient(); { --fClientCnt; CheckDestroy(); }. Int_t GetRefCnt() const; { return fCnt; }. Int_t GetClientRefCnt() const; { return fClientCnt; }. » Author: Timur Pocheptsov, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLContext.h 36675 2010-11-15 20:33:58Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLContextIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLContextIdentity.html
https://root.cern/root/html530/TGLCylinder.html:1813,Performance,cache,cached,1813,"ods); public:. TGLCylinder(const TBuffer3DTube& buffer); virtual~TGLCylinder(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tDLOffset(Short_t lod) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals(). protected:. v",MatchSource.WIKI,root/html530/TGLCylinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCylinder.html
https://root.cern/root/html530/TGLCylinder.html:3758,Performance,cache,cached,3758," box.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). private:. Double_tfDz; TGLVector3fHighPlaneNorm; TGLVector3fLowPlaneNorm; Double_tfPhi1; Double_tfPhi2; Double_tfR1; Double_tfR2; Double_tfR3; Double_tfR4; Bool_tfSegMesh. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLCylinder(const TBuffer3DTube& buffer); Copy out relevant parts of buffer - we create and delete mesh; parts on demand in DirectDraw() and they are DL cached. ~TGLCylinder(); destructor. UInt_t DLOffset(Short_t lod) const; Return display-list offset for given LOD.; Calculation based on what is done in virtual QuantizeShapeLOD below. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Factor in scene/viewer LOD and quantize. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. ELODAxes SupportedLODAxes() const; Cylinders support LOD (tesselation quality) adjustment along; X/Y axes (round the cylinder radius), but not along length (Z). { return ELODAxes(kLODAxesX | kLODAxesY); }. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLCylinder.h 26250 2008-11-17 20:56:44Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT",MatchSource.WIKI,root/html530/TGLCylinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLCylinder.html
https://root.cern/root/html530/TGLEmbeddedViewer.html:5394,Availability,error,error,5394," char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLV",MatchSource.WIKI,root/html530/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEmbeddedViewer.html
https://root.cern/root/html530/TGLEmbeddedViewer.html:5478,Availability,error,error,5478,"; voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLViewer::EDragActionTGLViewer::GetDragAction() const; Bool_tTGLViewer::GetDrawCameraCe",MatchSource.WIKI,root/html530/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEmbeddedViewer.html
https://root.cern/root/html530/TGLEmbeddedViewer.html:25238,Availability,error,error,25238,"ed, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLEmbeddedViewer(const TGWindow* parent, TVirtualPad* pad = 0, Int_t border = 2); Constructor.; Argument 'border' specifies how many pixels to pad on each side of the; viewer. This area can be used for highlightning of the active viewer. TGLEmbeddedViewer(const TGWindow* parent, TVirtualPad* pad, TGedEditor* ged, Int_t border = 2); Constructor allowing to also specify an GED editor to use.; Argument 'border' specifies how many pixels to pad on each side of the; viewer. This area can be used for highlightning of the active viewer. ~TGLEmbeddedViewer(); Destroy standalone viewer object. void Init(const TGWindow* parent); Common initialization from all constructors. void CreateFrames(); Internal frames creation. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. TGLEmbeddedViewer(const TGLEmbeddedViewer& ). TGLEmbeddedViewer& operator=(const TGLEmbeddedViewer& ). const char * GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetFrame() const; { return fFrame; }. TGLOrthoCamera * GetOrthoXOYCamera(); { return &fOrthoXOYCamera; }. TGLOrthoCamera * GetOrthoXOZCamera(); { return &fOrthoXOZCamera; }. TGLOrthoCamera * GetOrthoZOYCamera(); { return &fOrthoZOYCamera; }. » Author: Bertrand Bellenot 23/01/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLEmbeddedViewer.h 31330 2009-11-19 17:34:19Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppo",MatchSource.WIKI,root/html530/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEmbeddedViewer.html
https://root.cern/root/html530/TGLEmbeddedViewer.html:25368,Availability,error,error,25368,"efault color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLEmbeddedViewer(const TGWindow* parent, TVirtualPad* pad = 0, Int_t border = 2); Constructor.; Argument 'border' specifies how many pixels to pad on each side of the; viewer. This area can be used for highlightning of the active viewer. TGLEmbeddedViewer(const TGWindow* parent, TVirtualPad* pad, TGedEditor* ged, Int_t border = 2); Constructor allowing to also specify an GED editor to use.; Argument 'border' specifies how many pixels to pad on each side of the; viewer. This area can be used for highlightning of the active viewer. ~TGLEmbeddedViewer(); Destroy standalone viewer object. void Init(const TGWindow* parent); Common initialization from all constructors. void CreateFrames(); Internal frames creation. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. TGLEmbeddedViewer(const TGLEmbeddedViewer& ). TGLEmbeddedViewer& operator=(const TGLEmbeddedViewer& ). const char * GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetFrame() const; { return fFrame; }. TGLOrthoCamera * GetOrthoXOYCamera(); { return &fOrthoXOYCamera; }. TGLOrthoCamera * GetOrthoXOZCamera(); { return &fOrthoXOZCamera; }. TGLOrthoCamera * GetOrthoZOYCamera(); { return &fOrthoZOYCamera; }. » Author: Bertrand Bellenot 23/01/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLEmbeddedViewer.h 31330 2009-11-19 17:34:19Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEmbeddedViewer.html
https://root.cern/root/html530/TGLEmbeddedViewer.html:20957,Deployability,update,update,20957," enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLViewer::fGLCtxId!for embedded gl viewer; Int_tTGLViewer::fGLDevice!for embedded gl viewer; TGLWidget*TGLViewer::fGLWidget; TGedEditor*TGLViewer::fGedEditor! GED editor; Bool_tTGLViewer::fIgnoreSizesOnUpdateignore sizes of bounding-boxes on update; Bool_tTGLViewer::fIsPrinting!; Short_tTGLViewerBase::fLODViewer-lod for rendering.; TGLColorSetTGLViewer::fLightColorSet! color-set with light background; TGLLightSet*TGLViewer::fLightSet!; Float_tTGLViewer::fLineScale! width scale for lines; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGLLockable::ELockTGLLockable::fLockLock state.; Float_tTGLViewer::fMaxSceneDrawTimeHQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewer::fMaxSceneDrawTimeLQ! max time f",MatchSource.WIKI,root/html530/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEmbeddedViewer.html
https://root.cern/root/html530/TGLEmbeddedViewer.html:22822,Deployability,update,update,22822,GLViewer::fMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCameraTGLViewer::fOrthoXOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXOZCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOZCamera!; TGLOrthoCameraTGLViewer::fOrthoZOYCamera!; TGLOrthoCameraTGLViewer::fOrthoZnOYCamera!; TGLBoundingBoxTGLViewerBase::fOverallBoundingBoxAxis-aligned union of scene bboxes.; vector<TGLOverlayElement*>TGLViewerBase::fOverlay; TGLOvlSelectRecordTGLViewer::fOvlSelRec! select record from last overlay select; TGLPShapeObj*TGLViewer::fPShapeWrap; TVirtualPad*TGLViewer::fPad! external pad - remove replace with signal; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOY!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOZ!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraYOZ!; TStringTGLViewer::fPictureFileName! default file-name for SavePicture(); Float_tTGLViewer::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLin,MatchSource.WIKI,root/html530/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEmbeddedViewer.html
https://root.cern/root/html530/TGLEmbeddedViewer.html:22894,Deployability,update,update,22894,GLViewer::fMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCameraTGLViewer::fOrthoXOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXOZCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOZCamera!; TGLOrthoCameraTGLViewer::fOrthoZOYCamera!; TGLOrthoCameraTGLViewer::fOrthoZnOYCamera!; TGLBoundingBoxTGLViewerBase::fOverallBoundingBoxAxis-aligned union of scene bboxes.; vector<TGLOverlayElement*>TGLViewerBase::fOverlay; TGLOvlSelectRecordTGLViewer::fOvlSelRec! select record from last overlay select; TGLPShapeObj*TGLViewer::fPShapeWrap; TVirtualPad*TGLViewer::fPad! external pad - remove replace with signal; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOY!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOZ!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraYOZ!; TStringTGLViewer::fPictureFileName! default file-name for SavePicture(); Float_tTGLViewer::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLin,MatchSource.WIKI,root/html530/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEmbeddedViewer.html
https://root.cern/root/html530/TGLEmbeddedViewer.html:23428,Performance,cache,cache,23428,"er::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLEmbeddedViewer(cons",MatchSource.WIKI,root/html530/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEmbeddedViewer.html
https://root.cern/root/html530/TGLEmbeddedViewer.html:23434,Testability,log,logicals,23434,"er::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLEmbeddedViewer(cons",MatchSource.WIKI,root/html530/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEmbeddedViewer.html
https://root.cern/root/html530/TGLEmbeddedViewer.html:19704,Usability,guid,guides,19704,"teFrames(); voidInit(const TGWindow* parent); TGLEmbeddedViewer&operator=(const TGLEmbeddedViewer&). Data Members; public:. enum TGLViewer::ECameraType { kCameraPerspXOZ; kCameraPerspYOZ; kCameraPerspXOY; kCameraOrthoXOY; kCameraOrthoXOZ; kCameraOrthoZOY; kCameraOrthoXnOY; kCameraOrthoXnOZ; kCameraOrthoZnOY; };; enum TGLViewer::ESecSelType { kOnRequest; kOnKeyMod1; };; enum TGLViewer::EPushAction { kPushStd; kPushCamCenter; kPushAnnotate; };; enum TGLViewer::EDragAction { kDragNone; kDragCameraRotate; kDragCameraTruck; kDragCameraDolly; kDragOverlay; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLVi",MatchSource.WIKI,root/html530/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEmbeddedViewer.html
https://root.cern/root/html530/TGLEventHandler.html:4138,Availability,error,error,4138,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetDoInternalSelection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSecSelType() const; virtual const char*TNamed::GetTitle() const; Int_tGetTooltipPixelTolerance()",MatchSource.WIKI,root/html530/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEventHandler.html
https://root.cern/root/html530/TGLEventHandler.html:4222,Availability,error,error,4222,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetDoInternalSelection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSecSelType() const; virtual const char*TNamed::GetTitle() const; Int_tGetTooltipPixelTolerance() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tHandleButton(Event",MatchSource.WIKI,root/html530/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEventHandler.html
https://root.cern/root/html530/TGLEventHandler.html:13298,Modifiability,config,configure,13298,"void SelectForMouseOver(); Run selection (optionally with on secondary selection) and emit; corresponding MouseOver() signals.; Protected method. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Process event of type 'event' - one of EEventType types,; occuring at window location px, py; This is provided for use when embedding GL viewer into pad. Bool_t HandleEvent(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleFocusChange(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleCrossing(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleButton(Event_t* event); Handle mouse button 'event'. Bool_t HandleDoubleClick(Event_t* event); Handle mouse double click 'event'. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify 'event' - a window resize/movement. Bool_t HandleExpose(Event_t* event); Handle window expose 'event' - show. Bool_t HandleKey(Event_t* event); Handle keyboard 'event'. Bool_t HandleMotion(Event_t* event); Handle mouse motion 'event'. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Method to handle action TGLViewer::kDragCameraRotate. Bool_t HandleTimer(TTimer* t); If mouse delay timer times out emit signal. void StartMouseTimer(); Start mouse timer in single-shot mode. void StopMouseTimer(); Make sure mouse timers are not running. void ClearMouseOver(); Clear mouse-over state and emit mouse-over signals.; Current overlay element is also told the mouse has left. void Repaint(); Handle window expose 'event' - show. void PopupContextMenu(TGLPhysicalShape* pshp, Event_t* event, Int_t gx, Int_t gy); Popup context menu. void TriggerTooltip(const char* text); Trigger display of tooltip. void RemoveTooltip(); Hide the tooltip. void SetMouseOverSelectDela",MatchSource.WIKI,root/html530/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEventHandler.html
https://root.cern/root/html530/TGLEventHandler.html:13402,Security,expose,expose,13402,"; corresponding MouseOver() signals.; Protected method. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Process event of type 'event' - one of EEventType types,; occuring at window location px, py; This is provided for use when embedding GL viewer into pad. Bool_t HandleEvent(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleFocusChange(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleCrossing(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleButton(Event_t* event); Handle mouse button 'event'. Bool_t HandleDoubleClick(Event_t* event); Handle mouse double click 'event'. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify 'event' - a window resize/movement. Bool_t HandleExpose(Event_t* event); Handle window expose 'event' - show. Bool_t HandleKey(Event_t* event); Handle keyboard 'event'. Bool_t HandleMotion(Event_t* event); Handle mouse motion 'event'. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Method to handle action TGLViewer::kDragCameraRotate. Bool_t HandleTimer(TTimer* t); If mouse delay timer times out emit signal. void StartMouseTimer(); Start mouse timer in single-shot mode. void StopMouseTimer(); Make sure mouse timers are not running. void ClearMouseOver(); Clear mouse-over state and emit mouse-over signals.; Current overlay element is also told the mouse has left. void Repaint(); Handle window expose 'event' - show. void PopupContextMenu(TGLPhysicalShape* pshp, Event_t* event, Int_t gx, Int_t gy); Popup context menu. void TriggerTooltip(const char* text); Trigger display of tooltip. void RemoveTooltip(); Hide the tooltip. void SetMouseOverSelectDelay(Int_t ms); Set delay of mouse-over probe (highlight). void SetMouseOverTooltipDelay(Int_",MatchSource.WIKI,root/html530/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEventHandler.html
https://root.cern/root/html530/TGLEventHandler.html:14037,Security,expose,expose,14037,"ided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleButton(Event_t* event); Handle mouse button 'event'. Bool_t HandleDoubleClick(Event_t* event); Handle mouse double click 'event'. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify 'event' - a window resize/movement. Bool_t HandleExpose(Event_t* event); Handle window expose 'event' - show. Bool_t HandleKey(Event_t* event); Handle keyboard 'event'. Bool_t HandleMotion(Event_t* event); Handle mouse motion 'event'. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Method to handle action TGLViewer::kDragCameraRotate. Bool_t HandleTimer(TTimer* t); If mouse delay timer times out emit signal. void StartMouseTimer(); Start mouse timer in single-shot mode. void StopMouseTimer(); Make sure mouse timers are not running. void ClearMouseOver(); Clear mouse-over state and emit mouse-over signals.; Current overlay element is also told the mouse has left. void Repaint(); Handle window expose 'event' - show. void PopupContextMenu(TGLPhysicalShape* pshp, Event_t* event, Int_t gx, Int_t gy); Popup context menu. void TriggerTooltip(const char* text); Trigger display of tooltip. void RemoveTooltip(); Hide the tooltip. void SetMouseOverSelectDelay(Int_t ms); Set delay of mouse-over probe (highlight). void SetMouseOverTooltipDelay(Int_t ms); Set delay of tooltip timer. Int_t ControlValue(Int_t v); { return fViewerCentricControls ? -v : v; }. Int_t GetTooltipPixelTolerance() const; { return fTooltipPixelTolerance; }. void SetTooltipPixelTolerance(Int_t t); { fTooltipPixelTolerance = t; }. Int_t GetSecSelType() const; { return fSecSelType; }. void SetSecSelType(Int_t t); { fSecSelType = t; }. Bool_t GetDoInternalSelection() const; { return fDoInternalSelection; }. void SetDoInternalSelection(Bool_t x); { fDoInternalSelection = x; }. » Author: Bertrand Bellenot 29/01/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLEventHan",MatchSource.WIKI,root/html530/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLEventHandler.html
https://root.cern/root/html530/TGLFaceSet.html:2010,Performance,cache,cached,2010,"ogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; voidEnforceTriangles(); static Bool_tGetEnforceTriangles(); TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; UInt_tGetNbPols(); vector<Double_t>&GetNormals(); vector<Int_t>&GetPolyDesc(); TGLScene*TGLLogicalShape::GetScene() const; vector<Double_t>&GetVertices(); TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidSetEnforceTriangles(Bool_t e); voidSetFromMesh(const RootCsg::TBaseMesh* m); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html530/TGLFaceSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLFaceSet.html
https://root.cern/root/html530/TGLFaceSet.html:4641,Testability,test,test,4641,"ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). private:. UInt_tfNbPols; vector<Double_t>fNormals; vector<Int_t>fPolyDesc; vector<Double_t>fVertices; static Bool_tfgEnforceTriangles. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFaceSet(const TBuffer3D& buffer); constructor. void SetFromMesh(const RootCsg::TBaseMesh* m); Should only be done on an empty faceset object. void EnforceTriangles(); Use GLU tesselator to replace all polygons with N > 3 with triangles.; After this call polygon descriptions are changed.; New vertices are not expected -- exception is thrown if this is; requested by the triangulator. Support for adding of new vertices can be; provided. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. Int_t CheckPoints(const Int_t* source, Int_t* dest) const; CheckPoints. Bool_t Eq(const Double_t* p1, const Double_t* p2); test equality. void CalculateNormals(); CalculateNormals. Bool_t GetEnforceTriangles(); Get current state of static flag EnforceTriangles. void SetEnforceTriangles(Bool_t e); Set state of static flag EnforceTriangles.; When this is set, all tesselations will be automatically converted into; triangle-only meshes.; This is needed to export TGeo shapes and CSG meshes to external; triangle-mesh libraries that can not handle arbitrary polygons. std::vector<Double_t>& GetVertices(); { return fVertices; }. std::vector<Double_t>& GetNormals(); { return fNormals; }. std::vector<Int_t>& GetPolyDesc(); { return fPolyDesc; }. UInt_t GetNbPols(); { return fNbPols; }. void GLDrawPolys() const. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFaceSet.h 37192 2010-12-02 15:54:26Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regardi",MatchSource.WIKI,root/html530/TGLFaceSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLFaceSet.html
https://root.cern/root/html530/TGLFBO.html:1681,Energy Efficiency,allocate,allocated,1681,"ublic:. TGLFBO(); virtual~TGLFBO(); voidBind(); voidBindTexture(); static TClass*Class(); voidInit(int w, int h, int ms_samples = 0); virtual TClass*IsA() const; voidRelease(); voidSetAsReadBuffer(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUnbind(); voidUnbindTexture(). protected:. UInt_tCreateAndAttachColorTexture(); UInt_tCreateAndAttachRenderBuffer(Int_t format, Int_t type); voidInitMultiSample(); voidInitStandard(). private:. TGLFBO(const TGLFBO&); TGLFBO&operator=(const TGLFBO&). Data Members; protected:. UInt_tfColorTexture; UInt_tfDepthBuffer; UInt_tfFrameBuffer; Int_tfH; Float_tfHScale; Bool_tfIsRescaled; UInt_tfMSColorBuffer; Int_tfMSCoverageSamples; UInt_tfMSFrameBuffer; Int_tfMSSamples; Int_tfW; Float_tfWScale; static Bool_tfgMultiSampleNAWarned; static Bool_tfgRescaleToPow2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFBO(); Constructor. ~TGLFBO(); Destructor. void Init(int w, int h, int ms_samples = 0); Acquire GL resources for given width, height and number of; multi-sampling samples. void Release(); Release the allocated GL resources. void Bind(); Bind the frame-buffer object. void Unbind(); Unbind the frame-buffer object. void BindTexture(); Bind texture. void UnbindTexture(); Unbind texture. void SetAsReadBuffer(). void InitStandard(). void InitMultiSample(). UInt_t CreateAndAttachRenderBuffer(Int_t format, Int_t type). UInt_t CreateAndAttachColorTexture(); Initialize color-texture and attach it to current FB. TGLFBO(const TGLFBO& ). TGLFBO& operator=(const TGLFBO& ). » Author: Matevz Tadel, Aug 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFBO.h 36675 2010-11-15 20:33:58Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLFBO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLFBO.html
https://root.cern/root/html530/TGLFont.html:277,Integrability,wrap,wrapper,277,". TGLFont. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLFont. class TGLFont. TGLFont. A wrapper class for FTFont.; Holds pointer to FTFont object and its description: face size, font file; and class ID. It wraps Render and BBox functions. Function Members (Methods); public:. TGLFont(); TGLFont(const TGLFont& o); TGLFont(Int_t size, Int_t font, TGLFont::EMode mode, FTFont* f = 0, TGLFontManager* mng = 0); virtual~TGLFont(); voidBBox(const char* txt, Float_t& llx, Float_t& lly, Float_t& llz, Float_t& urx, Float_t& ury, Float_t& urz) const; static TClass*Class(); voidCopyAttributes(const TGLFont& o); Float_tGetAscent() const; Float_tGetDepth() const; Float_tGetDescent() const; Int_tGetFile() const; const FTFont*GetFont() const; Float_tGetLineHeight() const; const TGLFontManager*GetManager() const; TGLFont::EModeGetMode() const; Int_tGetSize() const; Int_tGetTrashCount() const; Int_tIncTrashCount() const; virtual TClass*IsA() const; voidMeasureBaseLineParams(Float_t& ascent, Float_t& descent, Float_t& line_height, const char* txt = ""Xj"") const; Bool_toperator<(const TGLFont& o) const; virtual voidPostRender() const; virtual voidPreRender(Bool_t autoLight = kTRUE, Bool_t lightOn = kFALSE) const; voidRender(const TString& txt) const; voidRender(const char* txt, Double_t x, Double_t y, Double_t angle, Double_t mgn) const; voidRender(const TString& txt, Float_t x, Float_t y, Float_t z, TGLFont::ETextAlignH_e alignH, TGLFont::ETextAlignV_e alignV) const; voidSetDepth(Float_t d); voidSetFont(FTFont* f); voidSetManager(TGLFontManager* mng); voidSetTrashCount(Int_t c) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLFont&operator=(const TGLFont& o). Data Members; public:. enum EMode { kUndef; kBitmap; kPixm",MatchSource.WIKI,root/html530/TGLFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLFont.html
https://root.cern/root/html530/TGLFont.html:395,Integrability,wrap,wraps,395,". TGLFont. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLFont. class TGLFont. TGLFont. A wrapper class for FTFont.; Holds pointer to FTFont object and its description: face size, font file; and class ID. It wraps Render and BBox functions. Function Members (Methods); public:. TGLFont(); TGLFont(const TGLFont& o); TGLFont(Int_t size, Int_t font, TGLFont::EMode mode, FTFont* f = 0, TGLFontManager* mng = 0); virtual~TGLFont(); voidBBox(const char* txt, Float_t& llx, Float_t& lly, Float_t& llz, Float_t& urx, Float_t& ury, Float_t& urz) const; static TClass*Class(); voidCopyAttributes(const TGLFont& o); Float_tGetAscent() const; Float_tGetDepth() const; Float_tGetDescent() const; Int_tGetFile() const; const FTFont*GetFont() const; Float_tGetLineHeight() const; const TGLFontManager*GetManager() const; TGLFont::EModeGetMode() const; Int_tGetSize() const; Int_tGetTrashCount() const; Int_tIncTrashCount() const; virtual TClass*IsA() const; voidMeasureBaseLineParams(Float_t& ascent, Float_t& descent, Float_t& line_height, const char* txt = ""Xj"") const; Bool_toperator<(const TGLFont& o) const; virtual voidPostRender() const; virtual voidPreRender(Bool_t autoLight = kTRUE, Bool_t lightOn = kFALSE) const; voidRender(const TString& txt) const; voidRender(const char* txt, Double_t x, Double_t y, Double_t angle, Double_t mgn) const; voidRender(const TString& txt, Float_t x, Float_t y, Float_t z, TGLFont::ETextAlignH_e alignH, TGLFont::ETextAlignV_e alignV) const; voidSetDepth(Float_t d); voidSetFont(FTFont* f); voidSetManager(TGLFontManager* mng); voidSetTrashCount(Int_t c) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLFont&operator=(const TGLFont& o). Data Members; public:. enum EMode { kUndef; kBitmap; kPixm",MatchSource.WIKI,root/html530/TGLFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLFont.html
https://root.cern/root/html530/TGLFont.html:3491,Usability,simpl,simply,3491,"Function documentation; TGLFont(); Constructor. TGLFont(Int_t size, Int_t font, TGLFont::EMode mode, FTFont* f = 0, TGLFontManager* mng = 0); Constructor. TGLFont(const TGLFont& o); Assignment operator. ~TGLFont(); Destructor. void CopyAttributes(const TGLFont& o); Assignment operator. Float_t GetAscent() const; Get font's ascent. Float_t GetDescent() const; Get font's descent. The returned value is positive. Float_t GetLineHeight() const; Get font's line-height. void MeasureBaseLineParams(Float_t& ascent, Float_t& descent, Float_t& line_height, const char* txt = ""Xj"") const; Measure font's base-line parameters from the passed text.; Note that the measured parameters are not the same as the ones; returned by get-functions - those were set by the font designer. void BBox(const char* txt, Float_t& llx, Float_t& lly, Float_t& llz, Float_t& urx, Float_t& ury, Float_t& urz) const; Get bounding box. void Render(const char* txt, Double_t x, Double_t y, Double_t angle, Double_t mgn) const; mgn is simply ignored, because ROOT's TVirtualX TGX11 are complete mess with; painting attributes. void Render(const TString& txt) const; Render text. void PreRender(Bool_t autoLight = kTRUE, Bool_t lightOn = kFALSE) const; Set-up GL state before FTFont rendering. void PostRender() const; Reset GL state after FTFont rendering. TGLFont& operator=(const TGLFont& o). Int_t GetSize() const; { return fSize;}. Int_t GetFile() const; { return fFile;}. EMode GetMode() const; { return fMode;}. Int_t GetTrashCount() const; { return fTrashCount; }. void SetTrashCount(Int_t c) const; { fTrashCount = c; }. Int_t IncTrashCount() const; { return ++fTrashCount; }. void SetFont(FTFont* f); { fFont =f;}. const FTFont* GetFont() const; { return fFont; }. void SetManager(TGLFontManager* mng); { fManager = mng; }. const TGLFontManager* GetManager() const; { return fManager; }. Float_t GetDepth() const; { return fDepth; }. void SetDepth(Float_t d); { fDepth = d; }. void Render(const char* txt, Double_t x, Doubl",MatchSource.WIKI,root/html530/TGLFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLFont.html
https://root.cern/root/html530/TGLFontManager.html:2199,Availability,avail,availabe,2199,"al voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidInitStatics(). private:. TGLFontManager(const TGLFontManager&); TGLFontManager&operator=(const TGLFontManager&). Data Members; protected:. map<TGLFont,int>fFontMapmap of created fonts; list<const TGLFont*>fFontTrashfonts to purge; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static vector<int>fgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFontManager.h 30425 2009-09-24 19:45:11Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLFontManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLFontManager.html
https://root.cern/root/html530/TGLFontManager.html:2274,Availability,avail,availabe,2274,"al voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidInitStatics(). private:. TGLFontManager(const TGLFontManager&); TGLFontManager&operator=(const TGLFontManager&). Data Members; protected:. map<TGLFont,int>fFontMapmap of created fonts; list<const TGLFont*>fFontTrashfonts to purge; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static vector<int>fgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFontManager.h 30425 2009-09-24 19:45:11Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLFontManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLFontManager.html
https://root.cern/root/html530/TGLFontManager.html:2407,Availability,avail,available,2407,"al voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidInitStatics(). private:. TGLFontManager(const TGLFontManager&); TGLFontManager&operator=(const TGLFontManager&). Data Members; protected:. map<TGLFont,int>fFontMapmap of created fonts; list<const TGLFont*>fFontTrashfonts to purge; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static vector<int>fgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFontManager.h 30425 2009-09-24 19:45:11Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLFontManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLFontManager.html
https://root.cern/root/html530/TGLFormat.html:2016,Integrability,depend,depends,2016,"tDepthSize(Int_t depth); voidSetDoubleBuffered(Bool_t db); voidSetSamples(Int_t samples); voidSetStencilSize(Int_t stencil); voidSetStereo(Bool_t db); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Int_tGetDefaultSamples(); static voidInitAvailableSamples(). Data Members; public:. enum EFormatOptions { kNone; kDoubleBuffer; kDepth; kAccum; kStencil; kStereo; kMultiSample; };. private:. Int_tfAccumSize; Int_tfDepthSize; Bool_tfDoubleBuffered; Int_tfSamples; Int_tfStencilSize; Bool_tfStereo; static vector<Int_t>fgAvailableSamples. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFormat(); 16-bits needed for some virtual machines (VirtualBox) and Xming-mesa; (when running ssh from windows to linux).; All others seem to have 24-bit depth-buffers only and use this anyway.; Default ctor. Default surface is:; -double buffered; -RGBA; -with depth buffer; -no accumulation buffer; -with stencil; -multi-sampling depends on seeting of ""OpenGL.Framebuffer.Multisample"". TGLFormat(EFormatOptions opt); Define surface using options. ~TGLFormat(); Destructor. Int_t GetDepthSize() const; Get the size of depth buffer. void SetDepthSize(Int_t depth); Set the size of color buffer. Bool_t HasDepth() const; Check, if this surface has depth buffer. Int_t GetStencilSize() const; Get the size of stencil buffer. void SetStencilSize(Int_t stencil); Set the size of stencil buffer. Bool_t HasStencil() const; Check, if this surface has stencil buffer. Int_t GetAccumSize() const; Get the size of accum buffer. void SetAccumSize(Int_t accum); Set the size of accum buffer. Bool_t HasAccumBuffer() const; Check, if this surface has accumulation buffer. Bool_t IsDoubleBuffered() const; Check, if the surface is double buffered. void SetDoubleBuffered(Bool_t db); Set the surface as double/single buffered. Bool_t IsStereo() const; Check, if the surface is stereo buffered. void S",MatchSource.WIKI,root/html530/TGLFormat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLFormat.html
https://root.cern/root/html530/TGLH2PolyPainter.html:4097,Deployability,update,updates,4097,"ter::fCamera; TGLPlotCoordinates*TGLPlotPainter::fCoord; Bool_tTGLPlotPainter::fDrawPalette; Bool_tTGLPlotPainter::fHighColor; TH1*TGLPlotPainter::fHist; TPointTGLPlotPainter::fMousePosition; Double_tTGLPlotPainter::fPadPhi; Double_tTGLPlotPainter::fPadTheta; const Float_t*TGLPlotPainter::fPhysicalShapeColor; Int_tTGLPlotPainter::fSelectedPart; TGLSelectionBufferTGLPlotPainter::fSelection; TGLPlotPainter::ESelectionBaseTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void D",MatchSource.WIKI,root/html530/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLH2PolyPainter.html
https://root.cern/root/html530/TGLH2PolyPainter.html:5079,Modifiability,variab,variables,5079,"vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return some gl states to original values. void DrawPlot() const; Draw extruded polygons and plot's frame. void DrawExtrusion() const; Extruded part of bins.; GL_QUADS, GL_QUAD_STRIP - have the same time on my laptop, so I use; GL_QUADS and forgot about vertex arrays (can require more memory BTW). void DrawExtrusion(const TGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; Extrude polygon, described by TGraph. void DrawExtrusion(const TMultiGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; Multigraph contains a list of graphs, draw them. void DrawCaps() const; Caps on bins. void DrawCap(TGLH2PolyPainter::CIter_t cap, Int_t bin) const; Draw a cap on top of a bin. Bool_t CacheGeometry(); Cache all data for TH2Poly object. Bool_t BuildTesselation(Rgl::Pad::Tesselator& tess, const TGraph* g, Double_t z); Tesselate a polygon described by TGraph. Bool_t BuildTesselation(Rgl::Pad::Tesselator& tess, const TMultiGra",MatchSource.WIKI,root/html530/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLH2PolyPainter.html
https://root.cern/root/html530/TGLH2PolyPainter.html:4498,Security,validat,validated,4498,"BaseTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return some gl states to original values. void DrawPlot() const; Draw extruded polygons and plot's frame. void DrawExtrusion() const; Extruded part of bins.; GL_QUADS, GL_QUAD_STRIP - have the same time on my laptop, so I use; GL_QUADS and forgot about vertex arrays (can require more memory BTW). void DrawExtrusion(const TGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; Extrude poly",MatchSource.WIKI,root/html530/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLH2PolyPainter.html
https://root.cern/root/html530/TGLH2PolyPainter.html:4092,Testability,log,logZ,4092,"ter::fCamera; TGLPlotCoordinates*TGLPlotPainter::fCoord; Bool_tTGLPlotPainter::fDrawPalette; Bool_tTGLPlotPainter::fHighColor; TH1*TGLPlotPainter::fHist; TPointTGLPlotPainter::fMousePosition; Double_tTGLPlotPainter::fPadPhi; Double_tTGLPlotPainter::fPadTheta; const Float_t*TGLPlotPainter::fPhysicalShapeColor; Int_tTGLPlotPainter::fSelectedPart; TGLSelectionBufferTGLPlotPainter::fSelection; TGLPlotPainter::ESelectionBaseTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void D",MatchSource.WIKI,root/html530/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLH2PolyPainter.html
https://root.cern/root/html530/TGLHistPainter.html:6666,Availability,error,error,6666,"* data); TGLHistPainter(TGLTH3Composition* comp); ~TGLHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGLPlotPainter*GetRealPainter(); virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static TVirtualHistPainter*TVirtua",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:6750,Availability,error,error,6750,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGLPlotPainter*GetRealPainter(); virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static TVirtualHistPainter*TVirtualHistPainter::HistPainter(TH1* obj); virtual voidTObject::Info(const char* method, c",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:3147,Energy Efficiency,green,green,3147,"rfaces.; ; TH3 as color boxes - (TGLVoxelPainter); The supported option is:; ; ""GLCOL"" : TH3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and; visualize the surface. Interaction with the plots. General information. All the interactions are implemented via standard methods DistancetoPrimitive and; ExecuteEvent. That's why all the interactions with the OpenGL plots are possible i; only when the mouse cursor is in the plot's area (the plot's area is the part of a the pad; occupied by gl-produced picture). If the mouse cursor is not above gl-picture,; the standard pad interaction is performed.; Selectable parts. Different parts of the plot can be selected:; ; xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the dynamic slicing; by this plane is supported, and it's highlighted in red, if the dynamic slicing; is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and ISO are not; outlined). On lego plots, the selected bin is highlihted. The bin number and content are displayed in pad's status; bar. In box plots, the box or sphere is highlighted and the bin info is displayed in pad's status bar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and parametric painters support box cut by pressing the 'c' or; 'C' key when the mouse cursor is in a plot's area. That will display a transparent box,; cutting away part of the surface (or boxes",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:4551,Energy Efficiency,green,green,4551,"ar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and parametric painters support box cut by pressing the 'c' or; 'C' key when the mouse cursor is in a plot's area. That will display a transparent box,; cutting away part of the surface (or boxes) in order to show internal part of plot.; This box can be moved inside the plot's area (the full size of the box is equal to the plot's; surrounding box) by selecting one of the box cut axes and pressing the left mouse button to move it.; Plot specific interactions (dynamic slicing etc.); Currently, all gl-plots support some form of slicing.; When back plane is selected (and if it's highlighted in green); you can press and hold left mouse button and shift key; and move this back plane inside plot's area, creating the slice.; During this ""slicing"" plot becomes semi-transparent. To remove all slices (and projected curves for surfaces); - double click with left mouse button in a plot's area.; ; Surface with option ""GLSURF"". The surface profile is displayed on the slicing plane.; The profile projection is drawn on the back plane; by pressing 'p' or 'P' key.; TF3. The contour plot is drawn on the slicing plane.; For TF3 the color scheme can be changed by pressing 's' or 'S'.; Box. The contour plot corresponding to slice plane position is drawn in real time.; Iso. Slicing is similar to ""GLBOX"" option.; Parametric plot. No slicing. Additional keys: 's' or 'S' to change color scheme - about 20 color schemes supported; ('s' for ""scheme""); 'l' or 'L' to increase number of polygons ('l' for ""level"" of details),; 'w' or 'W' to show outlines ('w' for ""wireframe"").; ; . Function Members (Methods); public:. TGLHistPainter(TH1* ",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:9188,Integrability,message,message,9188,"e_t y); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual Int_tMakeCuts(char* cutsOpt); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidPaint(Option_t* option); virtual voidPaintStat(Int_t dostat, TF1* fit); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidProcessMessage(const char* message, const TObject* obj); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetHistogram(TH1* hist); static voidTObject::SetObjectStat(Bool_t stat); static voidTVirtualHistPainter::SetPainter(const char* painter); virtual voidSetShowProjection(const char* option, Int_t nbins); virtual voidSetStack(TList* stack); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTO",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:13773,Integrability,message,message,13773,"onst; Get contour list.; I do not use this function. Contours are implemented in; a completely different way by gl-painters. char * GetObjectInfo(Int_t px, Int_t py) const; Overrides TObject::GetObjectInfo.; For lego info is: bin numbers (i, j), bin content.; For TF2 info is: x,y,z 3d surface-point for 2d screen-point under cursor; (this can work incorrectly now, because of wrong code in TF2).; For TF3 no info now.; For box info is: bin numbers (i, j, k), bin content. TList * GetStack() const; Get stack. Bool_t IsInside(Int_t x, Int_t y); Returns kTRUE if the cell ix, iy is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". Bool_t IsInside(Double_t x, Double_t y); Returns kTRUE if the cell x, y is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". void PaintStat(Int_t dostat, TF1* fit); Paint statistics.; This does not work on windows. void ProcessMessage(const char* message, const TObject* obj); Process message. void SetHistogram(TH1* hist); Set histogram. void SetStack(TList* stack); Set stack. Int_t MakeCuts(char* cutsOpt); Make cuts. void Paint(Option_t* option); Final-overrider for TObject::Paint. ParsePaintOption(const TString& option) const; In principle, we can have several conflicting options: ""lego surf pol sph"",; but only one will be selected, which one - depends on parsing order in this function. void CreatePainter(const TGLHistPainter::PlotOption_t& parsed, const TString& option); Create painter. void SetShowProjection(const char* option, Int_t nbins); Set show projection. void PadToViewport(Bool_t selectionPass = kFALSE). TGLHistPainter(TH1* hist). TGLPlotPainter * GetRealPainter(); {return fGLPainter.get();}. » Author: Timur Pocheptsov 17/11/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:13811,Integrability,message,message,13811,"onst; Get contour list.; I do not use this function. Contours are implemented in; a completely different way by gl-painters. char * GetObjectInfo(Int_t px, Int_t py) const; Overrides TObject::GetObjectInfo.; For lego info is: bin numbers (i, j), bin content.; For TF2 info is: x,y,z 3d surface-point for 2d screen-point under cursor; (this can work incorrectly now, because of wrong code in TF2).; For TF3 no info now.; For box info is: bin numbers (i, j, k), bin content. TList * GetStack() const; Get stack. Bool_t IsInside(Int_t x, Int_t y); Returns kTRUE if the cell ix, iy is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". Bool_t IsInside(Double_t x, Double_t y); Returns kTRUE if the cell x, y is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". void PaintStat(Int_t dostat, TF1* fit); Paint statistics.; This does not work on windows. void ProcessMessage(const char* message, const TObject* obj); Process message. void SetHistogram(TH1* hist); Set histogram. void SetStack(TList* stack); Set stack. Int_t MakeCuts(char* cutsOpt); Make cuts. void Paint(Option_t* option); Final-overrider for TObject::Paint. ParsePaintOption(const TString& option) const; In principle, we can have several conflicting options: ""lego surf pol sph"",; but only one will be selected, which one - depends on parsing order in this function. void CreatePainter(const TGLHistPainter::PlotOption_t& parsed, const TString& option); Create painter. void SetShowProjection(const char* option, Int_t nbins); Set show projection. void PadToViewport(Bool_t selectionPass = kFALSE). TGLHistPainter(TH1* hist). TGLPlotPainter * GetRealPainter(); {return fGLPainter.get();}. » Author: Timur Pocheptsov 17/11/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:14180,Integrability,depend,depends,14180,"ompletely different way by gl-painters. char * GetObjectInfo(Int_t px, Int_t py) const; Overrides TObject::GetObjectInfo.; For lego info is: bin numbers (i, j), bin content.; For TF2 info is: x,y,z 3d surface-point for 2d screen-point under cursor; (this can work incorrectly now, because of wrong code in TF2).; For TF3 no info now.; For box info is: bin numbers (i, j, k), bin content. TList * GetStack() const; Get stack. Bool_t IsInside(Int_t x, Int_t y); Returns kTRUE if the cell ix, iy is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". Bool_t IsInside(Double_t x, Double_t y); Returns kTRUE if the cell x, y is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". void PaintStat(Int_t dostat, TF1* fit); Paint statistics.; This does not work on windows. void ProcessMessage(const char* message, const TObject* obj); Process message. void SetHistogram(TH1* hist); Set histogram. void SetStack(TList* stack); Set stack. Int_t MakeCuts(char* cutsOpt); Make cuts. void Paint(Option_t* option); Final-overrider for TObject::Paint. ParsePaintOption(const TString& option) const; In principle, we can have several conflicting options: ""lego surf pol sph"",; but only one will be selected, which one - depends on parsing order in this function. void CreatePainter(const TGLHistPainter::PlotOption_t& parsed, const TString& option); Create painter. void SetShowProjection(const char* option, Int_t nbins); Set show projection. void PadToViewport(Bool_t selectionPass = kFALSE). TGLHistPainter(TH1* hist). TGLPlotPainter * GetRealPainter(); {return fGLPainter.get();}. » Author: Timur Pocheptsov 17/11/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:2993,Performance,perform,performed,2993,"n content.; ""GLBOX1"": the same as ""glbox"", but spheres are drawn instead of boxes.; ; TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:; ; ""GLISO"" : TH3 is drawn using iso-surfaces.; ; TH3 as color boxes - (TGLVoxelPainter); The supported option is:; ; ""GLCOL"" : TH3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and; visualize the surface. Interaction with the plots. General information. All the interactions are implemented via standard methods DistancetoPrimitive and; ExecuteEvent. That's why all the interactions with the OpenGL plots are possible i; only when the mouse cursor is in the plot's area (the plot's area is the part of a the pad; occupied by gl-produced picture). If the mouse cursor is not above gl-picture,; the standard pad interaction is performed.; Selectable parts. Different parts of the plot can be selected:; ; xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the dynamic slicing; by this plane is supported, and it's highlighted in red, if the dynamic slicing; is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and ISO are not; outlined). On lego plots, the selected bin is highlihted. The bin number and content are displayed in pad's status; bar. In box plots, the box or sphere is highlighted and the bin info is displayed in pad's status bar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and p",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:857,Testability,log,logarithmic,857,". TGLHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLHistPainter. class TGLHistPainter: public TVirtualHistPainter. The histogram painter class using OpenGL; Histograms are, by default, drawn via the THistPainter class.; TGLHistPainter allows to paint them using the OpenGL 3D graphics; library. The plotting options provided by TGLHistPainter start with; GL keyword.; General information: plot types and supported options; The following types of plots are provided:. Lego - (TGLLegoPainter); The supported options are:; ; ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars.; ; Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y (if you see; what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:; ; ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines.; ; The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis.; In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:; ; "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", ",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:918,Testability,log,logarithmic,918,". TGLHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLHistPainter. class TGLHistPainter: public TVirtualHistPainter. The histogram painter class using OpenGL; Histograms are, by default, drawn via the THistPainter class.; TGLHistPainter allows to paint them using the OpenGL 3D graphics; library. The plotting options provided by TGLHistPainter start with; GL keyword.; General information: plot types and supported options; The following types of plots are provided:. Lego - (TGLLegoPainter); The supported options are:; ; ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars.; ; Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y (if you see; what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:; ; ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines.; ; The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis.; In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:; ; "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", ",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:1426,Testability,log,logarithmic,1426,"ss.; TGLHistPainter allows to paint them using the OpenGL 3D graphics; library. The plotting options provided by TGLHistPainter start with; GL keyword.; General information: plot types and supported options; The following types of plots are provided:. Lego - (TGLLegoPainter); The supported options are:; ; ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars.; ; Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y (if you see; what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:; ; ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines.; ; The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis.; In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:; ; "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", but spheres are drawn instead of boxes.; ; TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:; ; ""GLISO"" : TH3 is drawn using iso-surfaces.; ; TH3 as color boxes - (TGLVoxelPainter); The supported option is:; ; ""GLCOL"" : TH3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a ",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLHistPainter.html:1510,Testability,log,logarithmic,1510," provided by TGLHistPainter start with; GL keyword.; General information: plot types and supported options; The following types of plots are provided:. Lego - (TGLLegoPainter); The supported options are:; ; ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars.; ; Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y (if you see; what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:; ; ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines.; ; The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis.; In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:; ; "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", but spheres are drawn instead of boxes.; ; TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:; ; ""GLISO"" : TH3 is drawn using iso-surfaces.; ; TH3 as color boxes - (TGLVoxelPainter); The supported option is:; ; ""GLCOL"" : TH3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how t",MatchSource.WIKI,root/html530/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html
https://root.cern/root/html530/TGLineLBEntry.html:4658,Availability,error,error,4658,"st char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGTextLBEntry::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTextLBEntry::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtu",MatchSource.WIKI,root/html530/TGLineLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineLBEntry.html
https://root.cern/root/html530/TGLineLBEntry.html:4742,Availability,error,error,4742,"m); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGTextLBEntry::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTextLBEntry::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; ",MatchSource.WIKI,root/html530/TGLineLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineLBEntry.html
https://root.cern/root/html530/TGLineLBEntry.html:16548,Availability,mask,mask,16548,,MatchSource.WIKI,root/html530/TGLineLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineLBEntry.html
https://root.cern/root/html530/TGLineLBEntry.html:447,Usability,simpl,simple,447,". TGLineLBEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineLBEntry. class TGLineLBEntry: public TGTextLBEntry. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. TGLineLBEntry(const TGWindow* p = 0, Int_t id = -1, const char* str = 0, UInt_t w = 0, Style_t s = 0, UInt_t options = kHorizontalFrame, Pixel_t back = GetWhitePixel()); virtual~TGLineLBEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLBEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Co",MatchSource.WIKI,root/html530/TGLineLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineLBEntry.html
https://root.cern/root/html530/TGLineStyleComboBox.html:381,Availability,down,down,381,". TGLineStyleComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineStyleComboBox. class TGLineStyleComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGLineStyleComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); ~TGLineStyleComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* meth",MatchSource.WIKI,root/html530/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineStyleComboBox.html
https://root.cern/root/html530/TGLineStyleComboBox.html:618,Availability,down,down,618,". TGLineStyleComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineStyleComboBox. class TGLineStyleComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGLineStyleComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); ~TGLineStyleComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* meth",MatchSource.WIKI,root/html530/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineStyleComboBox.html
https://root.cern/root/html530/TGLineStyleComboBox.html:5148,Availability,error,error,5148," voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDime",MatchSource.WIKI,root/html530/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineStyleComboBox.html
https://root.cern/root/html530/TGLineStyleComboBox.html:5232,Availability,error,error,5232,"* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGComboBox::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultW",MatchSource.WIKI,root/html530/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineStyleComboBox.html
https://root.cern/root/html530/TGLineStyleComboBox.html:19256,Availability,down,down,19256,,MatchSource.WIKI,root/html530/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineStyleComboBox.html
https://root.cern/root/html530/TGLineStyleComboBox.html:19411,Availability,mask,mask,19411,,MatchSource.WIKI,root/html530/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineStyleComboBox.html
https://root.cern/root/html530/TGLineWidthComboBox.html:381,Availability,down,down,381,". TGLineWidthComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineWidthComboBox. class TGLineWidthComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGLineWidthComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel(), Bool_t none = kFALSE); ~TGLineWidthComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::Chan",MatchSource.WIKI,root/html530/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineWidthComboBox.html
https://root.cern/root/html530/TGLineWidthComboBox.html:618,Availability,down,down,618,". TGLineWidthComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineWidthComboBox. class TGLineWidthComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGLineWidthComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel(), Bool_t none = kFALSE); ~TGLineWidthComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::Chan",MatchSource.WIKI,root/html530/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineWidthComboBox.html
https://root.cern/root/html530/TGLineWidthComboBox.html:5170,Availability,error,error,5170," voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDime",MatchSource.WIKI,root/html530/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineWidthComboBox.html
https://root.cern/root/html530/TGLineWidthComboBox.html:5254,Availability,error,error,5254,"* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGComboBox::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultW",MatchSource.WIKI,root/html530/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineWidthComboBox.html
https://root.cern/root/html530/TGLineWidthComboBox.html:19278,Availability,down,down,19278,,MatchSource.WIKI,root/html530/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineWidthComboBox.html
https://root.cern/root/html530/TGLineWidthComboBox.html:19433,Availability,mask,mask,19433,,MatchSource.WIKI,root/html530/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLineWidthComboBox.html
https://root.cern/root/html530/TGLIsoPainter.html:4627,Modifiability,variab,variables,4627,"TIsoMesh<float> > >fIsos; pair<double,double>fMinMax; TGLLevelPalettefPalette; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLIsoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor. char * GetPlotInfo(Int_t px, Int_t py); Return info for plot part under cursor. Bool_t InitGeometry(); Initializes meshes for 3d iso contours. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement.; User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& option); No additional options for TGLIsoPainter. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color sheme. void InitGL() const; Initialize OpenGL state variables. void DeInitGL() const; Initialize OpenGL state variables. void DrawPlot() const; Draw mesh. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. Bool_t HasSections() const; Any section exists. void SetSurfaceColor(Int_t ind) const; Set color for surface. void SetMesh(TGLIsoPainter::Mesh_t& mesh, Double_t isoValue); Grid geometry. void DrawMesh(const TGLIsoPainter::Mesh_t& mesh, Int_t level) const; Draw TF3 surface. void FindMinMax(); Find max/min bin contents for TH3. TGLIsoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord). » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to RO",MatchSource.WIKI,root/html530/TGLIsoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLIsoPainter.html
https://root.cern/root/html530/TGLIsoPainter.html:4685,Modifiability,variab,variables,4685,"at> > >fIsos; pair<double,double>fMinMax; TGLLevelPalettefPalette; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLIsoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor. char * GetPlotInfo(Int_t px, Int_t py); Return info for plot part under cursor. Bool_t InitGeometry(); Initializes meshes for 3d iso contours. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement.; User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& option); No additional options for TGLIsoPainter. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color sheme. void InitGL() const; Initialize OpenGL state variables. void DeInitGL() const; Initialize OpenGL state variables. void DrawPlot() const; Draw mesh. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. Bool_t HasSections() const; Any section exists. void SetSurfaceColor(Int_t ind) const; Set color for surface. void SetMesh(TGLIsoPainter::Mesh_t& mesh, Double_t isoValue); Grid geometry. void DrawMesh(const TGLIsoPainter::Mesh_t& mesh, Int_t level) const; Draw TF3 surface. void FindMinMax(); Find max/min bin contents for TH3. TGLIsoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord). » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLIsoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLIsoPainter.html
https://root.cern/root/html530/TGListBox.html:5278,Availability,error,error,5278,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; virtual TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListBox.html
https://root.cern/root/html530/TGListBox.html:5362,Availability,error,error,5362,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; virtual TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeFram",MatchSource.WIKI,root/html530/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListBox.html
https://root.cern/root/html530/TGListBox.html:19277,Availability,mask,mask,19277,"dObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TStringTGWidget::fCommandcommand to be executed; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tfIntegralHeighttrue if height should be multiple of fItemVsize; UInt_tfItemVsizemaximum height of single entry; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGLBContainer*fLbclistbox container; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGVScrollBar*fVScrollbarvertical scrollbar; TGViewPort*fVportlistbox viewport (see TGCanvas.h); Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event process",MatchSource.WIKI,root/html530/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListBox.html
https://root.cern/root/html530/TGListBox.html:22276,Integrability,rout,routine,22276,"tatic Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGListBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a listbox. ~TGListBox(); Delete a listbox widget. void InitListBox(); Initiate the internal classes of a list box. void DrawBorder(); Draw borders of the list box widget. void AddEntry(TGString* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntry(const char* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox. The; entry and layout will be adopted and later deleted by the listbox. void AddEntrySort(TGString* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntrySort(const char* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used ",MatchSource.WIKI,root/html530/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListBox.html
https://root.cern/root/html530/TGListBox.html:22491,Integrability,rout,routine,22491,"gHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGListBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a listbox. ~TGListBox(); Delete a listbox widget. void InitListBox(); Initiate the internal classes of a list box. void DrawBorder(); Draw borders of the list box widget. void AddEntry(TGString* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntry(const char* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox. The; entry and layout will be adopted and later deleted by the listbox. void AddEntrySort(TGString* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntrySort(const char* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected. void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Add s",MatchSource.WIKI,root/html530/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListBox.html
https://root.cern/root/html530/TGListBox.html:23006,Integrability,rout,routine,23006,"te a listbox widget. void InitListBox(); Initiate the internal classes of a list box. void DrawBorder(); Draw borders of the list box widget. void AddEntry(TGString* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntry(const char* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox. The; entry and layout will be adopted and later deleted by the listbox. void AddEntrySort(TGString* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntrySort(const char* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected. void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The; entry and layout will be adopted and later deleted by the listbox. void InsertEntry(TGString* s, Int_t id, Int_t afterID); Insert entry with specified string and id behind the entry with afterID.; The string will be adopted and later deleted by the listbox. void InsertEntry(const char* s, Int_t id,",MatchSource.WIKI,root/html530/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListBox.html
https://root.cern/root/html530/TGListBox.html:23387,Integrability,rout,routine,23387,"s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox. The; entry and layout will be adopted and later deleted by the listbox. void AddEntrySort(TGString* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntrySort(const char* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected. void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The; entry and layout will be adopted and later deleted by the listbox. void InsertEntry(TGString* s, Int_t id, Int_t afterID); Insert entry with specified string and id behind the entry with afterID.; The string will be adopted and later deleted by the listbox. void InsertEntry(const char* s, Int_t id, Int_t afterID); Insert entry with specified string and id behind the entry with afterID. void NewEntry(const char* s = ""Entry""); method used to add entry via context menu. void RemoveAll(); Remove all entries. void RemoveEntries(Int_t from_ID, Int_t to_ID); Remove a range of entries defined by from_ID and to_ID. void InsertEntry(TGLBEntry* lbe, TGLayoutHints* lhints, Int_t afte",MatchSource.WIKI,root/html530/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListBox.html
https://root.cern/root/html530/TGListBox.html:25452,Integrability,message,messages,25452,"yout will be adopted and later deleted by the listbox. TGLBEntry * GetEntry(Int_t id) const; Returns list box entry with specified id. void SetTopEntry(Int_t id = -1); Scroll the entry with id to the top of the listbox. void Resize(UInt_t w, UInt_t h); Resize the listbox widget. If fIntegralHeight is true make the height; an integral number of the maximum height of a single entry. void MoveResize(Int_t x, Int_t y, UInt_t w, UInt_t h); Move and resize the listbox widget. TGDimension GetDefaultSize() const; Return default size of listbox widget. void Layout(); Layout the listbox components. void SortByName(Bool_t ascend = kTRUE); Sort entries by name. Int_t GetSelected() const; Return id of selected listbox item. void GetSelectedEntries(TList* selected); Adds all selected entries (TGLBEntry) of the list box into; the list selected. void ChangeBackground(Pixel_t back); Change background to all entries. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox container and forward; messages to the listbox message handling window. void Selected(Int_t widgetId, Int_t id); Emit Selected signal with list box id and entry id. void DoubleClicked(Int_t widgetId, Int_t id); Emit DoubleClicked signal with list box id and entry id. TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list box widget as a C++ statement(s) on output stream out. TGTextLBEntry & operator=(const TGListBox& ). void RemoveEntry(Int_t id = -1). Bool_t GetSelection(Int_t id). TGLBEntry * GetSelectedEntry() const; { return fLastActive; }. TGLBEntry * Select(Int_t id, Bool_t sel = kTRUE). TGVScrollBar * GetVScrollbar() const. void SetMultipleSelections(Bool_t multi = kTRUE). Bool_t GetMultipleSelections() const; { return fMultiSelect; }. TGListBox(const TGListBox& ). void SetContainer(TGFrame* f); { fVport->SetContainer(f); }. Int_t GetNumberOfEntries() const; { return fLbc->GetList()->G",MatchSource.WIKI,root/html530/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListBox.html
https://root.cern/root/html530/TGListBox.html:25509,Integrability,message,messages,25509,"yout will be adopted and later deleted by the listbox. TGLBEntry * GetEntry(Int_t id) const; Returns list box entry with specified id. void SetTopEntry(Int_t id = -1); Scroll the entry with id to the top of the listbox. void Resize(UInt_t w, UInt_t h); Resize the listbox widget. If fIntegralHeight is true make the height; an integral number of the maximum height of a single entry. void MoveResize(Int_t x, Int_t y, UInt_t w, UInt_t h); Move and resize the listbox widget. TGDimension GetDefaultSize() const; Return default size of listbox widget. void Layout(); Layout the listbox components. void SortByName(Bool_t ascend = kTRUE); Sort entries by name. Int_t GetSelected() const; Return id of selected listbox item. void GetSelectedEntries(TList* selected); Adds all selected entries (TGLBEntry) of the list box into; the list selected. void ChangeBackground(Pixel_t back); Change background to all entries. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox container and forward; messages to the listbox message handling window. void Selected(Int_t widgetId, Int_t id); Emit Selected signal with list box id and entry id. void DoubleClicked(Int_t widgetId, Int_t id); Emit DoubleClicked signal with list box id and entry id. TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list box widget as a C++ statement(s) on output stream out. TGTextLBEntry & operator=(const TGListBox& ). void RemoveEntry(Int_t id = -1). Bool_t GetSelection(Int_t id). TGLBEntry * GetSelectedEntry() const; { return fLastActive; }. TGLBEntry * Select(Int_t id, Bool_t sel = kTRUE). TGVScrollBar * GetVScrollbar() const. void SetMultipleSelections(Bool_t multi = kTRUE). Bool_t GetMultipleSelections() const; { return fMultiSelect; }. TGListBox(const TGListBox& ). void SetContainer(TGFrame* f); { fVport->SetContainer(f); }. Int_t GetNumberOfEntries() const; { return fLbc->GetList()->G",MatchSource.WIKI,root/html530/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListBox.html
https://root.cern/root/html530/TGListBox.html:25533,Integrability,message,message,25533,"yout will be adopted and later deleted by the listbox. TGLBEntry * GetEntry(Int_t id) const; Returns list box entry with specified id. void SetTopEntry(Int_t id = -1); Scroll the entry with id to the top of the listbox. void Resize(UInt_t w, UInt_t h); Resize the listbox widget. If fIntegralHeight is true make the height; an integral number of the maximum height of a single entry. void MoveResize(Int_t x, Int_t y, UInt_t w, UInt_t h); Move and resize the listbox widget. TGDimension GetDefaultSize() const; Return default size of listbox widget. void Layout(); Layout the listbox components. void SortByName(Bool_t ascend = kTRUE); Sort entries by name. Int_t GetSelected() const; Return id of selected listbox item. void GetSelectedEntries(TList* selected); Adds all selected entries (TGLBEntry) of the list box into; the list selected. void ChangeBackground(Pixel_t back); Change background to all entries. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox container and forward; messages to the listbox message handling window. void Selected(Int_t widgetId, Int_t id); Emit Selected signal with list box id and entry id. void DoubleClicked(Int_t widgetId, Int_t id); Emit DoubleClicked signal with list box id and entry id. TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list box widget as a C++ statement(s) on output stream out. TGTextLBEntry & operator=(const TGListBox& ). void RemoveEntry(Int_t id = -1). Bool_t GetSelection(Int_t id). TGLBEntry * GetSelectedEntry() const; { return fLastActive; }. TGLBEntry * Select(Int_t id, Bool_t sel = kTRUE). TGVScrollBar * GetVScrollbar() const. void SetMultipleSelections(Bool_t multi = kTRUE). Bool_t GetMultipleSelections() const; { return fMultiSelect; }. TGListBox(const TGListBox& ). void SetContainer(TGFrame* f); { fVport->SetContainer(f); }. Int_t GetNumberOfEntries() const; { return fLbc->GetList()->G",MatchSource.WIKI,root/html530/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListBox.html
https://root.cern/root/html530/TGListBox.html:455,Usability,simpl,simple,455,". TGListBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListBox. class TGListBox: public TGCompositeFrame, public TGWidget. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. TGListBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); virtual~TGListBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidAddEntrySort(TGString* s, Int_t id); virtual voidAddEntrySort(const char* s, Int_t id); virtual voidAddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pix",MatchSource.WIKI,root/html530/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListBox.html
https://root.cern/root/html530/TGListDetailsLayout.html:803,Availability,down,downward,803,". TGListDetailsLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListDetailsLayout. class TGListDetailsLayout: public TGTileLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGListDetailsLayout(TGCompositeFrame* main, Int_t sep = 0, UInt_t w = 0); ~TGListDetailsLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Dra",MatchSource.WIKI,root/html530/TGListDetailsLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListDetailsLayout.html
https://root.cern/root/html530/TGListDetailsLayout.html:2332,Availability,error,error,2332,"Layout(TGCompositeFrame* main, Int_t sep = 0, UInt_t w = 0); ~TGListDetailsLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root/html530/TGListDetailsLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListDetailsLayout.html
https://root.cern/root/html530/TGListDetailsLayout.html:2416,Availability,error,error,2416," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html530/TGListDetailsLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListDetailsLayout.html
https://root.cern/root/html530/TGListLayout.html:782,Availability,down,downward,782,". TGListLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListLayout. class TGListLayout: public TGTileLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGListLayout(TGCompositeFrame* main, Int_t sep = 0); ~TGListLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::Dr",MatchSource.WIKI,root/html530/TGListLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListLayout.html
https://root.cern/root/html530/TGListLayout.html:2283,Availability,error,error,2283," TGListLayout(TGCompositeFrame* main, Int_t sep = 0); ~TGListLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::Dr",MatchSource.WIKI,root/html530/TGListLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListLayout.html
https://root.cern/root/html530/TGListLayout.html:2367,Availability,error,error,2367," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html530/TGListLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListLayout.html
https://root.cern/root/html530/TGListTree.html:2907,Availability,mask,mask,2907,"ate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); voidCheckAllChildren(TGListTreeItem* item, Bool_t state); virtual voidChecked(TObject* obj, Bool_t check)SIGNAL ; voidCheckItem(TGListTreeItem* item, Bool_t check = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearHighlighted(); virtual voidTGContainer::ClearViewPort(); virtual voidClicked(TGListTreeItem* entry, Int_t btn)SIGNAL ; virtual voidClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual voidClicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidCloseItem(TGListTreeItem* item); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDataDropped(TGListTreeItem* item, TDNDData* data)SIGNAL ; virtual voidTGFrame::Delete(Option_t* = """"); Int_tDeleteChildren(TGListTreeItem* item); Int_tDeleteItem(TGListTreeItem* item); Int_tDeleteSelected()MENU ;",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:6349,Availability,error,error,6349," signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnd(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGListTreeItem*FindChildByData(TGListTreeItem* item, void* userData); TGListTreeItem*FindChildByName(TGListTreeItem* item, const char* name); virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; TGListTreeItem*FindItemByObj(TGListTreeItem* item, void* ptr); TGListTreeItem*FindItemByPathname(const char* path); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGListTreeItem*FindSiblingByData(TGListTreeItem* item, void* userData); TGListTreeItem*FindSiblingByName(TGListTreeItem* item, const char* name); Int_tFo",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:6433,Availability,error,error,6433,"TQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnd(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGListTreeItem*FindChildByData(TGListTreeItem* item, void* userData); TGListTreeItem*FindChildByName(TGListTreeItem* item, const char* name); virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; TGListTreeItem*FindItemByObj(TGListTreeItem* item, void* ptr); TGListTreeItem*FindItemByPathname(const char* path); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGListTreeItem*FindSiblingByData(TGListTreeItem* item, void* userData); TGListTreeItem*FindSiblingByName(TGListTreeItem* item, const char* name); Int_tFontAscent(); Int_tFontHeight(); virtual Pixel_tTGFrame::GetBackground() const; static",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:13929,Availability,mask,mask,13929,"t(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; Bool_tIsEventHandled() const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidKeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidLineDown(Bool_t select = kFALSE); virtual voidTGContainer::LineLeft(Bool_t select = kFALSE); virtual voidTGContainer::LineRight(Bool_t select = kFALSE); virtual voidLineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidMouseOver(TGListTreeItem* entry)SIGNAL ; virtual voidMouseOver(TGListTreeItem* entry, UInt_t mask)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQO",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:14693,Availability,mask,mask,14693,"Sortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidKeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidLineDown(Bool_t select = kFALSE); virtual voidTGContainer::LineLeft(Bool_t select = kFALSE); virtual voidTGContainer::LineRight(Bool_t select = kFALSE); virtual voidLineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidMouseOver(TGListTreeItem* entry)SIGNAL ; virtual voidMouseOver(TGListTreeItem* entry, UInt_t mask)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual Int_tTGContainer::NumItems() const; virtual Int_tTGContainer::NumSelected() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidOpenItem(TGListTreeItem* item); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidPageDown(Bool_t select = kFALSE); virtual voi",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:26161,Availability,mask,mask,26161,"rame border width; TBufferFile*fBufbuffer used for Drag and Drop; TGCanvas*TGContainer::fCanvaspointer to canvas; TGListTree::ECheckModefCheckModehow to propagate check properties through the tree; TGClient*TGObject::fClientConnection to display server; GContext_tfColorGCdrawing context for main item color; TGListTree::EColorMarkupModefColorModeif/how to render item's main color; TGListTreeItem*fCurrentpointer to current item in list; TDNDDatafDNDDataDrag and Drop data; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*fDNDTypeListhandles DND types; UInt_tfDefhdefault list height; UInt_tfDefwdefault list width; Bool_tfDisableOpendisable branch opening on double-clicks; Bool_tTGContainer::fDraggingtrue if in dragging mode; GContext_tfDrawGCicon drawing context; TGListTreeItem*fDropItemitem on which DND is over; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; Bool_tfEventHandledflag used from user code to bypass standard event handling; UInt_tTGFrame::fEventMaskcurrenty active event mask; Int_tfExposeBottombottom y position of visible region; Int_tfExposeToptop y postion of visible region; TGRectangleTGContainer::fExposedRegionexposed area; TGFrameElement*TGFrame::fFEpointer to frame element; TGListTreeItem*fFirstpointer to first item in list; FontStruct_tfFontfont used to draw item text; Pixel_tfGrayPixelgray draw color; UInt_tTGFrame::fHeightframe height; GContext_tfHighlightGChighlighted icon drawing context; Int_tfHspacinghorizontal spacing between items; Handle_tTGObject::fIdX11/Win32 Window identifier; Int_tfIndentnumber of pixels indentation; TStringTGContainer::fKeyInputkeyboard input (buffer); TTimer*TGContainer::fKeyTimerkeyboard timer; Bool_tTGContainer::fKeyTimerActivekTRUE - keyboard timer is active; TGListTreeItem*fLastpointer to last item in list; TGFrameElement*TGContainer::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; UInt_tfLastEventStatemodifier state",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:32498,Availability,mask,mask,32498,"l_t HandleButton(Event_t* event); Handle button events in the list tree. Bool_t HandleDoubleClick(Event_t* event); Handle double click event in the list tree (only for kButton1). Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. void DataDropped(TGListTreeItem* item, TDNDData* data); Emit DataDropped() signal. Bool_t HandleMotion(Event_t* event); Handle mouse motion event. Used to set tool tip, to emit; MouseOver() signal and for DND handling. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. void MouseOver(TGListTreeItem* entry); Signal emitted when pointer is over entry. void MouseOver(TGListTreeItem* entry, UInt_t mask); Signal emitted when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* ent",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:32609,Availability,mask,mask,32609,"_t* event); Handle double click event in the list tree (only for kButton1). Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. void DataDropped(TGListTreeItem* item, TDNDData* data); Emit DataDropped() signal. Bool_t HandleMotion(Event_t* event); Handle mouse motion event. Used to set tool tip, to emit; MouseOver() signal and for DND handling. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. void MouseOver(TGListTreeItem* entry); Signal emitted when pointer is over entry. void MouseOver(TGListTreeItem* entry, UInt_t mask); Signal emitted when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeIte",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:32717,Availability,mask,mask,32717," event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. void DataDropped(TGListTreeItem* item, TDNDData* data); Emit DataDropped() signal. Bool_t HandleMotion(Event_t* event); Handle mouse motion event. Used to set tool tip, to emit; MouseOver() signal and for DND handling. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. void MouseOver(TGListTreeItem* entry); Signal emitted when pointer is over entry. void MouseOver(TGListTreeItem* entry, UInt_t mask); Signal emitted when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleCli",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:32737,Availability,mask,mask,32737," event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. void DataDropped(TGListTreeItem* item, TDNDData* data); Emit DataDropped() signal. Bool_t HandleMotion(Event_t* event); Handle mouse motion event. Used to set tool tip, to emit; MouseOver() signal and for DND handling. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. void MouseOver(TGListTreeItem* entry); Signal emitted when pointer is over entry. void MouseOver(TGListTreeItem* entry, UInt_t mask); Signal emitted when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleCli",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:33522,Availability,mask,mask,33522,"d when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleClicked() signal. void Home(Bool_t select = kFALSE); Move content to the top. void End(Bool_t select = kFALSE); Move content to the bottom. void PageUp(Bool_t select = kFALSE); Move content one page up. void PageDown(Bool_t select = kFALSE); Move content one page down. void LineUp(Bool_t select = kFALSE); Move content one item-size up. void LineDown(Bool_t select = kFALSE); Move content one item-size down. void AdjustPosition(TGListTreeItem* item); Move content to position of item. If item is 0, move to position; of currently selected item. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Redraw list tree. void Draw(Handle_t id, Int_t yevent, Int_t hevent); Draw list tree",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:34000,Availability,down,down,34000,"= BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleClicked() signal. void Home(Bool_t select = kFALSE); Move content to the top. void End(Bool_t select = kFALSE); Move content to the bottom. void PageUp(Bool_t select = kFALSE); Move content one page up. void PageDown(Bool_t select = kFALSE); Move content one page down. void LineUp(Bool_t select = kFALSE); Move content one item-size up. void LineDown(Bool_t select = kFALSE); Move content one item-size down. void AdjustPosition(TGListTreeItem* item); Move content to position of item. If item is 0, move to position; of currently selected item. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Redraw list tree. void Draw(Handle_t id, Int_t yevent, Int_t hevent); Draw list tree widget. Int_t DrawChildren(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t xroot); Draw children of item in list tree. void DrawItem(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t* xroot, UInt_t* retwidth, UInt_t* retheight); Draw list tree item. void DrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 0xbbbbbb, Bool_t clear = kFALSE); Draw a outline of color 'col' around an item. void DrawActive(Handle_t id, TGListTr",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:34140,Availability,down,down,34140,"Button5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleClicked() signal. void Home(Bool_t select = kFALSE); Move content to the top. void End(Bool_t select = kFALSE); Move content to the bottom. void PageUp(Bool_t select = kFALSE); Move content one page up. void PageDown(Bool_t select = kFALSE); Move content one page down. void LineUp(Bool_t select = kFALSE); Move content one item-size up. void LineDown(Bool_t select = kFALSE); Move content one item-size down. void AdjustPosition(TGListTreeItem* item); Move content to position of item. If item is 0, move to position; of currently selected item. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Redraw list tree. void Draw(Handle_t id, Int_t yevent, Int_t hevent); Draw list tree widget. Int_t DrawChildren(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t xroot); Draw children of item in list tree. void DrawItem(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t* xroot, UInt_t* retwidth, UInt_t* retheight); Draw list tree item. void DrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 0xbbbbbb, Bool_t clear = kFALSE); Draw a outline of color 'col' around an item. void DrawActive(Handle_t id, TGListTreeItem* item); Draw active item with its active color. void DrawItemName(Handle_t id, TGListTreeItem* item); Draw name of list tree item.",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:37268,Availability,down,downwards,37268," findy. void AddItem(TGListTreeItem* parent, TGListTreeItem* item); Add given item to list tree. TGListTreeItem * AddItem(TGListTreeItem* parent, const char* string, const TGPicture* open = 0, const TGPicture* closed = 0, Bool_t checkbox = kFALSE); Add item to list tree. Returns new item. TGListTreeItem * AddItem(TGListTreeItem* parent, const char* string, void* userData, const TGPicture* open = 0, const TGPicture* closed = 0, Bool_t checkbox = kFALSE); Add item to list tree. If item with same userData already exists; don't add it. Returns new item. void RenameItem(TGListTreeItem* item, const char* string); Rename item in list tree. Int_t DeleteItem(TGListTreeItem* item); Delete item from list tree. void OpenItem(TGListTreeItem* item); Open item in list tree (i.e. show child items). void CloseItem(TGListTreeItem* item); Close item in list tree (i.e. hide child items). Int_t RecursiveDeleteItem(TGListTreeItem* item, void* userData); Delete item with fUserData == ptr. Search tree downwards starting; at item. void SetToolTipItem(TGListTreeItem* item, const char* string); Set tooltip text for this item. By default an item for which the; userData is a pointer to an TObject the TObject::GetTitle() will; be used to get the tip text. Int_t DeleteChildren(TGListTreeItem* item); Delete children of item from list. Int_t Reparent(TGListTreeItem* item, TGListTreeItem* newparent); Make newparent the new parent of item. Int_t ReparentChildren(TGListTreeItem* item, TGListTreeItem* newparent); Make newparent the new parent of the children of item. Int_t Sort(TGListTreeItem* item); Sort items starting with item. Int_t SortSiblings(TGListTreeItem* item); Sort siblings of item. Int_t SortChildren(TGListTreeItem* item); Sort children of item. TGListTreeItem * FindSiblingByName(TGListTreeItem* item, const char* name); Find sibling of item by name. TGListTreeItem * FindSiblingByData(TGListTreeItem* item, void* userData); Find sibling of item by userData. TGListTreeItem * FindChildByName(TG",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:40533,Availability,down,downwards,40533,"turns the icon used by items in closed state. const TGPicture * GetCheckedPic(); Returns the icon used for checked checkbox. const TGPicture * GetUncheckedPic(); Returns the icon used for unchecked checkbox. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list tree widget as a C++ statements on output stream out. void SaveChildren(ostream& out, TGListTreeItem* item, Int_t& n); Save child items as a C++ statements on output stream out. void CheckItem(TGListTreeItem* item, Bool_t check = kTRUE); Set check button state for the node 'item'. void SetCheckBox(TGListTreeItem* item, Bool_t on = kTRUE); Set check button state for the node 'item'. void ToggleItem(TGListTreeItem* item); Toggle check button state of the node 'item'. void UpdateChecked(TGListTreeItem* item, Bool_t redraw = kFALSE); Update the state of the node 'item' according to the children states. TGListTreeItem * FindItemByObj(TGListTreeItem* item, void* ptr); Find item with fUserData == ptr. Search tree downwards starting; at item. void GetChecked(TList* checked); Add all checked list tree items of this list tree into; the list 'checked'. This list is not adopted and must; be deleted by the user later. void GetCheckedChildren(TList* checked, TGListTreeItem* item); Add all child items of 'item' into the list 'checked'. void CheckAllChildren(TGListTreeItem* item, Bool_t state); Check all child items of 'item' and 'item' itself according; to the state value: kTRUE means check all, kFALSE - uncheck all. TGListTreeItem& operator=(const TGListTree& ). void Draw(Handle_t id, Int_t yevent, Int_t hevent). TGListTreeItem * FindItem(Int_t findy). void Layout(); {}. void OnMouseOver(TGFrame* ); { }. void CurrentChanged(Int_t , Int_t ); { }. void CurrentChanged(TGFrame* ); { }. void ReturnPressed(TGFrame* ); { }. void Clicked(TGFrame* , Int_t ); { }. void Clicked(TGFrame* , Int_t , Int_t , Int_t ); { }. void DoubleClicked(TGFrame* , Int_t ); { }. void DoubleClicked(TGFrame* , Int_t , Int_t , Int_t ); { }.",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:28062,Integrability,message,messages,28062,t search; Bool_tTGContainer::fLastDirdirection of last search; UInt_tfLastEventStatemodifier state of the last keyboard event; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; GContext_tfLineGCdashed line drawing context; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; Int_tfMarginnumber of pixels margin from left side; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; TGListTreeItem*fSelectedpointer to selected item in list; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGToolTip*fTiptooltip shown when moving over list items; TGListTreeItem*fTipItemitem for which tooltip is set; Int_tTGContainer::fTotaltotal items; Bool_tfUserControlledlet user decides what is the behaviour on events; TGViewPort*TGContainer::fViewPortcontainer viewport; Int_tfVspacingvertical spacing between items; UInt_tTGFrame::fWidthframe widt,MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:5050,Usability,clear,clear,5050,"::DestroyWindow(); voidDisableOpen(Bool_t disable = kTRUE); Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(TQObject* sender, const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(const char* class_name, const char* signal, void* receiver = 0, const char* slot = 0); virtual voidTQObject::Disconnected(const char*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoubleClicked(TGListTreeItem* entry, Int_t btn)SIGNAL ; virtual voidDoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual voidDrawActive(Handle_t id, TGListTreeItem* item); virtual voidTGFrame::DrawBorder(); virtual voidTGFrame::DrawClass() const; virtual TObject*TGFrame::DrawClone(Option_t* = """") const; virtual voidTGFrame::DrawCopy(Handle_t, Int_t, Int_t); virtual voidDrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 0xbbbbbb, Bool_t clear = kFALSE); virtual voidDrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGFrame::Dump() const; voidTQObject::Emit(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::Emi",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTree.html:34872,Usability,clear,clear,34872,"to the bottom. void PageUp(Bool_t select = kFALSE); Move content one page up. void PageDown(Bool_t select = kFALSE); Move content one page down. void LineUp(Bool_t select = kFALSE); Move content one item-size up. void LineDown(Bool_t select = kFALSE); Move content one item-size down. void AdjustPosition(TGListTreeItem* item); Move content to position of item. If item is 0, move to position; of currently selected item. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Redraw list tree. void Draw(Handle_t id, Int_t yevent, Int_t hevent); Draw list tree widget. Int_t DrawChildren(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t xroot); Draw children of item in list tree. void DrawItem(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t* xroot, UInt_t* retwidth, UInt_t* retheight); Draw list tree item. void DrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 0xbbbbbb, Bool_t clear = kFALSE); Draw a outline of color 'col' around an item. void DrawActive(Handle_t id, TGListTreeItem* item); Draw active item with its active color. void DrawItemName(Handle_t id, TGListTreeItem* item); Draw name of list tree item. void DrawNode(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y); Draw node (little + in box). void SetToolTipText(const char* text, Int_t x, Int_t y, Long_t delayms); Set tool tip text associated with this item. The delay is in; milliseconds (minimum 250). To remove tool tip call method with; delayms = 0. To change delayms you first have to call this method; with delayms=0. void RemoveReference(TGListTreeItem* item); This function removes the specified item from the linked list.; It does not do anything with the data contained in the item, though. void PDeleteItem(TGListTreeItem* item); Delete given item. Takes care of list-tree state members; fSelected, fCurrent and fBelowMouse. void PDeleteChildren(TGListTreeItem* item); Recursively del",MatchSource.WIKI,root/html530/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTree.html
https://root.cern/root/html530/TGListTreeItem.html:890,Availability,avail,available,890,". TGListTreeItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListTreeItem. class TGListTreeItem. TGListTree and TGListTreeItem. A list tree is a widget that can contain a number of items; arranged in a tree structure. The items are represented by small; folder icons that can be either open or closed. The TGListTree is user callable. The TGListTreeItem is a service; class of the list tree. A list tree can generate the following events:; kC_LISTTREE, kCT_ITEMCLICK, which button, location (y<<16|x).; kC_LISTTREE, kCT_ITEMDBLCLICK, which button, location (y<<16|x). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGListTreeItem(); virtual voidCheckAllChildren(Bool_t = kTRUE); virtual voidCheckChildren(TGListTreeItem*, Bool_t); virtual voidCheckItem(Bool_t = kTRUE); static TClass*Class(); virtual voidClearColor(); virtual Pixel_tGetActiveColor() const; virtual const TGPicture*GetCheckBoxPicture() const; virtual Color_tGetColor() const; TGListTreeItem*GetFirstChild() const; TGListTreeItem*GetLastChild() const; TGListTreeItem*GetNextSibling() const; TGListTreeItem*GetParent() const; virtual const TGPicture*GetPicture() const; virtual UInt_tGetPicWidth() const; TGListTreeItem*GetPrevSibling() const; virtual const char*GetText() const; virtual Int_tGetTextLength() const; virtual const char*GetTipText() const; virtual Int_tGetTipTextLength() const; virtual void*GetUserData() const; virtual voidHandleDrag(); virtual voidHandleDrop(); virtual Bool_tHandlesDragAndDrop() const; virtual Bool_tHasCheckBox() const; virtual Bool_tHasCheckedChild(Bool_t = kFALSE); virtual Bool_tHasColor() const; virtual Bool_tHasUnCheckedChild(Bool_t = kFALSE); virtual TClass*IsA() const; virt",MatchSource.WIKI,root/html530/TGListTreeItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListTreeItem.html
https://root.cern/root/html530/TGListView.html:4887,Availability,error,error,4887,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*TGCanvas::GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCanvas::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html530/TGListView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListView.html
https://root.cern/root/html530/TGListView.html:4971,Availability,error,error,4971,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*TGCanvas::GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCanvas::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual ",MatchSource.WIKI,root/html530/TGListView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListView.html
https://root.cern/root/html530/TGListView.html:17484,Availability,mask,mask,17484,,MatchSource.WIKI,root/html530/TGListView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListView.html
https://root.cern/root/html530/TGListView.html:21696,Integrability,message,messages,21696,"xt and cmode is the x text; alignmode for the item text. const char * GetHeader(Int_t idx) const; Returns name of header idx. If illegal idx or header not set for idx; 0 is returned. void SetDefaultHeaders(); Default headers are: Name, Attributes, Size, Owner, Group, Modified.; The default is good for file system items. void SetViewMode(EListViewMode viewMode); Set list view mode. void SetContainer(TGFrame* f); Set list view container. Container must be at least of type; TGLVContainer. void SetIncrements(Int_t hInc, Int_t vInc); Set horizontal and vertical scrollbar increments. void SetDefaultColumnWidth(TGVFileSplitter* splitter); Set default column width of the columns headers. void ResizeColumns(); Resize column headers to show whole item names. void Layout(); Layout list view components (container and contents of container). void LayoutHeader(TGFrame* head); Layout list view components (container and contents of container). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle messages generated by the list view components. void Clicked(TGLVEntry* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGLVEntry* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleClicked() signal. FontStruct_t GetDefaultFontStruct(); Return the default font structure in use. const TGGC & GetDefaultGC(); Return the default graphics context in use. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list view widget as a C++ statement(s) on output stream out. TGLVEntry& operator=(const TGListView& ). EListViewMode GetViewMode() const; { return fViewMode; }. TGListView(const TGListView& ). void AdjustHeaders(); { fJustChanged = kTRUE; LayoutHeader(0); }. TGTextButton** GetHeaderButtons(); { return fColHeader; }. UInt_t GetNumColumns(); { return fNColumns; }. TGDimension GetMaxItemSize() const;",MatchSource.WIKI,root/html530/TGListView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGListView.html
https://root.cern/root/html530/TGLLegoPainter.html:4919,Modifiability,variab,variables,4919," pair<double,double>fMinMaxValFor texture coordinates generation.; Double_tfMinZ; TGLLevelPalettefPalette; TGLQuadricfQuadric; vector<Rgl::Range_t>fXEdges; vector<Rgl::Range_t>fYEdges. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLegoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Obtain bin's info (i, j, value). Bool_t InitGeometry(); Select method. Bool_t InitGeometryCartesian(); Geometry for lego in cartesian coords. Bool_t InitGeometryPolar(); Geometry for lego in polar coords. Bool_t InitGeometryCylindrical(); Geometry for lego in cylindrical coords. Bool_t InitGeometrySpherical(); Geometry for lego in spherical coords. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Move lego or section. void AddOption(const TString& stringOption); Parse additional options. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return some gl states to original values. void DrawPlot() const; Select method corresponding to coordinate system. void DrawLegoCartesian() const; Lego in cartesian system. void DrawLegoPolar() const; Lego in polar system. void DrawLegoCylindrical() const; Lego in cylindrical system. void DrawLegoSpherical() const; Lego in spherical system. void SetLegoColor() const; Set lego's color. void DrawSectionXOZ() const; XOZ plane parallel section. void DrawSectionYOZ() const; YOZ plane parallel section. void DrawSectionXOY() const; Empty. No such sections for lego. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove all sections and repaint. Bool_t ClampZ(Double_t& zVal) const; Clamp z value. Bool_t PreparePalette() const; Initialize color palette. void DrawPalette() const; Draw. Palette.; Originally, fCamera was never null.; It can be a null now because of gl-viewer. void DrawPaletteAxis() const; Draw. Palette. Axis. TGLLegoPainter(c",MatchSource.WIKI,root/html530/TGLLegoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLegoPainter.html
https://root.cern/root/html530/TGLLightSet.html:1335,Availability,error,error,1335," TGLLightSet(); virtual~TGLLightSet(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetFrontPower() const; virtual const char*TObject::GetIconName() const; UInt_tGetLightState(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static B",MatchSource.WIKI,root/html530/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSet.html
https://root.cern/root/html530/TGLLightSet.html:1419,Availability,error,error,1419," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetFrontPower() const; virtual const char*TObject::GetIconName() const; UInt_tGetLightState(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetSidePower() const; Float_tGetSpecularPower() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Bool_tGetUseSpecular() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; v",MatchSource.WIKI,root/html530/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSet.html
https://root.cern/root/html530/TGLLightSet.html:5792,Availability,mask,mask,5792,"::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGLLightSet(const TGLLightSet&); TGLLightSet&operator=(const TGLLightSet&). Data Members; public:. enum ELight { kLightFront; kLightTop; kLightBottom; kLightLeft; kLightRight; kLightMask; kLightSpecular; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfFrontPower! power of the front lamp; UInt_tfLightState! light states (on/off) mask; Float_tfSidePower! power of the side lamps; Float_tfSpecularPower! power of specular lamp; Bool_tfUseSpecular!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLightSet(); Constructor. void ToggleLight(TGLLightSet::ELight light); Toggle light on/off. void SetLight(TGLLightSet::ELight light, Bool_t on); Set a light on/off. void StdSetupLights(const TGLBoundingBox& bbox, const TGLCamera& camera, Bool_t debug = kFALSE); Setup lights for current given bounding box and camera.; This is called by standard GL viewer.; Expects matrix-mode to be model-view. TGLLightSet(const TGLLightSet& ). TGLLightSet& operator=(const TGLLightSet& ). virtual ~TGLLightSet(); {}. UInt_t GetLightState(); { return fLightState; }. Bool_t GetUseSpecular() const; { return fUseSpecular; }. void SetUseSpecular(Bool_t s); { fUseSpecular = s; }. Float_t GetFrontPower() const; { return fFrontPower; }. Float_t GetSidePower() const; { return fSidePower; }. Float_t GetSpecularPower() cons",MatchSource.WIKI,root/html530/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSet.html
https://root.cern/root/html530/TGLLightSet.html:5726,Energy Efficiency,power,power,5726,"::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGLLightSet(const TGLLightSet&); TGLLightSet&operator=(const TGLLightSet&). Data Members; public:. enum ELight { kLightFront; kLightTop; kLightBottom; kLightLeft; kLightRight; kLightMask; kLightSpecular; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfFrontPower! power of the front lamp; UInt_tfLightState! light states (on/off) mask; Float_tfSidePower! power of the side lamps; Float_tfSpecularPower! power of specular lamp; Bool_tfUseSpecular!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLightSet(); Constructor. void ToggleLight(TGLLightSet::ELight light); Toggle light on/off. void SetLight(TGLLightSet::ELight light, Bool_t on); Set a light on/off. void StdSetupLights(const TGLBoundingBox& bbox, const TGLCamera& camera, Bool_t debug = kFALSE); Setup lights for current given bounding box and camera.; This is called by standard GL viewer.; Expects matrix-mode to be model-view. TGLLightSet(const TGLLightSet& ). TGLLightSet& operator=(const TGLLightSet& ). virtual ~TGLLightSet(); {}. UInt_t GetLightState(); { return fLightState; }. Bool_t GetUseSpecular() const; { return fUseSpecular; }. void SetUseSpecular(Bool_t s); { fUseSpecular = s; }. Float_t GetFrontPower() const; { return fFrontPower; }. Float_t GetSidePower() const; { return fSidePower; }. Float_t GetSpecularPower() cons",MatchSource.WIKI,root/html530/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSet.html
https://root.cern/root/html530/TGLLightSet.html:5817,Energy Efficiency,power,power,5817,"::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGLLightSet(const TGLLightSet&); TGLLightSet&operator=(const TGLLightSet&). Data Members; public:. enum ELight { kLightFront; kLightTop; kLightBottom; kLightLeft; kLightRight; kLightMask; kLightSpecular; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfFrontPower! power of the front lamp; UInt_tfLightState! light states (on/off) mask; Float_tfSidePower! power of the side lamps; Float_tfSpecularPower! power of specular lamp; Bool_tfUseSpecular!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLightSet(); Constructor. void ToggleLight(TGLLightSet::ELight light); Toggle light on/off. void SetLight(TGLLightSet::ELight light, Bool_t on); Set a light on/off. void StdSetupLights(const TGLBoundingBox& bbox, const TGLCamera& camera, Bool_t debug = kFALSE); Setup lights for current given bounding box and camera.; This is called by standard GL viewer.; Expects matrix-mode to be model-view. TGLLightSet(const TGLLightSet& ). TGLLightSet& operator=(const TGLLightSet& ). virtual ~TGLLightSet(); {}. UInt_t GetLightState(); { return fLightState; }. Bool_t GetUseSpecular() const; { return fUseSpecular; }. void SetUseSpecular(Bool_t s); { fUseSpecular = s; }. Float_t GetFrontPower() const; { return fFrontPower; }. Float_t GetSidePower() const; { return fSidePower; }. Float_t GetSpecularPower() cons",MatchSource.WIKI,root/html530/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSet.html
https://root.cern/root/html530/TGLLightSet.html:5865,Energy Efficiency,power,power,5865,"::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGLLightSet(const TGLLightSet&); TGLLightSet&operator=(const TGLLightSet&). Data Members; public:. enum ELight { kLightFront; kLightTop; kLightBottom; kLightLeft; kLightRight; kLightMask; kLightSpecular; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfFrontPower! power of the front lamp; UInt_tfLightState! light states (on/off) mask; Float_tfSidePower! power of the side lamps; Float_tfSpecularPower! power of specular lamp; Bool_tfUseSpecular!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLightSet(); Constructor. void ToggleLight(TGLLightSet::ELight light); Toggle light on/off. void SetLight(TGLLightSet::ELight light, Bool_t on); Set a light on/off. void StdSetupLights(const TGLBoundingBox& bbox, const TGLCamera& camera, Bool_t debug = kFALSE); Setup lights for current given bounding box and camera.; This is called by standard GL viewer.; Expects matrix-mode to be model-view. TGLLightSet(const TGLLightSet& ). TGLLightSet& operator=(const TGLLightSet& ). virtual ~TGLLightSet(); {}. UInt_t GetLightState(); { return fLightState; }. Bool_t GetUseSpecular() const; { return fUseSpecular; }. void SetUseSpecular(Bool_t s); { fUseSpecular = s; }. Float_t GetFrontPower() const; { return fFrontPower; }. Float_t GetSidePower() const; { return fSidePower; }. Float_t GetSpecularPower() cons",MatchSource.WIKI,root/html530/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSet.html
https://root.cern/root/html530/TGLLightSetEditor.html:4490,Availability,error,error,4490,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGLLightSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSetEditor.html
https://root.cern/root/html530/TGLLightSetEditor.html:4574,Availability,error,error,4574,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGLLightSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSetEditor.html
https://root.cern/root/html530/TGLLightSetEditor.html:17378,Availability,mask,mask,17378,,MatchSource.WIKI,root/html530/TGLLightSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSetEditor.html
https://root.cern/root/html530/TGLLightSetSubEditor.html:4188,Availability,error,error,4188,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGLLightSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSetSubEditor.html
https://root.cern/root/html530/TGLLightSetSubEditor.html:4272,Availability,error,error,4272,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGLLightSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSetSubEditor.html
https://root.cern/root/html530/TGLLightSetSubEditor.html:16751,Availability,mask,mask,16751,,MatchSource.WIKI,root/html530/TGLLightSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLightSetSubEditor.html
https://root.cern/root/html530/TGLLine3.html:387,Integrability,wrap,wraps,387,". TGLLine3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLine3. class TGLLine3. TGLLine3. 3D space, fixed length, line class, with direction / length 'vector',; passing through point 'vertex'. Just wraps a TGLVector3 / TGLVertex3; pair. Function Members (Methods); public:. TGLLine3(const TGLLine3&); TGLLine3(const TGLVertex3& start, const TGLVertex3& end); TGLLine3(const TGLVertex3& start, const TGLVector3& vector); virtual~TGLLine3(); static TClass*Class(); voidDraw() const; const TGLVertex3End() const; virtual TClass*IsA() const; TGLLine3&operator=(const TGLLine3&); voidSet(const TGLVertex3& start, const TGLVertex3& end); voidSet(const TGLVertex3& start, const TGLVector3& vector); virtual voidShowMembers(TMemberInspector& insp); const TGLVertex3&Start() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const TGLVector3&Vector() const. Data Members; private:. TGLVector3fVector! Vector of line from fVertex; TGLVertex3fVertex! Start vertex of line. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLine3(const TGLVertex3& start, const TGLVertex3& end); Construct 3D line running from 'start' to 'end'. TGLLine3(const TGLVertex3& start, const TGLVector3& vector); Construct 3D line running from 'start', magnitude 'vect'. ~TGLLine3(); Destroy 3D line object. void Set(const TGLVertex3& start, const TGLVertex3& end); Set 3D line running from 'start' to 'end'. void Set(const TGLVertex3& start, const TGLVector3& vector); Set 3D line running from start, magnitude 'vect'. void Draw() const; Draw line in current basic GL color. Assume we are in the correct reference; frame. TGLLine3(const TGLVertex3& start, const TGLVertex3& end). const TGLVertex3 & Start() const; Bitwise copy constructor and = operator are fine; Accessors. { r",MatchSource.WIKI,root/html530/TGLLine3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLine3.html
https://root.cern/root/html530/TGLLockable.html:1560,Availability,failure,failure,1560,"l_tIsDrawOrSelectLock() const; Bool_tIsLocked() const; virtual const char*LockIdStr() const; static const char*LockName(TGLLockable::ELock lock); static Bool_tLockValid(TGLLockable::ELock lock); Bool_tReleaseLock(TGLLockable::ELock lock) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Bool_tTakeLock(TGLLockable::ELock lock) const. private:. TGLLockable(const TGLLockable&); TGLLockable&operator=(const TGLLockable&). Data Members; public:. enum ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLLockable::ELockfLockLock state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLockable(); Constructor. Bool_t TakeLock(TGLLockable::ELock lock) const; Lock the object in mode 'lock'. Return TRUE if successful, FALSE; if the object is already locked. Bool_t ReleaseLock(TGLLockable::ELock lock) const; Release current lock, make sure it the same as the 'lock' argument.; Returns TRUE on success, FALSE on failure. const char* LockName(TGLLockable::ELock lock); Return name-string for given lock-type. Bool_t LockValid(TGLLockable::ELock lock); Test if lock is a valid type to take/release.; kUnlocked is never valid in these cases. TGLLockable(const TGLLockable& ). TGLLockable& operator=(const TGLLockable& ). virtual ~TGLLockable(); {}. const char* LockIdStr() const; { return ""<unknown>""; }. Bool_t IsLocked() const; { return (fLock != kUnlocked); }. ELock CurrentLock() const; { return fLock; }. Bool_t IsDrawOrSelectLock() const; { return fLock == kDrawLock || fLock == kSelectLock; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLLockable.h 32465 2010-03-04 20:29:52Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLLockable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLockable.html
https://root.cern/root/html530/TGLLockable.html:1736,Deployability,release,release,1736,"l_tIsDrawOrSelectLock() const; Bool_tIsLocked() const; virtual const char*LockIdStr() const; static const char*LockName(TGLLockable::ELock lock); static Bool_tLockValid(TGLLockable::ELock lock); Bool_tReleaseLock(TGLLockable::ELock lock) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Bool_tTakeLock(TGLLockable::ELock lock) const. private:. TGLLockable(const TGLLockable&); TGLLockable&operator=(const TGLLockable&). Data Members; public:. enum ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLLockable::ELockfLockLock state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLockable(); Constructor. Bool_t TakeLock(TGLLockable::ELock lock) const; Lock the object in mode 'lock'. Return TRUE if successful, FALSE; if the object is already locked. Bool_t ReleaseLock(TGLLockable::ELock lock) const; Release current lock, make sure it the same as the 'lock' argument.; Returns TRUE on success, FALSE on failure. const char* LockName(TGLLockable::ELock lock); Return name-string for given lock-type. Bool_t LockValid(TGLLockable::ELock lock); Test if lock is a valid type to take/release.; kUnlocked is never valid in these cases. TGLLockable(const TGLLockable& ). TGLLockable& operator=(const TGLLockable& ). virtual ~TGLLockable(); {}. const char* LockIdStr() const; { return ""<unknown>""; }. Bool_t IsLocked() const; { return (fLock != kUnlocked); }. ELock CurrentLock() const; { return fLock; }. Bool_t IsDrawOrSelectLock() const; { return fLock == kDrawLock || fLock == kSelectLock; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLLockable.h 32465 2010-03-04 20:29:52Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLLockable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLockable.html
https://root.cern/root/html530/TGLLockable.html:306,Integrability,interface,interface,306,". TGLLockable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLockable. class TGLLockable. TGLLockable. Simple locking interface used by viewer and scene. Function Members (Methods); public:. TGLLockable(); virtual~TGLLockable(); static TClass*Class(); TGLLockable::ELockCurrentLock() const; virtual TClass*IsA() const; Bool_tIsDrawOrSelectLock() const; Bool_tIsLocked() const; virtual const char*LockIdStr() const; static const char*LockName(TGLLockable::ELock lock); static Bool_tLockValid(TGLLockable::ELock lock); Bool_tReleaseLock(TGLLockable::ELock lock) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Bool_tTakeLock(TGLLockable::ELock lock) const. private:. TGLLockable(const TGLLockable&); TGLLockable&operator=(const TGLLockable&). Data Members; public:. enum ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLLockable::ELockfLockLock state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLockable(); Constructor. Bool_t TakeLock(TGLLockable::ELock lock) const; Lock the object in mode 'lock'. Return TRUE if successful, FALSE; if the object is already locked. Bool_t ReleaseLock(TGLLockable::ELock lock) const; Release current lock, make sure it the same as the 'lock' argument.; Returns TRUE on success, FALSE on failure. const char* LockName(TGLLockable::ELock lock); Return name-string for given lock-type. Bool_t LockValid(TGLLockable::ELock lock); Test if lock is a valid type to take/release.; kUnlocked is never valid in these cases. TGLLockable(const TGLLockable& ). TGLLockable& operator=(const TGLLockable& ). virtual ~TGLLockable(); {}. const char* LockIdStr() const; { return ""<unknown>""; }. Bool_t IsLocked() const; { return (fLock != kUnlock",MatchSource.WIKI,root/html530/TGLLockable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLockable.html
https://root.cern/root/html530/TGLLogicalShape.html:2197,Availability,avail,available,2197,"al shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLLogicalShape(); voidAddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&BoundingBox() const; static TClass*Class(); voidDestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tDLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*GetExternal() const; const TGLPhysicalShape*GetFirstPhysical() const; TGLScene*GetScene() const; TObject*ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t ",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:985,Energy Efficiency,reduce,reduces,985,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:1000,Energy Efficiency,consumption,consumption,1000,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:5215,Integrability,depend,dependent,5215,"Object*fExternalObj! Also plays the role of ID.; TGLPhysicalShape*fFirstPhysical! first replica; Bool_tfOwnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Pur",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:1158,Performance,perform,performed,1158," description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Lo",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:3250,Performance,cache,cached,3250,"ption of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLLogicalShape(); voidAddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&BoundingBox() const; static TClass*Class(); voidDestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tDLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*GetExternal() const; const TGLPhysicalShape*GetFirstPhysical() const; TGLScene*GetScene() const; TObject*ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tRef() const; Bool_tSetDLCache(Bool_t cached); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidStrongRef(Bool_t strong) const; voidSubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tUnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidUpdateBoundingBoxesOfPhysicals(). protected:. voidPurgeDLRange(UInt_t base, Int_t size) const. private:. TGLLogicalShape&operator=(const TGLLogicalShape&). Data Members; public:. enum ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxfBou",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:5261,Performance,cache,cached,5261,"wnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids t",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:5312,Performance,cache,cache,5312,"wnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids t",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:5501,Performance,cache,cached,5501,"ere object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t bas",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:5892,Performance,cache,cache,5892,"RefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. ",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:6035,Performance,cache,cache,6035,"al in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() -",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:6260,Performance,cache,cache,6260,"ool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highli",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:6745,Performance,perform,perform,6745,"de this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; In",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:6944,Performance,cache,cache,6944,"eDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, ",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:7029,Performance,cache,cache,7029,"eDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, ",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:7050,Performance,cache,cached,7050,"to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalSha",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:7098,Performance,cache,cached,7098,"to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalSha",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:1050,Safety,detect,detector,1050,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:299,Testability,log,logical,299,". TGLLogicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:625,Testability,log,logical,625,". TGLLogicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:751,Testability,log,logical,751,". TGLLogicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:856,Testability,log,logicals,856,". TGLLogicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:962,Testability,log,logical,962,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:4619,Testability,log,logical,4619,"ndarySelect() const; UInt_tUnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidUpdateBoundingBoxesOfPhysicals(). protected:. voidPurgeDLRange(UInt_t base, Int_t size) const. private:. TGLLogicalShape&operator=(const TGLLogicalShape&). Data Members; public:. enum ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxfBoundingBox! Shape's bounding box.; UInt_tfDLBase! display-list id base; Bool_tfDLCache! use display list caching; Int_tfDLSize! display-list size for different LODs; UShort_tfDLValid! display-list validity bit-field; TObject*fExternalObj! Also plays the role of ID.; TGLPhysicalShape*fFirstPhysical! first replica; Bool_tfOwnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:4955,Testability,log,logical,4955," kLODAxesAll; };. protected:. TGLBoundingBoxfBoundingBox! Shape's bounding box.; UInt_tfDLBase! display-list id base; Bool_tfDLCache! use display list caching; Int_tfDLSize! display-list size for different LODs; UShort_tfDLValid! display-list validity bit-field; TObject*fExternalObj! Also plays the role of ID.; TGLPhysicalShape*fFirstPhysical! first replica; Bool_tfOwnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids ",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:7214,Testability,log,logical,7214,"Purge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* GetFirstPhysical() const; { return fFirstPhysical; }. TObject* ID() const; { return fExternalObj; }",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLLogicalShape.html:7640,Usability,simpl,simply,7640,"ly discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* GetFirstPhysical() const; { return fFirstPhysical; }. TObject* ID() const; { return fExternalObj; }. TObject* GetExternal() const; { return fExternalObj; }. TGLScene* GetScene() const; { return fScene; }. void UpdateBoundingBox(); {}. UInt_t DLOffset(Short_t ) const; { return 0; }. ELODAxes SupportedLODAxes() const; { return kLODAxesNone; }. void DirectDraw(TGLRnrCtx& rnrCtx) const. Bool_t IgnoreSizeForOfInterest() const; { return kFALSE; }. Bool_t KeepDuringSmartRefresh() const; Override in sub-classes that do direct object rendering (e.g. TGLObject).",MatchSource.WIKI,root/html530/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLLogicalShape.html
https://root.cern/root/html530/TGLManager.html:496,Availability,avail,available,496,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root/html530/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLManager.html
https://root.cern/root/html530/TGLManager.html:923,Availability,avail,available,923,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root/html530/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLManager.html
https://root.cern/root/html530/TGLManager.html:2062,Availability,error,error,2062,"t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractViewport(Int_t ctxInd, Int_t* vp); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFlush(Int_t ctxInd); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPlotInfo(TVirtualGLPainter* plot, Int_t px, Int_t py); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVirtu",MatchSource.WIKI,root/html530/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLManager.html
https://root.cern/root/html530/TGLManager.html:2146,Availability,error,error,2146," UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractViewport(Int_t ctxInd, Int_t* vp); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFlush(Int_t ctxInd); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPlotInfo(TVirtualGLPainter* plot, Int_t px, Int_t py); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVirtualXInd(Int_t ctxInd); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULo",MatchSource.WIKI,root/html530/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLManager.html
https://root.cern/root/html530/TGLManager.html:370,Integrability,interface,interface,370,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root/html530/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLManager.html
https://root.cern/root/html530/TGLManager.html:380,Integrability,protocol,protocol,380,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root/html530/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLManager.html
https://root.cern/root/html530/TGLManager.html:596,Integrability,interface,interface,596,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root/html530/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLManager.html
https://root.cern/root/html530/TGLManip.html:856,Availability,avail,available,856,". TGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManip. class TGLManip: public TVirtualGLManip. Abstract base class for viewer manipulators, which allow direct in; viewer manipulation of a (TGlPhysicalShape) object - currently; translation, scaling and rotation along/round objects local axes.; See derived classes for these implementations. This class provides binding to the zero or one manipulated physical,; hit testing (selection) for manipulator sub component (widget), and; some common mouse action handling/tracking. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManip(); voidAttach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tGetActive() const; TGLPhysicalShape*GetAttached() const; UInt_tGetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tSelect(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidSetActive(Bool_t a); voidSetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidCalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*ColorFor(UInt_t widget) const; TGLManip&operator=(const TGLManip&). Data Members; protected:. Bool_tfActive! manipulator is active?; TPointfFirstMouse! first (start) mouse position (in WINDOW coords); TPointfLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tfSelectedWidget! active width (axis) compon",MatchSource.WIKI,root/html530/TGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLManip.html
https://root.cern/root/html530/TGLManip.html:613,Testability,test,testing,613,". TGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManip. class TGLManip: public TVirtualGLManip. Abstract base class for viewer manipulators, which allow direct in; viewer manipulation of a (TGlPhysicalShape) object - currently; translation, scaling and rotation along/round objects local axes.; See derived classes for these implementations. This class provides binding to the zero or one manipulated physical,; hit testing (selection) for manipulator sub component (widget), and; some common mouse action handling/tracking. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManip(); voidAttach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tGetActive() const; TGLPhysicalShape*GetAttached() const; UInt_tGetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tSelect(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidSetActive(Bool_t a); voidSetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidCalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*ColorFor(UInt_t widget) const; TGLManip&operator=(const TGLManip&). Data Members; protected:. Bool_tfActive! manipulator is active?; TPointfFirstMouse! first (start) mouse position (in WINDOW coords); TPointfLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tfSelectedWidget! active width (axis) compon",MatchSource.WIKI,root/html530/TGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLManip.html
https://root.cern/root/html530/TGLManipSet.html:337,Availability,avail,available,337,". TGLManipSet. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManipSet. class TGLManipSet: public TGLOverlayElement, public TGLPShapeRef. Combine all available manipulators in a collection. At first I wanted to merge them back into TGLManip (to have a; single class) but then it seemed somehow messy.; Maybe next time. Function Members (Methods); public:. TGLManipSet(); virtual~TGLManipSet(); static TClass*Class(); TGLManip*GetCurrentManip() const; Bool_tGetDrawBBox() const; Int_tGetManipType() const; TGLPhysicalShape*TGLPShapeRef::GetPShape() const; TGLOverlayElement::ERoleTGLOverlayElement::GetRole() const; TGLOverlayElement::EStateTGLOverlayElement::GetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tTGLOverlayElement::MouseStillInside(TGLOvlSelectRecord& selRec); virtual voidTGLPShapeRef::PShapeModified(); virtual voidRender(TGLRnrCtx& rnrCtx); voidTGLOverlayElement::SetBinaryState(Bool_t s); voidSetDrawBBox(Bool_t bb); voidSetManipType(Int_t type); virtual voidSetPShape(TGLPhysicalShape* shape); voidTGLOverlayElement::SetRole(TGLOverlayElement::ERole r); voidTGLOverlayElement::SetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTGLOverlayElement::ProjectionMatrixPushIdentity(). private:. TGLManipSet(const TGLManipSet&); TGLManipSet&operator=(const TGLManipSet&). Data Members; public:. enum EManip { kTrans; kScale; kRotate; kEndType; };; enum TGLOverlayElement::ERole { kUser; kViewer; kAnnotation; kAll; };; enum TGLOverlayElement::EState { kInvisible; kDisabled; kActive; kAllVisible; };. protec",MatchSource.WIKI,root/html530/TGLManipSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLManipSet.html
https://root.cern/root/html530/TGLMatrix.html:552,Security,access,accessors,552,". TGLMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLMatrix. class TGLMatrix. TGLMatrix. 16 component (4x4) transform matrix - column MAJOR as per GL.; Provides limited support for adjusting the translation, scale and; rotation components. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLMatrix(); TGLMatrix(const TGLVertex3& translation); TGLMatrix(const Double_t* vals); TGLMatrix(const TGLMatrix& other); TGLMatrix(const TGLVertex3& origin, const TGLVector3& zAxis); TGLMatrix(Double_t x, Double_t y, Double_t z); TGLMatrix(const TGLVertex3& origin, const TGLVector3& zAxis, const TGLVector3& xAxis); virtual~TGLMatrix(); Double_t*Arr(); const Double_t*CArr() const; static TClass*Class(); voidDump() const; TGLVector3GetBaseVec(Int_t b) const; voidGetBaseVec(Int_t b, TGLVector3& v) const; voidGetBaseVec(Int_t b, Double_t* x) const; TGLVector3GetScale() const; TGLVector3GetTranslation() const; Double_tInvert(); virtual TClass*IsA() const; voidMove3LF(Double_t x, Double_t y, Double_t z); voidMoveLF(Int_t ai, Double_t amount); TGLVector3Multiply(const TGLVector3& v, Double_t w = 1) const; voidMultiplyIP(TGLVector3& v, Double_t w = 1) const; voidMultLeft(const TGLMatrix& lhs); voidMultRight(const TGLMatrix& rhs); TGLMatrix&operator*=(const TGLMatrix& rhs); TGLMatrix&operator=(const TGLMatrix& rhs); Double_t&operator[](Int_t index); Double_toperator[](Int_t index) const; TGLVector3Rotate(const TGLVector3& v) const; voidRotate(const TGLVertex3& pivot, const TG",MatchSource.WIKI,root/html530/TGLMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLMatrix.html
https://root.cern/root/html530/TGLMatrix.html:464,Usability,simpl,simple,464,". TGLMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLMatrix. class TGLMatrix. TGLMatrix. 16 component (4x4) transform matrix - column MAJOR as per GL.; Provides limited support for adjusting the translation, scale and; rotation components. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLMatrix(); TGLMatrix(const TGLVertex3& translation); TGLMatrix(const Double_t* vals); TGLMatrix(const TGLMatrix& other); TGLMatrix(const TGLVertex3& origin, const TGLVector3& zAxis); TGLMatrix(Double_t x, Double_t y, Double_t z); TGLMatrix(const TGLVertex3& origin, const TGLVector3& zAxis, const TGLVector3& xAxis); virtual~TGLMatrix(); Double_t*Arr(); const Double_t*CArr() const; static TClass*Class(); voidDump() const; TGLVector3GetBaseVec(Int_t b) const; voidGetBaseVec(Int_t b, TGLVector3& v) const; voidGetBaseVec(Int_t b, Double_t* x) const; TGLVector3GetScale() const; TGLVector3GetTranslation() const; Double_tInvert(); virtual TClass*IsA() const; voidMove3LF(Double_t x, Double_t y, Double_t z); voidMoveLF(Int_t ai, Double_t amount); TGLVector3Multiply(const TGLVector3& v, Double_t w = 1) const; voidMultiplyIP(TGLVector3& v, Double_t w = 1) const; voidMultLeft(const TGLMatrix& lhs); voidMultRight(const TGLMatrix& rhs); TGLMatrix&operator*=(const TGLMatrix& rhs); TGLMatrix&operator=(const TGLMatrix& rhs); Double_t&operator[](Int_t index); Double_toperator[](Int_t index) const; TGLVector3Rotate(const TGLVector3& v) const; voidRotate(const TGLVertex3& pivot, const TG",MatchSource.WIKI,root/html530/TGLMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLMatrix.html
https://root.cern/root/html530/TGlobal.html:1563,Availability,error,error,1563," TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html530/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGlobal.html
https://root.cern/root/html530/TGlobal.html:1647,Availability,error,error,1647,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_tGetArrayDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; Int_tGetMaxIndex(Int_t dim) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::",MatchSource.WIKI,root/html530/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGlobal.html
https://root.cern/root/html530/TGlobal.html:293,Modifiability,variab,variables,293,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html530/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGlobal.html
https://root.cern/root/html530/TGlobal.html:317,Modifiability,variab,variables,317,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html530/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGlobal.html
https://root.cern/root/html530/TGlobal.html:401,Modifiability,variab,variable,401,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html530/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGlobal.html
https://root.cern/root/html530/TGlobal.html:477,Modifiability,variab,variables,477,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html530/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGlobal.html
https://root.cern/root/html530/TGlobal.html:6652,Modifiability,variab,variable,6652,"_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. DataMemberInfo_t*fInfopointer to CINT data member info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGlobal(DataMemberInfo_t* info = 0); Default TGlobal ctor. TGlobals are constructed in TROOT via; a call to TCint::UpdateListOfGlobals(). TGlobal(const TGlobal& ); Copy constructor. TGlobal & operator=(const TGlobal& ); Assignment operator. ~TGlobal(); TGlobal dtor deletes adopted CINT DataMemberInfo object. void * GetAddress() const; Return address of global. Int_t GetArrayDim() const; Return number of array dimensions. Int_t GetMaxIndex(Int_t dim) const; Return maximum index for array dimension ""dim"". const char * GetTypeName() const; Get type of global variable, e,g.: ""class TDirectory*"" -> ""TDirectory"".; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of global variable, e,g.: ""class TDirectory*"". Long_t Property() const; Get property description word. For meaning of bits see EProperty. » Author: Rene Brun 13/11/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TGlobal.h 26606 2008-12-02 20:36:09Z pcanal $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGlobal.html
https://root.cern/root/html530/TGlobal.html:6827,Modifiability,variab,variable,6827,"_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. DataMemberInfo_t*fInfopointer to CINT data member info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGlobal(DataMemberInfo_t* info = 0); Default TGlobal ctor. TGlobals are constructed in TROOT via; a call to TCint::UpdateListOfGlobals(). TGlobal(const TGlobal& ); Copy constructor. TGlobal & operator=(const TGlobal& ); Assignment operator. ~TGlobal(); TGlobal dtor deletes adopted CINT DataMemberInfo object. void * GetAddress() const; Return address of global. Int_t GetArrayDim() const; Return number of array dimensions. Int_t GetMaxIndex(Int_t dim) const; Return maximum index for array dimension ""dim"". const char * GetTypeName() const; Get type of global variable, e,g.: ""class TDirectory*"" -> ""TDirectory"".; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of global variable, e,g.: ""class TDirectory*"". Long_t Property() const; Get property description word. For meaning of bits see EProperty. » Author: Rene Brun 13/11/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TGlobal.h 26606 2008-12-02 20:36:09Z pcanal $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGlobal.html
https://root.cern/root/html530/TGlobal.html:488,Security,access,accessible,488,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html530/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGlobal.html
https://root.cern/root/html530/TGLObject.html:857,Availability,avail,available,857,". TGLObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLObject. class TGLObject: public TGLLogicalShape. Base-class for direct OpenGL renderers.; This allows classes to circumvent passing of TBuffer3D and; use user-provided OpenGL code.; By convention, if you want class TFoo : public TObject to have direct rendering; you should also provide TFooGL : public TGLObject and implement; abstract functions SetModel() and SetBBox().; TAttBBox can be used to facilitate calculation of bounding-boxes.; See TPointSet3D and TPointSet3DGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLObject(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; v",MatchSource.WIKI,root/html530/TGLObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLObject.html
https://root.cern/root/html530/TGLObject.html:2326,Performance,cache,cached,2326,"hape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html530/TGLObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLObject.html
https://root.cern/root/html530/TGLOrthoCamera.html:545,Availability,down,down,545,". TGLOrthoCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOrthoCamera. class TGLOrthoCamera: public TGLCamera. TGLOrthoCamera. Orthographic projection camera. Currently limited to three types; defined at construction time - kXOY, kXOZ, kZOY - where this refers; to the viewport plane axis - e.g. kXOY has X axis horizontal, Y; vertical - i.e. looking down Z axis with Y vertical. The plane types restriction could easily be removed to supported; arbitary ortho projections along any axis/orientation with free; rotations about them. Function Members (Methods); public:. TGLOrthoCamera(TGLOrthoCamera::EType type, const TGLVector3& hAxis, const TGLVector3& vAxis); virtual~TGLOrthoCamera(); Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidTGLCamera::DrawDebugAids() const; TGLVector3TGLCamera::EyeDirection() const; TGLVertex3TGLCamera::EyePoint() const; TGLVertex3TGLCamera::FrustumCenter() const; EOverlapTGLCamera::FrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&TGLCamera::FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&TGLCamera::GetCamBase() const; const TGLMatrix&TGLCamera::GetCamTrans() const; Double_t*TGLCamera::GetCenterVec(); Bool_tGetDollyToZoom() const; Bool_tGetEnableRotate() const; Bool_tTGLCamera::GetExternalCenter(); Double_tTGLCamera::GetFarClip() const;",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOrthoCamera.html:10340,Availability,down,down,10340,"otate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same; as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; zoom - set directly (default = 0.78);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsOrthographic() const; { return kTRUE; }. void SetEnableRotate(Bool_t x); { fEnableRotate = x; }. Bool_t GetEnableRotate() const; { return fEnableRotate; }. Double_t GetZoomMin() const; { return fZoomMin; }. Double_t GetZoomMax() const; { return fZoomMax; }. void SetZoomMinMax(Double_t min, Double_t max); { SetZoomMin(min); SetZoomMax(max); }. void SetDollyToZoom(Bool_t x); { fDollyToZoom = x; }. Bool_t GetDollyToZoom() const; { return fDollyToZoom; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLOrthoCamera.h 28212 2009-04-15 11:05:29Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOrthoCamera.html:9710,Deployability,update,updates,9710,"ens 'focal length'. Returns kTRUE is redraw required (camera change), kFALSE otherwise. void SetZoomMin(Double_t z); Set minimum zoom factor. If current zoom is less than z it is; set to z. void SetZoomMax(Double_t z); Set maximum zoom factor. If current zoom is greater than z it; is set to z. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same; as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; zoom - set directly (default = 0.78);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsOrthographic() const; { return kTRUE; }. void SetEnableRotate(Bool_t x); { fEnableRotate = x; }. Bool_t GetEnableRotate() const; { return fEnableRotate; }. Double_t GetZoomMin() const; { return fZoomMin; }. Double_t GetZoomMax() const; { return fZoomMax; }. void SetZoomMinMax(Double_t min, Double_t max); { SetZoomMin(min); SetZo",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOrthoCamera.html:5517,Performance,cache,cached,5517,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOrthoCamera.html:5803,Performance,cache,cached,5803,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOrthoCamera.html:6390,Performance,cache,cached,6390,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOrthoCamera.html:6639,Performance,cache,cached,6639,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOrthoCamera.html:6694,Performance,cache,cached,6694,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOrthoCamera.html:6804,Performance,cache,cached,6804,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOrthoCamera.html:9722,Performance,cache,cached,9722,"ens 'focal length'. Returns kTRUE is redraw required (camera change), kFALSE otherwise. void SetZoomMin(Double_t z); Set minimum zoom factor. If current zoom is less than z it is; set to z. void SetZoomMax(Double_t z); Set maximum zoom factor. If current zoom is greater than z it; is set to z. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same; as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; zoom - set directly (default = 0.78);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsOrthographic() const; { return kTRUE; }. void SetEnableRotate(Bool_t x); { fEnableRotate = x; }. Bool_t GetEnableRotate() const; { return fEnableRotate; }. Double_t GetZoomMin() const; { return fZoomMin; }. Double_t GetZoomMax() const; { return fZoomMax; }. void SetZoomMinMax(Double_t min, Double_t max); { SetZoomMin(min); SetZo",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOrthoCamera.html:8646,Testability,log,logically,8646,"hAxis, const TGLVector3& vAxis); Construct orthographic camera. ~TGLOrthoCamera(); Destroy orthographic camera. void Setup(const TGLBoundingBox& box, Bool_t reset = kTRUE); Setup camera limits suitible to view the world volume defined by 'box'; and call Reset() to initialise camera. void Reset(); Reset the camera to defaults - trucking, zooming to reframe the world volume; established in Setup(). Note: limits defined in Setup() are not adjusted. Bool_t Dolly(Int_t delta, Bool_t mod1, Bool_t mod2); Dolly the camera.; By default the dolly is reinterpreted to zoom, but it can be; changed by modifying the fDollyToZoom data-member. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). For an orthographic camera dollying and zooming are identical and both equate; logically to a rescaling of the viewport limits - without center shift.; There is no perspective foreshortening or lens 'focal length'. Returns kTRUE is redraw required (camera change), kFALSE otherwise. void SetZoomMin(Double_t z); Set minimum zoom factor. If current zoom is less than z it is; set to z. void SetZoomMax(Double_t z); Set maximum zoom factor. If current zoom is greater than z it; is set to z. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this v",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOrthoCamera.html:9783,Testability,test,tests,9783,"ens 'focal length'. Returns kTRUE is redraw required (camera change), kFALSE otherwise. void SetZoomMin(Double_t z); Set minimum zoom factor. If current zoom is less than z it is; set to z. void SetZoomMax(Double_t z); Set maximum zoom factor. If current zoom is greater than z it; is set to z. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same; as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; zoom - set directly (default = 0.78);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsOrthographic() const; { return kTRUE; }. void SetEnableRotate(Bool_t x); { fEnableRotate = x; }. Bool_t GetEnableRotate() const; { return fEnableRotate; }. Double_t GetZoomMin() const; { return fZoomMin; }. Double_t GetZoomMax() const; { return fZoomMax; }. void SetZoomMinMax(Double_t min, Double_t max); { SetZoomMin(min); SetZo",MatchSource.WIKI,root/html530/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOrthoCamera.html
https://root.cern/root/html530/TGLOutput.html:321,Integrability,rout,routines,321,". TGLOutput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOutput. class TGLOutput. TGLOutput. Wrapper class for GL capture & output routines. Function Members (Methods); public:. TGLOutput(); TGLOutput(const TGLOutput&); virtual~TGLOutput(); static voidCapture(TGLViewer& viewer); static Bool_tCapture(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath = 0); static TClass*Class(); static voidCloseEmbeddedPS(); virtual TClass*IsA() const; TGLOutput&operator=(const TGLOutput&); virtual voidShowMembers(TMemberInspector& insp); static voidStartEmbeddedPS(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tCapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath). Data Members; public:. enum EFormat { kEPS_SIMPLE; kEPS_BSP; kPDF_SIMPLE; kPDF_BSP; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Capture(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath = 0); Capture viewer to file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format - only postscript types presently.; One of kEPS_SIMPLE, kEPS_BSP, kPDF_SIMPLE or kPDF_BSP; See TGLOutput::CapturePostscript() for meanings; 'filePath' - file output name. If null defaults to './viewer.eps' or './viewer.pdf'; depending on format requested. Note : Output files can be large and take considerable time (up to mins); to generate. Bool_t CapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath); Capture viewer to postscript file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format; kEPS_SIMPLE - lower quality EPS; kEPS_BSP - higher quality EPS; kPDF_SIMPLE - lower quality PDF; kPDF_BSP - higher quality PDF; 'f",MatchSource.WIKI,root/html530/TGLOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOutput.html
https://root.cern/root/html530/TGLOutput.html:1540,Integrability,depend,depending,1540,"ePath = 0); static TClass*Class(); static voidCloseEmbeddedPS(); virtual TClass*IsA() const; TGLOutput&operator=(const TGLOutput&); virtual voidShowMembers(TMemberInspector& insp); static voidStartEmbeddedPS(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tCapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath). Data Members; public:. enum EFormat { kEPS_SIMPLE; kEPS_BSP; kPDF_SIMPLE; kPDF_BSP; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Capture(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath = 0); Capture viewer to file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format - only postscript types presently.; One of kEPS_SIMPLE, kEPS_BSP, kPDF_SIMPLE or kPDF_BSP; See TGLOutput::CapturePostscript() for meanings; 'filePath' - file output name. If null defaults to './viewer.eps' or './viewer.pdf'; depending on format requested. Note : Output files can be large and take considerable time (up to mins); to generate. Bool_t CapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath); Capture viewer to postscript file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format; kEPS_SIMPLE - lower quality EPS; kEPS_BSP - higher quality EPS; kPDF_SIMPLE - lower quality PDF; kPDF_BSP - higher quality PDF; 'filePath' - file output name. If null defaults to './viewer.eps' or './viewer.pdf'; depending on format requested. void StartEmbeddedPS(); this function used by gl-in-pad. void CloseEmbeddedPS(); this function used by gl-in-pad; Restore the gVirtualPS output stream. void Capture(TGLViewer& viewer); this function used by gl-viewer, embedded into pad. virtual ~TGLOutput(); { }. » Author: Richard Maunder, Olivier Couet 02/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLOutput.h 20882 2007-11-19 11",MatchSource.WIKI,root/html530/TGLOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOutput.html
https://root.cern/root/html530/TGLOutput.html:2084,Integrability,depend,depending,2084,"PS(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tCapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath). Data Members; public:. enum EFormat { kEPS_SIMPLE; kEPS_BSP; kPDF_SIMPLE; kPDF_BSP; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Capture(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath = 0); Capture viewer to file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format - only postscript types presently.; One of kEPS_SIMPLE, kEPS_BSP, kPDF_SIMPLE or kPDF_BSP; See TGLOutput::CapturePostscript() for meanings; 'filePath' - file output name. If null defaults to './viewer.eps' or './viewer.pdf'; depending on format requested. Note : Output files can be large and take considerable time (up to mins); to generate. Bool_t CapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath); Capture viewer to postscript file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format; kEPS_SIMPLE - lower quality EPS; kEPS_BSP - higher quality EPS; kPDF_SIMPLE - lower quality PDF; kPDF_BSP - higher quality PDF; 'filePath' - file output name. If null defaults to './viewer.eps' or './viewer.pdf'; depending on format requested. void StartEmbeddedPS(); this function used by gl-in-pad. void CloseEmbeddedPS(); this function used by gl-in-pad; Restore the gVirtualPS output stream. void Capture(TGLViewer& viewer); this function used by gl-viewer, embedded into pad. virtual ~TGLOutput(); { }. » Author: Richard Maunder, Olivier Couet 02/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLOutput.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOutput.html
https://root.cern/root/html530/TGLOverlayElement.html:496,Availability,avail,available,496,". TGLOverlayElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOverlayElement. class TGLOverlayElement. An overlay element. Supports drawing (Render) and event-handling. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLOverlayElement(); static TClass*Class(); TGLOverlayElement::ERoleGetRole() const; TGLOverlayElement::EStateGetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tMouseStillInside(TGLOvlSelectRecord& selRec); virtual voidRender(TGLRnrCtx& rnrCtx); voidSetBinaryState(Bool_t s); voidSetRole(TGLOverlayElement::ERole r); voidSetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidProjectionMatrixPushIdentity(). private:. TGLOverlayElement&operator=(const TGLOverlayElement&). Data Members; public:. enum ERole { kUser; kViewer; kAnnotation; kAll; };; enum EState { kInvisible; kDisabled; kActive; kAllVisible; };. protected:. TGLOverlayElement::ERolefRole; TGLOverlayElement::EStatefState. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t MouseEnter(TGLOvlSelectRecord& selRec); Mouse has enetered this element.; Return TRUE if you want additional events. Bool_t MouseStillInside(TGLOvlSelectRecord& selRec); A new overlay hit is about to be processed.; By returning FALSE one can force mouse-leave (MouseLeave will be; called shortly).; If you return TRUE, Handle will be called soon.; Use this if your overlay object has som",MatchSource.WIKI,root/html530/TGLOverlayElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLOverlayElement.html
https://root.cern/root/html530/TGLPadPainter.html:501,Modifiability,inherit,inherit,501,". TGLPadPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPadPainter. class TGLPadPainter: public TVirtualPadPainter. ""Delegating"" part of TGLPadPainter. Line/fill/etc. attributes can be; set inside TPad, but not only there:; many of them are set by base sub-objects of 2d primitives; (2d primitives usually inherit TAttLine or TAttFill etc.). And these sub-objects; call gVirtualX->SetLineWidth ... etc. So, if I save some attributes in my painter,; it will be mess - at any moment I do not know, where to take line attribute - from; gVirtualX or from my own member. So! All attributed, _ALL_ go to/from gVirtualX. Function Members (Methods); public:. TGLPadPainter(); ~TGLPadPainter(); static TClass*Class(); virtual voidClearDrawable(); virtual voidCopyDrawable(Int_t id, Int_t px, Int_t py); virtual Int_tCreateDrawable(UInt_t w, UInt_t h); virtual voidDestroyDrawable(); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); virtual voidDrawFillArea(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawFillArea(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidDrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); virtual voidDrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); virtual voidDrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t x, Double_t y, const char* t",MatchSource.WIKI,root/html530/TGLPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPadPainter.html
https://root.cern/root/html530/TGLPadPainter.html:6173,Testability,test,test,6173,"tTextSize() const; Delegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Not required at the moment. void ClearDrawable(); Not required at the moment. void CopyDrawable(Int_t id, Int_t px, Int_t py); Not required at the moment. void DestroyDrawable(); Not required at the moment. void SelectDrawable(Int_t device); For gVirtualX this means select pixmap (or window); and all subsequent drawings will go into; this pixmap. For OpenGL this means the change of; coordinate system and viewport. void InitPainter(); Init gl-pad painter:; 1. 2D painter does not use depth test, should not modify; depth-buffer content (except initial cleanup).; 2. Disable cull face.; 3. Disable lighting.; 4. Set viewport (to the whole canvas area).; 5. Set camera.; 6. Unlock painter. void InvalidateCS(); When TPad::Range for gPad is called, projection; must be changed in OpenGL. void LockPainter(); Locked state of painter means, that; GL context can be invalid, so no GL calls; can be executed. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw line segment. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw line segment in NDC coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Draw filled or hollow box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Draw tesselated polygon (probably, outline only). void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Draw tesselated polygon (never called, probably, since TPad::PaintFillArea for floats; is deprecated). voi",MatchSource.WIKI,root/html530/TGLPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPadPainter.html
https://root.cern/root/html530/TGLPadPainter.html:7830,Testability,assert,assert,7830," x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Draw filled or hollow box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Draw tesselated polygon (probably, outline only). void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Draw tesselated polygon (never called, probably, since TPad::PaintFillArea for floats; is deprecated). void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Draw poly-line in user coordinates. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Never called?. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Poly line in NDC. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Poly-marker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Poly-marker. void DrawPolyMarker(); Poly-marker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Draw text. This operation is especially; dangerous if in locked state -; ftgl will assert on zero texture size; (which is result of bad GL context). void DrawTextNDC(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Draw text in NDC. This operation is especially; dangerous if in locked state -; ftgl will assert on zero texture size; (which is result of bad GL context). void SaveProjectionMatrix() const; Save the projection matrix.; Attention! GL_PROJECTION will become the current matrix; after this call!. void RestoreProjectionMatrix() const; Restore the projection matrix.; Attention! GL_PROJECTION will become the current matrix; after this call!. void SaveModelviewMatrix() const; Save the modelview matrix.; Attention! GL_MODELVIEW will become the current matrix; after this call!. void RestoreModelviewMatrix() const; Restore the modelview matrix.; Attention! GL_MODELVIEW will become the current matrix; after this call!. void SaveViewport(); Extract and save the current viewport. void RestoreViewport(); Restore the saved viewport. void",MatchSource.WIKI,root/html530/TGLPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPadPainter.html
https://root.cern/root/html530/TGLPadPainter.html:8082,Testability,assert,assert,8082,"t_t* y); Draw tesselated polygon (never called, probably, since TPad::PaintFillArea for floats; is deprecated). void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Draw poly-line in user coordinates. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Never called?. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Poly line in NDC. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Poly-marker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Poly-marker. void DrawPolyMarker(); Poly-marker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Draw text. This operation is especially; dangerous if in locked state -; ftgl will assert on zero texture size; (which is result of bad GL context). void DrawTextNDC(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Draw text in NDC. This operation is especially; dangerous if in locked state -; ftgl will assert on zero texture size; (which is result of bad GL context). void SaveProjectionMatrix() const; Save the projection matrix.; Attention! GL_PROJECTION will become the current matrix; after this call!. void RestoreProjectionMatrix() const; Restore the projection matrix.; Attention! GL_PROJECTION will become the current matrix; after this call!. void SaveModelviewMatrix() const; Save the modelview matrix.; Attention! GL_MODELVIEW will become the current matrix; after this call!. void RestoreModelviewMatrix() const; Restore the modelview matrix.; Attention! GL_MODELVIEW will become the current matrix; after this call!. void SaveViewport(); Extract and save the current viewport. void RestoreViewport(); Restore the saved viewport. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Using TImage save frame-buffer contents as a picture. TGLPadPainter(). » Author: Timur Pocheptsov 06/05/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last chang",MatchSource.WIKI,root/html530/TGLPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPadPainter.html
https://root.cern/root/html530/TGLPaintDevice.html:493,Availability,avail,available,493,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyrig",MatchSource.WIKI,root/html530/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPaintDevice.html
https://root.cern/root/html530/TGLPaintDevice.html:920,Availability,avail,available,920,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyrig",MatchSource.WIKI,root/html530/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPaintDevice.html
https://root.cern/root/html530/TGLPaintDevice.html:367,Integrability,interface,interface,367,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyrig",MatchSource.WIKI,root/html530/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPaintDevice.html
https://root.cern/root/html530/TGLPaintDevice.html:377,Integrability,protocol,protocol,377,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyrig",MatchSource.WIKI,root/html530/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPaintDevice.html
https://root.cern/root/html530/TGLPaintDevice.html:593,Integrability,interface,interface,593,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyrig",MatchSource.WIKI,root/html530/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPaintDevice.html
https://root.cern/root/html530/TGLParametricEquation.html:2424,Availability,error,error,2424,"LParametricEquation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEvalVertex(TGLVertex3& newVertex, Double_t u, Double_t v) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Rgl::Range_tGetURange() const; Rgl::Range_tGetVRange() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, c",MatchSource.WIKI,root/html530/TGLParametricEquation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLParametricEquation.html
https://root.cern/root/html530/TGLParametricEquation.html:2508,Availability,error,error,2508,"l voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEvalVertex(TGLVertex3& newVertex, Double_t u, Double_t v) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Rgl::Range_tGetURange() const; Rgl::Range_tGetVRange() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname)",MatchSource.WIKI,root/html530/TGLParametricEquation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLParametricEquation.html
https://root.cern/root/html530/TGLParametricEquation.html:7399,Availability,error,errors,7399,"const TGLParametricEquation&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_tfConstrained; ParametricEquation_tfEquation; Bool_tfModified; auto_ptr<TGLHistPainter>fPainter; pair<double,double>fURange; pair<double,double>fVRange; auto_ptr<TF2>fXEquation; auto_ptr<TF2>fYEquation; auto_ptr<TF2>fZEquation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLParametricEquation(const TString& name, const TString& xEquation, const TString& yEquation, const TString& zEquation, Double_t uMin, Double_t uMax, Double_t vMin, Double_t vMax); Surface is defined by three strings.; ROOT does not use exceptions in ctors,; so, I have to use MakeZombie to let; external user know about errors. TGLParametricEquation(const TString& name, ParametricEquation_t equation, Double_t uMin, Double_t uMax, Double_t vMin, Double_t vMax); Surface defined by user's function (see ParametricEquation_t declaration in TGLParametricEquation.h). Rgl::Range_t GetURange() const; [uMin, uMax]. Rgl::Range_t GetVRange() const; [vMin, vMax]. Bool_t IsConstrained() const; Check is constrained. void SetConstrained(Bool_t c); Set constrained. Bool_t IsModified() const; Something was changed in parametric equation (or constrained option was changed). void SetModified(Bool_t m); Set modified. void EvalVertex(TGLVertex3& newVertex, Double_t u, Double_t v) const; Calculate vertex. Int_t DistancetoPrimitive(Int_t px, Int_t py); Check, if parametric surface is under cursor. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Pass event to painter. char * GetObjectInfo(Int_t px, Int_t py) const; No object info yet. void Paint(Option_t* option); Delegate p",MatchSource.WIKI,root/html530/TGLParametricEquation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLParametricEquation.html
https://root.cern/root/html530/TGLParametricEquationGL.html:344,Integrability,wrap,wrapper,344,". TGLParametricEquationGL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLParametricEquationGL. class TGLParametricEquationGL: public TGLPlot3D. GL-renderer wrapper for TGLParametricEquation.; This allows rendering of parametric-equations in standard GL viewer. Function Members (Methods); public:. TGLParametricEquationGL(); virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx",MatchSource.WIKI,root/html530/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLParametricEquationGL.html
https://root.cern/root/html530/TGLParametricEquationGL.html:2218,Performance,cache,cached,2218,"obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html530/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLParametricEquationGL.html
https://root.cern/root/html530/TGLParametricEquationGL.html:980,Testability,log,logx,980," TGLParametricEquationGL(); virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx",MatchSource.WIKI,root/html530/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLParametricEquationGL.html
https://root.cern/root/html530/TGLParametricEquationGL.html:993,Testability,log,logy,993," TGLParametricEquationGL(); virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx",MatchSource.WIKI,root/html530/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLParametricEquationGL.html
https://root.cern/root/html530/TGLParametricEquationGL.html:1006,Testability,log,logz,1006," TGLParametricEquationGL(); virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx",MatchSource.WIKI,root/html530/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLParametricEquationGL.html
https://root.cern/root/html530/TGLParametricPlot.html:5282,Usability,simpl,simple,5282,"TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. Int_tfColorScheme; TGLParametricEquation*fEquation; TGL2DArray<TGLParametricPlot::Vertex_t>fMesh; Int_tfMeshSize; Bool_tfShowMesh. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera); Constructor. Bool_t InitGeometry(); Build mesh. The surface is 'immutable':; the only reason to rebuild it - the change in size or; if one of equations contain reference to TF2 function, whose; parameters were changed. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. char * GetPlotInfo(Int_t px, Int_t py); No object info yet. void AddOption(const TString& option); No additional options for parametric surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color/mesh size or switch on/off mesh/box cut.; Left double click - remove box cut. void InitGL() const; Initialize gl state. void DeInitGL() const; Initialize gl state. void DrawPlot() const; Draw parametric surface. void InitColors(); Calculate colors for vertices,; using one of 20 color themes.; -1 simple 'metal' surface. void DrawSectionXOZ() const; No such sections. void DrawSectionYOZ() const; No such sections. void DrawSectionXOY() const; No such sections. void SetSurfaceColor() const; Set material properties. TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera). » Author: Timur Pocheptsov 26/01/2007 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLParametric.h 28464 2009-05-06 12:37:21Z brun $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLParametricPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLParametricPlot.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:8841,Availability,down,down,8841,"Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPerspectiveCamera.h 31821 2009-12-10 18:22:44Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:667,Deployability,integrat,integrate,667,". TGLPerspectiveCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPerspectiveCamera. class TGLPerspectiveCamera: public TGLCamera. TGLPerspectiveCamera. Perspective projection camera - with characteristic foreshortening. TODO: Currently constrains YOZ plane to be floor - this is never; 'tipped'. While useful we really need to extend so can:; i) Pick any one of the three natural planes of the world to be floor.; ii) Can use a free arcball style camera with no contraint - integrate; TArcBall. Function Members (Methods); public:. TGLPerspectiveCamera(const TGLVector3& hAxis, const TGLVector3& vAxis); virtual~TGLPerspectiveCamera(); Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tTGLCamera::Dolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidTGLCamera::DrawDebugAids() const; TGLVector3TGLCamera::EyeDirection() const; TGLVertex3TGLCamera::EyePoint() const; TGLVertex3TGLCamera::FrustumCenter() const; EOverlapTGLCamera::FrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&TGLCamera::FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&TGLCamera::GetCamBase() const; const TGLMatrix&TGLCamera::GetCamTrans() const; Double_t*TGLCamera::GetCenterVec(); Bool_tTGLCamera::GetExternalCenter(); Double_tTGLCamera::GetFarClip() const; Double_t*TGLCamera::GetFixDefCenterVec(); Double_tGetFOV() const; Double_tTGLCamera::GetNearClip() const; Doub",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:8229,Deployability,update,updates,8229,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPerspectiveCamera.h 31821 2009-12-10 18:22:44Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated.",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:667,Integrability,integrat,integrate,667,". TGLPerspectiveCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPerspectiveCamera. class TGLPerspectiveCamera: public TGLCamera. TGLPerspectiveCamera. Perspective projection camera - with characteristic foreshortening. TODO: Currently constrains YOZ plane to be floor - this is never; 'tipped'. While useful we really need to extend so can:; i) Pick any one of the three natural planes of the world to be floor.; ii) Can use a free arcball style camera with no contraint - integrate; TArcBall. Function Members (Methods); public:. TGLPerspectiveCamera(const TGLVector3& hAxis, const TGLVector3& vAxis); virtual~TGLPerspectiveCamera(); Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tTGLCamera::Dolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidTGLCamera::DrawDebugAids() const; TGLVector3TGLCamera::EyeDirection() const; TGLVertex3TGLCamera::EyePoint() const; TGLVertex3TGLCamera::FrustumCenter() const; EOverlapTGLCamera::FrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&TGLCamera::FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&TGLCamera::GetCamBase() const; const TGLMatrix&TGLCamera::GetCamTrans() const; Double_t*TGLCamera::GetCenterVec(); Bool_tTGLCamera::GetExternalCenter(); Double_tTGLCamera::GetFarClip() const; Double_t*TGLCamera::GetFixDefCenterVec(); Double_tGetFOV() const; Double_tTGLCamera::GetNearClip() const; Doub",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:520,Modifiability,extend,extend,520,". TGLPerspectiveCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPerspectiveCamera. class TGLPerspectiveCamera: public TGLCamera. TGLPerspectiveCamera. Perspective projection camera - with characteristic foreshortening. TODO: Currently constrains YOZ plane to be floor - this is never; 'tipped'. While useful we really need to extend so can:; i) Pick any one of the three natural planes of the world to be floor.; ii) Can use a free arcball style camera with no contraint - integrate; TArcBall. Function Members (Methods); public:. TGLPerspectiveCamera(const TGLVector3& hAxis, const TGLVector3& vAxis); virtual~TGLPerspectiveCamera(); Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tTGLCamera::Dolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidTGLCamera::DrawDebugAids() const; TGLVector3TGLCamera::EyeDirection() const; TGLVertex3TGLCamera::EyePoint() const; TGLVertex3TGLCamera::FrustumCenter() const; EOverlapTGLCamera::FrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&TGLCamera::FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&TGLCamera::GetCamBase() const; const TGLMatrix&TGLCamera::GetCamTrans() const; Double_t*TGLCamera::GetCenterVec(); Bool_tTGLCamera::GetExternalCenter(); Double_tTGLCamera::GetFarClip() const; Double_t*TGLCamera::GetFixDefCenterVec(); Double_tGetFOV() const; Double_tTGLCamera::GetNearClip() const; Doub",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:5165,Performance,cache,cached,5165," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:5451,Performance,cache,cached,5451," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:6038,Performance,cache,cached,6038," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:6287,Performance,cache,cached,6287," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:6342,Performance,cache,cached,6342," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:6452,Performance,cache,cached,6452," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:8241,Performance,cache,cached,8241,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPerspectiveCamera.h 31821 2009-12-10 18:22:44Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated.",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPerspectiveCamera.html:8302,Testability,test,tests,8302,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPerspectiveCamera.h 31821 2009-12-10 18:22:44Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated.",MatchSource.WIKI,root/html530/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html
https://root.cern/root/html530/TGLPhysicalShape.html:937,Performance,perform,perform,937,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; ",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:6605,Performance,cache,cache,6605,"ding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index and transparency [0,100]. void SetDiffuseColor(const UChar_t rgba[4]); Set color from RGBA quadruplet. void SetDiffuseColor(Color_t ci, UChar_t transparency); Set color from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to 100 (kLODHigh - highest quality). Scene flags are not used. LOD quantization is not done. RnrCtx; is not modified as this is called via lodification stage of; rendering. void QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; Factor in scene/vierer LOD and Quantize ... forward to; logical shape. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Request creation of context menu on shape, attached to 'menu' at screen position; 'x' 'y'. TGLVector3 GetScale() const. TGLVertex3 GetTranslation() const. void SetTransform(const TGLMatrix& transform). void",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:6444,Safety,avoid,avoid,6444,"cal so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index and transparency [0,100]. void SetDiffuseColor(const UChar_t rgba[4]); Set color from RGBA quadruplet. void SetDiffuseColor(Color_t ci, UChar_t transparency); Set color from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to 100 (kLODHigh - highest quality). Scene flags are not used. LOD quantization is not done. RnrCtx; is not modified as this is called via lodification stage of; rendering. void QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; Factor in scene/vierer LOD and Quantize ... forward to; logical shape. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Request creation of context menu on shape, attached to 'menu' at screen positio",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:657,Testability,log,logical,657,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; ",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:892,Testability,log,logical,892,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; ",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:980,Testability,log,logical,980,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; ",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:1404,Testability,log,logicalShape,1404,"t. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; const TGLPhysicalShape*GetNextPhysical() const; TGLVector3GetScale() const; UChar_tGetSelected() const; TGLVertex3GetTranslation() const; UInt_tID() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tIsInvisible() const; Bool_tIsModified() const; Bool_tIsSelected() const; Bool_tIsTransparent() const; voidModified(); virtual voidQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidRemoveReference(TGLPShapeRef* ref); voidRotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle); voidScale(const TGLVector3& scale); voidSelect(UChar_t select); voidSetColor(const Float_t* rgba); voidSetColorOnFamily(const Float_t* rgba); voidSetDiffuseColor(const Float_t* rgba); voidSetDiffuseColor(const UChar_t* rgba); voidSetDiffuseColor(Color_t ci, UChar_t transparency); voidSetManip(TGLPhysicalShape::EManip manip); voidSetTransform(const TGLMatrix& transform); voidSetTransform(const Double_t* vals); voidSetTranslation(const TGLVertex3& translation); voidSetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTranslate(const TGLVector3& vect). private:. TGLPhysicalShape(const TGLPh",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:1540,Testability,log,logicalShape,1540,"t. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; const TGLPhysicalShape*GetNextPhysical() const; TGLVector3GetScale() const; UChar_tGetSelected() const; TGLVertex3GetTranslation() const; UInt_tID() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tIsInvisible() const; Bool_tIsModified() const; Bool_tIsSelected() const; Bool_tIsTransparent() const; voidModified(); virtual voidQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidRemoveReference(TGLPShapeRef* ref); voidRotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle); voidScale(const TGLVector3& scale); voidSelect(UChar_t select); voidSetColor(const Float_t* rgba); voidSetColorOnFamily(const Float_t* rgba); voidSetDiffuseColor(const Float_t* rgba); voidSetDiffuseColor(const UChar_t* rgba); voidSetDiffuseColor(Color_t ci, UChar_t transparency); voidSetManip(TGLPhysicalShape::EManip manip); voidSetTransform(const TGLMatrix& transform); voidSetTransform(const Double_t* vals); voidSetTranslation(const TGLVertex3& translation); voidSetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTranslate(const TGLVector3& vect). private:. TGLPhysicalShape(const TGLPh",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:3982,Testability,log,logical,3982,"ransform(const Double_t* vals); voidSetTranslation(const TGLVertex3& translation); voidSetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTranslate(const TGLVector3& vect). private:. TGLPhysicalShape(const TGLPhysicalShape&); voidInitColor(const Float_t* rgba); TGLPhysicalShape&operator=(const TGLPhysicalShape&); voidUpdateBoundingBox(). Data Members; public:. enum EManip { kTranslateX; kTranslateY; kTranslateZ; kTranslateAll; kScaleX; kScaleY; kScaleZ; kScaleAll; kRotateX; kRotateY; kRotateZ; kRotateAll; kManipAll; };. private:. TGLBoundingBoxfBoundingBox! bounding box of the physical (transformed); Float_tfColor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; i",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:4440,Testability,log,logicalShape,4440," kTranslateX; kTranslateY; kTranslateZ; kTranslateAll; kScaleX; kScaleY; kScaleZ; kScaleAll; kRotateX; kRotateY; kRotateZ; kRotateAll; kManipAll; };. private:. TGLBoundingBoxfBoundingBox! bounding box of the physical (transformed); Float_tfColor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to ",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:4596,Testability,log,logicalShape,4596,"ical (transformed); Float_tfColor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplie",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:4617,Testability,log,logical,4617,"ical (transformed); Float_tfColor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplie",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:4671,Testability,log,logical,4671,"ical (transformed); Float_tfColor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplie",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:4840,Testability,log,logicalShape,4840,"TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess.",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:4993,Testability,log,logicalShape,4993,"n modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index ",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:5014,Testability,log,logical,5014,"n modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index ",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:5090,Testability,log,logical,5090,"n modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index ",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:5996,Testability,log,logical,5996,"arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index and transparency [0,100]. void SetDiffuseColor(const UChar_t rgba[4]); Set color from RGBA quadruplet. void SetDiffuseColor(Color_t ci, UChar_t transparency); Set color from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to ",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPhysicalShape.html:7266,Testability,log,logical,7266,"r from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to 100 (kLODHigh - highest quality). Scene flags are not used. LOD quantization is not done. RnrCtx; is not modified as this is called via lodification stage of; rendering. void QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; Factor in scene/vierer LOD and Quantize ... forward to; logical shape. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Request creation of context menu on shape, attached to 'menu' at screen position; 'x' 'y'. TGLVector3 GetScale() const. TGLVertex3 GetTranslation() const. void SetTransform(const TGLMatrix& transform). void SetTransform(const Double_t* vals). void SetTranslation(const TGLVertex3& translation). void Translate(const TGLVector3& vect). void Scale(const TGLVector3& scale). void Rotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle). TGLPhysicalShape(const TGLPhysicalShape& ). TGLPhysicalShape& operator=(const TGLPhysicalShape& ). UInt_t ID() const; { return fID; }. const TGLLogicalShape * GetLogical() const; { return fLogicalShape; }. const TGLPhysicalShape * GetNextPhysical() const; { return fNextPhysical; }. EManip GetManip() const; Modification and manipulation. { return fManip; }. void SetManip(TGLPhysicalShape::EManip manip); { fManip = manip; }. Bool_t IsModified() const; { return fMo",MatchSource.WIKI,root/html530/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPhysicalShape.html
https://root.cern/root/html530/TGLPlane.html:446,Security,access,accessors,446,". TGLPlane. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlane. class TGLPlane. TGLPlane. 3D plane class - of format Ax + By + Cz + D = 0. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLPlane(); TGLPlane(const TGLPlane& other); TGLPlane(Double_t* eq); TGLPlane(const TGLVector3& norm, const TGLVertex3& point); TGLPlane(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); TGLPlane(Double_t a, Double_t b, Double_t c, Double_t d); virtual~TGLPlane(); Double_tA() const; Double_t*Arr(); Double_tB() const; Double_tC() const; const Double_t*CArr() const; static TClass*Class(); Double_tD() const; Double_tDistanceTo(const TGLVertex3& vertex) const; voidDump() const; virtual TClass*IsA() const; TGLVertex3NearestOn(const TGLVertex3& point) const; voidNegate(); TGLVector3Norm() const; TGLPlane&operator=(const TGLPlane&); voidSet(const TGLPlane& other); voidSet(Double_t* eq); voidSet(const TGLVector3& norm, const TGLVertex3& point); voidSet(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); voidSet(Double_t a, Double_t b, Double_t c, Double_t d); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. voidNormalise(). Data Members; private:. Double_tfVals[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlane(); Construct a default plane of x + y + z = 0. TGLPlane(const TGLPlane& other); Construct plane from 'other'. T",MatchSource.WIKI,root/html530/TGLPlane.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlane.html
https://root.cern/root/html530/TGLPlane.html:358,Usability,simpl,simple,358,". TGLPlane. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlane. class TGLPlane. TGLPlane. 3D plane class - of format Ax + By + Cz + D = 0. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLPlane(); TGLPlane(const TGLPlane& other); TGLPlane(Double_t* eq); TGLPlane(const TGLVector3& norm, const TGLVertex3& point); TGLPlane(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); TGLPlane(Double_t a, Double_t b, Double_t c, Double_t d); virtual~TGLPlane(); Double_tA() const; Double_t*Arr(); Double_tB() const; Double_tC() const; const Double_t*CArr() const; static TClass*Class(); Double_tD() const; Double_tDistanceTo(const TGLVertex3& vertex) const; voidDump() const; virtual TClass*IsA() const; TGLVertex3NearestOn(const TGLVertex3& point) const; voidNegate(); TGLVector3Norm() const; TGLPlane&operator=(const TGLPlane&); voidSet(const TGLPlane& other); voidSet(Double_t* eq); voidSet(const TGLVector3& norm, const TGLVertex3& point); voidSet(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); voidSet(Double_t a, Double_t b, Double_t c, Double_t d); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. voidNormalise(). Data Members; private:. Double_tfVals[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlane(); Construct a default plane of x + y + z = 0. TGLPlane(const TGLPlane& other); Construct plane from 'other'. T",MatchSource.WIKI,root/html530/TGLPlane.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlane.html
https://root.cern/root/html530/TGLPlot3D.html:450,Availability,avail,available,450,". TGLPlot3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlot3D. class TGLPlot3D: public TGLObject. Description of TGLPlot3D. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::Qu",MatchSource.WIKI,root/html530/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlot3D.html
https://root.cern/root/html530/TGLPlot3D.html:2170,Performance,cache,cached,2170,"Pad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTGLObject::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLObject::SetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html530/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlot3D.html
https://root.cern/root/html530/TGLPlot3D.html:904,Testability,log,logx,904," virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::Qu",MatchSource.WIKI,root/html530/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlot3D.html
https://root.cern/root/html530/TGLPlot3D.html:917,Testability,log,logy,917," virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::Qu",MatchSource.WIKI,root/html530/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlot3D.html
https://root.cern/root/html530/TGLPlot3D.html:930,Testability,log,logz,930," virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::Qu",MatchSource.WIKI,root/html530/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlot3D.html
https://root.cern/root/html530/TGLPlot3D.html:4818,Testability,log,logarithmic,4818,"Shape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; TGLPlotPainter*fPlotPainter; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLPlot3D(); Destructor. void SetPainter(TGLPlotPainter* p); Set painter object and destroy the old one. TGLPlot3D* InstantiatePlot(TObject* obj); Instantiate the correct plot-painter for given object.; Protected method. TGLPlot3D* CreatePlot(TH3* h, TPolyMarker3D* pm); Create GL plot for specified TH3 and polymarker. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); Create GL plot for specified object and options.; Which axes are logarithmic is determined from a pad. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); Create GL plot for specified object and options.; Which axes are logarithmic is determined from explicit arguments. TGLPlot3D& operator=(const TGLPlot3D& ). Bool_t KeepDuringSmartRefresh() const; { return kFALSE; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPlot3D.h 38817 2011-04-13 09:32:44Z couet $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlot3D.html
https://root.cern/root/html530/TGLPlot3D.html:4914,Testability,log,logx,4914,"Shape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; TGLPlotPainter*fPlotPainter; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLPlot3D(); Destructor. void SetPainter(TGLPlotPainter* p); Set painter object and destroy the old one. TGLPlot3D* InstantiatePlot(TObject* obj); Instantiate the correct plot-painter for given object.; Protected method. TGLPlot3D* CreatePlot(TH3* h, TPolyMarker3D* pm); Create GL plot for specified TH3 and polymarker. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); Create GL plot for specified object and options.; Which axes are logarithmic is determined from a pad. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); Create GL plot for specified object and options.; Which axes are logarithmic is determined from explicit arguments. TGLPlot3D& operator=(const TGLPlot3D& ). Bool_t KeepDuringSmartRefresh() const; { return kFALSE; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPlot3D.h 38817 2011-04-13 09:32:44Z couet $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlot3D.html
https://root.cern/root/html530/TGLPlot3D.html:4927,Testability,log,logy,4927,"Shape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; TGLPlotPainter*fPlotPainter; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLPlot3D(); Destructor. void SetPainter(TGLPlotPainter* p); Set painter object and destroy the old one. TGLPlot3D* InstantiatePlot(TObject* obj); Instantiate the correct plot-painter for given object.; Protected method. TGLPlot3D* CreatePlot(TH3* h, TPolyMarker3D* pm); Create GL plot for specified TH3 and polymarker. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); Create GL plot for specified object and options.; Which axes are logarithmic is determined from a pad. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); Create GL plot for specified object and options.; Which axes are logarithmic is determined from explicit arguments. TGLPlot3D& operator=(const TGLPlot3D& ). Bool_t KeepDuringSmartRefresh() const; { return kFALSE; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPlot3D.h 38817 2011-04-13 09:32:44Z couet $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlot3D.html
https://root.cern/root/html530/TGLPlot3D.html:4940,Testability,log,logz,4940,"Shape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; TGLPlotPainter*fPlotPainter; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLPlot3D(); Destructor. void SetPainter(TGLPlotPainter* p); Set painter object and destroy the old one. TGLPlot3D* InstantiatePlot(TObject* obj); Instantiate the correct plot-painter for given object.; Protected method. TGLPlot3D* CreatePlot(TH3* h, TPolyMarker3D* pm); Create GL plot for specified TH3 and polymarker. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); Create GL plot for specified object and options.; Which axes are logarithmic is determined from a pad. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); Create GL plot for specified object and options.; Which axes are logarithmic is determined from explicit arguments. TGLPlot3D& operator=(const TGLPlot3D& ). Bool_t KeepDuringSmartRefresh() const; { return kFALSE; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPlot3D.h 38817 2011-04-13 09:32:44Z couet $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlot3D.html
https://root.cern/root/html530/TGLPlot3D.html:5012,Testability,log,logarithmic,5012,"Shape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; TGLPlotPainter*fPlotPainter; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLPlot3D(); Destructor. void SetPainter(TGLPlotPainter* p); Set painter object and destroy the old one. TGLPlot3D* InstantiatePlot(TObject* obj); Instantiate the correct plot-painter for given object.; Protected method. TGLPlot3D* CreatePlot(TH3* h, TPolyMarker3D* pm); Create GL plot for specified TH3 and polymarker. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); Create GL plot for specified object and options.; Which axes are logarithmic is determined from a pad. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); Create GL plot for specified object and options.; Which axes are logarithmic is determined from explicit arguments. TGLPlot3D& operator=(const TGLPlot3D& ). Bool_t KeepDuringSmartRefresh() const; { return kFALSE; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPlot3D.h 38817 2011-04-13 09:32:44Z couet $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlot3D.html
https://root.cern/root/html530/TGLPlotCoordinates.html:1614,Availability,error,errors,1614,"bers; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotCoordinates. class TGLPlotCoordinates. Helper class for plot-painters holding information about axis; ranges, numbers of bins and flags if certain axis is logartihmic. Function Members (Methods); public:. TGLPlotCoordinates(); virtual~TGLPlotCoordinates(); static TClass*Class(); EGLCoordTypeGetCoordType() const; Double_tGetFactor() const; Int_tGetFirstXBin() const; Int_tGetFirstYBin() const; Int_tGetFirstZBin() const; Int_tGetLastXBin() const; Int_tGetLastYBin() const; Int_tGetLastZBin() const; Int_tGetNXBins() const; Int_tGetNYBins() const; Int_tGetNZBins() const; const Rgl::BinRange_t&GetXBins() const; Double_tGetXLength() const; Bool_tGetXLog() const; const Rgl::Range_t&GetXRange() const; const Rgl::Range_t&GetXRangeScaled() const; Double_tGetXScale() const; const Rgl::BinRange_t&GetYBins() const; Double_tGetYLength() const; Bool_tGetYLog() const; const Rgl::Range_t&GetYRange() const; const Rgl::Range_t&GetYRangeScaled() const; Double_tGetYScale() const; const Rgl::BinRange_t&GetZBins() const; Double_tGetZLength() const; Bool_tGetZLog() const; const Rgl::Range_t&GetZRange() const; const Rgl::Range_t&GetZRangeScaled() const; Double_tGetZScale() const; virtual TClass*IsA() const; Bool_tModified() const; voidResetModified(); voidSetCoordType(EGLCoordType type); Bool_tSetRanges(TH2Poly* hist); Bool_tSetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); voidSetXLog(Bool_t xLog); voidSetYLog(Bool_t yLog); voidSetZLog(Bool_t zLog); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPlotCoordinates(const TGLPlotCoordinates&); TGLPlotCoordinates&operator=(const TGLPlotCoordinates&); Bool_tSetRangesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetRangesPola",MatchSource.WIKI,root/html530/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotCoordinates.html
https://root.cern/root/html530/TGLPlotCoordinates.html:2090,Availability,error,errors,2090,"st; Bool_tGetYLog() const; const Rgl::Range_t&GetYRange() const; const Rgl::Range_t&GetYRangeScaled() const; Double_tGetYScale() const; const Rgl::BinRange_t&GetZBins() const; Double_tGetZLength() const; Bool_tGetZLog() const; const Rgl::Range_t&GetZRange() const; const Rgl::Range_t&GetZRangeScaled() const; Double_tGetZScale() const; virtual TClass*IsA() const; Bool_tModified() const; voidResetModified(); voidSetCoordType(EGLCoordType type); Bool_tSetRanges(TH2Poly* hist); Bool_tSetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); voidSetXLog(Bool_t xLog); voidSetYLog(Bool_t yLog); voidSetZLog(Bool_t zLog); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPlotCoordinates(const TGLPlotCoordinates&); TGLPlotCoordinates&operator=(const TGLPlotCoordinates&); Bool_tSetRangesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRangesSpherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. B",MatchSource.WIKI,root/html530/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotCoordinates.html
https://root.cern/root/html530/TGLPlotCoordinates.html:3481,Availability,error,errors,3481,"double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. const Rgl::Range_t & GetZRangeScaled() const; Scaled range. Double_t GetFactor() const; Get factor. Bool_t SetRangesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges, etc. Bool_t SetRanges(TH2Poly* hist); Set bin rang",MatchSource.WIKI,root/html530/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotCoordinates.html
https://root.cern/root/html530/TGLPlotCoordinates.html:4377,Availability,error,errors,4377,"); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. const Rgl::Range_t & GetZRangeScaled() const; Scaled range. Double_t GetFactor() const; Get factor. Bool_t SetRangesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges, etc. Bool_t SetRanges(TH2Poly* hist); Set bin ranges, ranges, etc. Bool_t SetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); Set bin ranges, ranges, etc. Bool_t SetRangesPolar(const TH1* hist); Set bin ranges, ranges, etc. Bool_t SetRangesCylindrical(const TH1* hist); Set ranges cylindrical. Bool_t SetRangesSpherical(const TH1* hist); Set ranges spherical. TGLPlotCoordinates(). Double_t GetXScale() const; {return fXScale;}. Double_t GetYScale() const; {return fYScale;}. Double_t GetZScale() const; {return fZScale;}. Int_t GetFirstXBin() const; {return fXBins.first;}. Int_t GetLastXBin() const; {return fXBins.second;}. Int_t GetFirstYBin() const; {return fYBins.first;}. Int_t GetLastYBin() const; {return fYBins.second;}. Int_t GetFirstZBin() const; {return fZBins.first;}. Int_t GetLastZBin() const; {return fZBins.second;}. » Author: Timur Pocheptsov 14/06/2006 » Copyright (C) 1995-2004, Rene Brun and Fons Radema",MatchSource.WIKI,root/html530/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotCoordinates.html
https://root.cern/root/html530/TGLPlotCoordinates.html:415,Testability,log,logartihmic,415,". TGLPlotCoordinates. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotCoordinates. class TGLPlotCoordinates. Helper class for plot-painters holding information about axis; ranges, numbers of bins and flags if certain axis is logartihmic. Function Members (Methods); public:. TGLPlotCoordinates(); virtual~TGLPlotCoordinates(); static TClass*Class(); EGLCoordTypeGetCoordType() const; Double_tGetFactor() const; Int_tGetFirstXBin() const; Int_tGetFirstYBin() const; Int_tGetFirstZBin() const; Int_tGetLastXBin() const; Int_tGetLastYBin() const; Int_tGetLastZBin() const; Int_tGetNXBins() const; Int_tGetNYBins() const; Int_tGetNZBins() const; const Rgl::BinRange_t&GetXBins() const; Double_tGetXLength() const; Bool_tGetXLog() const; const Rgl::Range_t&GetXRange() const; const Rgl::Range_t&GetXRangeScaled() const; Double_tGetXScale() const; const Rgl::BinRange_t&GetYBins() const; Double_tGetYLength() const; Bool_tGetYLog() const; const Rgl::Range_t&GetYRange() const; const Rgl::Range_t&GetYRangeScaled() const; Double_tGetYScale() const; const Rgl::BinRange_t&GetZBins() const; Double_tGetZLength() const; Bool_tGetZLog() const; const Rgl::Range_t&GetZRange() const; const Rgl::Range_t&GetZRangeScaled() const; Double_tGetZScale() const; virtual TClass*IsA() const; Bool_tModified() const; voidResetModified(); voidSetCoordType(EGLCoordType type); Bool_tSetRanges(TH2Poly* hist); Bool_tSetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); voidSetXLog(Bool_t xLog); voidSetYLog(Bool_t yLog); voidSetZLog(Bool_t zLog); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPlotCoordinates(const TGLPlotCoordinates&); TGLPlotCoordinate",MatchSource.WIKI,root/html530/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotCoordinates.html
https://root.cern/root/html530/TGLPlotCoordinates.html:3043,Testability,log,log,3043,"gesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRangesSpherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() co",MatchSource.WIKI,root/html530/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotCoordinates.html
https://root.cern/root/html530/TGLPlotCoordinates.html:3126,Testability,log,log,3126,"t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRangesSpherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const ",MatchSource.WIKI,root/html530/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotCoordinates.html
https://root.cern/root/html530/TGLPlotCoordinates.html:3161,Testability,log,log,3161,"st); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRangesSpherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const",MatchSource.WIKI,root/html530/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotCoordinates.html
https://root.cern/root/html530/TGLPlotCoordinates.html:3244,Testability,log,log,3244,"Spherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. cons",MatchSource.WIKI,root/html530/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotCoordinates.html
https://root.cern/root/html530/TGLPlotCoordinates.html:3279,Testability,log,log,3279,"dTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. const Rgl::Range_t & GetZRangeScaled() const; Scaled range. Dou",MatchSource.WIKI,root/html530/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotCoordinates.html
https://root.cern/root/html530/TGLPlotCoordinates.html:3362,Testability,log,log,3362,",int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. const Rgl::Range_t & GetZRangeScaled() const; Scaled range. Double_t GetFactor() const; Get factor. Bool_t SetRangesCartes",MatchSource.WIKI,root/html530/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotCoordinates.html
https://root.cern/root/html530/TGLPlotPainter.html:571,Availability,avail,available,571,". TGLPlotPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotPainter. class TGLPlotPainter: public TVirtualGLPainter. Base class for plot-painters that provide GL rendering of various; 2D and 3D histograms, functions and parametric surfaces. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLPlotPainter(); virtual voidAddOption(const TString& stringOption); static TClass*Class(); Bool_tCutAxisSelected() const; virtual voidDeInitGL() const; virtual voidDrawPlot() const; virtual char*TVirtualGLPainter::GetPlotInfo(Int_t px, Int_t py); virtual Bool_tInitGeometry(); virtual voidInitGL() const; voidInvalidateSelection(); virtual TClass*IsA() const; TVirtualGLPainter&TVirtualGLPainter::operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidTVirtualGLPainter::Pan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&RefBackBox() const; virtual voidSetFrameColor(const TColor* frameColor); voidSetPadColor(const TColor* color); voidSetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidClearBuffers() const; virtual voidDrawPaletteAxis() const; voidDrawSections() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; const TColor*GetPadColor() const; voidMoveSection(Int_t px, Int_t py); voidPrintPlot() const; voidRestoreModelviewMatrix() const; voidRestoreProjectionMatrix() const; voidSaveModelviewMatrix() const; voidSaveProjectionMatri",MatchSource.WIKI,root/html530/TGLPlotPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotPainter.html
https://root.cern/root/html530/TGLPlotPainter.html:3167,Deployability,update,updated,3167,"Axis; };. protected:. TGLPlotBoxfBackBox; TGLBoxCutfBoxCut; TGLPlotCamera*fCamera; TGLPlotCoordinates*fCoord; Bool_tfDrawPalette; Bool_tfHighColor; TH1*fHist; TPointfMousePosition; Double_tfPadPhi; Double_tfPadTheta; const Float_t*fPhysicalShapeColor; Int_tfSelectedPart; TGLSelectionBufferfSelection; TGLPlotPainter::ESelectionBasefSelectionBase; Bool_tfSelectionPass; Bool_tfUpdateSelection; TAxis*fXAxis; Double_tfXOYSectionPos; Double_tfXOZSectionPos; TAxis*fYAxis; Double_tfYOZSectionPos; TAxis*fZAxis; vector<Double_t>fZLevels. private:. const TColor*fPadColor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Paint(); Draw lego/surf/whatever you can. void PrintPlot() const; Generate PS using gl2ps. Bool_t PlotSelected(Int_t px, Int_t py); Read color buffer content to find selected object. void SetPadColor(const TColor* color); Used in a pad. void SetFrameColor(const TColor* frameColor); Set plot's back box color. void InvalidateSelection(); Selection must be updated. const TColor * GetPadColor() const; Get pad color. void MoveSection(Int_t px, Int_t py); Create dynamic profile using selected plane. void DrawSections() const; Draw sections (if any). void ClearBuffers() const. // Clear buffer.; Float_t rgb[3] = {1.f, 1.f, 1.f};; if (const TColor *color = GetPadColor()); color->GetRGB(rgb[0], rgb[1], rgb[2]);; glClearColor(rgb[0], rgb[1], rgb[2], 1.);; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);. void DrawPaletteAxis() const; Draw. Palette. Axis. void SaveModelviewMatrix() const. void SaveProjectionMatrix() const. void RestoreModelviewMatrix() const. void RestoreProjectionMatrix() const. const TGLPlotBox& RefBackBox() const; { return fBackBox; }. void SetPhysicalShapeColor(const Float_t* rgba). void InitGL() const. void DeInitGL() const. void DrawPlot() const. Bool_t InitGeometry(); Init geometry does plot's specific initialization. void StartPan(Int_t px, Int_t py); Pan function is already declared in TVirtualGLPai",MatchSource.WIKI,root/html530/TGLPlotPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPlotPainter.html
https://root.cern/root/html530/TGLPolyLine.html:3574,Modifiability,inherit,inheritance,3574,"Shape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals(). protected:. voidTGLLogicalShape::PurgeDLRange(UInt_t base, Int_t size) const. Data Members; public:. enum TGLLogicalShape::ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). private:. Double_tfLineWidth; vector<Double_t>fVertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPolyLine(const TBuffer3D& buffer); constructor; dynamic_cast because of multiple inheritance. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPolyLine.h 21252 2007-12-07 01:39:32Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPolyLine.html
https://root.cern/root/html530/TGLPolyLine.html:1796,Performance,cache,cached,1796,"yLine(const TBuffer3D& buffer); ~TGLPolyLine(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html530/TGLPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPolyLine.html
https://root.cern/root/html530/TGLPolyMarker.html:1793,Performance,cache,cached,1793,"c:. TGLPolyMarker(const TBuffer3D& buffer); ~TGLPolyMarker(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals(). pr",MatchSource.WIKI,root/html530/TGLPolyMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPolyMarker.html
https://root.cern/root/html530/TGLPShapeObj.html:1420,Availability,error,error,1420,"hapeObj(); TGLPShapeObj(TGLPhysicalShape* sh, TGLViewer* v); virtual~TGLPShapeObj(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtu",MatchSource.WIKI,root/html530/TGLPShapeObj.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPShapeObj.html
https://root.cern/root/html530/TGLPShapeObj.html:1504,Availability,error,error,1504," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect",MatchSource.WIKI,root/html530/TGLPShapeObj.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPShapeObj.html
https://root.cern/root/html530/TGLPShapeObjEditor.html:4653,Availability,error,error,4653,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGeoValueSet(Long_t unusedVal); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompo",MatchSource.WIKI,root/html530/TGLPShapeObjEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPShapeObjEditor.html
https://root.cern/root/html530/TGLPShapeObjEditor.html:4737,Availability,error,error,4737,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGeoValueSet(Long_t unusedVal); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); vi",MatchSource.WIKI,root/html530/TGLPShapeObjEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPShapeObjEditor.html
https://root.cern/root/html530/TGLPShapeObjEditor.html:17982,Availability,mask,mask,17982,"renced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; TGLPhysicalShape*TGLPShapeRef::fPShapePointer to referenced physical shape.; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidth",MatchSource.WIKI,root/html530/TGLPShapeObjEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPShapeObjEditor.html
https://root.cern/root/html530/TGLPShapeObjEditor.html:22245,Deployability,update,update,22245,"r multiplet; TGHSlider*fRedSliderred component of selected material; TGHSlider*fShineSliderspecular refelction of selected material. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeObjEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of TGLPhysicalShape editor GUI. ~TGLPShapeObjEditor(); Destroy color editor GUI component.; Done automatically. void SetPShape(TGLPhysicalShape* shape); Shape has changed.; Check if set to zero and make sure we're no longer in editor. void PShapeModified(); Shape has been modified.; Update editor if we're still shown. Otherwise unref. void SetModel(TObject* obj); Sets model or disables/hides viewer. void SetCenter(const Double_t* center); Set internal center data from 3 component 'c'. void SetScale(const Double_t* scale); Set internal scale data from 3 component 'c'. void DoGeoButton(); Process 'Apply' - update the viewer object from GUI. void GetObjectData(Double_t* shift, Double_t* scale); Extract the GUI object data, return center in 3 component 'center'; scale in 3 component 'scale'. void GeoValueSet(Long_t unusedVal); Process setting of value in edit box - activate 'Apply' button. void CreateGeoControls(); Create GUI for setting scale and position. void SetRGBA(const Float_t* rgba); Set color sliders from 17 component 'rgba'. void DoColorSlider(Int_t val); Process slider movement. void DoColorButton(); Process button action. void CreateColorRadioButtons(); Create Diffuse/Ambient/Specular/Emissive radio buttons and sub-frames. void CreateColorSliders(); Create GUI for setting light color. void SetColorSlidersPos(); Update GUI sliders from internal data. void DoRedraw(); Redraw widget. Render sphere and pass to base-class. void DrawSphere() const; Draw local sphere reflecting current color options. void CreateColorControls(); Create widgets to chhos colors componnet and its RGBA v",MatchSource.WIKI,root/html530/TGLPShapeObjEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPShapeObjEditor.html
https://root.cern/root/html530/TGLPShapeRef.html:1521,Performance,perform,perform,1521,"t need to be notified; when the shape is destroyed.; Could also deliver 'change' notifications. Function Members (Methods); public:. TGLPShapeRef(); TGLPShapeRef(TGLPhysicalShape* shape); virtual~TGLPShapeRef(); static TClass*Class(); TGLPhysicalShape*GetPShape() const; virtual TClass*IsA() const; virtual voidPShapeModified(); virtual voidSetPShape(TGLPhysicalShape* shape); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPShapeRef(const TGLPShapeRef&); TGLPShapeRef&operator=(const TGLPShapeRef&). Data Members; protected:. TGLPhysicalShape*fPShapePointer to referenced physical shape. private:. TGLPShapeRef*fNextPSRefInternal pointer to the next reference (used by TGLPhysicalShape directly). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeRef(); Default contructor. TGLPShapeRef(TGLPhysicalShape* shape); Constructor with known shape - reference it. ~TGLPShapeRef(); Destructor - unreference the shape if set. void SetPShape(TGLPhysicalShape* shape); Set the shape. Unreference the old and reference the new.; This is virtual so that sub-classes can perform other tasks; on change. This function should be called first from there. This is also called from destructor of the refereced physical; shape with 0 argument. void PShapeModified(); This is called from physical shape when it is modified.; Sub-classes can override and take appropriate action. TGLPShapeRef(const TGLPShapeRef& ). TGLPShapeRef& operator=(const TGLPShapeRef& ). TGLPhysicalShape * GetPShape() const; { return fPShape; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPShapeRef.h 26394 2008-11-23 14:35:25Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLPShapeRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLPShapeRef.html
https://root.cern/root/html530/TGLRnrCtx.html:6871,Availability,avail,available,6871,"Base* viewer); Constructor. ~TGLRnrCtx(); Destructor. TGLSceneBase * GetScene(); Return current scene (based on scene-info data). TGLSceneBase & RefScene(); Return current scene (based on scene-info data). Bool_t IsDrawPassFilled() const; Returns true if current render-pass uses filled polygon style. Bool_t HasStopwatchTimedOut(); Check if the stopwatch went beyond the render time limit. void BeginSelection(Int_t x, Int_t y, Int_t r = 3); Setup context for running selection.; x and y are in window coordinates. void EndSelection(Int_t glResult); End selection. TGLRect * GetPickRectangle(); Return current pick rectangle. This is *zero* when; selection is not set. Int_t GetPickRadius(); Return pick radius. If selection is not active it returns 0. void PushColorSet(); Create copy of current color-set on the top of the stack. TGLColorSet& ColorSet(); Return reference to current color-set (top of hte stack). void PopColorSet(); Pops the top-most color-set.; If only one entry is available, error is printed and the entry remains. TGLColorSet* ChangeBaseColorSet(TGLColorSet* set); Change the default/bottom color-set.; Returns the previous color-set. TGLColorSet* GetBaseColorSet(); Returns the current base color-set. void ColorOrForeground(Color_t col); Set col if it is different from background, otherwise use; current foreground color. void OpenDLCapture(); Start display-list capture. void CloseDLCapture(); End display list capture. void ReleaseFont(TGLFont& font); Release font in the GL rendering context. void RegisterFontNoScale(Int_t size, Int_t file, Int_t mode, TGLFont& out); Get font in the GL rendering context. void RegisterFontNoScale(Int_t size, const char* name, Int_t mode, TGLFont& out); Get font in the GL rendering context. void RegisterFont(Int_t size, Int_t file, Int_t mode, TGLFont& out); Get font in the GL rendering context.; The font is scaled relative to current render scale. void RegisterFont(Int_t size, const char* name, Int_t mode, TGLFont& out); Get font",MatchSource.WIKI,root/html530/TGLRnrCtx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLRnrCtx.html
https://root.cern/root/html530/TGLRnrCtx.html:6882,Availability,error,error,6882,"Base* viewer); Constructor. ~TGLRnrCtx(); Destructor. TGLSceneBase * GetScene(); Return current scene (based on scene-info data). TGLSceneBase & RefScene(); Return current scene (based on scene-info data). Bool_t IsDrawPassFilled() const; Returns true if current render-pass uses filled polygon style. Bool_t HasStopwatchTimedOut(); Check if the stopwatch went beyond the render time limit. void BeginSelection(Int_t x, Int_t y, Int_t r = 3); Setup context for running selection.; x and y are in window coordinates. void EndSelection(Int_t glResult); End selection. TGLRect * GetPickRectangle(); Return current pick rectangle. This is *zero* when; selection is not set. Int_t GetPickRadius(); Return pick radius. If selection is not active it returns 0. void PushColorSet(); Create copy of current color-set on the top of the stack. TGLColorSet& ColorSet(); Return reference to current color-set (top of hte stack). void PopColorSet(); Pops the top-most color-set.; If only one entry is available, error is printed and the entry remains. TGLColorSet* ChangeBaseColorSet(TGLColorSet* set); Change the default/bottom color-set.; Returns the previous color-set. TGLColorSet* GetBaseColorSet(); Returns the current base color-set. void ColorOrForeground(Color_t col); Set col if it is different from background, otherwise use; current foreground color. void OpenDLCapture(); Start display-list capture. void CloseDLCapture(); End display list capture. void ReleaseFont(TGLFont& font); Release font in the GL rendering context. void RegisterFontNoScale(Int_t size, Int_t file, Int_t mode, TGLFont& out); Get font in the GL rendering context. void RegisterFontNoScale(Int_t size, const char* name, Int_t mode, TGLFont& out); Get font in the GL rendering context. void RegisterFont(Int_t size, Int_t file, Int_t mode, TGLFont& out); Get font in the GL rendering context.; The font is scaled relative to current render scale. void RegisterFont(Int_t size, const char* name, Int_t mode, TGLFont& out); Get font",MatchSource.WIKI,root/html530/TGLRnrCtx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLRnrCtx.html
https://root.cern/root/html530/TGLRnrCtx.html:533,Testability,log,logical,533,". TGLRnrCtx. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLRnrCtx. class TGLRnrCtx. The TGLRnrCtx class aggregates data for a given redering context as; needed by various parts of the ROOT's OpenGL infractructure. It; serves as a connecting point between the steering part of the; infrastructure (viewer, scene) and concrete rendering classes; (logical, physical shape). It is just a data-holder, there is no; functionality in it. Development notes:. One RnrCtx is created by each viewer and it is just an extension of; the viewer context that changes along the render; descend. Separating this also has some abstract benefit of hiding; viewer implementation from those that do not need to know it. Current scene / scene-info part is always initialized by viewer,; scenes can assume they're ok. Function Members (Methods); public:. TGLRnrCtx(TGLViewerBase* viewer); virtual~TGLRnrCtx(); voidBeginSelection(Int_t x, Int_t y, Int_t r = 3); TGLColorSet*ChangeBaseColorSet(TGLColorSet* set); static TClass*Class(); TGLClip*Clip() const; voidCloseDLCapture(); voidColorOrForeground(Color_t col); TGLColorSet&ColorSet(); Short_tCombiLOD() const; Short_tDrawPass() const; voidEndSelection(Int_t glResult); TGLColorSet*GetBaseColorSet(); TGLCamera*GetCamera(); const TGLCamera*GetCamera() const; UInt_tGetEventKeySym() const; TGLContextIdentity*GetGLCtxIdentity() const; GLUquadric*GetGluQuadric(); Bool_tGetGrabImage() const; Int_tGetPickRadius(); TGLRect*GetPickRectangle(); Float_tGetRenderScale() const; TGLSceneBase*GetScene(); TGLSceneInfo*GetSceneInfo(); TGLSelectBuffer*GetSelectBuffer() const; TGLViewerBase*GetViewer(); Bool_tHasClip() const; Bool_tHasStopwatchTimedOut(); Bool_tHighlight() const; Bool_tHighlightOutline() const; virtual TClass*IsA() const; Bool_tIsDLCaptureOpen() const; Bool_tIsDrawPassFilled",MatchSource.WIKI,root/html530/TGLRnrCtx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLRnrCtx.html
https://root.cern/root/html530/TGLRotateManip.html:614,Energy Efficiency,green,green,614,". TGLRotateManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLRotateManip. class TGLRotateManip: public TGLManip. Rotate manipulator - attaches to physical shape and draws local axes; widgets - rings drawn from attached physical center, in plane defined; by axis. User can mouse over (turns yellow) and L click/drag to; rotate attached physical round the ring center.; Widgets use standard 3D package axes colours: X red, Y green, Z blue. Function Members (Methods); public:. TGLRotateManip(); TGLRotateManip(TGLPhysicalShape* shape); TGLRotateManip(const TGLRotateManip&); virtual~TGLRotateManip(); voidTGLManip::Attach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tTGLManip::GetActive() const; TGLPhysicalShape*TGLManip::GetAttached() const; UInt_tTGLManip::GetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tTGLManip::Select(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidTGLManip::SetActive(Bool_t a); voidTGLManip::SetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static Double_tAngle(const TGLVector3& v1, const TGLVector3& v2); static Double_tAngle(const TGLVector3& v1, const TGLVector3& v2, const TGLVector3& ref); voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). private:. Double_tCalculateAngleDelta(const TPoint& mouse, const TGLCamera& camera); TGLLine3CalculateRingLine(con",MatchSource.WIKI,root/html530/TGLRotateManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLRotateManip.html
https://root.cern/root/html530/TGLRotateManip.html:3746,Energy Efficiency,green,green,3746,"nt! front or back of the active shallow ring?; Bool_tfShallowRing! does active ring form shallow angle to eye?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t Angle(const TGLVector3& v1, const TGLVector3& v2); Calculate unsigned angle between vectors v1 and v2. Double_t Angle(const TGLVector3& v1, const TGLVector3& v2, const TGLVector3& ref); Calculate signed angle between vectors v1 and v2, using ref to define right handed coord system; If v1.v2 parallel to ref vector: +ive for clockwise, -ive for anticlockwise; If v1.v2 antiparallel to ref vector: -ive for clockwise, +ive for anticlockwise. TGLRotateManip(); Construct rotation manipulator not bound to any physical shape. TGLRotateManip(TGLPhysicalShape* shape); Construct rotation manipulator bound to TGLPhysicalShape 'shape'. ~TGLRotateManip(); Destory the rotation manipulator. void Draw(const TGLCamera& camera) const; Draw rotate manipulator - axis rings drawn from attached; physical center, in plane defined by axis as normal, in red(X),; green(Y) and blue(Z), with white center sphere. If selected; widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleButton(const Event_t& event, const TGLCamera& camera); Handle mouse button event over manipulator - returns kTRUE if; redraw required kFALSE otherwise. Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) rotate physical around selected ring widget plane; normal. Returns kTRUE if redraw required kFALSE otherwise. Double_t CalculateAngleDelta(const TPoint& mouse, const TGLCamera& camera); Calculate angle delta for rotation based on new mouse position. TGLLine3 CalculateRingLine(const TPoint& mouse, const TGLCamera& camera) const; Calculated interaction line between 'mouse' viewport point, and; current selected widget (ring), under supplied 'camera'; projection. void DrawAxisRing(const TGLVertex3& origin, const TGLV",MatchSource.WIKI,root/html530/TGLRotateManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLRotateManip.html
https://root.cern/root/html530/TGLSAFrame.html:4375,Availability,error,error,4375,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGLSAFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAFrame.html
https://root.cern/root/html530/TGLSAFrame.html:4459,Availability,error,error,4459,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGLSAFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAFrame.html
https://root.cern/root/html530/TGLSAFrame.html:18576,Availability,mask,mask,18576,,MatchSource.WIKI,root/html530/TGLSAFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAFrame.html
https://root.cern/root/html530/TGLSAFrame.html:21818,Integrability,message,message,21818,"Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGLSAViewer&fViewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSAFrame(TGLSAViewer& viewer); Construct GUI frame, bound to passed 'viewer'. TGLSAFrame(const TGWindow* parent, TGLSAViewer& viewer); Construct GUI frame, bound to passed 'viewer'. ~TGLSAFrame(); Destroy the GUI frame. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process GUI message - defered back up to TGLSAViewer::ProcessFrameMessage(). void CloseWindow(); Close the GUI frame. TGLSAFrame(const TGLSAFrame& ); non-copyable class. » Author: Richard Maunder 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAFrame.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLSAFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAFrame.html
https://root.cern/root/html530/TGLSAViewer.html:5463,Availability,error,error,5463,"am); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnableMenuBarHiding(); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLV",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:5547,Availability,error,error,5547,"char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnableMenuBarHiding(); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLViewer::EDragActionTGLViewer::GetDragAction() const; Bool_tTGLViewer::GetDrawCameraCe",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:26298,Availability,error,error,26298,"TGCompositeFrame*fRightVerticalFrame; Int_tfTypeIdx; static const char*fgHelpText1; static const char*fgHelpText2; static const Int_tfgInitH; static const Int_tfgInitW; static const Int_tfgInitX; static const Int_tfgInitY; static Long_tfgMenuHidingTimeout. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSAViewer(TVirtualPad* pad, TGLFormat* format = 0); Construct a standalone viewer, bound to supplied 'pad'. TGLSAViewer(const TGWindow* parent, TVirtualPad* pad, TGedEditor* ged = 0, TGLFormat* format = 0); Construct an embedded standalone viewer, bound to supplied 'pad'.; If format is passed, it gets adopted by the viewer as it might; need to be reused several times when recreating the GL-widget. Modified version of the previous constructor for embedding the; viewer into another frame (parent). ~TGLSAViewer(); Destroy standalone viewer object. TGCompositeFrame* GetFrame() const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout)",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:26428,Availability,error,error,26428,"t Int_tfgInitH; static const Int_tfgInitW; static const Int_tfgInitX; static const Int_tfgInitY; static Long_tfgMenuHidingTimeout. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSAViewer(TVirtualPad* pad, TGLFormat* format = 0); Construct a standalone viewer, bound to supplied 'pad'. TGLSAViewer(const TGWindow* parent, TVirtualPad* pad, TGedEditor* ged = 0, TGLFormat* format = 0); Construct an embedded standalone viewer, bound to supplied 'pad'.; If format is passed, it gets adopted by the viewer as it might; need to be reused several times when recreating the GL-widget. Modified version of the previous constructor for embedding the; viewer into another frame (parent). ~TGLSAViewer(); Destroy standalone viewer object. TGCompositeFrame* GetFrame() const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, L",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:21566,Deployability,update,update,21566," enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLViewer::fGLCtxId!for embedded gl viewer; Int_tTGLViewer::fGLDevice!for embedded gl viewer; TGLWidget*TGLViewer::fGLWidget; TGedEditor*TGLViewer::fGedEditor! GED editor; Bool_tTGLViewer::fIgnoreSizesOnUpdateignore sizes of bounding-boxes on update; Bool_tTGLViewer::fIsPrinting!; Short_tTGLViewerBase::fLODViewer-lod for rendering.; TGLColorSetTGLViewer::fLightColorSet! color-set with light background; TGLLightSet*TGLViewer::fLightSet!; Float_tTGLViewer::fLineScale! width scale for lines; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGLLockable::ELockTGLLockable::fLockLock state.; Float_tTGLViewer::fMaxSceneDrawTimeHQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewer::fMaxSceneDrawTimeLQ! max time f",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:23431,Deployability,update,update,23431,GLViewer::fMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCameraTGLViewer::fOrthoXOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXOZCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOZCamera!; TGLOrthoCameraTGLViewer::fOrthoZOYCamera!; TGLOrthoCameraTGLViewer::fOrthoZnOYCamera!; TGLBoundingBoxTGLViewerBase::fOverallBoundingBoxAxis-aligned union of scene bboxes.; vector<TGLOverlayElement*>TGLViewerBase::fOverlay; TGLOvlSelectRecordTGLViewer::fOvlSelRec! select record from last overlay select; TGLPShapeObj*TGLViewer::fPShapeWrap; TVirtualPad*TGLViewer::fPad! external pad - remove replace with signal; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOY!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOZ!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraYOZ!; TStringTGLViewer::fPictureFileName! default file-name for SavePicture(); Float_tTGLViewer::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLin,MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:23503,Deployability,update,update,23503,GLViewer::fMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCameraTGLViewer::fOrthoXOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXOZCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOZCamera!; TGLOrthoCameraTGLViewer::fOrthoZOYCamera!; TGLOrthoCameraTGLViewer::fOrthoZnOYCamera!; TGLBoundingBoxTGLViewerBase::fOverallBoundingBoxAxis-aligned union of scene bboxes.; vector<TGLOverlayElement*>TGLViewerBase::fOverlay; TGLOvlSelectRecordTGLViewer::fOvlSelRec! select record from last overlay select; TGLPShapeObj*TGLViewer::fPShapeWrap; TVirtualPad*TGLViewer::fPad! external pad - remove replace with signal; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOY!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOZ!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraYOZ!; TStringTGLViewer::fPictureFileName! default file-name for SavePicture(); Float_tTGLViewer::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLin,MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:27435,Integrability,message,message,27435,".; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:345,Modifiability,plugin,plugin,345,". TGLSAViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSAViewer. class TGLSAViewer: public TGLViewer. The top level standalone GL-viewer - created via plugin manager. Function Members (Methods); public:. TGLSAViewer(TVirtualPad* pad, TGLFormat* format = 0); TGLSAViewer(const TGWindow* parent, TVirtualPad* pad, TGedEditor* ged = 0, TGLFormat* format = 0); virtual~TGLSAViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLViewer::Activated()SIGNAL ; virtual voidTGLViewer::AddCompositeOp(UInt_t); virtual Int_tTGLViewer::AddObject(const TBuffer3D&, Bool_t* = 0); virtual Int_tTGLViewer::AddObject(UInt_t, const TBuffer3D&, Bool_t* = 0); virtual voidTGLViewerBase::AddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*TGLViewerBase::AddScene(TGLSceneBase* scene); virtual voidTObject::AppendPad(Option_t* option = """"); voidTGLViewer::ApplySelection(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidTGLViewer::AutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); virtual voidTGLViewer::BeginScene(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTGLViewer::BuildingScene() const; virtual Bool_tTGLViewer::CanLoopOnPrimitives() const; virtual voidTGLViewerBase::Changed(); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGLViewer::ClearCurrentOvlElm(); virtual voidTGLViewer::Clicked(TObject* obj)SIGNAL ; virtual voidTGLViewer::Clicked(TObject* obj, UInt_t button, UInt_t state)SIGNAL ; TGLClip*TGLViewerBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; voidC",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:24037,Performance,cache,cache,24037,"er::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. TGPopupMenu*fCameraMenu; Bool_tfDeleteMenuBar; TStringfDirName; TGPopupMenu*fFileMenu; TGPopupMenu*fFileSaveMenu; TGLFormat*fFormat; TGLSAFrame*fFrame; ",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:15403,Safety,timeout,timeout,15403,"tBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGLViewer::SetCameraOverlay(TGLCameraOverlay* m); voidTGLViewer::SetClearColor(Color_t col); voidTGLViewerBase::SetClip(TGLClip* p); voidTGLViewer::SetClipAutoUpdate(Bool_t x); voidTGLViewer::SetCurrentCamera(TGLViewer::ECameraType camera); voidTGLViewer::SetDrawCameraCenter(Bool_t x); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTGLViewer::SetEventHandler(TGEventHandler* handler); voidTGLViewer::SetFader(Float_t x); virtual voidTGLViewer::SetGedEditor(TGedEditor* ed); voidTGLViewer::SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); voidTGLViewer::SetIgnoreSizesOnUpdate(Bool_t v); voidTGLViewer::SetLineScale(Float_t s); voidTGLViewerBase::SetLOD(Short_t lod); voidTGLViewer::SetMaxSceneDrawTimeHQ(Float_t t); voidTGLViewer::SetMaxSceneDrawTimeLQ(Float_t t); static voidSetMenuHidingTimeout(Long_t timeout); static voidTObject::SetObjectStat(Bool_t stat); voidTGLViewerBase::SetOLLineW(Float_t w); voidTGLViewer::SetOrthoCamera(TGLViewer::ECameraType camera, Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); voidTGLViewer::SetPerspectiveCamera(TGLViewer::ECameraType camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); voidTGLViewer::SetPictureFileName(const TString& f); voidTGLViewer::SetPointScale(Float_t s); voidTGLViewer::SetResetCamerasOnUpdate(Bool_t v); voidTGLViewer::SetSmartRefresh(Bool_t smart_ref); voidTGLViewer::SetSmoothLines(Bool_t s); voidTGLViewer::SetSmoothPoints(Bool_t s); voidTGLViewer::SetStereo(Bool_t s); voidTGLViewer::SetStereoEyeOffsetFac(Float_t f); voidTGLViewer::SetStereoFrustumAsymFac(Float_t f); voidTGLViewer::SetStereoZeroParallax(Float_t f); voidTGLViewerBase::SetStyle(Short_t st); virtual voidTObject::SetUniqueID(UInt_t uid); voidTGLViewerBase::SetWFLineW(Float_t w); voidShow(); vi",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:27238,Safety,timeout,timeout,27238,"const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. ",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:27280,Safety,timeout,timeout,27280,"s an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general pl",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:27301,Safety,timeout,timeout,27301,"s an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general pl",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:24043,Testability,log,logicals,24043,"er::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. TGPopupMenu*fCameraMenu; Bool_tfDeleteMenuBar; TStringfDirName; TGPopupMenu*fFileMenu; TGPopupMenu*fFileSaveMenu; TGLFormat*fFormat; TGLSAFrame*fFrame; ",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLSAViewer.html:20313,Usability,guid,guides,20313,"GLSavePNG; kGLSaveGIF; kGLSaveAnimGIF; kGLSaveJPG; kGLSaveAS; kGLCloseViewer; kGLQuitROOT; kGLEditObject; kGLHideMenus; };; enum TGLViewer::ECameraType { kCameraPerspXOZ; kCameraPerspYOZ; kCameraPerspXOY; kCameraOrthoXOY; kCameraOrthoXOZ; kCameraOrthoZOY; kCameraOrthoXnOY; kCameraOrthoXnOZ; kCameraOrthoZnOY; };; enum TGLViewer::ESecSelType { kOnRequest; kOnKeyMod1; };; enum TGLViewer::EPushAction { kPushStd; kPushCamCenter; kPushAnnotate; };; enum TGLViewer::EDragAction { kDragNone; kDragCameraRotate; kDragCameraTruck; kDragCameraDolly; kDragOverlay; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLVi",MatchSource.WIKI,root/html530/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html
https://root.cern/root/html530/TGLScaleManip.html:544,Energy Efficiency,green,green,544,". TGLScaleManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScaleManip. class TGLScaleManip: public TGLManip. TGLScaleManip. Scale manipulator - attaches to physical shape and draws local axes; widgets with box heads. User can mouse over (turns yellow) and L; click/drag to scale along this axis.; Widgets use standard 3D package axes colours: X red, Y green, Z blue. Function Members (Methods); public:. TGLScaleManip(); TGLScaleManip(TGLPhysicalShape* shape); TGLScaleManip(const TGLScaleManip&); virtual~TGLScaleManip(); voidTGLManip::Attach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tTGLManip::GetActive() const; TGLPhysicalShape*TGLManip::GetAttached() const; UInt_tTGLManip::GetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tTGLManip::Select(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidTGLManip::SetActive(Bool_t a); voidTGLManip::SetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). private:. voidLimitScale(Double_t& factor) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; ",MatchSource.WIKI,root/html530/TGLScaleManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScaleManip.html
https://root.cern/root/html530/TGLScaleManip.html:2568,Energy Efficiency,green,green,2568,"base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). private:. voidLimitScale(Double_t& factor) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. private:. TGLVector3fStartScale! initial scaling factors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScaleManip(); Construct scale manipulator not bound to any physical shape. TGLScaleManip(TGLPhysicalShape* shape); Construct scale manipulator bound to TGLPhysicalShape 'shape'. ~TGLScaleManip(); Destory the scale manipulator. void Draw(const TGLCamera& camera) const; Draw scale manipulator - tubes with box heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleButton(const Event_t& event, const TGLCamera& camera); Handle mouse button event over manipulator - returns kTRUE if; redraw required kFALSE otherwise. Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) scale physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. void LimitScale(Double_t& factor) const; Clamp scale to sizable values: 1000 - 1/1000; Guards against div by zero problems. TGLScaleManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLScaleManip.h 30815 2009-10-20 13:49:22Z rdm $ » Last generated: 2011-07-04 15:29; This page has been automatically gen",MatchSource.WIKI,root/html530/TGLScaleManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScaleManip.html
https://root.cern/root/html530/TGLScene.html:10981,Availability,error,error,10981,"wElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:2368,Deployability,update,updateViewers,2368, TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ,MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:6264,Deployability,update,update,6264,"Int_t phid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx). protected:. virtual voidDestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); voidReleaseGLCtxIdentity(). private:. TGLScene(const TGLScene&); static Bool_tComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); static Bool_tComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); TGLScene&operator=(const TGLScene&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; TGLClip*TGLSceneBase::fClipScene clipping-plane.; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*fGLCtxIdentity; Bool_tfInSmartRefresh!; Short_tTGLSceneBase::fLODScene-lod.; Float_tfLastLineWidthScale; Float_tfLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneB",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:6890,Deployability,update,update,6890,"ysicalShape* shape1, const TGLPhysicalShape* shape2); static Bool_tComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); TGLScene&operator=(const TGLScene&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; TGLClip*TGLSceneBase::fClipScene clipping-plane.; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*fGLCtxIdentity; Bool_tfInSmartRefresh!; Short_tTGLSceneBase::fLODScene-lod.; Float_tfLastLineWidthScale; Float_tfLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScene(); {}. ~TGLScene(); Destroy scene objects. void ReleaseGLCtxIdentity(); Release all GL resources for current context identity.; Requires iteration over all logical shapes. Bool_t ComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); C",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:7318,Deployability,update,update,7318,"o access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; TGLClip*TGLSceneBase::fClipScene clipping-plane.; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*fGLCtxIdentity; Bool_tfInSmartRefresh!; Short_tTGLSceneBase::fLODScene-lod.; Float_tfLastLineWidthScale; Float_tfLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScene(); {}. ~TGLScene(); Destroy scene objects. void ReleaseGLCtxIdentity(); Release all GL resources for current context identity.; Requires iteration over all logical shapes. Bool_t ComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. Bool_t ComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. void RebuildSceneInfo(TGLRnrCtx& rnrCtx); Major change in scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by sh",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:12061,Deployability,update,update,12061,"l logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:12183,Deployability,update,updateViewers,12183,"* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject*",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:12218,Deployability,update,update,12218,"* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject*",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:12518,Deployability,update,updateViewers,12518,"o perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate c",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:12637,Deployability,update,updateViewers,12637,"e defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in ref",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:605,Integrability,interface,interface,605,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:8957,Integrability,depend,dependant,8957,"ComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. void RebuildSceneInfo(TGLRnrCtx& rnrCtx); Major change in scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Here we have to iterate over all the physical shapes and select; the visible ones. While at it, opaque and transparent shapes are; divided into two groups. void LodifySceneInfo(TGLRnrCtx& rnrCtx); Setup LOD-dependant values in scene-info.; We have to perform LOD quantization for all draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void Re",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:477,Performance,load,loaded,477,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:9001,Performance,perform,perform,9001,"alShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. void RebuildSceneInfo(TGLRnrCtx& rnrCtx); Major change in scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Here we have to iterate over all the physical shapes and select; the visible ones. While at it, opaque and transparent shapes are; divided into two groups. void LodifySceneInfo(TGLRnrCtx& rnrCtx); Setup LOD-dependant values in scene-info.; We have to perform LOD quantization for all draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, B",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:11562,Performance,perform,perform,11562,"apsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (defa",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:13560,Performance,cache,cache,13560,"pdateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary expo",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:13680,Performance,cache,cache,13680," be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context hol",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:13816,Performance,cache,cache,13816,"eLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context holding display-list definitions. { return fGLCtxIdentity; }. » Author: Matevz Tadel, Feb 2007 » Co",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:10122,Safety,timeout,timeout,10122,"draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:6294,Security,access,access,6294,"Int_t phid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx). protected:. virtual voidDestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); voidReleaseGLCtxIdentity(). private:. TGLScene(const TGLScene&); static Bool_tComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); static Bool_tComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); TGLScene&operator=(const TGLScene&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; TGLClip*TGLSceneBase::fClipScene clipping-plane.; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*fGLCtxIdentity; Bool_tfInSmartRefresh!; Short_tTGLSceneBase::fLODScene-lod.; Float_tfLastLineWidthScale; Float_tfLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneB",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:381,Testability,log,logical,381,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:731,Testability,log,logical,731,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:2091,Testability,log,logid,2091, TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ,MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:2437,Testability,log,logid,2437, TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ,MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:5239,Testability,log,logid,5239,"TGLSceneBase::PreRender(TGLRnrCtx& rnrCtx); virtual voidRebuildSceneInfo(TGLRnrCtx& rnrCtx); TGLScene::LogicalShapeMap_t&RefLogicalShapes(); Bool_tTGLLockable::ReleaseLock(TGLLockable::ELock lock) const; voidTGLSceneBase::RemoveViewer(TGLViewerBase* viewer); virtual voidTGLSceneBase::Render(TGLRnrCtx& rnrCtx); virtual voidRenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); virtual voidRenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); virtual voidRenderOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelTransp(TGLRnrCtx& rnrCtx); virtual voidRenderTransp(TGLRnrCtx& rnrCtx); virtual Bool_tResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); static voidRGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); voidTGLSceneBase::SetAutoDestruct(Bool_t a); voidTGLSceneBase::SetClip(TGLClip* p); voidTGLSceneBase::SetLOD(Short_t lod); virtual voidTGLSceneBase::SetName(const char* name); virtual voidTGLSceneBase::SetNameTitle(const char* name, const char* title); voidTGLSceneBase::SetSelectable(Bool_t a); voidTGLSceneBase::SetStyle(Short_t st); virtual voidTGLSceneBase::SetTitle(const char* title); virtual voidShowMembers(TMemberInspector& insp); UInt_tSizeOfScene() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tTGLSceneBase::Style() const; voidTGLSceneBase::TagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateLogical(TObject* logid); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx).",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:5457,Testability,log,logid,5457,"TGLSceneBase::PreRender(TGLRnrCtx& rnrCtx); virtual voidRebuildSceneInfo(TGLRnrCtx& rnrCtx); TGLScene::LogicalShapeMap_t&RefLogicalShapes(); Bool_tTGLLockable::ReleaseLock(TGLLockable::ELock lock) const; voidTGLSceneBase::RemoveViewer(TGLViewerBase* viewer); virtual voidTGLSceneBase::Render(TGLRnrCtx& rnrCtx); virtual voidRenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); virtual voidRenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); virtual voidRenderOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelTransp(TGLRnrCtx& rnrCtx); virtual voidRenderTransp(TGLRnrCtx& rnrCtx); virtual Bool_tResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); static voidRGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); voidTGLSceneBase::SetAutoDestruct(Bool_t a); voidTGLSceneBase::SetClip(TGLClip* p); voidTGLSceneBase::SetLOD(Short_t lod); virtual voidTGLSceneBase::SetName(const char* name); virtual voidTGLSceneBase::SetNameTitle(const char* name, const char* title); voidTGLSceneBase::SetSelectable(Bool_t a); voidTGLSceneBase::SetStyle(Short_t st); virtual voidTGLSceneBase::SetTitle(const char* title); virtual voidShowMembers(TMemberInspector& insp); UInt_tSizeOfScene() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tTGLSceneBase::Style() const; voidTGLSceneBase::TagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateLogical(TObject* logid); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx).",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:5537,Testability,log,logid,5537,"TGLSceneBase::PreRender(TGLRnrCtx& rnrCtx); virtual voidRebuildSceneInfo(TGLRnrCtx& rnrCtx); TGLScene::LogicalShapeMap_t&RefLogicalShapes(); Bool_tTGLLockable::ReleaseLock(TGLLockable::ELock lock) const; voidTGLSceneBase::RemoveViewer(TGLViewerBase* viewer); virtual voidTGLSceneBase::Render(TGLRnrCtx& rnrCtx); virtual voidRenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); virtual voidRenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); virtual voidRenderOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelTransp(TGLRnrCtx& rnrCtx); virtual voidRenderTransp(TGLRnrCtx& rnrCtx); virtual Bool_tResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); static voidRGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); voidTGLSceneBase::SetAutoDestruct(Bool_t a); voidTGLSceneBase::SetClip(TGLClip* p); voidTGLSceneBase::SetLOD(Short_t lod); virtual voidTGLSceneBase::SetName(const char* name); virtual voidTGLSceneBase::SetNameTitle(const char* name, const char* title); voidTGLSceneBase::SetSelectable(Bool_t a); voidTGLSceneBase::SetStyle(Short_t st); virtual voidTGLSceneBase::SetTitle(const char* title); virtual voidShowMembers(TMemberInspector& insp); UInt_tSizeOfScene() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tTGLSceneBase::Style() const; voidTGLSceneBase::TagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateLogical(TObject* logid); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx).",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:7727,Testability,log,logical,7727,"ointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScene(); {}. ~TGLScene(); Destroy scene objects. void ReleaseGLCtxIdentity(); Release all GL resources for current context identity.; Requires iteration over all logical shapes. Bool_t ComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. Bool_t ComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. void RebuildSceneInfo(TGLRnrCtx& rnrCtx); Major change in scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (view",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:9233,Testability,log,logicals,9233,"scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Here we have to iterate over all the physical shapes and select; the visible ones. While at it, opaque and transparent shapes are; divided into two groups. void LodifySceneInfo(TGLRnrCtx& rnrCtx); Setup LOD-dependant values in scene-info.; We have to perform LOD quantization for all draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipp",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:10159,Testability,test,test,10159," shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:10716,Testability,log,logical,10716,"rCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:10824,Testability,log,logid,10824,"transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phi",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:10865,Testability,log,logical,10865,"transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phi",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:11006,Testability,log,logical,11006,"wElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:11066,Testability,log,logical,11066," clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene i",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:11119,Testability,log,logicals,11119,"c with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:11168,Testability,log,logid,11168,"t its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t u",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:11198,Testability,log,logical,11198,"t its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t u",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:11233,Testability,log,logid,11233,"t its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t u",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:12772,Testability,log,logid,12772," shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqi",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:12807,Testability,log,logical,12807," shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqi",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:13168,Testability,log,logid,13168,"ene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:13245,Testability,log,logical,13245,"ene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and ",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:13330,Testability,log,logid,13330,"colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLSce",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:13423,Testability,log,logical,13423,"colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLSce",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:13508,Testability,log,logicals,13508,"pdateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary expo",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:13660,Testability,log,logicals,13660," be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context hol",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:13765,Testability,log,logical,13765,"eLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context holding display-list definitions. { return fGLCtxIdentity; }. » Author: Matevz Tadel, Feb 2007 » Co",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
https://root.cern/root/html530/TGLScene.html:13978,Testability,log,logical,13978,"cal shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context holding display-list definitions. { return fGLCtxIdentity; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLScene.h 32334 2010-02-12 11:52:13Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root/html530/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGLScene.html
