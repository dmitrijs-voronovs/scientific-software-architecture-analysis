id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/RVec_8hxx_source.html:24919,Usability,clear,clear,24919,"/// Append \p NumInputs copies of \p Elt to the end.; 665 void append(size_type NumInputs, const T &Elt); 666 {; 667 if (NumInputs > this->capacity() - this->size()); 668 this->grow(this->size() + NumInputs);; 669 ; 670 std::uninitialized_fill_n(this->end(), NumInputs, Elt);; 671 this->set_size(this->size() + NumInputs);; 672 }; 673 ; 674 void append(std::initializer_list<T> IL) { append(IL.begin(), IL.end()); }; 675 ; 676 // from the original LLVM implementation:; 677 // FIXME: Consider assigning over existing elements, rather than clearing &; 678 // re-initializing them - for all assign(...) variants.; 679 ; 680 void assign(size_type NumElts, const T &Elt); 681 {; 682 clear();; 683 if (this->capacity() < NumElts); 684 this->grow(NumElts);; 685 this->set_size(NumElts);; 686 std::uninitialized_fill(this->begin(), this->end(), Elt);; 687 }; 688 ; 689 template <typename in_iter,; 690 typename = typename std::enable_if<std::is_convertible<; 691 typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type>; 692 void assign(in_iter in_start, in_iter in_end); 693 {; 694 clear();; 695 append(in_start, in_end);; 696 }; 697 ; 698 void assign(std::initializer_list<T> IL); 699 {; 700 clear();; 701 append(IL);; 702 }; 703 ; 704 iterator erase(const_iterator CI); 705 {; 706 // Just cast away constness because this is a non-const member function.; 707 iterator I = const_cast<iterator>(CI);; 708 ; 709 if (I < this->begin() || I >= this->end()) {; 710 throw std::runtime_error(""The iterator passed to `erase` is out of bounds."");; 711 }; 712 ; 713 iterator N = I;; 714 // Shift all elts down one.; 715 std::move(I + 1, this->end(), I);; 716 // Drop the last elt.; 717 this->pop_back();; 718 return (N);; 719 }; 720 ; 721 iterator erase(const_iterator CS, const_iterator CE); 722 {; 723 // Just cast away constness because this is a non-const member function.; 724 iterator S = const_cast<iterator>(CS);; 725 iterator E = const_cast<iterator>(CE);; 726 ; 72",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:25030,Usability,clear,clear,25030,"/// Append \p NumInputs copies of \p Elt to the end.; 665 void append(size_type NumInputs, const T &Elt); 666 {; 667 if (NumInputs > this->capacity() - this->size()); 668 this->grow(this->size() + NumInputs);; 669 ; 670 std::uninitialized_fill_n(this->end(), NumInputs, Elt);; 671 this->set_size(this->size() + NumInputs);; 672 }; 673 ; 674 void append(std::initializer_list<T> IL) { append(IL.begin(), IL.end()); }; 675 ; 676 // from the original LLVM implementation:; 677 // FIXME: Consider assigning over existing elements, rather than clearing &; 678 // re-initializing them - for all assign(...) variants.; 679 ; 680 void assign(size_type NumElts, const T &Elt); 681 {; 682 clear();; 683 if (this->capacity() < NumElts); 684 this->grow(NumElts);; 685 this->set_size(NumElts);; 686 std::uninitialized_fill(this->begin(), this->end(), Elt);; 687 }; 688 ; 689 template <typename in_iter,; 690 typename = typename std::enable_if<std::is_convertible<; 691 typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type>; 692 void assign(in_iter in_start, in_iter in_end); 693 {; 694 clear();; 695 append(in_start, in_end);; 696 }; 697 ; 698 void assign(std::initializer_list<T> IL); 699 {; 700 clear();; 701 append(IL);; 702 }; 703 ; 704 iterator erase(const_iterator CI); 705 {; 706 // Just cast away constness because this is a non-const member function.; 707 iterator I = const_cast<iterator>(CI);; 708 ; 709 if (I < this->begin() || I >= this->end()) {; 710 throw std::runtime_error(""The iterator passed to `erase` is out of bounds."");; 711 }; 712 ; 713 iterator N = I;; 714 // Shift all elts down one.; 715 std::move(I + 1, this->end(), I);; 716 // Drop the last elt.; 717 this->pop_back();; 718 return (N);; 719 }; 720 ; 721 iterator erase(const_iterator CS, const_iterator CE); 722 {; 723 // Just cast away constness because this is a non-const member function.; 724 iterator S = const_cast<iterator>(CS);; 725 iterator E = const_cast<iterator>(CE);; 726 ; 72",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:28916,Usability,simpl,simple,28916,"s->size() + 1);; 793 ; 794 // If we just moved the element we're inserting, be sure to update; 795 // the reference.; 796 const T *EltPtr = &Elt;; 797 if (I <= EltPtr && EltPtr < this->end()); 798 ++EltPtr;; 799 ; 800 *I = *EltPtr;; 801 return I;; 802 }; 803 ; 804 iterator insert(iterator I, size_type NumToInsert, const T &Elt); 805 {; 806 // Convert iterator to elt# to avoid invalidating iterator when we reserve(); 807 size_t InsertElt = I - this->begin();; 808 ; 809 if (I == this->end()) { // Important special case for empty vector.; 810 append(NumToInsert, Elt);; 811 return this->begin() + InsertElt;; 812 }; 813 ; 814 if (I < this->begin() || I > this->end()) {; 815 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 816 }; 817 ; 818 // Ensure there is enough space.; 819 reserve(this->size() + NumToInsert);; 820 ; 821 // Uninvalidate the iterator.; 822 I = this->begin() + InsertElt;; 823 ; 824 // If there are more elements between the insertion point and the end of the; 825 // range than there are being inserted, we can use a simple approach to; 826 // insertion. Since we already reserved space, we know that this won't; 827 // reallocate the vector.; 828 if (size_t(this->end() - I) >= NumToInsert) {; 829 T *OldEnd = this->end();; 830 append(std::move_iterator<iterator>(this->end() - NumToInsert), std::move_iterator<iterator>(this->end()));; 831 ; 832 // Copy the existing elements that get replaced.; 833 std::move_backward(I, OldEnd - NumToInsert, OldEnd);; 834 ; 835 std::fill_n(I, NumToInsert, Elt);; 836 return I;; 837 }; 838 ; 839 // Otherwise, we're inserting more elements than exist already, and we're; 840 // not inserting at the end.; 841 ; 842 // Move over the elements that we're about to overwrite.; 843 T *OldEnd = this->end();; 844 this->set_size(this->size() + NumToInsert);; 845 size_t NumOverwritten = OldEnd - I;; 846 this->uninitialized_move(I, OldEnd, this->end() - NumOverwritten);; 847 ; 848 // Replace the overwritten part.",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:31080,Usability,simpl,simple,31080,", Elt);; 853 return I;; 854 }; 855 ; 856 template <typename ItTy,; 857 typename = typename std::enable_if<std::is_convertible<; 858 typename std::iterator_traits<ItTy>::iterator_category, std::input_iterator_tag>::value>::type>; 859 iterator insert(iterator I, ItTy From, ItTy To); 860 {; 861 // Convert iterator to elt# to avoid invalidating iterator when we reserve(); 862 size_t InsertElt = I - this->begin();; 863 ; 864 if (I == this->end()) { // Important special case for empty vector.; 865 append(From, To);; 866 return this->begin() + InsertElt;; 867 }; 868 ; 869 if (I < this->begin() || I > this->end()) {; 870 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 871 }; 872 ; 873 size_t NumToInsert = std::distance(From, To);; 874 ; 875 // Ensure there is enough space.; 876 reserve(this->size() + NumToInsert);; 877 ; 878 // Uninvalidate the iterator.; 879 I = this->begin() + InsertElt;; 880 ; 881 // If there are more elements between the insertion point and the end of the; 882 // range than there are being inserted, we can use a simple approach to; 883 // insertion. Since we already reserved space, we know that this won't; 884 // reallocate the vector.; 885 if (size_t(this->end() - I) >= NumToInsert) {; 886 T *OldEnd = this->end();; 887 append(std::move_iterator<iterator>(this->end() - NumToInsert), std::move_iterator<iterator>(this->end()));; 888 ; 889 // Copy the existing elements that get replaced.; 890 std::move_backward(I, OldEnd - NumToInsert, OldEnd);; 891 ; 892 std::copy(From, To, I);; 893 return I;; 894 }; 895 ; 896 // Otherwise, we're inserting more elements than exist already, and we're; 897 // not inserting at the end.; 898 ; 899 // Move over the elements that we're about to overwrite.; 900 T *OldEnd = this->end();; 901 this->set_size(this->size() + NumToInsert);; 902 size_t NumOverwritten = OldEnd - I;; 903 this->uninitialized_move(I, OldEnd, this->end() - NumOverwritten);; 904 ; 905 // Replace the overwritten part.; 906 for ",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:36739,Usability,clear,clear,36739,"allows us to avoid copying them during the grow.; 1024 // From the original LLVM implementation:; 1025 // FIXME: don't do this if they're efficiently moveable.; 1026 if (this->capacity() < RHSSize) {; 1027 if (this->Owns()) {; 1028 // Destroy current elements.; 1029 this->destroy_range(this->begin(), this->end());; 1030 }; 1031 this->set_size(0);; 1032 CurSize = 0;; 1033 this->grow(RHSSize);; 1034 } else if (CurSize) {; 1035 // Otherwise, use assignment for the already-constructed elements.; 1036 std::copy(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1037 }; 1038 ; 1039 // Copy construct the new elements in place.; 1040 this->uninitialized_copy(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1041 ; 1042 // Set end.; 1043 this->set_size(RHSSize);; 1044 return *this;; 1045}; 1046 ; 1047template <typename T>; 1048RVecImpl<T> &RVecImpl<T>::operator=(RVecImpl<T> &&RHS); 1049{; 1050 // Avoid self-assignment.; 1051 if (this == &RHS); 1052 return *this;; 1053 ; 1054 // If the RHS isn't small, clear this vector and then steal its buffer.; 1055 if (!RHS.isSmall()) {; 1056 if (this->Owns()) {; 1057 this->destroy_range(this->begin(), this->end());; 1058 if (!this->isSmall()); 1059 free(this->begin());; 1060 }; 1061 this->fBeginX = RHS.fBeginX;; 1062 this->fSize = RHS.fSize;; 1063 this->fCapacity = RHS.fCapacity;; 1064 RHS.resetToSmall();; 1065 return *this;; 1066 }; 1067 ; 1068 // If we already have sufficient space, assign the common elements, then; 1069 // destroy any excess.; 1070 size_t RHSSize = RHS.size();; 1071 size_t CurSize = this->size();; 1072 if (CurSize >= RHSSize) {; 1073 // Assign common elements.; 1074 iterator NewEnd = this->begin();; 1075 if (RHSSize); 1076 NewEnd = std::move(RHS.begin(), RHS.end(), NewEnd);; 1077 ; 1078 // Destroy excess elements and trim the bounds.; 1079 if (this->Owns()); 1080 this->destroy_range(NewEnd, this->end());; 1081 this->set_size(RHSSize);; 1082 ; 1083 // Clear the RHS.; 1084 RHS.clear();; 1085 ; 1086 return *t",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:37688,Usability,clear,clear,37688,"or and then steal its buffer.; 1055 if (!RHS.isSmall()) {; 1056 if (this->Owns()) {; 1057 this->destroy_range(this->begin(), this->end());; 1058 if (!this->isSmall()); 1059 free(this->begin());; 1060 }; 1061 this->fBeginX = RHS.fBeginX;; 1062 this->fSize = RHS.fSize;; 1063 this->fCapacity = RHS.fCapacity;; 1064 RHS.resetToSmall();; 1065 return *this;; 1066 }; 1067 ; 1068 // If we already have sufficient space, assign the common elements, then; 1069 // destroy any excess.; 1070 size_t RHSSize = RHS.size();; 1071 size_t CurSize = this->size();; 1072 if (CurSize >= RHSSize) {; 1073 // Assign common elements.; 1074 iterator NewEnd = this->begin();; 1075 if (RHSSize); 1076 NewEnd = std::move(RHS.begin(), RHS.end(), NewEnd);; 1077 ; 1078 // Destroy excess elements and trim the bounds.; 1079 if (this->Owns()); 1080 this->destroy_range(NewEnd, this->end());; 1081 this->set_size(RHSSize);; 1082 ; 1083 // Clear the RHS.; 1084 RHS.clear();; 1085 ; 1086 return *this;; 1087 }; 1088 ; 1089 // If we have to grow to have enough elements, destroy the current elements.; 1090 // This allows us to avoid copying them during the grow.; 1091 // From the original LLVM implementation:; 1092 // FIXME: this may not actually make any sense if we can efficiently move; 1093 // elements.; 1094 if (this->capacity() < RHSSize) {; 1095 if (this->Owns()) {; 1096 // Destroy current elements.; 1097 this->destroy_range(this->begin(), this->end());; 1098 }; 1099 this->set_size(0);; 1100 CurSize = 0;; 1101 this->grow(RHSSize);; 1102 } else if (CurSize) {; 1103 // Otherwise, use assignment for the already-constructed elements.; 1104 std::move(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1105 }; 1106 ; 1107 // Move-construct the new elements in place.; 1108 this->uninitialized_move(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1109 ; 1110 // Set end.; 1111 this->set_size(RHSSize);; 1112 ; 1113 RHS.clear();; 1114 return *this;; 1115}; 1116 ; 1117template <typename T>; 1118bool IsSmall(c",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:38666,Usability,clear,clear,38666," ; 1089 // If we have to grow to have enough elements, destroy the current elements.; 1090 // This allows us to avoid copying them during the grow.; 1091 // From the original LLVM implementation:; 1092 // FIXME: this may not actually make any sense if we can efficiently move; 1093 // elements.; 1094 if (this->capacity() < RHSSize) {; 1095 if (this->Owns()) {; 1096 // Destroy current elements.; 1097 this->destroy_range(this->begin(), this->end());; 1098 }; 1099 this->set_size(0);; 1100 CurSize = 0;; 1101 this->grow(RHSSize);; 1102 } else if (CurSize) {; 1103 // Otherwise, use assignment for the already-constructed elements.; 1104 std::move(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1105 }; 1106 ; 1107 // Move-construct the new elements in place.; 1108 this->uninitialized_move(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1109 ; 1110 // Set end.; 1111 this->set_size(RHSSize);; 1112 ; 1113 RHS.clear();; 1114 return *this;; 1115}; 1116 ; 1117template <typename T>; 1118bool IsSmall(const ROOT::VecOps::RVec<T> &v); 1119{; 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typename T>; 1124bool IsAdopting(const ROOT::VecOps::RVec<T> &v); 1125{; 1126 return !v.Owns();; 1127}; 1128 ; 1129} // namespace VecOps; 1130} // namespace Detail; 1131 ; 1132namespace VecOps {; 1133// Note that we open here with @{ the Doxygen group vecops and it is; 1134// closed again at the end of the C++ namespace VecOps; 1135/**; 1136 * \defgroup vecops VecOps; 1137 * A ""std::vector""-like collection of values implementing handy operation to analyse them; 1138 * @{; 1139*/; 1140 ; 1141// From the original SmallVector code:; 1142// This is a 'vector' (really, a variable-sized array), optimized; 1143// for the case when the array is small. It contains some number of elements; 1144// in-place, which allows it to avoid heap allocation when the actual number of; 1145// elements is below that threshold. This allows normal ""small"" cases to be; 1146// fast without losing general",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:46111,Usability,simpl,simply,46111,"tor[](pos);; 1311 }; 1312 ; 1313 /// No exception thrown. The user specifies the desired value in case the RVecN is shorter than `pos`.; 1314 value_type at(size_type pos, value_type fallback) const; 1315 {; 1316 if (pos >= size_type(this->fSize)); 1317 return fallback;; 1318 return this->operator[](pos);; 1319 }; 1320};; 1321 ; 1322// clang-format off; 1323/**; 1324\class ROOT::VecOps::RVec; 1325\brief A ""std::vector""-like collection of values implementing handy operation to analyse them; 1326\tparam T The type of the contained objects; 1327 ; 1328A RVec is a container designed to make analysis of values' collections fast and easy.; 1329Its storage is contiguous in memory and its interface is designed such to resemble to the one; 1330of the stl vector. In addition the interface features methods and; 1331[external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; 1332of the data in the RVec.; 1333 ; 1334\note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; 1335are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; 1336- RVecB (`bool`); 1337- RVecC (`char`); 1338- RVecD (`double`); 1339- RVecF (`float`); 1340- RVecI (`int`); 1341- RVecL (`long`); 1342- RVecLL (`long long`); 1343- RVecU (`unsigned`); 1344- RVecUL (`unsigned long`); 1345- RVecULL (`unsigned long long`); 1346 ; 1347\note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; 1348other operations will be propagated potentially leaving the RVec object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; 1351to make RVec a drop-in replacement for `std::vector`.; 1352 ; 1353\htmlonly; 1354<a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:50536,Usability,simpl,simply,50536," <, >, ==, !=, <=, >=, &&, ||; 1410 - ~, !; 1411 - &, |, ^; 1412 - &=, |=, ^=; 1413 - <<=, >>=; 1414 ; 1415The most common mathematical functions are supported. It is possible to invoke them passing ; 1416RVecs as arguments.; 1417 - abs, fdim, fmod, remainder; 1418 - floor, ceil, trunc, round, lround, llround; 1419 - exp, exp2, expm1; 1420 - log, log10, log2, log1p; 1421 - pow; 1422 - sqrt, cbrt; 1423 - sin, cos, tan, asin, acos, atan, atan2, hypot; 1424 - sinh, cosh, tanh, asinh, acosh; 1425 - erf, erfc; 1426 - lgamma, tgamma; 1427 ; 1428If the VDT library is available, the following functions can be invoked. Internally the calculations; 1429are vectorized:; 1430 - fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; 1431 - fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan; 1432 ; 1433\anchor owningandadoptingmemory; 1434## Owning and adopting memory; 1435RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case,; 1436it can be constructed with the address of the memory associated to it and its length. For example:; 1437~~~{.cpp}; 1438std::vector<int> myStlVec {1,2,3};; 1439RVec<int> myRVec(myStlVec.data(), myStlVec.size());; 1440~~~; 1441In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"".; 1442If any method which implies a re-allocation is called, e.g. *emplace_back* or *resize*, the adopted; 1443memory is released and new one is allocated. The previous content is copied in the new memory and; 1444preserved.; 1445 ; 1446\anchor sorting; 1447## Sorting and manipulation of indices; 1448 ; 1449### Sorting; 1450RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms; 1451can be used, for example sorting:; 1452~~~{.cpp}; 1453RVec<double> v{6., 4., 5.};; 1454std::sort(v.begin(), v.end());; 1455~~~; 1456 ; 1457For convenience, helpers are provided too:; 1458~~~{.cpp}; 1459au",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:50882,Usability,simpl,simply,50882,"ound; 1419 - exp, exp2, expm1; 1420 - log, log10, log2, log1p; 1421 - pow; 1422 - sqrt, cbrt; 1423 - sin, cos, tan, asin, acos, atan, atan2, hypot; 1424 - sinh, cosh, tanh, asinh, acosh; 1425 - erf, erfc; 1426 - lgamma, tgamma; 1427 ; 1428If the VDT library is available, the following functions can be invoked. Internally the calculations; 1429are vectorized:; 1430 - fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; 1431 - fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan; 1432 ; 1433\anchor owningandadoptingmemory; 1434## Owning and adopting memory; 1435RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case,; 1436it can be constructed with the address of the memory associated to it and its length. For example:; 1437~~~{.cpp}; 1438std::vector<int> myStlVec {1,2,3};; 1439RVec<int> myRVec(myStlVec.data(), myStlVec.size());; 1440~~~; 1441In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"".; 1442If any method which implies a re-allocation is called, e.g. *emplace_back* or *resize*, the adopted; 1443memory is released and new one is allocated. The previous content is copied in the new memory and; 1444preserved.; 1445 ; 1446\anchor sorting; 1447## Sorting and manipulation of indices; 1448 ; 1449### Sorting; 1450RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms; 1451can be used, for example sorting:; 1452~~~{.cpp}; 1453RVec<double> v{6., 4., 5.};; 1454std::sort(v.begin(), v.end());; 1455~~~; 1456 ; 1457For convenience, helpers are provided too:; 1458~~~{.cpp}; 1459auto sorted_v = Sort(v);; 1460auto reversed_v = Reverse(v);; 1461~~~; 1462 ; 1463### Manipulation of indices; 1464 ; 1465It is also possible to manipulated the RVecs acting on their indices. For example,; 1466the following syntax; 1467~~~{.cpp}; 1468RVecD v0 {9., 7., 8.};; 1469auto v1 = Take(v0, {1, 2, 0});",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:134106,Usability,clear,clearvoid,134106,"T &Elt)Definition RVec.hxx:804; ROOT::Detail::VecOps::RVecImpl::pop_back_valT pop_back_val()Definition RVec.hxx:641; ROOT::Detail::VecOps::RVecImpl::~RVecImpl~RVecImpl()Definition RVec.hxx:577; ROOT::Detail::VecOps::RVecImpl::operator=RVecImpl & operator=(const RVecImpl &RHS)Definition RVec.hxx:995; ROOT::Detail::VecOps::RVecImpl::eraseiterator erase(const_iterator CS, const_iterator CE)Definition RVec.hxx:721; ROOT::Detail::VecOps::RVecImpl::referencetypename SuperClass::reference referenceDefinition RVec.hxx:567; ROOT::Detail::VecOps::RVecImpl::appendvoid append(size_type NumInputs, const T &Elt)Append NumInputs copies of Elt to the end.Definition RVec.hxx:665; ROOT::Detail::VecOps::RVecImpl::eraseiterator erase(const_iterator CI)Definition RVec.hxx:704; ROOT::Detail::VecOps::RVecImpl::operator=RVecImpl & operator=(RVecImpl &&RHS)Definition RVec.hxx:1048; ROOT::Detail::VecOps::RVecImpl::pop_back_nvoid pop_back_n(size_type NumItems)Definition RVec.hxx:631; ROOT::Detail::VecOps::RVecImpl::clearvoid clear()Definition RVec.hxx:586; ROOT::Detail::VecOps::RVecImpl::RVecImplRVecImpl(const RVecImpl &)=delete; ROOT::Detail::VecOps::RVecImpl::appendvoid append(std::initializer_list< T > IL)Definition RVec.hxx:674; ROOT::Detail::VecOps::RVecImpl::insertvoid insert(iterator I, std::initializer_list< T > IL)Definition RVec.hxx:917; ROOT::Internal::VecOps::SmallVectorBaseThis is all the stuff common to all SmallVectors.Definition RVec.hxx:138; ROOT::Internal::VecOps::SmallVectorBase::SmallVectorBaseSmallVectorBase()=delete; ROOT::Internal::VecOps::SmallVectorBase::SmallVectorBaseSmallVectorBase(void *FirstEl, size_t TotalCapacity)Definition RVec.hxx:156; ROOT::Internal::VecOps::SmallVectorBase::SizeTypeMaxstatic constexpr size_t SizeTypeMax()The maximum value of the Size_T used.Definition RVec.hxx:153; ROOT::Internal::VecOps::SmallVectorBase::fCapacitySize_T fCapacityAlways >= -1. fCapacity == -1 indicates the RVec is in ""memory adoption"" mode.Definition RVec.hxx:150; ROOT::Int",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:134116,Usability,clear,clear,134116,"T &Elt)Definition RVec.hxx:804; ROOT::Detail::VecOps::RVecImpl::pop_back_valT pop_back_val()Definition RVec.hxx:641; ROOT::Detail::VecOps::RVecImpl::~RVecImpl~RVecImpl()Definition RVec.hxx:577; ROOT::Detail::VecOps::RVecImpl::operator=RVecImpl & operator=(const RVecImpl &RHS)Definition RVec.hxx:995; ROOT::Detail::VecOps::RVecImpl::eraseiterator erase(const_iterator CS, const_iterator CE)Definition RVec.hxx:721; ROOT::Detail::VecOps::RVecImpl::referencetypename SuperClass::reference referenceDefinition RVec.hxx:567; ROOT::Detail::VecOps::RVecImpl::appendvoid append(size_type NumInputs, const T &Elt)Append NumInputs copies of Elt to the end.Definition RVec.hxx:665; ROOT::Detail::VecOps::RVecImpl::eraseiterator erase(const_iterator CI)Definition RVec.hxx:704; ROOT::Detail::VecOps::RVecImpl::operator=RVecImpl & operator=(RVecImpl &&RHS)Definition RVec.hxx:1048; ROOT::Detail::VecOps::RVecImpl::pop_back_nvoid pop_back_n(size_type NumItems)Definition RVec.hxx:631; ROOT::Detail::VecOps::RVecImpl::clearvoid clear()Definition RVec.hxx:586; ROOT::Detail::VecOps::RVecImpl::RVecImplRVecImpl(const RVecImpl &)=delete; ROOT::Detail::VecOps::RVecImpl::appendvoid append(std::initializer_list< T > IL)Definition RVec.hxx:674; ROOT::Detail::VecOps::RVecImpl::insertvoid insert(iterator I, std::initializer_list< T > IL)Definition RVec.hxx:917; ROOT::Internal::VecOps::SmallVectorBaseThis is all the stuff common to all SmallVectors.Definition RVec.hxx:138; ROOT::Internal::VecOps::SmallVectorBase::SmallVectorBaseSmallVectorBase()=delete; ROOT::Internal::VecOps::SmallVectorBase::SmallVectorBaseSmallVectorBase(void *FirstEl, size_t TotalCapacity)Definition RVec.hxx:156; ROOT::Internal::VecOps::SmallVectorBase::SizeTypeMaxstatic constexpr size_t SizeTypeMax()The maximum value of the Size_T used.Definition RVec.hxx:153; ROOT::Internal::VecOps::SmallVectorBase::fCapacitySize_T fCapacityAlways >= -1. fCapacity == -1 indicates the RVec is in ""memory adoption"" mode.Definition RVec.hxx:150; ROOT::Int",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVersion_8h.html:540,Deployability,update,updated,540,". ROOT: core/foundation/inc/RVersion.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros ; RVersion.h File Reference. #include ""ROOT/RVersion.hxx"". Include dependency graph for RVersion.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ROOT_RELEASE_TIME   ""00:00:00"" /* not updated anymore */;  . Macro Definition Documentation. ◆ ROOT_RELEASE_TIME. #define ROOT_RELEASE_TIME   ""00:00:00"" /* not updated anymore */. Definition at line 6 of file RVersion.h. corefoundationincRVersion.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RVersion_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVersion_8h.html
https://root.cern/doc/master/RVersion_8h.html:662,Deployability,update,updated,662,". ROOT: core/foundation/inc/RVersion.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros ; RVersion.h File Reference. #include ""ROOT/RVersion.hxx"". Include dependency graph for RVersion.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ROOT_RELEASE_TIME   ""00:00:00"" /* not updated anymore */;  . Macro Definition Documentation. ◆ ROOT_RELEASE_TIME. #define ROOT_RELEASE_TIME   ""00:00:00"" /* not updated anymore */. Definition at line 6 of file RVersion.h. corefoundationincRVersion.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RVersion_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVersion_8h.html
https://root.cern/doc/master/RVersion_8h.html:210,Integrability,depend,dependency,210,". ROOT: core/foundation/inc/RVersion.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros ; RVersion.h File Reference. #include ""ROOT/RVersion.hxx"". Include dependency graph for RVersion.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ROOT_RELEASE_TIME   ""00:00:00"" /* not updated anymore */;  . Macro Definition Documentation. ◆ ROOT_RELEASE_TIME. #define ROOT_RELEASE_TIME   ""00:00:00"" /* not updated anymore */. Definition at line 6 of file RVersion.h. corefoundationincRVersion.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RVersion_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVersion_8h.html
https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html:12936,Deployability,configurat,configuration,12936," created QWebEngineView can be found with the command:; 355///; 356/// auto view = qparent->findChild<QWebEngineView*>(""RootWebView"");; 357 ; 358std::string RWebDisplayArgs::GetQt5EmbedQualifier(const void *qparent, const std::string &urlopt, unsigned qtversion); 359{; 360 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 361 if (qparent) {; 362 where.append("":"");; 363 where.append(std::to_string((uintptr_t) qparent));; 364 }; 365 if (!urlopt.empty()) {; 366 where.append(""?"");; 367 where.append(urlopt);; 368 }; 369 return where;; 370}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:252; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:99; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:149; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCus",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html:1472,Modifiability,config,configured,1472," * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#include <ROOT/RWebDisplayArgs.hxx>; 14 ; 15#include <ROOT/RConfig.hxx>; 16#include <ROOT/RLogger.hxx>; 17#include <ROOT/RWebWindow.hxx>; 18 ; 19#include ""TROOT.h""; 20#include <string>; 21 ; 22using namespace ROOT;; 23 ; 24ROOT::Experimental::RLogChannel &ROOT::WebGUILog(); 25{; 26 static ROOT::Experimental::RLogChannel sLog(""ROOT.WebGUI"");; 27 return sLog;; 28}; 29 ; 30 ; 31/** \class ROOT::RWebDisplayArgs; 32\ingroup webdisplay; 33 ; 34Holds different arguments for starting browser with RWebDisplayHandle::Display() method; 35 ; 36*/; 37 ; 38///////////////////////////////////////////////////////////////////////////////////////////; 39/// Default constructor.; 40/// Browser kind configured from gROOT->GetWebDisplay(); 41 ; 42RWebDisplayArgs::RWebDisplayArgs(); 43{; 44 SetBrowserKind("""");; 45}; 46 ; 47///////////////////////////////////////////////////////////////////////////////////////////; 48/// Constructor.; 49/// Browser kind specified as std::string.; 50/// See \ref SetBrowserKind method for description of allowed parameters; 51 ; 52RWebDisplayArgs::RWebDisplayArgs(const std::string &browser); 53{; 54 SetBrowserKind(browser);; 55}; 56 ; 57///////////////////////////////////////////////////////////////////////////////////////////; 58/// Constructor.; 59/// Browser kind specified as `const char *`.; 60/// See \ref SetBrowserKind method for description of allowed parameters; 61 ; 62RWebDisplayArgs::RWebDisplayArgs(const char *browser); 63{; 64 SetBrowserKind(browser);; 65}; 66 ; 67///////////////////////////////////////////////////////////////////////////////////////////; 68/// Constructor.; 69/// Let specify window width and height; 70 ; 71RWebDisplayArgs::RWebDisplayArgs(int width, int height, int x, int y, const std::string &browser); 72{; 73 SetSize(width, he",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html:8498,Modifiability,config,configured,8498,"""local""); 212 SetBrowserKind(kLocal);; 213 else if (kind == ""native""); 214 SetBrowserKind(kNative);; 215 else if (kind.empty() || (kind == ""on"")); 216 SetBrowserKind(kOn);; 217 else if ((kind == ""dflt"") || (kind == ""default"") || (kind == ""browser"")); 218 SetBrowserKind(kDefault);; 219 else if (kind == ""firefox""); 220 SetBrowserKind(kFirefox);; 221 else if ((kind == ""chrome"") || (kind == ""chromium"")); 222 SetBrowserKind(kChrome);; 223#ifdef R__MACOSX; 224 else if (kind == ""safari""); 225 SetBrowserKind(kSafari);; 226#endif; 227#ifdef _MSC_VER; 228 else if ((kind == ""edge"") || (kind == ""msedge"")); 229 SetBrowserKind(kEdge);; 230#endif; 231 else if ((kind == ""cef"") || (kind == ""cef3"")); 232 SetBrowserKind(kCEF);; 233 else if ((kind == ""qt"") || (kind == ""qt5"")); 234 SetBrowserKind(kQt5);; 235 else if (kind == ""qt6""); 236 SetBrowserKind(kQt6);; 237 else if ((kind == ""embed"") || (kind == ""embedded"")); 238 SetBrowserKind(kEmbedded);; 239 else if (kind == ""server""); 240 SetBrowserKind(kServer);; 241 else if (kind == ""off""); 242 SetBrowserKind(kOff);; 243 else if (!SetSizeAsStr(kind)); 244 SetCustomExec(kind);; 245 ; 246 return *this;; 247}; 248 ; 249/////////////////////////////////////////////////////////////////////; 250/// Returns configured browser name; 251 ; 252std::string RWebDisplayArgs::GetBrowserName() const; 253{; 254 switch (GetBrowserKind()) {; 255 case kChrome: return ""chrome"";; 256 case kEdge: return ""edge"";; 257 case kSafari: return ""safari"";; 258 case kFirefox: return ""firefox"";; 259 case kNative: return ""native"";; 260 case kCEF: return ""cef"";; 261 case kQt5: return ""qt5"";; 262 case kQt6: return ""qt6"";; 263 case kLocal: return ""local"";; 264 case kDefault: return ""default"";; 265 case kServer: return ""server"";; 266 case kEmbedded: return ""embed"";; 267 case kOff: return ""off"";; 268 case kOn: return ""on"";; 269 case kCustom:; 270 auto pos = fExec.find("" "");; 271 return (pos == std::string::npos) ? fExec : fExec.substr(0,pos);; 272 }; 273 ; 274 return """";; 275}; 27",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html:12936,Modifiability,config,configuration,12936," created QWebEngineView can be found with the command:; 355///; 356/// auto view = qparent->findChild<QWebEngineView*>(""RootWebView"");; 357 ; 358std::string RWebDisplayArgs::GetQt5EmbedQualifier(const void *qparent, const std::string &urlopt, unsigned qtversion); 359{; 360 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 361 if (qparent) {; 362 where.append("":"");; 363 where.append(std::to_string((uintptr_t) qparent));; 364 }; 365 if (!urlopt.empty()) {; 366 where.append(""?"");; 367 where.append(urlopt);; 368 }; 369 return where;; 370}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:252; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:99; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:149; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCus",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html:13220,Modifiability,config,configured,13220,"on); 359{; 360 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 361 if (qparent) {; 362 where.append("":"");; 363 where.append(std::to_string((uintptr_t) qparent));; 364 }; 365 if (!urlopt.empty()) {; 366 where.append(""?"");; 367 where.append(urlopt);; 368 }; 369 return where;; 370}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:252; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:99; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:149; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCustom typeDefinition RWebDisplayArgs.hxx:72; ROOT::RWebDisplayArgs::SetSizeRWebDisplayArgs & SetSize(int w, int h)set preferable web window width and heightDefinition RWebDisplayArgs.hxx:174; ROOT::RWebDisplayArgs::fUrlOptstd::string fUrlOpt! extra URL options,",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html:13438,Modifiability,config,configured,13438,"rlopt);; 368 }; 369 return where;; 370}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:252; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:99; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:149; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCustom typeDefinition RWebDisplayArgs.hxx:72; ROOT::RWebDisplayArgs::SetSizeRWebDisplayArgs & SetSize(int w, int h)set preferable web window width and heightDefinition RWebDisplayArgs.hxx:174; ROOT::RWebDisplayArgs::fUrlOptstd::string fUrlOpt! extra URL options, which are append to window URLDefinition RWebDisplayArgs.hxx:71; ROOT::RWebDisplayArgs::GetUrlconst std::string & GetUrl() constreturns window urlDefinition RWebDisplayArgs.hxx:130; ROOT::RWebDisplayArgs::SetCustomExecvoid SetCustomExec(const std::stri",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html:12932,Testability,log,log,12932," created QWebEngineView can be found with the command:; 355///; 356/// auto view = qparent->findChild<QWebEngineView*>(""RootWebView"");; 357 ; 358std::string RWebDisplayArgs::GetQt5EmbedQualifier(const void *qparent, const std::string &urlopt, unsigned qtversion); 359{; 360 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 361 if (qparent) {; 362 where.append("":"");; 363 where.append(std::to_string((uintptr_t) qparent));; 364 }; 365 if (!urlopt.empty()) {; 366 where.append(""?"");; 367 where.append(urlopt);; 368 }; 369 return where;; 370}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:252; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:99; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:149; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCus",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html:5764,Usability,clear,clear,5764,"rowser; 147/// firefox - use Mozilla Firefox web browser; 148/// edge - use Microsoft Edge web browser (Windows only); 149/// native - either chrome/edge or firefox, only these browsers support batch (headless) mode; 150/// default - default system web-browser, no batch mode; 151/// cef - Chromium Embeded Framework, local display, local communication; 152/// qt5 - Qt5 QWebEngine, local display, local communication; 153/// qt6 - Qt6 QWebEngineCore, local display, local communication; 154/// local - either cef or qt5 or qt6; 155/// off - disable web display; 156/// on - first try ""local"", then ""native"", then ""default"" (default option); 157/// `<prog>` - any program name which will be started to open widget URL, like ""/usr/bin/opera""; 158 ; 159RWebDisplayArgs &RWebDisplayArgs::SetBrowserKind(const std::string &_kind); 160{; 161 std::string kind = _kind;; 162 ; 163 auto pos = kind.find(""?"");; 164 if (pos == 0) {; 165 SetUrlOpt(kind.substr(1));; 166 kind.clear();; 167 } else if (pos != std::string::npos) {; 168 SetUrlOpt(kind.substr(pos+1));; 169 kind.resize(pos);; 170 }; 171 ; 172 pos = kind.find(""size:"");; 173 if (pos != std::string::npos) {; 174 auto epos = kind.find_first_of("" ;"", pos+5);; 175 if (epos == std::string::npos) epos = kind.length();; 176 SetSizeAsStr(kind.substr(pos+5, epos-pos-5));; 177 kind.erase(pos, epos-pos);; 178 }; 179 ; 180 pos = kind.find(""pos:"");; 181 if (pos != std::string::npos) {; 182 auto epos = kind.find_first_of("" ;"", pos+4);; 183 if (epos == std::string::npos) epos = kind.length();; 184 SetPosAsStr(kind.substr(pos+4, epos-pos-4));; 185 kind.erase(pos, epos-pos);; 186 }; 187 ; 188 pos = kind.rfind(""headless"");; 189 if ((pos != std::string::npos) && (pos == kind.length() - 8)) {; 190 SetHeadless(true);; 191 kind.resize(pos);; 192 if ((pos > 0) && (kind[pos-1] == ';')) kind.resize(pos-1);; 193 }; 194 ; 195 // very special handling of qt5/qt6 which can specify pointer as a string; 196 if ((kind.find(""qt5:"") == 0) || (kind.find(""qt6:"") == 0)) ",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:3990,Availability,avail,available,3990,"WebWindow &win, bool remote = false, std::string *produced_key = nullptr);; 76 ; 77 bool CreateServer(bool with_http = false);; 78 ; 79 bool InformListener(const std::string &msg);; 80 ; 81 static std::string GenerateKey(int keylen = 32);; 82 ; 83public:; 84 RWebWindowsManager();; 85 ; 86 ~RWebWindowsManager();; 87 ; 88 /// Returns THttpServer instance; 89 THttpServer *GetServer() const { return fServer.get(); }; 90 ; 91 /// Returns http address of the server, empty string when not available; 92 std::string GetServerAddr() const { return fAddr; }; 93 ; 94 /// Assign show callback which can catch window showing, used by RBrowser; 95 void SetShowCallback(WebWindowShowCallback_t func) { fShowCallback = func; }; 96 ; 97 /// Assign show callback which can catch window showing, used by RBrowser; 98 void SetDeleteCallback(WebWindowDeleteCallback_t func) { fDeleteCallback = func; }; 99 ; 100 static std::shared_ptr<RWebWindowsManager> &Instance();; 101 ; 102 std::shared_ptr<RWebWindow> CreateWindow();; 103 ; 104 void Terminate();; 105 ; 106 static bool IsMainThrd();; 107 static void AssignMainThrd();; 108 ; 109 static void SetLoopbackMode(bool on = true);; 110 static bool IsLoopbackMode();; 111 ; 112 static void SetUseSessionKey(bool on = true);; 113 static void SetUseConnectionKey(bool on = true);; 114 ; 115 static void AddServerLocation(const std::string &server_prefix, const std::string &files_path);; 116 static std::map<std::string, std::string> GetServerLocations();; 117 static void ClearServerLocations();; 118};; 119 ; 120} // namespace ROOT; 121 ; 122#endif; RWebWindow.hxx; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; winOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttribute",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:11319,Availability,avail,available,11319,"wsManager.hxx:89; ROOT::RWebWindowsManager::fSessionKeystd::string fSessionKey! secret session key used on client to code connections keysDefinition RWebWindowsManager.hxx:47; ROOT::RWebWindowsManager::fUseHttpThrdbool fUseHttpThrd! use special thread for THttpServerDefinition RWebWindowsManager.hxx:51; ROOT::RWebWindowsManager::AssignMainThrdstatic void AssignMainThrd()Re-assigns main thread id Normally main thread id recognized at the moment when library is loaded It ...Definition RWebWindowsManager.cxx:117; ROOT::RWebWindowsManager::SetUseSessionKeystatic void SetUseSessionKey(bool on=true)Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate...Definition RWebWindowsManager.cxx:157; ROOT::RWebWindowsManager::IsUseHttpThreadbool IsUseHttpThread() constReturns true if http server use special thread for requests processing (default off)Definition RWebWindowsManager.hxx:60; ROOT::RWebWindowsManager::GetServerAddrstd::string GetServerAddr() constReturns http address of the server, empty string when not available.Definition RWebWindowsManager.hxx:92; ROOT::RWebWindowsManager::fUseSenderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:52; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:45; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:129; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:105; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements li",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:8576,Deployability,configurat,configuration,8576,"ssEventsbool fExternalProcessEvents! indicate that there are external process events engineDefinition RWebWindowsManager.hxx:54; ROOT::RWebWindowsManager::fMutexstd::recursive_mutex fMutex! main mutex, used for window creationsDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::SetDeleteCallbackvoid SetDeleteCallback(WebWindowDeleteCallback_t func)Assign show callback which can catch window showing, used by RBrowser.Definition RWebWindowsManager.hxx:98; ROOT::RWebWindowsManager::RWebWindowsManagerRWebWindowsManager()window manager constructor Required here for correct usage of unique_ptr<THttpServer>Definition RWebWindowsManager.cxx:273; ROOT::RWebWindowsManager::WaitForint WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed=false, double tm=-1)Waits until provided check function or lambdas returns non-zero value Regularly calls WebWindow::Sync...Definition RWebWindowsManager.cxx:901; ROOT::RWebWindowsManager::ClearServerLocationsstatic void ClearServerLocations()Clear all server locations Does not change configuration of already running HTTP server.Definition RWebWindowsManager.cxx:239; ROOT::RWebWindowsManager::fShowCallbackWebWindowShowCallback_t fShowCallback! function called for each RWebWindow::Show callDefinition RWebWindowsManager.hxx:56; ROOT::RWebWindowsManager::fDeleteCallbackWebWindowDeleteCallback_t fDeleteCallback! function called when RWebWindow is destroyedDefinition RWebWindowsManager.hxx:57; ROOT::RWebWindowsManager::ShowWindowunsigned ShowWindow(RWebWindow &win, const RWebDisplayArgs &args)Show window in specified location, see Show() method for more details.Definition RWebWindowsManager.cxx:778; ROOT::RWebWindowsManager::fAddrstd::string fAddr! HTTP address of the serverDefinition RWebWindowsManager.hxx:46; ROOT::RWebWindowsManager::Terminatevoid Terminate()Terminate http server and ROOT application.Definition RWebWindowsManager.cxx:937; ROOT::RWebWindowsManager::fIdCntunsigned fIdCnt! counter for identifiersDefinition RWebW",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:12448,Integrability,message,message,12448,"nderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:52; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:45; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:129; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:105; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:79; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:299; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:53; ROOT::RWebWindowsManager::GetServerLocationsstatic std::map< std::string, std::string > GetServerLocations()Returns server locations as <std::string, std::string> Key is location name (with slash at the end) a...Definition RWebWindowsManager.cxx:209; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:686; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:674; ROOT::RWebWindowsManager::IsLoopbackModestatic boo",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:7038,Modifiability,config,configure,7038,"ance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:40; ROOT::RWebWindowsManager::AddServerLocationstatic void AddServerLocation(const std::string &server_prefix, const std::string &files_path)Configure server location which can be used for loading of custom scripts or files When THttpServer i...Definition RWebWindowsManager.cxx:178; ROOT::RWebWindowsManager::GenerateKeystatic std::string GenerateKey(int keylen=32)Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in b...Definition RWebWindowsManager.cxx:250; ROOT::RWebWindowsManager::fUseSessionKeybool fUseSessionKey! is session key has to be used for data signingDefinition RWebWindowsManager.hxx:48; ROOT::RWebWindowsManager::fAssgnExecstd::unique_ptr< TExec > fAssgnExec! special exec to assign thread id via ProcessEventsDefinition RWebWindowsManager.hxx:55; ROOT::RWebWindowsManager::CreateServerbool CreateServer(bool with_http=false)Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP...Definition RWebWindowsManager.cxx:430; ROOT::RWebWindowsManager::GetLaunchTmoutfloat GetLaunchTmout() constReturns timeout for launching new browser process.Definition RWebWindowsManager.hxx:66; ROOT::RWebWindowsManager::SetUseConnectionKeystatic void SetUseConnectionKey(bool on=true)Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection)...Definition RWebWindowsManager.cxx:168; ROOT::RWebWindowsManager::fExternalProcessEventsbool fExternalProcessEvents! indicate that there are external process events engineDefinition RWebWindowsManager.hxx:54; ROOT::RWebWindowsManager::fMutexstd::recursive_mutex fMutex! main mutex, used for window creationsDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::SetDeleteCallbackvoid SetDeleteCallback(WebWindowDeleteCallback_t func)Assign show callback which can catch window showing, used by RBrowser.Defin",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:8576,Modifiability,config,configuration,8576,"ssEventsbool fExternalProcessEvents! indicate that there are external process events engineDefinition RWebWindowsManager.hxx:54; ROOT::RWebWindowsManager::fMutexstd::recursive_mutex fMutex! main mutex, used for window creationsDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::SetDeleteCallbackvoid SetDeleteCallback(WebWindowDeleteCallback_t func)Assign show callback which can catch window showing, used by RBrowser.Definition RWebWindowsManager.hxx:98; ROOT::RWebWindowsManager::RWebWindowsManagerRWebWindowsManager()window manager constructor Required here for correct usage of unique_ptr<THttpServer>Definition RWebWindowsManager.cxx:273; ROOT::RWebWindowsManager::WaitForint WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed=false, double tm=-1)Waits until provided check function or lambdas returns non-zero value Regularly calls WebWindow::Sync...Definition RWebWindowsManager.cxx:901; ROOT::RWebWindowsManager::ClearServerLocationsstatic void ClearServerLocations()Clear all server locations Does not change configuration of already running HTTP server.Definition RWebWindowsManager.cxx:239; ROOT::RWebWindowsManager::fShowCallbackWebWindowShowCallback_t fShowCallback! function called for each RWebWindow::Show callDefinition RWebWindowsManager.hxx:56; ROOT::RWebWindowsManager::fDeleteCallbackWebWindowDeleteCallback_t fDeleteCallback! function called when RWebWindow is destroyedDefinition RWebWindowsManager.hxx:57; ROOT::RWebWindowsManager::ShowWindowunsigned ShowWindow(RWebWindow &win, const RWebDisplayArgs &args)Show window in specified location, see Show() method for more details.Definition RWebWindowsManager.cxx:778; ROOT::RWebWindowsManager::fAddrstd::string fAddr! HTTP address of the serverDefinition RWebWindowsManager.hxx:46; ROOT::RWebWindowsManager::Terminatevoid Terminate()Terminate http server and ROOT application.Definition RWebWindowsManager.cxx:937; ROOT::RWebWindowsManager::fIdCntunsigned fIdCnt! counter for identifiersDefinition RWebW",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:12424,Modifiability,variab,variable,12424,"nderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:52; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:45; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:129; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:105; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:79; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:299; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:53; ROOT::RWebWindowsManager::GetServerLocationsstatic std::map< std::string, std::string > GetServerLocations()Returns server locations as <std::string, std::string> Key is location name (with slash at the end) a...Definition RWebWindowsManager.cxx:209; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:686; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:674; ROOT::RWebWindowsManager::IsLoopbackModestatic boo",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:12436,Modifiability,config,configured,12436,"nderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:52; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:45; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:129; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:105; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:79; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:299; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:53; ROOT::RWebWindowsManager::GetServerLocationsstatic std::map< std::string, std::string > GetServerLocations()Returns server locations as <std::string, std::string> Key is location name (with slash at the end) a...Definition RWebWindowsManager.cxx:209; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:686; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:674; ROOT::RWebWindowsManager::IsLoopbackModestatic boo",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:6257,Performance,load,loading,6257,"or GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; winOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t winDefinition TGWin32VirtualXProxy.cxx:186; THttpEngine.h; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebWindowRepresents web window, which can be shown in web browser or any other supported environment.Definition RWebWindow.hxx:54; ROOT::RWebWindowsManagerCentral instance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:40; ROOT::RWebWindowsManager::AddServerLocationstatic void AddServerLocation(const std::string &server_prefix, const std::string &files_path)Configure server location which can be used for loading of custom scripts or files When THttpServer i...Definition RWebWindowsManager.cxx:178; ROOT::RWebWindowsManager::GenerateKeystatic std::string GenerateKey(int keylen=32)Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in b...Definition RWebWindowsManager.cxx:250; ROOT::RWebWindowsManager::fUseSessionKeybool fUseSessionKey! is session key has to be used for data signingDefinition RWebWindowsManager.hxx:48; ROOT::RWebWindowsManager::fAssgnExecstd::unique_ptr< TExec > fAssgnExec! special exec to assign thread id via ProcessEventsDefinition RWebWindowsManager.hxx:55; ROOT::RWebWindowsManager::CreateServerbool CreateServer(bool with_http=false)Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP...Definition RWebWindowsManager.cxx:430; ROOT::RWebWindowsManager::GetLaunchTmoutfloat GetLaunchTmout() constReturns timeout f",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:10719,Performance,load,loaded,10719,"e if extra threads to send data via websockets will be used (default off)Definition RWebWindowsManager.hxx:63; ROOT::RWebWindowsManager::SetShowCallbackvoid SetShowCallback(WebWindowShowCallback_t func)Assign show callback which can catch window showing, used by RBrowser.Definition RWebWindowsManager.hxx:95; ROOT::RWebWindowsManager::~RWebWindowsManager~RWebWindowsManager()window manager destructor Required here for correct usage of unique_ptr<THttpServer>Definition RWebWindowsManager.cxx:287; ROOT::RWebWindowsManager::GetServerTHttpServer * GetServer() constReturns THttpServer instance.Definition RWebWindowsManager.hxx:89; ROOT::RWebWindowsManager::fSessionKeystd::string fSessionKey! secret session key used on client to code connections keysDefinition RWebWindowsManager.hxx:47; ROOT::RWebWindowsManager::fUseHttpThrdbool fUseHttpThrd! use special thread for THttpServerDefinition RWebWindowsManager.hxx:51; ROOT::RWebWindowsManager::AssignMainThrdstatic void AssignMainThrd()Re-assigns main thread id Normally main thread id recognized at the moment when library is loaded It ...Definition RWebWindowsManager.cxx:117; ROOT::RWebWindowsManager::SetUseSessionKeystatic void SetUseSessionKey(bool on=true)Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate...Definition RWebWindowsManager.cxx:157; ROOT::RWebWindowsManager::IsUseHttpThreadbool IsUseHttpThread() constReturns true if http server use special thread for requests processing (default off)Definition RWebWindowsManager.hxx:60; ROOT::RWebWindowsManager::GetServerAddrstd::string GetServerAddr() constReturns http address of the server, empty string when not available.Definition RWebWindowsManager.hxx:92; ROOT::RWebWindowsManager::fUseSenderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:52; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all ",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:12042,Performance,load,load,12042,"finition RWebWindowsManager.cxx:157; ROOT::RWebWindowsManager::IsUseHttpThreadbool IsUseHttpThread() constReturns true if http server use special thread for requests processing (default off)Definition RWebWindowsManager.hxx:60; ROOT::RWebWindowsManager::GetServerAddrstd::string GetServerAddr() constReturns http address of the server, empty string when not available.Definition RWebWindowsManager.hxx:92; ROOT::RWebWindowsManager::fUseSenderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:52; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:45; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:129; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:105; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:79; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:299; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:53; ROOT::RWebWindowsManager::GetServerLocationsstatic std::map< std::string, std::string > GetServerLocations()Returns server locations as <std::string, std::string> Key is location name (with slash at the end) a...Definition RWebWindowsManager.cxx:209; ROOT::RWebWindowsManager::GetUr",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:2286,Safety,timeout,timeout,2286,"pThrd{false}; ///<! use special thread for THttpServer; 52 bool fUseSenderThreads{false}; ///<! use extra threads for sending data from RWebWindow to clients; 53 float fLaunchTmout{30.}; ///<! timeout in seconds to start browser process, default 30s; 54 bool fExternalProcessEvents{false}; ///<! indicate that there are external process events engine; 55 std::unique_ptr<TExec> fAssgnExec; ///<! special exec to assign thread id via ProcessEvents; 56 WebWindowShowCallback_t fShowCallback; ///<! function called for each RWebWindow::Show call; 57 WebWindowDeleteCallback_t fDeleteCallback; ///<! function called when RWebWindow is destroyed; 58 ; 59 /// Returns true if http server use special thread for requests processing (default off); 60 bool IsUseHttpThread() const { return fUseHttpThrd; }; 61 ; 62 /// Returns true if extra threads to send data via websockets will be used (default off); 63 bool IsUseSenderThreads() const { return fUseSenderThreads; }; 64 ; 65 /// Returns timeout for launching new browser process; 66 float GetLaunchTmout() const { return fLaunchTmout; }; 67 ; 68 void Unregister(RWebWindow &win);; 69 ; 70 /// Show window in specified location, see Show() method for more details; 71 unsigned ShowWindow(RWebWindow &win, const RWebDisplayArgs &args);; 72 ; 73 int WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed = false, double tm = -1);; 74 ; 75 std::string GetUrl(RWebWindow &win, bool remote = false, std::string *produced_key = nullptr);; 76 ; 77 bool CreateServer(bool with_http = false);; 78 ; 79 bool InformListener(const std::string &msg);; 80 ; 81 static std::string GenerateKey(int keylen = 32);; 82 ; 83public:; 84 RWebWindowsManager();; 85 ; 86 ~RWebWindowsManager();; 87 ; 88 /// Returns THttpServer instance; 89 THttpServer *GetServer() const { return fServer.get(); }; 90 ; 91 /// Returns http address of the server, empty string when not available; 92 std::string GetServerAddr() const { return fAddr; }; 93 ; 94 /// Assign show callback whic",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:3075,Safety,timeout,timeout,3075,"pThrd{false}; ///<! use special thread for THttpServer; 52 bool fUseSenderThreads{false}; ///<! use extra threads for sending data from RWebWindow to clients; 53 float fLaunchTmout{30.}; ///<! timeout in seconds to start browser process, default 30s; 54 bool fExternalProcessEvents{false}; ///<! indicate that there are external process events engine; 55 std::unique_ptr<TExec> fAssgnExec; ///<! special exec to assign thread id via ProcessEvents; 56 WebWindowShowCallback_t fShowCallback; ///<! function called for each RWebWindow::Show call; 57 WebWindowDeleteCallback_t fDeleteCallback; ///<! function called when RWebWindow is destroyed; 58 ; 59 /// Returns true if http server use special thread for requests processing (default off); 60 bool IsUseHttpThread() const { return fUseHttpThrd; }; 61 ; 62 /// Returns true if extra threads to send data via websockets will be used (default off); 63 bool IsUseSenderThreads() const { return fUseSenderThreads; }; 64 ; 65 /// Returns timeout for launching new browser process; 66 float GetLaunchTmout() const { return fLaunchTmout; }; 67 ; 68 void Unregister(RWebWindow &win);; 69 ; 70 /// Show window in specified location, see Show() method for more details; 71 unsigned ShowWindow(RWebWindow &win, const RWebDisplayArgs &args);; 72 ; 73 int WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed = false, double tm = -1);; 74 ; 75 std::string GetUrl(RWebWindow &win, bool remote = false, std::string *produced_key = nullptr);; 76 ; 77 bool CreateServer(bool with_http = false);; 78 ; 79 bool InformListener(const std::string &msg);; 80 ; 81 static std::string GenerateKey(int keylen = 32);; 82 ; 83public:; 84 RWebWindowsManager();; 85 ; 86 ~RWebWindowsManager();; 87 ; 88 /// Returns THttpServer instance; 89 THttpServer *GetServer() const { return fServer.get(); }; 90 ; 91 /// Returns http address of the server, empty string when not available; 92 std::string GetServerAddr() const { return fAddr; }; 93 ; 94 /// Assign show callback whic",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:7179,Safety,timeout,timeout,7179,"tring &server_prefix, const std::string &files_path)Configure server location which can be used for loading of custom scripts or files When THttpServer i...Definition RWebWindowsManager.cxx:178; ROOT::RWebWindowsManager::GenerateKeystatic std::string GenerateKey(int keylen=32)Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in b...Definition RWebWindowsManager.cxx:250; ROOT::RWebWindowsManager::fUseSessionKeybool fUseSessionKey! is session key has to be used for data signingDefinition RWebWindowsManager.hxx:48; ROOT::RWebWindowsManager::fAssgnExecstd::unique_ptr< TExec > fAssgnExec! special exec to assign thread id via ProcessEventsDefinition RWebWindowsManager.hxx:55; ROOT::RWebWindowsManager::CreateServerbool CreateServer(bool with_http=false)Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP...Definition RWebWindowsManager.cxx:430; ROOT::RWebWindowsManager::GetLaunchTmoutfloat GetLaunchTmout() constReturns timeout for launching new browser process.Definition RWebWindowsManager.hxx:66; ROOT::RWebWindowsManager::SetUseConnectionKeystatic void SetUseConnectionKey(bool on=true)Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection)...Definition RWebWindowsManager.cxx:168; ROOT::RWebWindowsManager::fExternalProcessEventsbool fExternalProcessEvents! indicate that there are external process events engineDefinition RWebWindowsManager.hxx:54; ROOT::RWebWindowsManager::fMutexstd::recursive_mutex fMutex! main mutex, used for window creationsDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::SetDeleteCallbackvoid SetDeleteCallback(WebWindowDeleteCallback_t func)Assign show callback which can catch window showing, used by RBrowser.Definition RWebWindowsManager.hxx:98; ROOT::RWebWindowsManager::RWebWindowsManagerRWebWindowsManager()window manager constructor Required here for correct usage of unique_ptr<THttpServer>Definit",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:12586,Safety,timeout,timeout,12586,"> fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:45; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:129; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:105; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:79; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:299; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:53; ROOT::RWebWindowsManager::GetServerLocationsstatic std::map< std::string, std::string > GetServerLocations()Returns server locations as <std::string, std::string> Key is location name (with slash at the end) a...Definition RWebWindowsManager.cxx:209; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:686; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:674; ROOT::RWebWindowsManager::IsLoopbackModestatic bool IsLoopbackMode()Returns true if loopback mode used by THttpServer for web widgets.Definition RWebWindowsManager.cxx:147; ROOT::RWebWindowsManager::CreateWindowstd::shared_ptr< RWebWindow > Create",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:13075,Security,access,access,13075,"t when library is load...Definition RWebWindowsManager.cxx:105; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:79; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:299; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:53; ROOT::RWebWindowsManager::GetServerLocationsstatic std::map< std::string, std::string > GetServerLocations()Returns server locations as <std::string, std::string> Key is location name (with slash at the end) a...Definition RWebWindowsManager.cxx:209; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:686; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:674; ROOT::RWebWindowsManager::IsLoopbackModestatic bool IsLoopbackMode()Returns true if loopback mode used by THttpServer for web widgets.Definition RWebWindowsManager.cxx:147; ROOT::RWebWindowsManager::CreateWindowstd::shared_ptr< RWebWindow > CreateWindow()Creates new window To show window, RWebWindow::Show() have to be called.Definition RWebWindowsManager.cxx:619; TExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpWSHandlerClass for user-side handling of websocket with THttpServer.Definition THttpWS",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:8797,Integrability,protocol,protocol,8797,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:8867,Integrability,protocol,protocol,8867,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:8967,Integrability,protocol,protocol,8967,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:9081,Integrability,protocol,protocol,9081,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:17369,Integrability,protocol,protocol,17369,"t num = 0) const;; 344 ; 345 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 346 ; 347 bool HasConnection(unsigned connid = 0, bool only_active = true) const;; 348 ; 349 void CloseConnections();; 350 ; 351 void CloseConnection(unsigned connid);; 352 ; 353 /// Returns timeout for synchronous WebWindow operations; 354 float GetOperationTmout() const { return fOperationTmout; }; 355 ; 356 /// Set timeout for synchronous WebWindow operations; 357 void SetOperationTmout(float tm = 50.) { fOperationTmout = tm; }; 358 ; 359 std::string GetUrl(bool remote = true);; 360 ; 361 THttpServer *GetServer();; 362 ; 363 void Sync();; 364 ; 365 void Run(double tm = 0.);; 366 ; 367 unsigned Show(const RWebDisplayArgs &args = """");; 368 ; 369 unsigned GetDisplayConnection() const;; 370 ; 371 /// Returns true when window was shown at least once; 372 bool IsShown() const { return GetDisplayConnection() != 0; }; 373 ; 374 bool CanSend(unsigned connid, bool direct = true) const;; 375 ; 376 int GetSendQueueLength(unsigned connid) const;; 377 ; 378 void Send(unsigned connid, const std::string &data);; 379 ; 380 void SendBinary(unsigned connid, const void *data, std::size_t len);; 381 ; 382 void SendBinary(unsigned connid, std::string &&data);; 383 ; 384 void RecordData(const std::string &fname = ""protocol.json"", const std::string &fprefix = """");; 385 ; 386 std::string GetAddr() const;; 387 ; 388 _R__DEPRECATED_LATER(""Use GetUrl() to get valid connection URL""); 389 std::string GetRelativeAddr(const std::shared_ptr<RWebWindow> &win) const;; 390 ; 391 _R__DEPRECATED_LATER(""Use GetAddr() to get valid connection URL""); 392 std::string GetRelativeAddr(const RWebWindow &win) const;; 393 ; 394 void SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn = nullptr);; 395 ; 396 void SetConnectCallBack(WebWindowConnectCallback_t func);; 397 ; 398 void SetDataCallBack(WebWindowDataCallback_t func);; 399 ; 400 void SetDisconnectCa",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:21444,Integrability,wrap,wrapper,21444,"tyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t winDefinition TGWin32VirtualXProxy.cxx:186; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; namechar name[80]Definition TGX11.cxx:110; ROOT::RFileDialogWeb-based FileDialog.Definition RFileDialog.hxx:41; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayHandleHandle of created web-based display Depending from type of web display, holds handle of started brows...Definition RWebDisplayHandle.hxx:25; ROOT::RWebWindowWSHandlerjust wrapper to deliver websockets call-backs to the RWebWindow classDefinition RWebWindowWSHandler.hxx:30; ROOT::RWebWindowRepresents web window, which can be shown in web browser or any other supported environment.Definition RWebWindow.hxx:54; ROOT::RWebWindow::CheckDataToSendbool CheckDataToSend(std::shared_ptr< WebConn > &conn)Checks if one should send data for specified connection Returns true when send operation was performe...Definition RWebWindow.cxx:1191; ROOT::RWebWindow::fDefaultPagestd::string fDefaultPage! HTML page (or file name) returned when window URL is openedDefinition RWebWindow.hxx:142; ROOT::RWebWindow::WaitForint WaitFor(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1831; ROOT::RWebWindow::GetIdunsigned GetId() constReturns ID for the window - unique inside window manager.Definition RWebWindow.hxx:251; ROOT::RWebWindow::GetMasterConnectionsstd::vector< MasterConn > GetMasterConnections(un",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:24242,Integrability,protocol,protocolDefinition,24242,"er time For instance, batch browser will be ...Definition RWebWindow.cxx:659; ROOT::RWebWindow::fIdunsigned fId! unique identifierDefinition RWebWindow.hxx:144; ROOT::RWebWindow::fHasWindowThrdbool fHasWindowThrd! indicate if special window thread was startedDefinition RWebWindow.hxx:165; ROOT::RWebWindow::fMasterConnsstd::vector< MasterConn > fMasterConns! master connectionsDefinition RWebWindow.hxx:141; ROOT::RWebWindow::SetClearOnClosevoid SetClearOnClose(const std::shared_ptr< void > &handle=nullptr)Set handle which is cleared when last active connection is closed Typically can be used to destroy we...Definition RWebWindow.cxx:1806; ROOT::RWebWindow::StartThreadvoid StartThread()Start special thread which will be used by the window to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1722; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:151; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:175; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1500; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks should be invokedDefinition RWebWindow.hxx:163; ROOT::RWebWindow::RemoveKeyvoid RemoveKey(const std::string &key)Removes all connections with the key.Definition RWebWindow.cxx:584; ROOT::RWebWindow::fInputQueuestd::queue< QueueEntry > fInputQueue! input queue for all callbacksDefinition RWebWindow.hxx:167; ROOT::RWebWindow::_CanTrustInbool _CanTrustIn(std::shared_ptr< WebConn > &conn, const std::string &key, const std::string &ntry, bool remote, bool test_first_time)Check if provided hash, ",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:33568,Integrability,message,message,33568,"h should be provided for connecting windowDefinition RWebWindow.hxx:156; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:285; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definition RWebWindow.cxx:1957; ROOT::RWebWindow::fWSHandlerstd::shared_ptr< RWebWindowWSHandler > fWSHandler! specialize websocket handler for all incoming connectionsDefinition RWebWindow.hxx:150; ROOT::RWebWindow::StopThreadvoid StopThread()Stop special thread.Definition RWebWindow.cxx:1744; ROOT::RWebWindow::SubmitDatavoid SubmitData(unsigned connid, bool txt, std::string &&data, int chid=1)Internal method to send data.Definition RWebWindow.cxx:1571; ROOT::RWebWindow::HMACstatic std::string HMAC(const std::string &key, const std::string &sessionKey, const char *msg, int msglen)Calculate HMAC checksum for provided key and message Key combained from connection key and session ke...Definition RWebWindow.cxx:2034; ROOT::RWebWindow::~RWebWindow~RWebWindow()RWebWindow destructor Closes all connections and remove window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:2019; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1489; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:152; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only ac",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:36706,Integrability,protocol,protocolDefinition,36706,"ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWebWindow::SetNativeOnlyConnvoid SetNativeOnlyConn(bool on=true)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:311; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:176; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1551; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:177; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1526; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1362; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1397; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:146; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RW",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:37172,Integrability,protocol,protocol,37172,"ength for specified connection.Definition RWebWindow.cxx:1551; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:177; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1526; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1362; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1397; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:146; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:159; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:704; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr<",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:37264,Integrability,protocol,protocol,37264,"WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:177; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1526; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1362; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1397; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:146; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:159; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:704; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definitio",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:39058,Integrability,protocol,protocol,39058,"ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1995; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:143; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1869; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWebWindow.hxx:169; ROOT::RWebWindow::GetAddrstd::string GetAddr() constReturns window address which is used in URL.Definition RWebWindow.cxx:1283; ROOT::RWebWindow::fMgrstd::shared_ptr< RWebWindowsManager > fMgr! display managerDefinition RWebWindow.hxx:139; ROOT::RWebWindow::fProtocolFileNamestd::string fProtocolFileName! local file where communication protocol will be writtenDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:293; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:157; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:254; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:153; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:160; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:625; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is c",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:42987,Integrability,protocol,protocol,42987,"g and check if next operation has to be start...Definition RWebWindow.cxx:1121; ROOT::RWebWindow::IsUseCurrentDirbool IsUseCurrentDir() constreturns true if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:331; ROOT::RWebWindow::fUseServerThreadsbool fUseServerThreads! indicates that server thread is using, no special window threadDefinition RWebWindow.hxx:145; ROOT::RWebWindow::FindHeadlessConnectionunsigned FindHeadlessConnection()Returns connection id of window running in headless mode This can be special connection which may run...Definition RWebWindow.cxx:221; ROOT::RWebWindow::WaitForTimedint WaitForTimed(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1845; ROOT::RWebWindow::fProcessMTbool fProcessMT! if window event processing performed in dedicated threadDefinition RWebWindow.hxx:147; ROOT::RWebWindow::fProtocolCntint fProtocolCnt! counter for protocol recordingDefinition RWebWindow.hxx:174; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client version, used as prefix in scripts URL When changed, web browser will reload all related J...Definition RWebWindow.cxx:1331; ROOT::RWebWindow::RemoveMasterConnectionvoid RemoveMasterConnection(unsigned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:344; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1909; ROOT::RWebWindow::SetCallBacks_R__DEPRECATED_LATER(""Use GetUrl() to get valid connection URL"") std _R__DEPRECATED_LATER(""Use GetAddr() to get valid connection URL"") std void SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1814; ROOT::RWeb",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:45229,Integrability,message,message,45229," unique key for the window.Definition RWebWindow.cxx:612; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:327; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:162; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:307; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Data@ kind_DataDefinition RWebWindow.hxx:127; ROOT::RWebWindow::IsFileDialogMessagestatic bool IsFileDialogMessage(const std::string &msg)Check if this could be the message send by client to start new file dialog If returns true,...Definition RWebWindow.cxx:2005; ROOT::RWebWindowsManagerCentral instance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:40; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; bool; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::WebWindowDataCallback_tstd::function< void(unsigned, const std::string &)> WebWindowDataCallback_tfunction signature for call-backs from the window clients first argument is connection id,...Definition RWebWindow.hxx:41; ROOT::WebWindowConnectCallback_tstd::function< void(unsigned)> WebWindowConnectCallback_tfunction s",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:8667,Modifiability,config,configured,8667,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:13083,Modifiability,config,configured,13083,,MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:13319,Modifiability,config,configured,13319,,MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:13512,Modifiability,config,configured,13512,,MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:13695,Modifiability,config,configured,13695,,MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:14021,Modifiability,config,configures,14021,"///////////////////////////////////////; 279 /// returns configured window width (0 - default); 280 /// actual window width can be different; 281 unsigned GetWidth() const { return fWidth; }; 282 ; 283 /////////////////////////////////////////////////////////////////////////; 284 /// returns configured window height (0 - default); 285 unsigned GetHeight() const { return fHeight; }; 286 ; 287 /////////////////////////////////////////////////////////////////////////; 288 /// returns configured window X position (-1 - default); 289 int GetX() const { return fX; }; 290 ; 291 /////////////////////////////////////////////////////////////////////////; 292 /// returns configured window Y position (-1 - default); 293 int GetY() const { return fY; }; 294 ; 295 void SetConnLimit(unsigned lmt = 0);; 296 ; 297 unsigned GetConnLimit() const;; 298 ; 299 void SetConnToken(const std::string &token = """");; 300 ; 301 /////////////////////////////////////////////////////////////////////////; 302 /// configures maximal queue length of data which can be held by window; 303 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 304 ; 305 /////////////////////////////////////////////////////////////////////////; 306 /// Return maximal queue length of data which can be held by window; 307 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 308 ; 309 /////////////////////////////////////////////////////////////////////////; 310 /// configures that only native (own-created) connections are allowed; 311 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKe",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:14483,Modifiability,config,configures,14483,"//////; 288 /// returns configured window X position (-1 - default); 289 int GetX() const { return fX; }; 290 ; 291 /////////////////////////////////////////////////////////////////////////; 292 /// returns configured window Y position (-1 - default); 293 int GetY() const { return fY; }; 294 ; 295 void SetConnLimit(unsigned lmt = 0);; 296 ; 297 unsigned GetConnLimit() const;; 298 ; 299 void SetConnToken(const std::string &token = """");; 300 ; 301 /////////////////////////////////////////////////////////////////////////; 302 /// configures maximal queue length of data which can be held by window; 303 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 304 ; 305 /////////////////////////////////////////////////////////////////////////; 306 /// Return maximal queue length of data which can be held by window; 307 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 308 ; 309 /////////////////////////////////////////////////////////////////////////; 310 /// configures that only native (own-created) connections are allowed; 311 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 320 ; 321 /////////////////////////////////////////////////////////////////////////; 322 /// returns true if authentication string is required; 323 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 324 ; 325 /////////////////////////////////////////////////////////////////////////; 326 /// Configure if window can access local files via currentdir/ path of http server; 327 void SetUseCurrentDir(bool on = true) { ",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:30128,Modifiability,config,configured,30128,"ess_mode, const std::string &key, std::unique_ptr< RWebDisplayHandle > &handle)Add display handle and associated key Key is large random string generated when starting new window W...Definition RWebWindow.cxx:483; ROOT::RWebWindow::ConnectionsList_tstd::vector< std::shared_ptr< WebConn > > ConnectionsList_tDefinition RWebWindow.hxx:137; ROOT::RWebWindow::AssignThreadIdvoid AssignThreadId()Assign thread id which has to be used for callbacks WARNING!!! only for expert use Automatically done...Definition RWebWindow.cxx:1687; ROOT::RWebWindow::IsNativeOnlyConnbool IsNativeOnlyConn() constreturns true if only native (own-created) connections are allowedDefinition RWebWindow.hxx:315; ROOT::RWebWindow::SendBinaryvoid SendBinary(unsigned connid, const void *data, std::size_t len)Send binary data to specified connection.Definition RWebWindow.cxx:1672; ROOT::RWebWindow::fYint fY! initial window position, -1 ignoredDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetXint GetX() constreturns configured window X position (-1 - default)Definition RWebWindow.hxx:289; ROOT::RWebWindow::Createstatic std::shared_ptr< RWebWindow > Create()Create new RWebWindow Using default RWebWindowsManager.Definition RWebWindow.cxx:1925; ROOT::RWebWindow::fWidthunsigned fWidthDefinition RWebWindow.hxx:169; ROOT::RWebWindow::fClientVersionstd::string fClientVersion! configured client version, used as prefix in scripts URLDefinition RWebWindow.hxx:172; ROOT::RWebWindow::ProcessBatchHolderbool ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request, used to hold headless browser running Such requests should not be repli...Definition RWebWindow.cxx:375; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:357; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1888; ROO",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:30488,Modifiability,config,configured,30488,"signThreadIdvoid AssignThreadId()Assign thread id which has to be used for callbacks WARNING!!! only for expert use Automatically done...Definition RWebWindow.cxx:1687; ROOT::RWebWindow::IsNativeOnlyConnbool IsNativeOnlyConn() constreturns true if only native (own-created) connections are allowedDefinition RWebWindow.hxx:315; ROOT::RWebWindow::SendBinaryvoid SendBinary(unsigned connid, const void *data, std::size_t len)Send binary data to specified connection.Definition RWebWindow.cxx:1672; ROOT::RWebWindow::fYint fY! initial window position, -1 ignoredDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetXint GetX() constreturns configured window X position (-1 - default)Definition RWebWindow.hxx:289; ROOT::RWebWindow::Createstatic std::shared_ptr< RWebWindow > Create()Create new RWebWindow Using default RWebWindowsManager.Definition RWebWindow.cxx:1925; ROOT::RWebWindow::fWidthunsigned fWidthDefinition RWebWindow.hxx:169; ROOT::RWebWindow::fClientVersionstd::string fClientVersion! configured client version, used as prefix in scripts URLDefinition RWebWindow.hxx:172; ROOT::RWebWindow::ProcessBatchHolderbool ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request, used to hold headless browser running Such requests should not be repli...Definition RWebWindow.cxx:375; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:357; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1888; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1795; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection fro",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:32638,Modifiability,config,configured,32638,"unction for data, received from the clients via websocket.Definition RWebWindow.cxx:1775; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:171; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:149; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:238; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1352; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:156; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:285; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definition RWebWindow.cxx:1957; ROOT::RWebWindow::fWSHandlerstd::shared_ptr< RWebWindowWSHandler > fWSHandler! specialize websocket handler for all incoming connectionsDefinition RWebWindow.hxx:150; ROOT::RWebWindow::StopThreadvoid StopThread()Stop special thread.Definition RWebWindow.cxx:1744; ROOT::RWebWindow::SubmitDatavoid SubmitData(unsigned connid, bool txt, std::string &&data, int chid=1)Internal method to send data.Definition RWebWindow.cxx:1571; ROOT::RWebWindow::HMACstatic std::string HMAC(const std::string &key, const std::string &sessionKey, const char *msg, int msglen)Calculate HMAC checksum for provided key and message Key combained from connection key and session ke...Defini",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:34641,Modifiability,config,configured,34641,"ession ke...Definition RWebWindow.cxx:2034; ROOT::RWebWindow::~RWebWindow~RWebWindow()RWebWindow destructor Closes all connections and remove window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:2019; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1489; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:152; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only active connections are returned -...Definition RWebWindow.cxx:1412; ROOT::RWebWindow::GetConnTokenstd::string GetConnToken() constReturns configured connection token.Definition RWebWindow.cxx:726; ROOT::RWebWindow::GetOperationTmoutfloat GetOperationTmout() constReturns timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:354; ROOT::RWebWindow::SetConnLimitvoid SetConnLimit(unsigned lmt=0)Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing con...Definition RWebWindow.cxx:694; ROOT::RWebWindow::SetPanelNamevoid SetPanelName(const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:272; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:323; ROOT::RWebWindow::RWebWindowRWebW",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:35816,Modifiability,config,configures,35816,"efinition RWebWindow.hxx:354; ROOT::RWebWindow::SetConnLimitvoid SetConnLimit(unsigned lmt=0)Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing con...Definition RWebWindow.cxx:694; ROOT::RWebWindow::SetPanelNamevoid SetPanelName(const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:272; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:323; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWebWindow::SetNativeOnlyConnvoid SetNativeOnlyConn(bool on=true)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:311; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:176; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1551; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:177; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) co",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:36989,Modifiability,config,configured,36989,"ed files namesDefinition RWebWindow.hxx:176; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1551; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:177; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1526; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1362; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1397; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:146; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:159; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - de",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:37955,Modifiability,config,configured,37955,"sstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1362; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1397; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:146; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:159; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:704; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1995; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:143; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1869; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWebWindow.hxx:169; ROOT::RWebWindow::GetAddrstd::string GetAddr() constReturns window address which is used in URL.Definition RWebWindow.cxx:1283; ROOT::RWebWindow::fMgrstd::shared_ptr< RWebWindowsManager > fMgr! display managerDefinition RWebWind",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:39159,Modifiability,config,configured,39159,"const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1995; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:143; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1869; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWebWindow.hxx:169; ROOT::RWebWindow::GetAddrstd::string GetAddr() constReturns window address which is used in URL.Definition RWebWindow.cxx:1283; ROOT::RWebWindow::fMgrstd::shared_ptr< RWebWindowsManager > fMgr! display managerDefinition RWebWindow.hxx:139; ROOT::RWebWindow::fProtocolFileNamestd::string fProtocolFileName! local file where communication protocol will be writtenDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:293; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:157; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:254; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:153; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:160; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:625; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:179; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinitio",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:40651,Modifiability,config,configures,40651,"lbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:160; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:625; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:179; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:168; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1140; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:62; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:303; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:737; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:1455; ROOT::RWebWindow::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:281; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:166; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:422; ROOT::RWebWindow::HasKeybool ",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:41178,Modifiability,config,configured,41178,":RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1140; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:62; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:303; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:737; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:1455; ROOT::RWebWindow::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:281; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:166; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:422; ROOT::RWebWindow::HasKeybool HasKey(const std::string &key, bool also_newkey=false) constReturns true if provided key value already exists (in processes map or in existing connections) In sp...Definition RWebWindow.cxx:559; ROOT::RWebWindow::CompleteWSSendvoid CompleteWSSend(unsigned wsid)Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be start...Definition RWebWindow.cxx:1121; ROOT::RWebWindow::IsUseCurrentDirbool IsUseCurrentDir() constreturns true if window can access local files via currentdir/ path of http serv",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:994,Performance,queue,queue,994,"hxx""; 19 ; 20#include <memory>; 21#include <vector>; 22#include <string>; 23#include <queue>; 24#include <map>; 25#include <functional>; 26#include <mutex>; 27#include <thread>; 28#include <chrono>; 29 ; 30class THttpCallArg;; 31class THttpServer;; 32 ; 33namespace ROOT {; 34 ; 35/// function signature for connect/disconnect call-backs; 36/// argument is connection id; 37using WebWindowConnectCallback_t = std::function<void(unsigned)>;; 38 ; 39/// function signature for call-backs from the window clients; 40/// first argument is connection id, second is received data; 41using WebWindowDataCallback_t = std::function<void(unsigned, const std::string &)>;; 42 ; 43/// function signature for waiting call-backs; 44/// Such callback used when calling thread need to waits for some special data,; 45/// but wants to run application event loop; 46/// As argument, spent time in second will be provided; 47/// Waiting will be performed until function returns non-zero value; 48using WebWindowWaitFunc_t = std::function<int(double)>;; 49 ; 50class RFileDialog;; 51class RWebWindowsManager;; 52c",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:1834,Performance,perform,performed,1834,"hxx""; 19 ; 20#include <memory>; 21#include <vector>; 22#include <string>; 23#include <queue>; 24#include <map>; 25#include <functional>; 26#include <mutex>; 27#include <thread>; 28#include <chrono>; 29 ; 30class THttpCallArg;; 31class THttpServer;; 32 ; 33namespace ROOT {; 34 ; 35/// function signature for connect/disconnect call-backs; 36/// argument is connection id; 37using WebWindowConnectCallback_t = std::function<void(unsigned)>;; 38 ; 39/// function signature for call-backs from the window clients; 40/// first argument is connection id, second is received data; 41using WebWindowDataCallback_t = std::function<void(unsigned, const std::string &)>;; 42 ; 43/// function signature for waiting call-backs; 44/// Such callback used when calling thread need to waits for some special data,; 45/// but wants to run application event loop; 46/// As argument, spent time in second will be provided; 47/// Waiting will be performed until function returns non-zero value; 48using WebWindowWaitFunc_t = std::function<int(double)>;; 49 ; 50class RFileDialog;; 51class RWebWindowsManager;; 52c",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:3840,Performance,perform,performed,3840,"tamp_t fSendStamp; ///<! last server operation, always used from window thread; 81 bool fActive{false}; ///<! flag indicates if connection is active; 82 unsigned fWSId{0}; ///<! websocket id; 83 int fReady{0}; ///<! 0 - not ready, 1..9 - interim, 10 - done; 84 mutable std::mutex fMutex; ///<! mutex must be used to protect all following data; 85 timestamp_t fRecvStamp; ///<! last receive operation, protected with connection mutex; 86 int fRecvCount{0}; ///<! number of received packets, should return back with next sending; 87 int fSendCredits{0}; ///<! how many send operation can be performed without confirmation from other side; 88 int fClientCredits{0}; ///<! number of credits received from client; 89 bool fDoingSend{false}; ///<! true when performing send operation; 90 unsigned long fRecvSeq{0}; ///<! sequence id of last received packet; 91 unsigned long fSendSeq{1}; ///<! sequence id of last send packet; 92 std::queue<QueueItem> fQueue; ///<! output queue; 93 std::map<int,std::shared_ptr<RWebWindow>> fEmbed; ///<! map of embed window for that connection, key value is channel id; 94 WebConn() = default;; 95 WebConn(unsigned connid) : fConnId(connid) {}; 96 WebConn(unsigned connid, unsigned wsid) : fConnId(connid), fActive(true), fWSId(wsid) {}; 97 WebConn(unsigned connid, bool headless_mode, const std::string &key); 98 : fConnId(connid), fHeadlessMode(headless_mode), fKey(key); 99 {; 100 ResetStamps();; 101 }; 102 ~WebConn();; 103 ; 104 void ResetStamps() { fSendStamp = fRecvStamp = std::chrono::system_clock::now(); }; 105 ; 106 void ResetData(); 107 {; 108 fActive = false;; 109 fWSId = 0;; 110 fReady = 0;; 111 fDoingSend = false;; 112 fSendCredits = 0;; 113 fClientCredits = 0;; 114 fRecvSeq = 0;; 115 fSendSeq = 1;; 116 while (!fQueue.empty()); 117 fQueue.pop();; 118 }; 119 };; 120 ; 121 struct MasterConn {; 122 unsigned connid{0};; 123 int channel{-1};; 124 MasterConn(unsigned _connid, int _channel) : connid(_connid), channel(_channel) {}; 125 };; 126 ; 127 enum E",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:4003,Performance,perform,performing,4003,"tamp_t fSendStamp; ///<! last server operation, always used from window thread; 81 bool fActive{false}; ///<! flag indicates if connection is active; 82 unsigned fWSId{0}; ///<! websocket id; 83 int fReady{0}; ///<! 0 - not ready, 1..9 - interim, 10 - done; 84 mutable std::mutex fMutex; ///<! mutex must be used to protect all following data; 85 timestamp_t fRecvStamp; ///<! last receive operation, protected with connection mutex; 86 int fRecvCount{0}; ///<! number of received packets, should return back with next sending; 87 int fSendCredits{0}; ///<! how many send operation can be performed without confirmation from other side; 88 int fClientCredits{0}; ///<! number of credits received from client; 89 bool fDoingSend{false}; ///<! true when performing send operation; 90 unsigned long fRecvSeq{0}; ///<! sequence id of last received packet; 91 unsigned long fSendSeq{1}; ///<! sequence id of last send packet; 92 std::queue<QueueItem> fQueue; ///<! output queue; 93 std::map<int,std::shared_ptr<RWebWindow>> fEmbed; ///<! map of embed window for that connection, key value is channel id; 94 WebConn() = default;; 95 WebConn(unsigned connid) : fConnId(connid) {}; 96 WebConn(unsigned connid, unsigned wsid) : fConnId(connid), fActive(true), fWSId(wsid) {}; 97 WebConn(unsigned connid, bool headless_mode, const std::string &key); 98 : fConnId(connid), fHeadlessMode(headless_mode), fKey(key); 99 {; 100 ResetStamps();; 101 }; 102 ~WebConn();; 103 ; 104 void ResetStamps() { fSendStamp = fRecvStamp = std::chrono::system_clock::now(); }; 105 ; 106 void ResetData(); 107 {; 108 fActive = false;; 109 fWSId = 0;; 110 fReady = 0;; 111 fDoingSend = false;; 112 fSendCredits = 0;; 113 fClientCredits = 0;; 114 fRecvSeq = 0;; 115 fSendSeq = 1;; 116 while (!fQueue.empty()); 117 fQueue.pop();; 118 }; 119 };; 120 ; 121 struct MasterConn {; 122 unsigned connid{0};; 123 int channel{-1};; 124 MasterConn(unsigned _connid, int _channel) : connid(_connid), channel(_channel) {}; 125 };; 126 ; 127 enum E",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:4180,Performance,queue,queue,4180,"tamp_t fSendStamp; ///<! last server operation, always used from window thread; 81 bool fActive{false}; ///<! flag indicates if connection is active; 82 unsigned fWSId{0}; ///<! websocket id; 83 int fReady{0}; ///<! 0 - not ready, 1..9 - interim, 10 - done; 84 mutable std::mutex fMutex; ///<! mutex must be used to protect all following data; 85 timestamp_t fRecvStamp; ///<! last receive operation, protected with connection mutex; 86 int fRecvCount{0}; ///<! number of received packets, should return back with next sending; 87 int fSendCredits{0}; ///<! how many send operation can be performed without confirmation from other side; 88 int fClientCredits{0}; ///<! number of credits received from client; 89 bool fDoingSend{false}; ///<! true when performing send operation; 90 unsigned long fRecvSeq{0}; ///<! sequence id of last received packet; 91 unsigned long fSendSeq{1}; ///<! sequence id of last send packet; 92 std::queue<QueueItem> fQueue; ///<! output queue; 93 std::map<int,std::shared_ptr<RWebWindow>> fEmbed; ///<! map of embed window for that connection, key value is channel id; 94 WebConn() = default;; 95 WebConn(unsigned connid) : fConnId(connid) {}; 96 WebConn(unsigned connid, unsigned wsid) : fConnId(connid), fActive(true), fWSId(wsid) {}; 97 WebConn(unsigned connid, bool headless_mode, const std::string &key); 98 : fConnId(connid), fHeadlessMode(headless_mode), fKey(key); 99 {; 100 ResetStamps();; 101 }; 102 ~WebConn();; 103 ; 104 void ResetStamps() { fSendStamp = fRecvStamp = std::chrono::system_clock::now(); }; 105 ; 106 void ResetData(); 107 {; 108 fActive = false;; 109 fWSId = 0;; 110 fReady = 0;; 111 fDoingSend = false;; 112 fSendCredits = 0;; 113 fClientCredits = 0;; 114 fRecvSeq = 0;; 115 fSendSeq = 1;; 116 while (!fQueue.empty()); 117 fQueue.pop();; 118 }; 119 };; 120 ; 121 struct MasterConn {; 122 unsigned connid{0};; 123 int channel{-1};; 124 MasterConn(unsigned _connid, int _channel) : connid(_connid), channel(_channel) {}; 125 };; 126 ; 127 enum E",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:4218,Performance,queue,queue,4218,"tamp_t fSendStamp; ///<! last server operation, always used from window thread; 81 bool fActive{false}; ///<! flag indicates if connection is active; 82 unsigned fWSId{0}; ///<! websocket id; 83 int fReady{0}; ///<! 0 - not ready, 1..9 - interim, 10 - done; 84 mutable std::mutex fMutex; ///<! mutex must be used to protect all following data; 85 timestamp_t fRecvStamp; ///<! last receive operation, protected with connection mutex; 86 int fRecvCount{0}; ///<! number of received packets, should return back with next sending; 87 int fSendCredits{0}; ///<! how many send operation can be performed without confirmation from other side; 88 int fClientCredits{0}; ///<! number of credits received from client; 89 bool fDoingSend{false}; ///<! true when performing send operation; 90 unsigned long fRecvSeq{0}; ///<! sequence id of last received packet; 91 unsigned long fSendSeq{1}; ///<! sequence id of last send packet; 92 std::queue<QueueItem> fQueue; ///<! output queue; 93 std::map<int,std::shared_ptr<RWebWindow>> fEmbed; ///<! map of embed window for that connection, key value is channel id; 94 WebConn() = default;; 95 WebConn(unsigned connid) : fConnId(connid) {}; 96 WebConn(unsigned connid, unsigned wsid) : fConnId(connid), fActive(true), fWSId(wsid) {}; 97 WebConn(unsigned connid, bool headless_mode, const std::string &key); 98 : fConnId(connid), fHeadlessMode(headless_mode), fKey(key); 99 {; 100 ResetStamps();; 101 }; 102 ~WebConn();; 103 ; 104 void ResetStamps() { fSendStamp = fRecvStamp = std::chrono::system_clock::now(); }; 105 ; 106 void ResetData(); 107 {; 108 fActive = false;; 109 fWSId = 0;; 110 fReady = 0;; 111 fDoingSend = false;; 112 fSendCredits = 0;; 113 fClientCredits = 0;; 114 fRecvSeq = 0;; 115 fSendSeq = 1;; 116 while (!fQueue.empty()); 117 fQueue.pop();; 118 }; 119 };; 120 ; 121 struct MasterConn {; 122 unsigned connid{0};; 123 int channel{-1};; 124 MasterConn(unsigned _connid, int _channel) : connid(_connid), channel(_channel) {}; 125 };; 126 ; 127 enum E",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:6477,Performance,perform,performed,6477," ///<! data for given connection; 133 QueueEntry() = default;; 134 QueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&data) : fConnId(connid), fKind(kind), fData(data) {}; 135 };; 136 ; 137 using ConnectionsList_t = std::vector<std::shared_ptr<WebConn>>;; 138 ; 139 std::shared_ptr<RWebWindowsManager> fMgr; ///<! display manager; 140 std::shared_ptr<RWebWindow> fMaster; ///<! master window where this window is embedded; 141 std::vector<MasterConn> fMasterConns; ///<! master connections; 142 std::string fDefaultPage; ///<! HTML page (or file name) returned when window URL is opened; 143 std::string fPanelName; ///<! panel name which should be shown in the window; 144 unsigned fId{0}; ///<! unique identifier; 145 bool fUseServerThreads{false}; ///<! indicates that server thread is using, no special window thread; 146 bool fUseProcessEvents{false}; ///<! all window functionality will run through process events; 147 bool fProcessMT{false}; ///<! if window event processing performed in dedicated thread; 148 bool fSendMT{false}; ///<! true is special threads should be used for sending data; 149 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 150 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 151 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 152 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 153 ConnectionsList_t fConn; ///<! list of all accepted connections; 154 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 155 unsigned fConnLimit{1}; ///<! number of allowed active connections; 156 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 157 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 158 bool fUseCurrentDir{false}; ///<! if window can ac",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:7594,Performance,queue,queue,7594,"l threads should be used for sending data; 149 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 150 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 151 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 152 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 153 ConnectionsList_t fConn; ///<! list of all accepted connections; 154 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 155 unsigned fConnLimit{1}; ///<! number of allowed active connections; 156 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 157 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 158 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 159 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 160 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 161 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 162 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:8212,Performance,queue,queue,8212,"l threads should be used for sending data; 149 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 150 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 151 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 152 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 153 ConnectionsList_t fConn; ///<! list of all accepted connections; 154 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 155 unsigned fConnLimit{1}; ///<! number of allowed active connections; 156 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 157 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 158 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 159 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 160 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 161 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 162 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:8255,Performance,queue,queue,8255,"l threads should be used for sending data; 149 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 150 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 151 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 152 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 153 ConnectionsList_t fConn; ///<! list of all accepted connections; 154 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 155 unsigned fConnLimit{1}; ///<! number of allowed active connections; 156 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 157 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 158 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 159 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 160 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 161 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 162 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:8342,Performance,queue,queue,8342,"l threads should be used for sending data; 149 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 150 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 151 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 152 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 153 ConnectionsList_t fConn; ///<! list of all accepted connections; 154 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 155 unsigned fConnLimit{1}; ///<! number of allowed active connections; 156 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 157 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 158 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 159 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 160 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 161 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 162 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:8585,Performance,perform,perform,8585,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:14040,Performance,queue,queue,14040,"//////////////////////; 279 /// returns configured window width (0 - default); 280 /// actual window width can be different; 281 unsigned GetWidth() const { return fWidth; }; 282 ; 283 /////////////////////////////////////////////////////////////////////////; 284 /// returns configured window height (0 - default); 285 unsigned GetHeight() const { return fHeight; }; 286 ; 287 /////////////////////////////////////////////////////////////////////////; 288 /// returns configured window X position (-1 - default); 289 int GetX() const { return fX; }; 290 ; 291 /////////////////////////////////////////////////////////////////////////; 292 /// returns configured window Y position (-1 - default); 293 int GetY() const { return fY; }; 294 ; 295 void SetConnLimit(unsigned lmt = 0);; 296 ; 297 unsigned GetConnLimit() const;; 298 ; 299 void SetConnToken(const std::string &token = """");; 300 ; 301 /////////////////////////////////////////////////////////////////////////; 302 /// configures maximal queue length of data which can be held by window; 303 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 304 ; 305 /////////////////////////////////////////////////////////////////////////; 306 /// Return maximal queue length of data which can be held by window; 307 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 308 ; 309 /////////////////////////////////////////////////////////////////////////; 310 /// configures that only native (own-created) connections are allowed; 311 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKey(bool on) { fRe",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:14272,Performance,queue,queue,14272,"//////////////////////////; 284 /// returns configured window height (0 - default); 285 unsigned GetHeight() const { return fHeight; }; 286 ; 287 /////////////////////////////////////////////////////////////////////////; 288 /// returns configured window X position (-1 - default); 289 int GetX() const { return fX; }; 290 ; 291 /////////////////////////////////////////////////////////////////////////; 292 /// returns configured window Y position (-1 - default); 293 int GetY() const { return fY; }; 294 ; 295 void SetConnLimit(unsigned lmt = 0);; 296 ; 297 unsigned GetConnLimit() const;; 298 ; 299 void SetConnToken(const std::string &token = """");; 300 ; 301 /////////////////////////////////////////////////////////////////////////; 302 /// configures maximal queue length of data which can be held by window; 303 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 304 ; 305 /////////////////////////////////////////////////////////////////////////; 306 /// Return maximal queue length of data which can be held by window; 307 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 308 ; 309 /////////////////////////////////////////////////////////////////////////; 310 /// configures that only native (own-created) connections are allowed; 311 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 320 ; 321 /////////////////////////////////////////////////////////////////////////; 322 /// returns true if authentication string is required; 323 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 324",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:21865,Performance,perform,performe,21865,"ption_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; namechar name[80]Definition TGX11.cxx:110; ROOT::RFileDialogWeb-based FileDialog.Definition RFileDialog.hxx:41; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayHandleHandle of created web-based display Depending from type of web display, holds handle of started brows...Definition RWebDisplayHandle.hxx:25; ROOT::RWebWindowWSHandlerjust wrapper to deliver websockets call-backs to the RWebWindow classDefinition RWebWindowWSHandler.hxx:30; ROOT::RWebWindowRepresents web window, which can be shown in web browser or any other supported environment.Definition RWebWindow.hxx:54; ROOT::RWebWindow::CheckDataToSendbool CheckDataToSend(std::shared_ptr< WebConn > &conn)Checks if one should send data for specified connection Returns true when send operation was performe...Definition RWebWindow.cxx:1191; ROOT::RWebWindow::fDefaultPagestd::string fDefaultPage! HTML page (or file name) returned when window URL is openedDefinition RWebWindow.hxx:142; ROOT::RWebWindow::WaitForint WaitFor(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1831; ROOT::RWebWindow::GetIdunsigned GetId() constReturns ID for the window - unique inside window manager.Definition RWebWindow.hxx:251; ROOT::RWebWindow::GetMasterConnectionsstd::vector< MasterConn > GetMasterConnections(unsigned connid=0) constGet list of master connections.Definition RWebWindow.cxx:326; ROOT::RWebWindow::AddMasterConnectionvoid AddMasterConnection(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add new master connection If there are many connections - only same master is allowed.Defi",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:24923,Performance,queue,queue,24923,"ndow to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1722; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:151; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:175; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1500; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks should be invokedDefinition RWebWindow.hxx:163; ROOT::RWebWindow::RemoveKeyvoid RemoveKey(const std::string &key)Removes all connections with the key.Definition RWebWindow.cxx:584; ROOT::RWebWindow::fInputQueuestd::queue< QueueEntry > fInputQueue! input queue for all callbacksDefinition RWebWindow.hxx:167; ROOT::RWebWindow::_CanTrustInbool _CanTrustIn(std::shared_ptr< WebConn > &conn, const std::string &key, const std::string &ntry, bool remote, bool test_first_time)Check if provided hash, ntry parameters from the connection request could be accepted.Definition RWebWindow.cxx:514; ROOT::RWebWindow::SetConnTokenvoid SetConnToken(const std::string &token="""")Configures connection token (default none) When specified, in URL of webpage such token should be pro...Definition RWebWindow.cxx:716; ROOT::RWebWindow::MakeHeadlessunsigned MakeHeadless(bool create_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnecti",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:24962,Performance,queue,queue,24962,"ndow to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1722; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:151; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:175; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1500; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks should be invokedDefinition RWebWindow.hxx:163; ROOT::RWebWindow::RemoveKeyvoid RemoveKey(const std::string &key)Removes all connections with the key.Definition RWebWindow.cxx:584; ROOT::RWebWindow::fInputQueuestd::queue< QueueEntry > fInputQueue! input queue for all callbacksDefinition RWebWindow.hxx:167; ROOT::RWebWindow::_CanTrustInbool _CanTrustIn(std::shared_ptr< WebConn > &conn, const std::string &key, const std::string &ntry, bool remote, bool test_first_time)Check if provided hash, ntry parameters from the connection request could be accepted.Definition RWebWindow.cxx:514; ROOT::RWebWindow::SetConnTokenvoid SetConnToken(const std::string &token="""")Configures connection token (default none) When specified, in URL of webpage such token should be pro...Definition RWebWindow.cxx:716; ROOT::RWebWindow::MakeHeadlessunsigned MakeHeadless(bool create_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnecti",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:31801,Performance,perform,perform,31801,"ebWindow.cxx:375; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:357; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1888; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1795; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1429; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1775; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:171; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:149; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:238; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1352; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:156; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:285; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:36129,Performance,queue,queue,36129,"const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:272; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:323; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWebWindow::SetNativeOnlyConnvoid SetNativeOnlyConn(bool on=true)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:311; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:176; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1551; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:177; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1526; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:36879,Performance,perform,performed,36879,"rue)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:311; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:176; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1551; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:177; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1526; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1362; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1397; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:146; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RW",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:37787,Performance,queue,queue,37787,"::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1526; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1362; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1397; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:146; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:159; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:704; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1995; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:143; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1869; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWebWindow.hxx:169; ROOT::RWebWindow::GetAddrstd::string GetA",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:38510,Performance,perform,performed,38510,"46; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:159; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:704; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1995; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:143; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1869; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWebWindow.hxx:169; ROOT::RWebWindow::GetAddrstd::string GetAddr() constReturns window address which is used in URL.Definition RWebWindow.cxx:1283; ROOT::RWebWindow::fMgrstd::shared_ptr< RWebWindowsManager > fMgr! display managerDefinition RWebWindow.hxx:139; ROOT::RWebWindow::fProtocolFileNamestd::string fProtocolFileName! local file where communication protocol will be writtenDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:293; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:157; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition ",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:40150,Performance,queue,queueDefinition,40150,"T::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:293; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:157; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:254; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:153; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:160; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:625; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:179; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:168; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1140; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:62; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:303; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:737; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:145",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:40670,Performance,queue,queue,40670,"lbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:160; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:625; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:179; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:168; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1140; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:62; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:303; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:737; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:1455; ROOT::RWebWindow::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:281; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:166; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:422; ROOT::RWebWindow::HasKeybool ",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:42867,Performance,perform,performed,42867,"OOT::RWebWindow::CompleteWSSendvoid CompleteWSSend(unsigned wsid)Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be start...Definition RWebWindow.cxx:1121; ROOT::RWebWindow::IsUseCurrentDirbool IsUseCurrentDir() constreturns true if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:331; ROOT::RWebWindow::fUseServerThreadsbool fUseServerThreads! indicates that server thread is using, no special window threadDefinition RWebWindow.hxx:145; ROOT::RWebWindow::FindHeadlessConnectionunsigned FindHeadlessConnection()Returns connection id of window running in headless mode This can be special connection which may run...Definition RWebWindow.cxx:221; ROOT::RWebWindow::WaitForTimedint WaitForTimed(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1845; ROOT::RWebWindow::fProcessMTbool fProcessMT! if window event processing performed in dedicated threadDefinition RWebWindow.hxx:147; ROOT::RWebWindow::fProtocolCntint fProtocolCnt! counter for protocol recordingDefinition RWebWindow.hxx:174; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client version, used as prefix in scripts URL When changed, web browser will reload all related J...Definition RWebWindow.cxx:1331; ROOT::RWebWindow::RemoveMasterConnectionvoid RemoveMasterConnection(unsigned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:344; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1909; ROOT::RWebWindow::SetCallBacks_R__DEPRECATED_LATER(""Use GetUrl() to get valid connection URL"") std _R__DEPRECATED_LATER(""Use GetAddr() to get valid connection URL"") std void SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t d",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:44657,Performance,queue,queue,44657,"l() to get valid connection URL"") std _R__DEPRECATED_LATER(""Use GetAddr() to get valid connection URL"") std void SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1814; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWindow.hxx:319; ROOT::RWebWindow::GenerateKeystd::string GenerateKey() constGenerate new unique key for the window.Definition RWebWindow.cxx:612; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:327; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:162; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:307; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Data@ kind_DataDefinition RWebWindow.hxx:127; ROOT::RWebWindow::IsFileDialogMessagestatic bool IsFileDialogMessage(const std::string &msg)Check if this could be the message send by client to start new file dialog If returns true,...Definition RWebWindow.cxx:2005; ROOT::RWebWindowsManagerCentral instance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:40; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:50040,Performance,perform,performing,50040,"bConn::fEmbedstd::map< int, std::shared_ptr< RWebWindow > > fEmbed! map of embed window for that connection, key value is channel idDefinition RWebWindow.hxx:93; ROOT::RWebWindow::WebConn::fKeystd::string fKey! key value supplied to the window (when exists)Definition RWebWindow.hxx:75; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, bool headless_mode, const std::string &key)Definition RWebWindow.hxx:97; ROOT::RWebWindow::WebConn::fSendSequnsigned long fSendSeq! sequence id of last send packetDefinition RWebWindow.hxx:91; ROOT::RWebWindow::WebConn::fKeyUsedint fKeyUsed! key value used to verify connectionDefinition RWebWindow.hxx:76; ROOT::RWebWindow::WebConn::~WebConn~WebConn()Destructor for WebConn Notify special HTTP request which blocks headless browser from exit.Definition RWebWindow.cxx:42; ROOT::RWebWindow::WebConn::fMutexstd::mutex fMutex! mutex must be used to protect all following dataDefinition RWebWindow.hxx:84; ROOT::RWebWindow::WebConn::fDoingSendbool fDoingSend! true when performing send operationDefinition RWebWindow.hxx:89; ROOT::RWebWindow::WebConn::fWasFirstbool fWasFirst! indicate if this was first connection, will be reinjected also on first placeDefinition RWebWindow.hxx:74; ROOT::RWebWindow::WebConn::fSendCreditsint fSendCredits! how many send operation can be performed without confirmation from other sideDefinition RWebWindow.hxx:87; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, unsigned wsid)Definition RWebWindow.hxx:96; ROOT::RWebWindow::WebConn::fNewKeystd::string fNewKey! new key if connection request reloadDefinition RWebWindow.hxx:77; ROOT::RWebWindow::WebConn::fWSIdunsigned fWSId! websocket idDefinition RWebWindow.hxx:82; ROOT::RWebWindow::WebConn::fSendStamptimestamp_t fSendStamp! last server operation, always used from window threadDefinition RWebWindow.hxx:80; ROOT::RWebWindow::WebConn::fRecvStamptimestamp_t fRecvStamp! last receive operation, protected with connection mutexDefinition RWebWindow.hxx:85; ROOT::",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:50342,Performance,perform,performed,50342,"ow::WebConn::WebConnWebConn(unsigned connid, bool headless_mode, const std::string &key)Definition RWebWindow.hxx:97; ROOT::RWebWindow::WebConn::fSendSequnsigned long fSendSeq! sequence id of last send packetDefinition RWebWindow.hxx:91; ROOT::RWebWindow::WebConn::fKeyUsedint fKeyUsed! key value used to verify connectionDefinition RWebWindow.hxx:76; ROOT::RWebWindow::WebConn::~WebConn~WebConn()Destructor for WebConn Notify special HTTP request which blocks headless browser from exit.Definition RWebWindow.cxx:42; ROOT::RWebWindow::WebConn::fMutexstd::mutex fMutex! mutex must be used to protect all following dataDefinition RWebWindow.hxx:84; ROOT::RWebWindow::WebConn::fDoingSendbool fDoingSend! true when performing send operationDefinition RWebWindow.hxx:89; ROOT::RWebWindow::WebConn::fWasFirstbool fWasFirst! indicate if this was first connection, will be reinjected also on first placeDefinition RWebWindow.hxx:74; ROOT::RWebWindow::WebConn::fSendCreditsint fSendCredits! how many send operation can be performed without confirmation from other sideDefinition RWebWindow.hxx:87; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, unsigned wsid)Definition RWebWindow.hxx:96; ROOT::RWebWindow::WebConn::fNewKeystd::string fNewKey! new key if connection request reloadDefinition RWebWindow.hxx:77; ROOT::RWebWindow::WebConn::fWSIdunsigned fWSId! websocket idDefinition RWebWindow.hxx:82; ROOT::RWebWindow::WebConn::fSendStamptimestamp_t fSendStamp! last server operation, always used from window threadDefinition RWebWindow.hxx:80; ROOT::RWebWindow::WebConn::fRecvStamptimestamp_t fRecvStamp! last receive operation, protected with connection mutexDefinition RWebWindow.hxx:85; ROOT::RWebWindow::WebConn::fRecvCountint fRecvCount! number of received packets, should return back with next sendingDefinition RWebWindow.hxx:86; ROOT::RWebWindow::WebConn::ResetStampsvoid ResetStamps()Definition RWebWindow.hxx:104; ROOT::RWebWindow::WebConn::fQueuestd::queue< QueueItem > fQueue! output ",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:51294,Performance,queue,queue,51294,"OOT::RWebWindow::WebConn::~WebConn~WebConn()Destructor for WebConn Notify special HTTP request which blocks headless browser from exit.Definition RWebWindow.cxx:42; ROOT::RWebWindow::WebConn::fMutexstd::mutex fMutex! mutex must be used to protect all following dataDefinition RWebWindow.hxx:84; ROOT::RWebWindow::WebConn::fDoingSendbool fDoingSend! true when performing send operationDefinition RWebWindow.hxx:89; ROOT::RWebWindow::WebConn::fWasFirstbool fWasFirst! indicate if this was first connection, will be reinjected also on first placeDefinition RWebWindow.hxx:74; ROOT::RWebWindow::WebConn::fSendCreditsint fSendCredits! how many send operation can be performed without confirmation from other sideDefinition RWebWindow.hxx:87; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, unsigned wsid)Definition RWebWindow.hxx:96; ROOT::RWebWindow::WebConn::fNewKeystd::string fNewKey! new key if connection request reloadDefinition RWebWindow.hxx:77; ROOT::RWebWindow::WebConn::fWSIdunsigned fWSId! websocket idDefinition RWebWindow.hxx:82; ROOT::RWebWindow::WebConn::fSendStamptimestamp_t fSendStamp! last server operation, always used from window threadDefinition RWebWindow.hxx:80; ROOT::RWebWindow::WebConn::fRecvStamptimestamp_t fRecvStamp! last receive operation, protected with connection mutexDefinition RWebWindow.hxx:85; ROOT::RWebWindow::WebConn::fRecvCountint fRecvCount! number of received packets, should return back with next sendingDefinition RWebWindow.hxx:86; ROOT::RWebWindow::WebConn::ResetStampsvoid ResetStamps()Definition RWebWindow.hxx:104; ROOT::RWebWindow::WebConn::fQueuestd::queue< QueueItem > fQueue! output queueDefinition RWebWindow.hxx:92; ROOT::RWebWindow::WebConn::fDisplayHandlestd::unique_ptr< RWebDisplayHandle > fDisplayHandle! handle assigned with started web display (when exists)Definition RWebWindow.hxx:78. guiwebdisplayincROOTRWebWindow.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:51328,Performance,queue,queueDefinition,51328,"OOT::RWebWindow::WebConn::~WebConn~WebConn()Destructor for WebConn Notify special HTTP request which blocks headless browser from exit.Definition RWebWindow.cxx:42; ROOT::RWebWindow::WebConn::fMutexstd::mutex fMutex! mutex must be used to protect all following dataDefinition RWebWindow.hxx:84; ROOT::RWebWindow::WebConn::fDoingSendbool fDoingSend! true when performing send operationDefinition RWebWindow.hxx:89; ROOT::RWebWindow::WebConn::fWasFirstbool fWasFirst! indicate if this was first connection, will be reinjected also on first placeDefinition RWebWindow.hxx:74; ROOT::RWebWindow::WebConn::fSendCreditsint fSendCredits! how many send operation can be performed without confirmation from other sideDefinition RWebWindow.hxx:87; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, unsigned wsid)Definition RWebWindow.hxx:96; ROOT::RWebWindow::WebConn::fNewKeystd::string fNewKey! new key if connection request reloadDefinition RWebWindow.hxx:77; ROOT::RWebWindow::WebConn::fWSIdunsigned fWSId! websocket idDefinition RWebWindow.hxx:82; ROOT::RWebWindow::WebConn::fSendStamptimestamp_t fSendStamp! last server operation, always used from window threadDefinition RWebWindow.hxx:80; ROOT::RWebWindow::WebConn::fRecvStamptimestamp_t fRecvStamp! last receive operation, protected with connection mutexDefinition RWebWindow.hxx:85; ROOT::RWebWindow::WebConn::fRecvCountint fRecvCount! number of received packets, should return back with next sendingDefinition RWebWindow.hxx:86; ROOT::RWebWindow::WebConn::ResetStampsvoid ResetStamps()Definition RWebWindow.hxx:104; ROOT::RWebWindow::WebConn::fQueuestd::queue< QueueItem > fQueue! output queueDefinition RWebWindow.hxx:92; ROOT::RWebWindow::WebConn::fDisplayHandlestd::unique_ptr< RWebDisplayHandle > fDisplayHandle! handle assigned with started web display (when exists)Definition RWebWindow.hxx:78. guiwebdisplayincROOTRWebWindow.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:8563,Safety,timeout,timeout,8563,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:16346,Safety,timeout,timeout,16346,"tNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 320 ; 321 /////////////////////////////////////////////////////////////////////////; 322 /// returns true if authentication string is required; 323 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 324 ; 325 /////////////////////////////////////////////////////////////////////////; 326 /// Configure if window can access local files via currentdir/ path of http server; 327 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 328 ; 329 /////////////////////////////////////////////////////////////////////////; 330 /// returns true if window can access local files via currentdir/ path of http server; 331 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 332 ; 333 void SetClientVersion(const std::string &vers);; 334 ; 335 std::string GetClientVersion() const;; 336 ; 337 void SetUserArgs(const std::string &args);; 338 ; 339 std::string GetUserArgs() const;; 340 ; 341 int NumConnections(bool with_pending = false) const;; 342 ; 343 unsigned GetConnectionId(int num = 0) const;; 344 ; 345 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 346 ; 347 bool HasConnection(unsigned connid = 0, bool only_active = true) const;; 348 ; 349 void CloseConnections();; 350 ; 351 void CloseConnection(unsigned connid);; 352 ; 353 /// Returns timeout for synchronous WebWindow operations; 354 float GetOperationTmout() const { return fOperationTmout; }; 355 ; 356 /// Set timeout for synchronous WebWindow operations; 357 void SetOperationTmout(float tm = 50.",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:16475,Safety,timeout,timeout,16475,"tNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 320 ; 321 /////////////////////////////////////////////////////////////////////////; 322 /// returns true if authentication string is required; 323 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 324 ; 325 /////////////////////////////////////////////////////////////////////////; 326 /// Configure if window can access local files via currentdir/ path of http server; 327 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 328 ; 329 /////////////////////////////////////////////////////////////////////////; 330 /// returns true if window can access local files via currentdir/ path of http server; 331 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 332 ; 333 void SetClientVersion(const std::string &vers);; 334 ; 335 std::string GetClientVersion() const;; 336 ; 337 void SetUserArgs(const std::string &args);; 338 ; 339 std::string GetUserArgs() const;; 340 ; 341 int NumConnections(bool with_pending = false) const;; 342 ; 343 unsigned GetConnectionId(int num = 0) const;; 344 ; 345 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 346 ; 347 bool HasConnection(unsigned connid = 0, bool only_active = true) const;; 348 ; 349 void CloseConnections();; 350 ; 351 void CloseConnection(unsigned connid);; 352 ; 353 /// Returns timeout for synchronous WebWindow operations; 354 float GetOperationTmout() const { return fOperationTmout; }; 355 ; 356 /// Set timeout for synchronous WebWindow operations; 357 void SetOperationTmout(float tm = 50.",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:30882,Safety,timeout,timeout,30882,"::size_t len)Send binary data to specified connection.Definition RWebWindow.cxx:1672; ROOT::RWebWindow::fYint fY! initial window position, -1 ignoredDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetXint GetX() constreturns configured window X position (-1 - default)Definition RWebWindow.hxx:289; ROOT::RWebWindow::Createstatic std::shared_ptr< RWebWindow > Create()Create new RWebWindow Using default RWebWindowsManager.Definition RWebWindow.cxx:1925; ROOT::RWebWindow::fWidthunsigned fWidthDefinition RWebWindow.hxx:169; ROOT::RWebWindow::fClientVersionstd::string fClientVersion! configured client version, used as prefix in scripts URLDefinition RWebWindow.hxx:172; ROOT::RWebWindow::ProcessBatchHolderbool ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request, used to hold headless browser running Such requests should not be repli...Definition RWebWindow.cxx:375; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:357; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1888; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1795; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1429; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1775; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:171; ROOT::RWebWindow::fRequireAu",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:31779,Safety,timeout,timeout,31779,"ebWindow.cxx:375; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:357; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1888; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1795; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1429; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1775; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:171; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:149; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:238; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1352; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:156; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:285; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:34774,Safety,timeout,timeout,34774,"e window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:2019; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1489; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:152; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only active connections are returned -...Definition RWebWindow.cxx:1412; ROOT::RWebWindow::GetConnTokenstd::string GetConnToken() constReturns configured connection token.Definition RWebWindow.cxx:726; ROOT::RWebWindow::GetOperationTmoutfloat GetOperationTmout() constReturns timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:354; ROOT::RWebWindow::SetConnLimitvoid SetConnLimit(unsigned lmt=0)Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing con...Definition RWebWindow.cxx:694; ROOT::RWebWindow::SetPanelNamevoid SetPanelName(const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:272; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:323; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWeb",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:6645,Security,authenticat,authentication,6645,"Data(data) {}; 135 };; 136 ; 137 using ConnectionsList_t = std::vector<std::shared_ptr<WebConn>>;; 138 ; 139 std::shared_ptr<RWebWindowsManager> fMgr; ///<! display manager; 140 std::shared_ptr<RWebWindow> fMaster; ///<! master window where this window is embedded; 141 std::vector<MasterConn> fMasterConns; ///<! master connections; 142 std::string fDefaultPage; ///<! HTML page (or file name) returned when window URL is opened; 143 std::string fPanelName; ///<! panel name which should be shown in the window; 144 unsigned fId{0}; ///<! unique identifier; 145 bool fUseServerThreads{false}; ///<! indicates that server thread is using, no special window thread; 146 bool fUseProcessEvents{false}; ///<! all window functionality will run through process events; 147 bool fProcessMT{false}; ///<! if window event processing performed in dedicated thread; 148 bool fSendMT{false}; ///<! true is special threads should be used for sending data; 149 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 150 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 151 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 152 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 153 ConnectionsList_t fConn; ///<! list of all accepted connections; 154 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 155 unsigned fConnLimit{1}; ///<! number of allowed active connections; 156 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 157 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 158 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 159 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 160 WebWindowConnectCallback_t fConnCallback",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:7480,Security,access,access,7480,"med in dedicated thread; 148 bool fSendMT{false}; ///<! true is special threads should be used for sending data; 149 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 150 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 151 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 152 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 153 ConnectionsList_t fConn; ///<! list of all accepted connections; 154 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 155 unsigned fConnLimit{1}; ///<! number of allowed active connections; 156 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 157 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 158 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 159 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 160 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 161 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 162 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; //",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:9154,Security,access,accessible,9154,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:14949,Security,authenticat,authentication,14949,///////////////////////////////////////////////////////; 302 /// configures maximal queue length of data which can be held by window; 303 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 304 ; 305 /////////////////////////////////////////////////////////////////////////; 306 /// Return maximal queue length of data which can be held by window; 307 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 308 ; 309 /////////////////////////////////////////////////////////////////////////; 310 /// configures that only native (own-created) connections are allowed; 311 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 320 ; 321 /////////////////////////////////////////////////////////////////////////; 322 /// returns true if authentication string is required; 323 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 324 ; 325 /////////////////////////////////////////////////////////////////////////; 326 /// Configure if window can access local files via currentdir/ path of http server; 327 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 328 ; 329 /////////////////////////////////////////////////////////////////////////; 330 /// returns true if window can access local files via currentdir/ path of http server; 331 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 332 ; 333 void SetClientVersion(const std::string &vers);; 334 ; 335 std::string GetClientVersion() const;; 336 ; 337 void SetUserArgs(const std::string &args);; 338 ; 339 std::string GetUserArgs() const;; 3,MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:15174,Security,authenticat,authentication,15174,//////////////////////////////////////////////////////////////////; 306 /// Return maximal queue length of data which can be held by window; 307 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 308 ; 309 /////////////////////////////////////////////////////////////////////////; 310 /// configures that only native (own-created) connections are allowed; 311 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 320 ; 321 /////////////////////////////////////////////////////////////////////////; 322 /// returns true if authentication string is required; 323 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 324 ; 325 /////////////////////////////////////////////////////////////////////////; 326 /// Configure if window can access local files via currentdir/ path of http server; 327 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 328 ; 329 /////////////////////////////////////////////////////////////////////////; 330 /// returns true if window can access local files via currentdir/ path of http server; 331 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 332 ; 333 void SetClientVersion(const std::string &vers);; 334 ; 335 std::string GetClientVersion() const;; 336 ; 337 void SetUserArgs(const std::string &args);; 338 ; 339 std::string GetUserArgs() const;; 340 ; 341 int NumConnections(bool with_pending = false) const;; 342 ; 343 unsigned GetConnectionId(int num = 0) const;; 344 ; 345 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 346 ; 347 bool HasConnectio,MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:15389,Security,access,access,15389,"8 ; 309 /////////////////////////////////////////////////////////////////////////; 310 /// configures that only native (own-created) connections are allowed; 311 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 320 ; 321 /////////////////////////////////////////////////////////////////////////; 322 /// returns true if authentication string is required; 323 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 324 ; 325 /////////////////////////////////////////////////////////////////////////; 326 /// Configure if window can access local files via currentdir/ path of http server; 327 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 328 ; 329 /////////////////////////////////////////////////////////////////////////; 330 /// returns true if window can access local files via currentdir/ path of http server; 331 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 332 ; 333 void SetClientVersion(const std::string &vers);; 334 ; 335 std::string GetClientVersion() const;; 336 ; 337 void SetUserArgs(const std::string &args);; 338 ; 339 std::string GetUserArgs() const;; 340 ; 341 int NumConnections(bool with_pending = false) const;; 342 ; 343 unsigned GetConnectionId(int num = 0) const;; 344 ; 345 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 346 ; 347 bool HasConnection(unsigned connid = 0, bool only_active = true) const;; 348 ; 349 void CloseConnections();; 350 ; 351 void CloseConnection(unsigned connid);; 352 ; 353 /// Returns timeout for synchronous WebWindow operations; 3",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:15633,Security,access,access,15633,"tNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 312 ; 313 /////////////////////////////////////////////////////////////////////////; 314 /// returns true if only native (own-created) connections are allowed; 315 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 316 ; 317 /////////////////////////////////////////////////////////////////////////; 318 /// Configure if authentication key in connection string is required; 319 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 320 ; 321 /////////////////////////////////////////////////////////////////////////; 322 /// returns true if authentication string is required; 323 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 324 ; 325 /////////////////////////////////////////////////////////////////////////; 326 /// Configure if window can access local files via currentdir/ path of http server; 327 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 328 ; 329 /////////////////////////////////////////////////////////////////////////; 330 /// returns true if window can access local files via currentdir/ path of http server; 331 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 332 ; 333 void SetClientVersion(const std::string &vers);; 334 ; 335 std::string GetClientVersion() const;; 336 ; 337 void SetUserArgs(const std::string &args);; 338 ; 339 std::string GetUserArgs() const;; 340 ; 341 int NumConnections(bool with_pending = false) const;; 342 ; 343 unsigned GetConnectionId(int num = 0) const;; 344 ; 345 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 346 ; 347 bool HasConnection(unsigned connid = 0, bool only_active = true) const;; 348 ; 349 void CloseConnections();; 350 ; 351 void CloseConnection(unsigned connid);; 352 ; 353 /// Returns timeout for synchronous WebWindow operations; 354 float GetOperationTmout() const { return fOperationTmout; }; 355 ; 356 /// Set timeout for synchronous WebWindow operations; 357 void SetOperationTmout(float tm = 50.",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:25197,Security,hash,hash,25197,":151; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:175; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1500; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks should be invokedDefinition RWebWindow.hxx:163; ROOT::RWebWindow::RemoveKeyvoid RemoveKey(const std::string &key)Removes all connections with the key.Definition RWebWindow.cxx:584; ROOT::RWebWindow::fInputQueuestd::queue< QueueEntry > fInputQueue! input queue for all callbacksDefinition RWebWindow.hxx:167; ROOT::RWebWindow::_CanTrustInbool _CanTrustIn(std::shared_ptr< WebConn > &conn, const std::string &key, const std::string &ntry, bool remote, bool test_first_time)Check if provided hash, ntry parameters from the connection request could be accepted.Definition RWebWindow.cxx:514; ROOT::RWebWindow::SetConnTokenvoid SetConnToken(const std::string &token="""")Configures connection token (default none) When specified, in URL of webpage such token should be pro...Definition RWebWindow.cxx:716; ROOT::RWebWindow::MakeHeadlessunsigned MakeHeadless(bool create_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnections()Closes all connection to clients Normally leads to closing of all correspondent browser windows Some ...Definition RWebWindow.cxx:1480; ROOT::RWebWindow::fMasterstd::shared_ptr< RWebWindo",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:26605,Security,access,accessible,26605,"_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnections()Closes all connection to clients Normally leads to closing of all correspondent browser windows Some ...Definition RWebWindow.cxx:1480; ROOT::RWebWindow::fMasterstd::shared_ptr< RWebWindow > fMaster! master window where this window is embeddedDefinition RWebWindow.hxx:140; ROOT::RWebWindow::NumConnectionsint NumConnections(bool with_pending=false) constReturns current number of active clients connections.Definition RWebWindow.cxx:1372; ROOT::RWebWindow::fCallbacksThrdIdSetbool fCallbacksThrdIdSet! flag indicating that thread id is assignedDefinition RWebWindow.hxx:164; ROOT::RWebWindow::fUserArgsstd::string fUserArgs! arbitrary JSON code, which is accessible via conn.getUserArgs() methodDefinition RWebWindow.hxx:178; ROOT::RWebWindow::SetDefaultPagevoid SetDefaultPage(const std::string &page)Set content of default window HTML page This page returns when URL address of the window will be requ...Definition RWebWindow.hxx:260; ROOT::RWebWindow::fConnLimitunsigned fConnLimit! number of allowed active connectionsDefinition RWebWindow.hxx:155; ROOT::RWebWindow::InvokeCallbacksvoid InvokeCallbacks(bool force=false)Invoke callbacks with existing data Must be called from appropriate thread.Definition RWebWindow.cxx:439; ROOT::RWebWindow::FindConnectionstd::shared_ptr< WebConn > FindConnection(unsigned wsid)Find connection with specified websocket id.Definition RWebWindow.cxx:264; ROOT::RWebWindow::GetClientVersionstd::string GetClientVersion() constReturns current client version.Definition RWebWindow.cxx:1340; ROOT::RWebWindow::SetConnectCallBackvoid SetConnectCallBack(WebWindowConnectCallback_t func)Set",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:28564,Security,access,access,28564,"func)Set call-back function for new connection.Definition RWebWindow.cxx:1785; ROOT::RWebWindow::IsShownbool IsShown() constReturns true when window was shown at least once.Definition RWebWindow.hxx:372; ROOT::RWebWindow::Syncvoid Sync()Special method to process all internal activity when window runs in separate thread.Definition RWebWindow.cxx:1269; ROOT::RWebWindow::UseServerThreadsvoid UseServerThreads()Let use THttpServer threads to process requests WARNING!!! only for expert use Should be only used wh...Definition RWebWindow.cxx:1709; ROOT::RWebWindow::SetGeometryvoid SetGeometry(unsigned width, unsigned height)Set window geometry. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:265; ROOT::RWebWindow::TerminateROOTvoid TerminateROOT()Terminate ROOT session Tries to correctly close THttpServer, associated with RWebWindowsManager After...Definition RWebWindow.cxx:1935; ROOT::RWebWindow::fUseCurrentDirbool fUseCurrentDir! if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:158; ROOT::RWebWindow::Sendvoid Send(unsigned connid, const std::string &data)Sends data to specified connection.Definition RWebWindow.cxx:1651; ROOT::RWebWindow::Showunsigned Show(const RWebDisplayArgs &args="""")Show window in specified location.Definition RWebWindow.cxx:191; ROOT::RWebWindow::GetServerTHttpServer * GetServer()Return THttpServer instance serving requests to the window.Definition RWebWindow.cxx:181; ROOT::RWebWindow::AddDisplayHandleunsigned AddDisplayHandle(bool headless_mode, const std::string &key, std::unique_ptr< RWebDisplayHandle > &handle)Add display handle and associated key Key is large random string generated when starting new window W...Definition RWebWindow.cxx:483; ROOT::RWebWindow::ConnectionsList_tstd::vector< std::shared_ptr< WebConn > > ConnectionsList_tDefinition RWebWindow.hxx:137; ROOT::RWebWindow::AssignThreadIdvoid AssignThreadId()Assign thread id which has to be used f",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:31940,Security,authenticat,authentication,31940,"ndow.hxx:357; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1888; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1795; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1429; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1775; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:171; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:149; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:238; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1352; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:156; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:285; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definitio",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:32315,Security,access,accessible,32315,".Definition RWebWindow.cxx:1795; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1429; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1775; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:171; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:149; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:238; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1352; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:156; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:285; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definition RWebWindow.cxx:1957; ROOT::RWebWindow::fWSHandlerstd::shared_ptr< RWebWindowWSHandler > fWSHandler! specialize websocket handler for all incoming connectionsDefinition RWebWindow.hxx:150; ROOT::RWebWindow::StopThreadvoid StopThread()Stop special thread.Definition RWebWindow.cxx:1744; ROOT::RWebWindow::SubmitDatavoid Submi",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:33538,Security,checksum,checksum,33538,"h should be provided for connecting windowDefinition RWebWindow.hxx:156; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:285; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definition RWebWindow.cxx:1957; ROOT::RWebWindow::fWSHandlerstd::shared_ptr< RWebWindowWSHandler > fWSHandler! specialize websocket handler for all incoming connectionsDefinition RWebWindow.hxx:150; ROOT::RWebWindow::StopThreadvoid StopThread()Stop special thread.Definition RWebWindow.cxx:1744; ROOT::RWebWindow::SubmitDatavoid SubmitData(unsigned connid, bool txt, std::string &&data, int chid=1)Internal method to send data.Definition RWebWindow.cxx:1571; ROOT::RWebWindow::HMACstatic std::string HMAC(const std::string &key, const std::string &sessionKey, const char *msg, int msglen)Calculate HMAC checksum for provided key and message Key combained from connection key and session ke...Definition RWebWindow.cxx:2034; ROOT::RWebWindow::~RWebWindow~RWebWindow()RWebWindow destructor Closes all connections and remove window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:2019; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1489; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:152; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only ac",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:35518,Security,authenticat,authentication,35518,"y active connections are returned -...Definition RWebWindow.cxx:1412; ROOT::RWebWindow::GetConnTokenstd::string GetConnToken() constReturns configured connection token.Definition RWebWindow.cxx:726; ROOT::RWebWindow::GetOperationTmoutfloat GetOperationTmout() constReturns timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:354; ROOT::RWebWindow::SetConnLimitvoid SetConnLimit(unsigned lmt=0)Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing con...Definition RWebWindow.cxx:694; ROOT::RWebWindow::SetPanelNamevoid SetPanelName(const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:272; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:323; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWebWindow::SetNativeOnlyConnvoid SetNativeOnlyConn(bool on=true)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:311; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:176; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1551; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigne",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:42140,Security,access,access,42140,"Window::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:281; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:166; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:422; ROOT::RWebWindow::HasKeybool HasKey(const std::string &key, bool also_newkey=false) constReturns true if provided key value already exists (in processes map or in existing connections) In sp...Definition RWebWindow.cxx:559; ROOT::RWebWindow::CompleteWSSendvoid CompleteWSSend(unsigned wsid)Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be start...Definition RWebWindow.cxx:1121; ROOT::RWebWindow::IsUseCurrentDirbool IsUseCurrentDir() constreturns true if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:331; ROOT::RWebWindow::fUseServerThreadsbool fUseServerThreads! indicates that server thread is using, no special window threadDefinition RWebWindow.hxx:145; ROOT::RWebWindow::FindHeadlessConnectionunsigned FindHeadlessConnection()Returns connection id of window running in headless mode This can be special connection which may run...Definition RWebWindow.cxx:221; ROOT::RWebWindow::WaitForTimedint WaitForTimed(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1845; ROOT::RWebWindow::fProcessMTbool fProcessMT! if window event processing performed in dedicated threadDefinition RWebWindow.hxx:147; ROOT::RWebWindow::fProtocolCntint fProtocolCnt! counter for protocol recordingDefinition RWebWindow.hxx:174; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client ve",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:44042,Security,authenticat,authentication,44042,"dow.hxx:174; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client version, used as prefix in scripts URL When changed, web browser will reload all related J...Definition RWebWindow.cxx:1331; ROOT::RWebWindow::RemoveMasterConnectionvoid RemoveMasterConnection(unsigned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:344; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1909; ROOT::RWebWindow::SetCallBacks_R__DEPRECATED_LATER(""Use GetUrl() to get valid connection URL"") std _R__DEPRECATED_LATER(""Use GetAddr() to get valid connection URL"") std void SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1814; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWindow.hxx:319; ROOT::RWebWindow::GenerateKeystd::string GenerateKey() constGenerate new unique key for the window.Definition RWebWindow.cxx:612; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:327; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:162; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:307; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWe",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:44348,Security,access,access,44348,"gned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:344; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1909; ROOT::RWebWindow::SetCallBacks_R__DEPRECATED_LATER(""Use GetUrl() to get valid connection URL"") std _R__DEPRECATED_LATER(""Use GetAddr() to get valid connection URL"") std void SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1814; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWindow.hxx:319; ROOT::RWebWindow::GenerateKeystd::string GenerateKey() constGenerate new unique key for the window.Definition RWebWindow.cxx:612; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:327; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:162; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:307; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Data@ kind_DataDefinition RWebWindow.hxx:127; ROOT::RWebWindow::IsFileDialogMessagestatic bool IsFileDialogMessage(const std::string &msg)Check if this could be the message send by client to start new file dialog If returns true,...Definition RWebWindow.cxx:200",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:9258,Usability,clear,cleared,9258,,MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:23731,Usability,clear,cleared,23731,"tion If there are many connections - only same master is allowed.Definition RWebWindow.cxx:311; ROOT::RWebWindow::fConnMutexstd::mutex fConnMutex! mutex used to protect connection listDefinition RWebWindow.hxx:154; ROOT::RWebWindow::fDataCallbackWebWindowDataCallback_t fDataCallback! main callback when data over channel 1 is arrivedDefinition RWebWindow.hxx:161; ROOT::RWebWindow::CheckInactiveConnectionsvoid CheckInactiveConnections()Check if there are connection which are inactive for longer time For instance, batch browser will be ...Definition RWebWindow.cxx:659; ROOT::RWebWindow::fIdunsigned fId! unique identifierDefinition RWebWindow.hxx:144; ROOT::RWebWindow::fHasWindowThrdbool fHasWindowThrd! indicate if special window thread was startedDefinition RWebWindow.hxx:165; ROOT::RWebWindow::fMasterConnsstd::vector< MasterConn > fMasterConns! master connectionsDefinition RWebWindow.hxx:141; ROOT::RWebWindow::SetClearOnClosevoid SetClearOnClose(const std::shared_ptr< void > &handle=nullptr)Set handle which is cleared when last active connection is closed Typically can be used to destroy we...Definition RWebWindow.cxx:1806; ROOT::RWebWindow::StartThreadvoid StartThread()Start special thread which will be used by the window to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1722; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:151; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:175; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1500; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks ",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/RWebWindow_8hxx_source.html:39995,Usability,clear,cleared,39995,":fProtocolFileNamestd::string fProtocolFileName! local file where communication protocol will be writtenDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:293; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:157; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:254; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:153; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:160; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:625; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:179; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:168; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1140; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:62; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:303; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:737; ROOT::RWebWindow::HasConnectionboo",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
https://root.cern/doc/master/saveall_8C.html:508,Safety,avoid,avoid,508,". ROOT: tutorials/graphics/saveall.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. saveall.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Creates many canvases and save as images or pdf. ; This macro creates 100 canvases and store them in different images files using TCanvas::SaveAll() method. Demonstrated how different output format can be used in batch mode.; ; void saveall(); {; gROOT->SetBatch(kTRUE); // enforce batch mode to avoid appearance of multiple canvas windows; ; std::vector<TPad *> pads;; ; for(int n = 0; n < 100; ++n) {; auto c = new TCanvas(TString::Format(""canvas%d"", n), ""Canvas with histogram"");; ; auto h1 = new TH1I(TString::Format(""hist%d"", n), ""Histogram with random data"", 100, -5., 5);; h1->SetDirectory(nullptr);; h1->FillRandom(""gaus"", 10000);; ; h1->Draw();; ; pads.push_back(c);; }; ; TCanvas::SaveAll(pads, ""image%03d.png""); // create 100 PNG images; ; TCanvas::SaveAll(pads, ""image.svg""); // create 100 SVG images, %d pattern will be automatically append; ; TCanvas::SaveAll(pads, ""images.root""); // create single ROOT file with all canvases; ; TCanvas::SaveAll(); // save all existing canvases in allcanvases.pdf file; }; c#define c(i)Definition RSha256.hxx:101; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gROOT#define gROOTDefinition TROOT.h:406; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::SaveAllstatic Bool_t SaveAll(const std::vector< TPad * > &={}, const char *filename="""", Option_t *option="""")Save provided pads/canvases into the image file(s) Filename can include printf argument for image num...Definition TCanvas.cxx:2654; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FillRandomvirtual void FillRandom(const char *fnam",MatchSource.WIKI,doc/master/saveall_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/saveall_8C.html
https://root.cern/doc/master/save__batch_8C.html:425,Performance,perform,performance,425,". ROOT: tutorials/graphics/save_batch.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. save_batch.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro demonstrates batch image mode of web canvas When enabled - several images converted into JSON before all together provided to headless browser to produce image files. ; Let significantly increase performance. Important - disable batch mode for flushing remaining images; ; void save_batch(); {; // 37 canvases will be collected together for conversion; TWebCanvas::BatchImageMode(37);; ; auto c = new TCanvas(""canvas"", ""Canvas with histogram"");; ; auto h1 = new TH1I(""hist"", ""Histogram with random data"", 100, -5., 5);; h1->SetDirectory(nullptr);; h1->FillRandom(""gaus"", 10000);; h1->Draw();; ; for(int n = 0; n < 100; ++n) {; h1->FillRandom(""gaus"", 10000);; c->SaveAs(TString::Format(""batch_image_%03d.png"", n));; }; ; // Important - disabling batch mode also flush remaining images; TWebCanvas::BatchImageMode(0);; }; c#define c(i)Definition RSha256.hxx:101; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TWebCanvas::BatchImageModestatic void BatchImageMode(UInt_t n=100)Configure batch image mode for web graphics.Definitio",MatchSource.WIKI,doc/master/save__batch_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/save__batch_8C.html
https://root.cern/doc/master/Scanner_8cxx.html:649,Integrability,depend,dependency,649,". ROOT: core/dictgen/src/Scanner.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; Scanner.cxx File Reference. #include ""Scanner.h""; #include ""clang/AST/ASTConsumer.h""; #include ""clang/Basic/SourceLocation.h""; #include ""clang/Basic/SourceManager.h""; #include ""llvm/ADT/SmallSet.h""; #include ""clang/Sema/Sema.h""; #include ""clang/Frontend/CompilerInstance.h""; #include ""cling/Interpreter/Interpreter.h""; #include ""llvm/Support/Path.h""; #include ""TClassEdit.h""; #include <iostream>; #include <sstream>; #include ""llvm/ADT/StringExtras.h""; #include ""SelectionRules.h"". Include dependency graph for Scanner.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; std::string AddSpace (const std::string &txt);  ; long APIntToLong (const llvm::APInt &num);  ; size_t APIntToSize (const llvm::APInt &num);  ; std::string APIntToStr (const llvm::APInt &num);  ; std::string IntToStd (int num);  ; std::string IntToStr (int num);  ; std::string Message (const std::string &msg, const std::string &location);  ; void * ToDeclProp (clang::Decl *item);  . Variables; cling::Interpreter * gInterp;  . Function Documentation. ◆ AddSpace(). std::string AddSpace ; (; const std::string & ; txt). inline . Definition at line 266 of file Scanner.cxx. ◆ APIntToLong(). long APIntToLong ; (; const llvm::APInt & ; num). inline . Definition at line 147 of file Scanner.cxx. ◆ APIntToSize(). size_t APIntToSize ; (; const llvm::APInt & ; num). inline . Definition at line 140 of file Scanner.cxx. ◆ APIntToStr(). std::string APIntToStr ; (; const llvm::APInt & ; num). inline . Definition at line 154 of file Scanner.cxx. ◆ IntToStd(). std::string IntToStd ; (; int ; num). inline . Definition at line 170 of file Scanner.cxx. ◆ IntToStr(). std::string IntToStr ; (; int ; num). inline . Definition at line 161 of file Scanner.cxx. ◆ Message(). std::string Message ; (; const std::string & ; msg, . co",MatchSource.WIKI,doc/master/Scanner_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx.html
https://root.cern/doc/master/Scanner_8cxx_source.html:6316,Integrability,message,message,6316,"std::string IntToStd(int num); 171{; 172 std::ostringstream stream;; 173 stream << num;; 174 return stream.str();; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178 ; 179inline std::string Message(const std::string &msg, const std::string &location); 180{; 181 std::string loc = location;; 182 ; 183 if (loc == """"); 184 return msg;; 185 else; 186 return loc + "" "" + msg;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190 ; 191void RScanner::ShowInfo(const std::string &msg, const std::string &location) const; 192{; 193 const std::string message = Message(msg, location);; 194 std::cout << message << std::endl;; 195}; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198 ; 199void RScanner::ShowWarning(const std::string &msg, const std::string &location) const; 200{; 201 const std::string message = Message(msg, location);; 202 std::cout << message << std::endl;; 203}; 204 ; 205////////////////////////////////////////////////////////////////////////////////; 206 ; 207void RScanner::ShowError(const std::string &msg, const std::string &location) const; 208{; 209 const std::string message = Message(msg, location);; 210 std::cout << message << std::endl;; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214 ; 215void RScanner::ShowTemplateInfo(const std::string &msg, const std::string &location) const; 216{; 217 std::string loc = location;; 218 if (loc == """"); 219 loc = GetLocation (fLastDecl);; 220 ShowWarning(msg, loc);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224 ; 225std::string RScanner::GetSrcLocation(clang::SourceLocation L) const; 226{; 227 std::string location = """";; 228 llvm::raw_string_ostream stream(location);; 229 L.print(stream, *fSourceManager);; 230 return stream.str();; 231}; 232 ; 233/////////////////////////////////",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:6368,Integrability,message,message,6368,"std::string IntToStd(int num); 171{; 172 std::ostringstream stream;; 173 stream << num;; 174 return stream.str();; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178 ; 179inline std::string Message(const std::string &msg, const std::string &location); 180{; 181 std::string loc = location;; 182 ; 183 if (loc == """"); 184 return msg;; 185 else; 186 return loc + "" "" + msg;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190 ; 191void RScanner::ShowInfo(const std::string &msg, const std::string &location) const; 192{; 193 const std::string message = Message(msg, location);; 194 std::cout << message << std::endl;; 195}; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198 ; 199void RScanner::ShowWarning(const std::string &msg, const std::string &location) const; 200{; 201 const std::string message = Message(msg, location);; 202 std::cout << message << std::endl;; 203}; 204 ; 205////////////////////////////////////////////////////////////////////////////////; 206 ; 207void RScanner::ShowError(const std::string &msg, const std::string &location) const; 208{; 209 const std::string message = Message(msg, location);; 210 std::cout << message << std::endl;; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214 ; 215void RScanner::ShowTemplateInfo(const std::string &msg, const std::string &location) const; 216{; 217 std::string loc = location;; 218 if (loc == """"); 219 loc = GetLocation (fLastDecl);; 220 ShowWarning(msg, loc);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224 ; 225std::string RScanner::GetSrcLocation(clang::SourceLocation L) const; 226{; 227 std::string location = """";; 228 llvm::raw_string_ostream stream(location);; 229 L.print(stream, *fSourceManager);; 230 return stream.str();; 231}; 232 ; 233/////////////////////////////////",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:6612,Integrability,message,message,6612,"std::string IntToStd(int num); 171{; 172 std::ostringstream stream;; 173 stream << num;; 174 return stream.str();; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178 ; 179inline std::string Message(const std::string &msg, const std::string &location); 180{; 181 std::string loc = location;; 182 ; 183 if (loc == """"); 184 return msg;; 185 else; 186 return loc + "" "" + msg;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190 ; 191void RScanner::ShowInfo(const std::string &msg, const std::string &location) const; 192{; 193 const std::string message = Message(msg, location);; 194 std::cout << message << std::endl;; 195}; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198 ; 199void RScanner::ShowWarning(const std::string &msg, const std::string &location) const; 200{; 201 const std::string message = Message(msg, location);; 202 std::cout << message << std::endl;; 203}; 204 ; 205////////////////////////////////////////////////////////////////////////////////; 206 ; 207void RScanner::ShowError(const std::string &msg, const std::string &location) const; 208{; 209 const std::string message = Message(msg, location);; 210 std::cout << message << std::endl;; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214 ; 215void RScanner::ShowTemplateInfo(const std::string &msg, const std::string &location) const; 216{; 217 std::string loc = location;; 218 if (loc == """"); 219 loc = GetLocation (fLastDecl);; 220 ShowWarning(msg, loc);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224 ; 225std::string RScanner::GetSrcLocation(clang::SourceLocation L) const; 226{; 227 std::string location = """";; 228 llvm::raw_string_ostream stream(location);; 229 L.print(stream, *fSourceManager);; 230 return stream.str();; 231}; 232 ; 233/////////////////////////////////",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:6664,Integrability,message,message,6664,"std::string IntToStd(int num); 171{; 172 std::ostringstream stream;; 173 stream << num;; 174 return stream.str();; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178 ; 179inline std::string Message(const std::string &msg, const std::string &location); 180{; 181 std::string loc = location;; 182 ; 183 if (loc == """"); 184 return msg;; 185 else; 186 return loc + "" "" + msg;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190 ; 191void RScanner::ShowInfo(const std::string &msg, const std::string &location) const; 192{; 193 const std::string message = Message(msg, location);; 194 std::cout << message << std::endl;; 195}; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198 ; 199void RScanner::ShowWarning(const std::string &msg, const std::string &location) const; 200{; 201 const std::string message = Message(msg, location);; 202 std::cout << message << std::endl;; 203}; 204 ; 205////////////////////////////////////////////////////////////////////////////////; 206 ; 207void RScanner::ShowError(const std::string &msg, const std::string &location) const; 208{; 209 const std::string message = Message(msg, location);; 210 std::cout << message << std::endl;; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214 ; 215void RScanner::ShowTemplateInfo(const std::string &msg, const std::string &location) const; 216{; 217 std::string loc = location;; 218 if (loc == """"); 219 loc = GetLocation (fLastDecl);; 220 ShowWarning(msg, loc);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224 ; 225std::string RScanner::GetSrcLocation(clang::SourceLocation L) const; 226{; 227 std::string location = """";; 228 llvm::raw_string_ostream stream(location);; 229 L.print(stream, *fSourceManager);; 230 return stream.str();; 231}; 232 ; 233/////////////////////////////////",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:6906,Integrability,message,message,6906,"std::string IntToStd(int num); 171{; 172 std::ostringstream stream;; 173 stream << num;; 174 return stream.str();; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178 ; 179inline std::string Message(const std::string &msg, const std::string &location); 180{; 181 std::string loc = location;; 182 ; 183 if (loc == """"); 184 return msg;; 185 else; 186 return loc + "" "" + msg;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190 ; 191void RScanner::ShowInfo(const std::string &msg, const std::string &location) const; 192{; 193 const std::string message = Message(msg, location);; 194 std::cout << message << std::endl;; 195}; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198 ; 199void RScanner::ShowWarning(const std::string &msg, const std::string &location) const; 200{; 201 const std::string message = Message(msg, location);; 202 std::cout << message << std::endl;; 203}; 204 ; 205////////////////////////////////////////////////////////////////////////////////; 206 ; 207void RScanner::ShowError(const std::string &msg, const std::string &location) const; 208{; 209 const std::string message = Message(msg, location);; 210 std::cout << message << std::endl;; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214 ; 215void RScanner::ShowTemplateInfo(const std::string &msg, const std::string &location) const; 216{; 217 std::string loc = location;; 218 if (loc == """"); 219 loc = GetLocation (fLastDecl);; 220 ShowWarning(msg, loc);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224 ; 225std::string RScanner::GetSrcLocation(clang::SourceLocation L) const; 226{; 227 std::string location = """";; 228 llvm::raw_string_ostream stream(location);; 229 L.print(stream, *fSourceManager);; 230 return stream.str();; 231}; 232 ; 233/////////////////////////////////",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:6958,Integrability,message,message,6958,"std::string IntToStd(int num); 171{; 172 std::ostringstream stream;; 173 stream << num;; 174 return stream.str();; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178 ; 179inline std::string Message(const std::string &msg, const std::string &location); 180{; 181 std::string loc = location;; 182 ; 183 if (loc == """"); 184 return msg;; 185 else; 186 return loc + "" "" + msg;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190 ; 191void RScanner::ShowInfo(const std::string &msg, const std::string &location) const; 192{; 193 const std::string message = Message(msg, location);; 194 std::cout << message << std::endl;; 195}; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198 ; 199void RScanner::ShowWarning(const std::string &msg, const std::string &location) const; 200{; 201 const std::string message = Message(msg, location);; 202 std::cout << message << std::endl;; 203}; 204 ; 205////////////////////////////////////////////////////////////////////////////////; 206 ; 207void RScanner::ShowError(const std::string &msg, const std::string &location) const; 208{; 209 const std::string message = Message(msg, location);; 210 std::cout << message << std::endl;; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214 ; 215void RScanner::ShowTemplateInfo(const std::string &msg, const std::string &location) const; 216{; 217 std::string loc = location;; 218 if (loc == """"); 219 loc = GetLocation (fLastDecl);; 220 ShowWarning(msg, loc);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224 ; 225std::string RScanner::GetSrcLocation(clang::SourceLocation L) const; 226{; 227 std::string location = """";; 228 llvm::raw_string_ostream stream(location);; 229 L.print(stream, *fSourceManager);; 230 return stream.str();; 231}; 232 ; 233/////////////////////////////////",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:21510,Integrability,depend,dependent,21510,"es.; 622 // At the end of the method, if the typedef name is matched, an AnnotatedRecordDecl; 623 // with the underlying RecordDecl is fed to the machinery.; 624 ; 625 const clang::RecordDecl* recordDecl = clang::dyn_cast<clang::RecordDecl>(typeDecl);; 626 const clang::TypedefNameDecl* typedefNameDecl = clang::dyn_cast<clang::TypedefNameDecl>(typeDecl);; 627 ; 628 // If typeDecl is not a RecordDecl, try to fetch the RecordDecl behind the TypedefDecl; 629 if (!recordDecl && typedefNameDecl) {; 630 recordDecl = ROOT::TMetaUtils::GetUnderlyingRecordDecl(typedefNameDecl->getUnderlyingType());; 631 }; 632 ; 633 // If at this point recordDecl is still NULL, we have a problem; 634 if (!recordDecl) {; 635 ROOT::TMetaUtils::Warning(""RScanner::TreatRecordDeclOrTypeNameDecl"",; 636 ""Could not cast typeDecl either to RecordDecl or could not get RecordDecl underneath typedef.\n"");; 637 return true;; 638 }; 639 ; 640 // Do not select unnamed records.; 641 if (!recordDecl->getIdentifier()); 642 return true;; 643 ; 644 // Do not select dependent types.; 645 if (recordDecl->isDependentType()); 646 return true;; 647 ; 648 if (fScanType == EScanType::kOnePCM && ROOT::TMetaUtils::IsStdClass(*recordDecl)); 649 return true;; 650 ; 651 ; 652 // At this point, recordDecl must be a RecordDecl pointer.; 653 ; 654 if (fRecordDeclCallback) {; 655 // Pass on any declaration. This is usually used to record dependency.; 656 // Since rootcint see C++ compliant header files, we can assume that; 657 // if a forward declaration or declaration has been inserted, the; 658 // classes for which we are creating a dictionary will be using; 659 // them either directly or indirectly. Any false positive can be; 660 // resolved by removing the spurrious dependency in the (user) header; 661 // files.; 662 fRecordDeclCallback(recordDecl);; 663 }; 664 ; 665 // in case it is implicit or a forward declaration, we are not interested.; 666 if(recordDecl->isImplicit() || !recordDecl->isCompleteDefinition()) {; 667 retu",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:21874,Integrability,depend,dependency,21874," a RecordDecl, try to fetch the RecordDecl behind the TypedefDecl; 629 if (!recordDecl && typedefNameDecl) {; 630 recordDecl = ROOT::TMetaUtils::GetUnderlyingRecordDecl(typedefNameDecl->getUnderlyingType());; 631 }; 632 ; 633 // If at this point recordDecl is still NULL, we have a problem; 634 if (!recordDecl) {; 635 ROOT::TMetaUtils::Warning(""RScanner::TreatRecordDeclOrTypeNameDecl"",; 636 ""Could not cast typeDecl either to RecordDecl or could not get RecordDecl underneath typedef.\n"");; 637 return true;; 638 }; 639 ; 640 // Do not select unnamed records.; 641 if (!recordDecl->getIdentifier()); 642 return true;; 643 ; 644 // Do not select dependent types.; 645 if (recordDecl->isDependentType()); 646 return true;; 647 ; 648 if (fScanType == EScanType::kOnePCM && ROOT::TMetaUtils::IsStdClass(*recordDecl)); 649 return true;; 650 ; 651 ; 652 // At this point, recordDecl must be a RecordDecl pointer.; 653 ; 654 if (fRecordDeclCallback) {; 655 // Pass on any declaration. This is usually used to record dependency.; 656 // Since rootcint see C++ compliant header files, we can assume that; 657 // if a forward declaration or declaration has been inserted, the; 658 // classes for which we are creating a dictionary will be using; 659 // them either directly or indirectly. Any false positive can be; 660 // resolved by removing the spurrious dependency in the (user) header; 661 // files.; 662 fRecordDeclCallback(recordDecl);; 663 }; 664 ; 665 // in case it is implicit or a forward declaration, we are not interested.; 666 if(recordDecl->isImplicit() || !recordDecl->isCompleteDefinition()) {; 667 return true;; 668 }; 669 ; 670 // Never select the class templates themselves.; 671 const clang::CXXRecordDecl *cxxdecl = llvm::dyn_cast<clang::CXXRecordDecl>(recordDecl);; 672 if (cxxdecl && cxxdecl->getDescribedClassTemplate ()) {; 673 return true;; 674 }; 675 ; 676 const ClassSelectionRule *selectedFromTypedef = typedefNameDecl ? fSelectionRules.IsDeclSelected(typedefNameDecl) : nullptr;",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:22213,Integrability,depend,dependency,22213,"arning(""RScanner::TreatRecordDeclOrTypeNameDecl"",; 636 ""Could not cast typeDecl either to RecordDecl or could not get RecordDecl underneath typedef.\n"");; 637 return true;; 638 }; 639 ; 640 // Do not select unnamed records.; 641 if (!recordDecl->getIdentifier()); 642 return true;; 643 ; 644 // Do not select dependent types.; 645 if (recordDecl->isDependentType()); 646 return true;; 647 ; 648 if (fScanType == EScanType::kOnePCM && ROOT::TMetaUtils::IsStdClass(*recordDecl)); 649 return true;; 650 ; 651 ; 652 // At this point, recordDecl must be a RecordDecl pointer.; 653 ; 654 if (fRecordDeclCallback) {; 655 // Pass on any declaration. This is usually used to record dependency.; 656 // Since rootcint see C++ compliant header files, we can assume that; 657 // if a forward declaration or declaration has been inserted, the; 658 // classes for which we are creating a dictionary will be using; 659 // them either directly or indirectly. Any false positive can be; 660 // resolved by removing the spurrious dependency in the (user) header; 661 // files.; 662 fRecordDeclCallback(recordDecl);; 663 }; 664 ; 665 // in case it is implicit or a forward declaration, we are not interested.; 666 if(recordDecl->isImplicit() || !recordDecl->isCompleteDefinition()) {; 667 return true;; 668 }; 669 ; 670 // Never select the class templates themselves.; 671 const clang::CXXRecordDecl *cxxdecl = llvm::dyn_cast<clang::CXXRecordDecl>(recordDecl);; 672 if (cxxdecl && cxxdecl->getDescribedClassTemplate ()) {; 673 return true;; 674 }; 675 ; 676 const ClassSelectionRule *selectedFromTypedef = typedefNameDecl ? fSelectionRules.IsDeclSelected(typedefNameDecl) : nullptr;; 677 ; 678 const ClassSelectionRule *selectedFromRecDecl = fSelectionRules.IsDeclSelected(recordDecl, false /* exclude typedef rules*/);; 679 ; 680 const ClassSelectionRule *selected = typedefNameDecl ? selectedFromTypedef : selectedFromRecDecl;; 681 ; 682 if (! selected) return true; // early exit. Nothing more to be done.; 683 ; 684",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:26612,Integrability,message,message,26612,"readySelected = fselectedRecordDecls.insert((RecordDecl*)recordDecl->getCanonicalDecl()).second;; 736 if (!fFirstPass && !rcrdDeclNotAlreadySelected) {; 737 // Diagnose conflicting selection rules:; 738 auto declSelRuleMapIt = fDeclSelRuleMap.find(recordDecl->getCanonicalDecl());; 739 if (declSelRuleMapIt != fDeclSelRuleMap.end() &&; 740 declSelRuleMapIt->second != selected) {; 741 std::string normName;; 742 TMetaUtils::GetNormalizedName(normName,; 743 recordDecl->getASTContext().getTypeDeclType(recordDecl),; 744 fInterpreter,; 745 fNormCtxt);; 746 ; 747 auto previouslyMatchingRule = (const ClassSelectionRule*)declSelRuleMapIt->second;; 748 int previouslineno = previouslyMatchingRule->GetLineNumber();; 749 ; 750 std::string cleanFileName = llvm::sys::path::filename(selected->GetSelFileName()).str();; 751 auto lineno = selected->GetLineNumber();; 752 auto rulesAreCompatible = SelectionRulesUtils::areEqual<ClassSelectionRule>(selected, previouslyMatchingRule, true /*moduloNameOrPattern*/);; 753 if (!rulesAreCompatible){; 754 std::stringstream message;; 755 if (lineno > 1) message << ""Selection file "" << cleanFileName << "", lines ""; 756 << lineno << "" and "" << previouslineno << "". "";; 757 message << ""Attempt to select a class ""<< normName << "" with two rules which have incompatible attributes. ""; 758 << ""The attributes such as transiency might not be correctly propagated to the typesystem of ROOT.\n"";; 759 selected->Print(message);; 760 message << ""Conflicting rule already matched:\n"";; 761 previouslyMatchingRule->Print(message);; 762 ROOT::TMetaUtils::Warning(nullptr,""%s\n"", message.str().c_str());; 763 }; 764 }; 765 }; 766 ; 767 fDeclSelRuleMap[recordDecl->getCanonicalDecl()] = selected;; 768 ; 769 if (!rcrdDeclNotAlreadySelected || fFirstPass); 770 return true;; 771 ; 772 // Before adding the decl to the selected ones, check its access.; 773 // We do not yet support I/O of private or protected classes.; 774 // See ROOT-7450.; 775 // Additionally, private declaration",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:26642,Integrability,message,message,26642,"readySelected = fselectedRecordDecls.insert((RecordDecl*)recordDecl->getCanonicalDecl()).second;; 736 if (!fFirstPass && !rcrdDeclNotAlreadySelected) {; 737 // Diagnose conflicting selection rules:; 738 auto declSelRuleMapIt = fDeclSelRuleMap.find(recordDecl->getCanonicalDecl());; 739 if (declSelRuleMapIt != fDeclSelRuleMap.end() &&; 740 declSelRuleMapIt->second != selected) {; 741 std::string normName;; 742 TMetaUtils::GetNormalizedName(normName,; 743 recordDecl->getASTContext().getTypeDeclType(recordDecl),; 744 fInterpreter,; 745 fNormCtxt);; 746 ; 747 auto previouslyMatchingRule = (const ClassSelectionRule*)declSelRuleMapIt->second;; 748 int previouslineno = previouslyMatchingRule->GetLineNumber();; 749 ; 750 std::string cleanFileName = llvm::sys::path::filename(selected->GetSelFileName()).str();; 751 auto lineno = selected->GetLineNumber();; 752 auto rulesAreCompatible = SelectionRulesUtils::areEqual<ClassSelectionRule>(selected, previouslyMatchingRule, true /*moduloNameOrPattern*/);; 753 if (!rulesAreCompatible){; 754 std::stringstream message;; 755 if (lineno > 1) message << ""Selection file "" << cleanFileName << "", lines ""; 756 << lineno << "" and "" << previouslineno << "". "";; 757 message << ""Attempt to select a class ""<< normName << "" with two rules which have incompatible attributes. ""; 758 << ""The attributes such as transiency might not be correctly propagated to the typesystem of ROOT.\n"";; 759 selected->Print(message);; 760 message << ""Conflicting rule already matched:\n"";; 761 previouslyMatchingRule->Print(message);; 762 ROOT::TMetaUtils::Warning(nullptr,""%s\n"", message.str().c_str());; 763 }; 764 }; 765 }; 766 ; 767 fDeclSelRuleMap[recordDecl->getCanonicalDecl()] = selected;; 768 ; 769 if (!rcrdDeclNotAlreadySelected || fFirstPass); 770 return true;; 771 ; 772 // Before adding the decl to the selected ones, check its access.; 773 // We do not yet support I/O of private or protected classes.; 774 // See ROOT-7450.; 775 // Additionally, private declaration",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:26760,Integrability,message,message,26760,"dDecl->getCanonicalDecl());; 739 if (declSelRuleMapIt != fDeclSelRuleMap.end() &&; 740 declSelRuleMapIt->second != selected) {; 741 std::string normName;; 742 TMetaUtils::GetNormalizedName(normName,; 743 recordDecl->getASTContext().getTypeDeclType(recordDecl),; 744 fInterpreter,; 745 fNormCtxt);; 746 ; 747 auto previouslyMatchingRule = (const ClassSelectionRule*)declSelRuleMapIt->second;; 748 int previouslineno = previouslyMatchingRule->GetLineNumber();; 749 ; 750 std::string cleanFileName = llvm::sys::path::filename(selected->GetSelFileName()).str();; 751 auto lineno = selected->GetLineNumber();; 752 auto rulesAreCompatible = SelectionRulesUtils::areEqual<ClassSelectionRule>(selected, previouslyMatchingRule, true /*moduloNameOrPattern*/);; 753 if (!rulesAreCompatible){; 754 std::stringstream message;; 755 if (lineno > 1) message << ""Selection file "" << cleanFileName << "", lines ""; 756 << lineno << "" and "" << previouslineno << "". "";; 757 message << ""Attempt to select a class ""<< normName << "" with two rules which have incompatible attributes. ""; 758 << ""The attributes such as transiency might not be correctly propagated to the typesystem of ROOT.\n"";; 759 selected->Print(message);; 760 message << ""Conflicting rule already matched:\n"";; 761 previouslyMatchingRule->Print(message);; 762 ROOT::TMetaUtils::Warning(nullptr,""%s\n"", message.str().c_str());; 763 }; 764 }; 765 }; 766 ; 767 fDeclSelRuleMap[recordDecl->getCanonicalDecl()] = selected;; 768 ; 769 if (!rcrdDeclNotAlreadySelected || fFirstPass); 770 return true;; 771 ; 772 // Before adding the decl to the selected ones, check its access.; 773 // We do not yet support I/O of private or protected classes.; 774 // See ROOT-7450.; 775 // Additionally, private declarations lead to uncompilable code, so just ignore (ROOT-9112).; 776 if (recordDecl->getAccess() == AS_private || recordDecl->getAccess() == AS_protected) {; 777 // Don't warn about types selected by ""everything in that file"".; 778 auto isFileSelection = select",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:26998,Integrability,message,message,26998,",; 744 fInterpreter,; 745 fNormCtxt);; 746 ; 747 auto previouslyMatchingRule = (const ClassSelectionRule*)declSelRuleMapIt->second;; 748 int previouslineno = previouslyMatchingRule->GetLineNumber();; 749 ; 750 std::string cleanFileName = llvm::sys::path::filename(selected->GetSelFileName()).str();; 751 auto lineno = selected->GetLineNumber();; 752 auto rulesAreCompatible = SelectionRulesUtils::areEqual<ClassSelectionRule>(selected, previouslyMatchingRule, true /*moduloNameOrPattern*/);; 753 if (!rulesAreCompatible){; 754 std::stringstream message;; 755 if (lineno > 1) message << ""Selection file "" << cleanFileName << "", lines ""; 756 << lineno << "" and "" << previouslineno << "". "";; 757 message << ""Attempt to select a class ""<< normName << "" with two rules which have incompatible attributes. ""; 758 << ""The attributes such as transiency might not be correctly propagated to the typesystem of ROOT.\n"";; 759 selected->Print(message);; 760 message << ""Conflicting rule already matched:\n"";; 761 previouslyMatchingRule->Print(message);; 762 ROOT::TMetaUtils::Warning(nullptr,""%s\n"", message.str().c_str());; 763 }; 764 }; 765 }; 766 ; 767 fDeclSelRuleMap[recordDecl->getCanonicalDecl()] = selected;; 768 ; 769 if (!rcrdDeclNotAlreadySelected || fFirstPass); 770 return true;; 771 ; 772 // Before adding the decl to the selected ones, check its access.; 773 // We do not yet support I/O of private or protected classes.; 774 // See ROOT-7450.; 775 // Additionally, private declarations lead to uncompilable code, so just ignore (ROOT-9112).; 776 if (recordDecl->getAccess() == AS_private || recordDecl->getAccess() == AS_protected) {; 777 // Don't warn about types selected by ""everything in that file"".; 778 auto isFileSelection = selected->HasAttributeFileName() &&; 779 selected->HasAttributePattern() &&; 780 ""*"" == selected->GetAttributePattern();; 781 if (!isFileSelection) {; 782 std::string normName;; 783 TMetaUtils::GetNormalizedName(normName,; 784 recordDecl->getASTContext().getTypeDec",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:27013,Integrability,message,message,27013,",; 744 fInterpreter,; 745 fNormCtxt);; 746 ; 747 auto previouslyMatchingRule = (const ClassSelectionRule*)declSelRuleMapIt->second;; 748 int previouslineno = previouslyMatchingRule->GetLineNumber();; 749 ; 750 std::string cleanFileName = llvm::sys::path::filename(selected->GetSelFileName()).str();; 751 auto lineno = selected->GetLineNumber();; 752 auto rulesAreCompatible = SelectionRulesUtils::areEqual<ClassSelectionRule>(selected, previouslyMatchingRule, true /*moduloNameOrPattern*/);; 753 if (!rulesAreCompatible){; 754 std::stringstream message;; 755 if (lineno > 1) message << ""Selection file "" << cleanFileName << "", lines ""; 756 << lineno << "" and "" << previouslineno << "". "";; 757 message << ""Attempt to select a class ""<< normName << "" with two rules which have incompatible attributes. ""; 758 << ""The attributes such as transiency might not be correctly propagated to the typesystem of ROOT.\n"";; 759 selected->Print(message);; 760 message << ""Conflicting rule already matched:\n"";; 761 previouslyMatchingRule->Print(message);; 762 ROOT::TMetaUtils::Warning(nullptr,""%s\n"", message.str().c_str());; 763 }; 764 }; 765 }; 766 ; 767 fDeclSelRuleMap[recordDecl->getCanonicalDecl()] = selected;; 768 ; 769 if (!rcrdDeclNotAlreadySelected || fFirstPass); 770 return true;; 771 ; 772 // Before adding the decl to the selected ones, check its access.; 773 // We do not yet support I/O of private or protected classes.; 774 // See ROOT-7450.; 775 // Additionally, private declarations lead to uncompilable code, so just ignore (ROOT-9112).; 776 if (recordDecl->getAccess() == AS_private || recordDecl->getAccess() == AS_protected) {; 777 // Don't warn about types selected by ""everything in that file"".; 778 auto isFileSelection = selected->HasAttributeFileName() &&; 779 selected->HasAttributePattern() &&; 780 ""*"" == selected->GetAttributePattern();; 781 if (!isFileSelection) {; 782 std::string normName;; 783 TMetaUtils::GetNormalizedName(normName,; 784 recordDecl->getASTContext().getTypeDec",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:27098,Integrability,message,message,27098,",; 744 fInterpreter,; 745 fNormCtxt);; 746 ; 747 auto previouslyMatchingRule = (const ClassSelectionRule*)declSelRuleMapIt->second;; 748 int previouslineno = previouslyMatchingRule->GetLineNumber();; 749 ; 750 std::string cleanFileName = llvm::sys::path::filename(selected->GetSelFileName()).str();; 751 auto lineno = selected->GetLineNumber();; 752 auto rulesAreCompatible = SelectionRulesUtils::areEqual<ClassSelectionRule>(selected, previouslyMatchingRule, true /*moduloNameOrPattern*/);; 753 if (!rulesAreCompatible){; 754 std::stringstream message;; 755 if (lineno > 1) message << ""Selection file "" << cleanFileName << "", lines ""; 756 << lineno << "" and "" << previouslineno << "". "";; 757 message << ""Attempt to select a class ""<< normName << "" with two rules which have incompatible attributes. ""; 758 << ""The attributes such as transiency might not be correctly propagated to the typesystem of ROOT.\n"";; 759 selected->Print(message);; 760 message << ""Conflicting rule already matched:\n"";; 761 previouslyMatchingRule->Print(message);; 762 ROOT::TMetaUtils::Warning(nullptr,""%s\n"", message.str().c_str());; 763 }; 764 }; 765 }; 766 ; 767 fDeclSelRuleMap[recordDecl->getCanonicalDecl()] = selected;; 768 ; 769 if (!rcrdDeclNotAlreadySelected || fFirstPass); 770 return true;; 771 ; 772 // Before adding the decl to the selected ones, check its access.; 773 // We do not yet support I/O of private or protected classes.; 774 // See ROOT-7450.; 775 // Additionally, private declarations lead to uncompilable code, so just ignore (ROOT-9112).; 776 if (recordDecl->getAccess() == AS_private || recordDecl->getAccess() == AS_protected) {; 777 // Don't warn about types selected by ""everything in that file"".; 778 auto isFileSelection = selected->HasAttributeFileName() &&; 779 selected->HasAttributePattern() &&; 780 ""*"" == selected->GetAttributePattern();; 781 if (!isFileSelection) {; 782 std::string normName;; 783 TMetaUtils::GetNormalizedName(normName,; 784 recordDecl->getASTContext().getTypeDec",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:27155,Integrability,message,message,27155,",; 744 fInterpreter,; 745 fNormCtxt);; 746 ; 747 auto previouslyMatchingRule = (const ClassSelectionRule*)declSelRuleMapIt->second;; 748 int previouslineno = previouslyMatchingRule->GetLineNumber();; 749 ; 750 std::string cleanFileName = llvm::sys::path::filename(selected->GetSelFileName()).str();; 751 auto lineno = selected->GetLineNumber();; 752 auto rulesAreCompatible = SelectionRulesUtils::areEqual<ClassSelectionRule>(selected, previouslyMatchingRule, true /*moduloNameOrPattern*/);; 753 if (!rulesAreCompatible){; 754 std::stringstream message;; 755 if (lineno > 1) message << ""Selection file "" << cleanFileName << "", lines ""; 756 << lineno << "" and "" << previouslineno << "". "";; 757 message << ""Attempt to select a class ""<< normName << "" with two rules which have incompatible attributes. ""; 758 << ""The attributes such as transiency might not be correctly propagated to the typesystem of ROOT.\n"";; 759 selected->Print(message);; 760 message << ""Conflicting rule already matched:\n"";; 761 previouslyMatchingRule->Print(message);; 762 ROOT::TMetaUtils::Warning(nullptr,""%s\n"", message.str().c_str());; 763 }; 764 }; 765 }; 766 ; 767 fDeclSelRuleMap[recordDecl->getCanonicalDecl()] = selected;; 768 ; 769 if (!rcrdDeclNotAlreadySelected || fFirstPass); 770 return true;; 771 ; 772 // Before adding the decl to the selected ones, check its access.; 773 // We do not yet support I/O of private or protected classes.; 774 // See ROOT-7450.; 775 // Additionally, private declarations lead to uncompilable code, so just ignore (ROOT-9112).; 776 if (recordDecl->getAccess() == AS_private || recordDecl->getAccess() == AS_protected) {; 777 // Don't warn about types selected by ""everything in that file"".; 778 auto isFileSelection = selected->HasAttributeFileName() &&; 779 selected->HasAttributePattern() &&; 780 ""*"" == selected->GetAttributePattern();; 781 if (!isFileSelection) {; 782 std::string normName;; 783 TMetaUtils::GetNormalizedName(normName,; 784 recordDecl->getASTContext().getTypeDec",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:3114,Performance,cache,cache,3114,"e ROOT;; 59using namespace clang;; 60 ; 61extern cling::Interpreter *gInterp;; 62 ; 63const char* RScanner::fgClangDeclKey = ""ClangDecl""; // property key used for connection with Clang objects; 64const char* RScanner::fgClangFuncKey = ""ClangFunc""; // property key for demangled names; 65 ; 66int RScanner::fgAnonymousClassCounter = 0;; 67int RScanner::fgBadClassCounter = 0;; 68int RScanner::fgAnonymousEnumCounter = 0;; 69 ; 70std::map <clang::Decl*, std::string> RScanner::fgAnonymousClassMap;; 71std::map <clang::Decl*, std::string> RScanner::fgAnonymousEnumMap;; 72 ; 73////////////////////////////////////////////////////////////////////////////////; 74/// Regular constructor setting up the scanner to search for entities; 75/// matching the 'rules'.; 76 ; 77RScanner::RScanner (SelectionRules &rules,; 78 EScanType stype,; 79 const cling::Interpreter &interpret,; 80 ROOT::TMetaUtils::TNormalizedCtxt &normCtxt,; 81 unsigned int verbose /* = 0 */) :; 82 fVerboseLevel(verbose),; 83 fSourceManager(nullptr),; 84 fInterpreter(interpret),; 85 fRecordDeclCallback(nullptr),; 86 fNormCtxt(normCtxt),; 87 fSelectionRules(rules),; 88 fScanType(stype),; 89 fFirstPass(true); 90{; 91 // Build the cache for all selection rules; 92 fSelectionRules.FillCache();; 93 ; 94 for (int i = 0; i <= fgDeclLast; i ++); 95 fDeclTable [i] = false;; 96 ; 97 for (int i = 0; i <= fgTypeLast; i ++); 98 fTypeTable [i] = false;; 99 ; 100 fLastDecl = nullptr;; 101}; 102 ; 103////////////////////////////////////////////////////////////////////////////////; 104 ; 105RScanner::~RScanner (); 106{; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Whether we can actually visit this declaration, i.e. if it is reachable; 111/// via name lookup.; 112///; 113/// RScanner shouldn't touch decls for which this method returns false as we; 114/// call Sema methods on those declarations. Those will fail in strange way as; 115/// they assume those decls are already visibl",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:36563,Safety,detect,detected,36563,"E = F->param_end(); I != E; ++I) {; 1027 clang::ParmVarDecl* P = *I;; 1028 ; 1029 if (prototype != """"); 1030 prototype += "","";; 1031 ; 1032 //std::string type = P->getType().getAsString();; 1033 std::string type = P->getType().getAsString();; 1034 if (type.at(type.length()-1) == '*') {; 1035 type.at(type.length()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = ",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:27416,Security,access,access,27416,"leName = llvm::sys::path::filename(selected->GetSelFileName()).str();; 751 auto lineno = selected->GetLineNumber();; 752 auto rulesAreCompatible = SelectionRulesUtils::areEqual<ClassSelectionRule>(selected, previouslyMatchingRule, true /*moduloNameOrPattern*/);; 753 if (!rulesAreCompatible){; 754 std::stringstream message;; 755 if (lineno > 1) message << ""Selection file "" << cleanFileName << "", lines ""; 756 << lineno << "" and "" << previouslineno << "". "";; 757 message << ""Attempt to select a class ""<< normName << "" with two rules which have incompatible attributes. ""; 758 << ""The attributes such as transiency might not be correctly propagated to the typesystem of ROOT.\n"";; 759 selected->Print(message);; 760 message << ""Conflicting rule already matched:\n"";; 761 previouslyMatchingRule->Print(message);; 762 ROOT::TMetaUtils::Warning(nullptr,""%s\n"", message.str().c_str());; 763 }; 764 }; 765 }; 766 ; 767 fDeclSelRuleMap[recordDecl->getCanonicalDecl()] = selected;; 768 ; 769 if (!rcrdDeclNotAlreadySelected || fFirstPass); 770 return true;; 771 ; 772 // Before adding the decl to the selected ones, check its access.; 773 // We do not yet support I/O of private or protected classes.; 774 // See ROOT-7450.; 775 // Additionally, private declarations lead to uncompilable code, so just ignore (ROOT-9112).; 776 if (recordDecl->getAccess() == AS_private || recordDecl->getAccess() == AS_protected) {; 777 // Don't warn about types selected by ""everything in that file"".; 778 auto isFileSelection = selected->HasAttributeFileName() &&; 779 selected->HasAttributePattern() &&; 780 ""*"" == selected->GetAttributePattern();; 781 if (!isFileSelection) {; 782 std::string normName;; 783 TMetaUtils::GetNormalizedName(normName,; 784 recordDecl->getASTContext().getTypeDeclType(recordDecl),; 785 fInterpreter,; 786 fNormCtxt);; 787 auto msg = ""Class or struct %s was selected but its dictionary cannot be generated: ""; 788 ""this is a private or protected class and this is not supported. No direct "";",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:15807,Testability,test,test,15807," 448 if (P->getInit()) {; 449 std::string init_value = ExprToStr(P->getDefaultArg());; 450 result += ""="" + init_value;; 451 }; 452 }; 453 ; 454 return result;; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458 ; 459std::string RScanner::FuncParameterList(clang::FunctionDecl* D) const; 460{; 461 std::string result = """";; 462 ; 463 for (clang::FunctionDecl::param_iterator I = D->param_begin(), E = D->param_end(); I != E; ++I) {; 464 clang::ParmVarDecl* P = *I;; 465 ; 466 if (result != """"); 467 result += "","";; 468 ; 469 std::string type = P->getType().getAsString();; 470 result += type;; 471 }; 472 ; 473 return ""("" + result + "")"";; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// This method visits a namespace node; 478 ; 479bool RScanner::VisitNamespaceDecl(clang::NamespaceDecl* N); 480{; 481 // We don't need to visit this while creating the big PCM; 482 if (fScanType == EScanType::kOnePCM); 483 return true;; 484 ; 485 if (!shouldVisitDecl(N)); 486 return true;; 487 ; 488 // in case it is implicit we don't create a builder; 489 // [Note: Can N be nullptr?, is so 'ShouldVisitDecl' should test or we should test sooner]; 490 if((N && N->isImplicit()) || !N){; 491 return true;; 492 }; 493 ; 494 bool ret = true;; 495 ; 496 const ClassSelectionRule *selected = fSelectionRules.IsDeclSelected(N);; 497 if (selected) {; 498 ; 499 clang::DeclContext* primary_ctxt = N->getPrimaryContext();; 500 clang::NamespaceDecl* primary = llvm::dyn_cast<clang::NamespaceDecl>(primary_ctxt);; 501 ; 502 RPredicateIsSameNamespace pred(primary);; 503 if ( find_if(fSelectedNamespaces.begin(),fSelectedNamespaces.end(),pred) == fSelectedNamespaces.end() ) {; 504 // The namespace is not already registered.; 505 ; 506 if (fVerboseLevel > 0) {; 507 std::string qual_name;; 508 GetDeclQualName(N,qual_name);; 509 // std::cout<<""\tSelected namespace -> "" << qual_name << "" ptr "" << (void*)N << "" decl ctxt",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:15825,Testability,test,test,15825," 448 if (P->getInit()) {; 449 std::string init_value = ExprToStr(P->getDefaultArg());; 450 result += ""="" + init_value;; 451 }; 452 }; 453 ; 454 return result;; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458 ; 459std::string RScanner::FuncParameterList(clang::FunctionDecl* D) const; 460{; 461 std::string result = """";; 462 ; 463 for (clang::FunctionDecl::param_iterator I = D->param_begin(), E = D->param_end(); I != E; ++I) {; 464 clang::ParmVarDecl* P = *I;; 465 ; 466 if (result != """"); 467 result += "","";; 468 ; 469 std::string type = P->getType().getAsString();; 470 result += type;; 471 }; 472 ; 473 return ""("" + result + "")"";; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// This method visits a namespace node; 478 ; 479bool RScanner::VisitNamespaceDecl(clang::NamespaceDecl* N); 480{; 481 // We don't need to visit this while creating the big PCM; 482 if (fScanType == EScanType::kOnePCM); 483 return true;; 484 ; 485 if (!shouldVisitDecl(N)); 486 return true;; 487 ; 488 // in case it is implicit we don't create a builder; 489 // [Note: Can N be nullptr?, is so 'ShouldVisitDecl' should test or we should test sooner]; 490 if((N && N->isImplicit()) || !N){; 491 return true;; 492 }; 493 ; 494 bool ret = true;; 495 ; 496 const ClassSelectionRule *selected = fSelectionRules.IsDeclSelected(N);; 497 if (selected) {; 498 ; 499 clang::DeclContext* primary_ctxt = N->getPrimaryContext();; 500 clang::NamespaceDecl* primary = llvm::dyn_cast<clang::NamespaceDecl>(primary_ctxt);; 501 ; 502 RPredicateIsSameNamespace pred(primary);; 503 if ( find_if(fSelectedNamespaces.begin(),fSelectedNamespaces.end(),pred) == fSelectedNamespaces.end() ) {; 504 // The namespace is not already registered.; 505 ; 506 if (fVerboseLevel > 0) {; 507 std::string qual_name;; 508 GetDeclQualName(N,qual_name);; 509 // std::cout<<""\tSelected namespace -> "" << qual_name << "" ptr "" << (void*)N << "" decl ctxt",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:36752,Usability,clear,clear,36752,"sString();; 1033 std::string type = P->getType().getAsString();; 1034 if (type.at(type.length()-1) == '*') {; 1035 type.at(type.length()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = callback;; 1087 return old;; 1088}; IntToStrstd::string IntToStr(int num)Definition Scanner.cxx:161; APIntToLonglong APIntToLong(const llvm::APInt &num)Definition Scanner.cxx:147",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:36782,Usability,clear,clear,36782,"pe = P->getType().getAsString();; 1034 if (type.at(type.length()-1) == '*') {; 1035 type.at(type.length()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = callback;; 1087 return old;; 1088}; IntToStrstd::string IntToStr(int num)Definition Scanner.cxx:161; APIntToLonglong APIntToLong(const llvm::APInt &num)Definition Scanner.cxx:147; gInterpcling::Interpreter * gI",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:36815,Usability,clear,clear,36815,"1034 if (type.at(type.length()-1) == '*') {; 1035 type.at(type.length()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = callback;; 1087 return old;; 1088}; IntToStrstd::string IntToStr(int num)Definition Scanner.cxx:161; APIntToLonglong APIntToLong(const llvm::APInt &num)Definition Scanner.cxx:147; gInterpcling::Interpreter * gInterp; AddSpacestd::string AddSpa",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:36849,Usability,clear,clear,36849,"== '*') {; 1035 type.at(type.length()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = callback;; 1087 return old;; 1088}; IntToStrstd::string IntToStr(int num)Definition Scanner.cxx:161; APIntToLonglong APIntToLong(const llvm::APInt &num)Definition Scanner.cxx:147; gInterpcling::Interpreter * gInterp; AddSpacestd::string AddSpace(const std::string &txt)Definiti",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/Scanner_8cxx_source.html:36883,Usability,clear,clear,36883,"gth()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = callback;; 1087 return old;; 1088}; IntToStrstd::string IntToStr(int num)Definition Scanner.cxx:161; APIntToLonglong APIntToLong(const llvm::APInt &num)Definition Scanner.cxx:147; gInterpcling::Interpreter * gInterp; AddSpacestd::string AddSpace(const std::string &txt)Definition Scanner.cxx:266; APIntToSizes",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
https://root.cern/doc/master/scatter_8C.html:1515,Modifiability,variab,variables,1515,"catter.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. scatter.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a scatter plot. . ; void scatter(); {; auto canvas = new TCanvas();; canvas->SetRightMargin(0.14);; gStyle->SetPalette(kBird, 0, 0.6); // define a transparent palette; ; const int n = 175;; double x[n];; double y[n];; double c[n];; double s[n];; ; // Define four random data set; auto r = new TRandom();; for (int i=0; i<n; i++) {; x[i] = 100*r->Rndm(i);; y[i] = 200*r->Rndm(i);; c[i] = 300*r->Rndm(i);; s[i] = 400*r->Rndm(i);; }; ; auto scatter = new TScatter(n, x, y, c, s);; scatter->SetMarkerStyle(20);; scatter->SetTitle(""Scatter plot title;X title;Y title;Z title"");; scatter->GetXaxis()->SetRangeUser(20.,90.);; scatter->GetYaxis()->SetRangeUser(55.,90.);; scatter->GetZaxis()->SetRangeUser(10.,200.);; scatter->Draw(""A"");; }; c#define c(i)Definition RSha256.hxx:101; kBird@ kBirdDefinition TColor.h:118; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TScatterA TScatter is able to draw four variables scatter plot on a single plot.Definition TScatter.h:32; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; AuthorOlivier Couet ; Definition in file scatter.C. tutorialsgraphsscatter.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/scatter_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/scatter_8C.html
https://root.cern/doc/master/schroedinger__hydrogen_8C.html:448,Energy Efficiency,energy,energy,448,". ROOT: tutorials/graphics/schroedinger_hydrogen.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. schroedinger_hydrogen.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Plot the Amplitude of a Hydrogen Atom. ; Visualize the Amplitude of a Hydrogen Atom in the n = 2, l = 0, m = 0 state. Demonstrates how TH2F can be used in Quantum Mechanics.; The formula for Hydrogen in this energy state is \( \psi_{200} = \frac{1}{4\sqrt{2\pi}a_0 ^{\frac{3}{2}}}(2-\frac{\sqrt{x^2+y^2}}{a_0})e^{-\frac{\sqrt{x^2+y^2}}{2a_0}} \). ; #include <cmath>; ; double WaveFunction(double x, double y) {; double r = sqrt(x *x + y*y);; ; double w = (1/pow((4*sqrt(2*TMath::Pi())* 1), 1.5)) * (2 - (r / 1)*pow(TMath::E(), (-1 * r)/2)); // Wavefunction formula for psi 2,0,0; ; return w*w; // Amplitude; ; }; ; void schroedinger_hydrogen() {; TH2F *h2D = new TH2F(""Hydrogen Atom"",; ""Hydrogen in n = 2, l = 0, m = 0 state; Position in x direction; Position in y direction"",; 200, -10, 10, 200, -10, 10);; ; for (float i = -10; i < 10; i += 0.01) {; for (float j = -10; j < 10; j += 0.01) {; h2D->Fill(i, j, WaveFunction(i, j));; }; }; ; gStyle->SetPalette(kCividis);; gStyle->SetOptStat(0);; ; TCanvas *c1 = new TCanvas(""c1"", ""Schroedinger's Hydrogen Atom"", 750, 1500);; c1->Divide(1, 2);; ; auto c1_1 = c1->cd(1);; c1_1->SetRightMargin(0.14);; h2D->GetXaxis()->SetLabelSize(0.03);; h2D->GetYaxis()->SetLabelSize(0.03);; h2D->GetZaxis()->SetLabelSize(0.03);; h2D->SetContour(50);; h2D->Draw(""colz"");; ; TLatex *l = new TLatex(-10, -12.43, ""The Electron is more likely to be found in the yellow areas and less likely to be found in the blue areas."");; l->SetTextFont(42);; l->SetTextSize(0.02);; l->Draw();; ; auto c1_2 = c1->cd(2);; c1_2->SetTheta(42.);; ; TH2D *h2Dc = (TH2D*)h2D->Clone();; h2Dc->SetTitle(""3D view of probability amplitude;;"");; h2Dc->Draw(""surf2"");; }; kCividis@ kCividisDefinition TColor.h:136; wwinID wDefinition TGWin32VirtualGLProxy.cx",MatchSource.WIKI,doc/master/schroedinger__hydrogen_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/schroedinger__hydrogen_8C.html
https://root.cern/doc/master/schroedinger__hydrogen_8C.html:4055,Testability,log,log,4055,"ize of axis labels.Definition TAttAxis.cxx:203; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; lTLine lDefinition textangle.C:4; AuthorAdvait Dhingra ; Definition in file schroedinger_hydrogen.C. tutorialsgraphicsschroedinger_hydrogen.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/schroedinger__hydrogen_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/schroedinger__hydrogen_8C.html
https://root.cern/doc/master/sha1_8inl.html:240,Integrability,depend,dependency,240,". ROOT: net/http/civetweb/sha1.inl File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Macros |; Functions ; sha1.inl File Reference. #include <stdint.h>; #include <string.h>. Include dependency graph for sha1.inl:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; union  CHAR64LONG16;  ; struct  SHA_CTX;  . Macros; #define blk(block, i);  ; #define R0(v, w, x, y, z, i);  ; #define R1(v, w, x, y, z, i);  ; #define R2(v, w, x, y, z, i);  ; #define R3(v, w, x, y, z, i);  ; #define R4(v, w, x, y, z, i);  ; #define rol(value, bits)   (((value) << (bits)) | ((value) >> (32 - (bits))));  ; #define SHA1_DIGEST_SIZE   20;  . Functions; static uint32_t blk0 (CHAR64LONG16 *block, int i);  ; SHA_API void SHA1_Final (unsigned char *digest, SHA_CTX *context);  ; SHA_API void SHA1_Init (SHA_CTX *context);  ; static void SHA1_Transform (uint32_t state[5], const uint8_t buffer[64]);  ; SHA_API void SHA1_Update (SHA_CTX *context, const uint8_t *data, const uint32_t len);  . Macro Definition Documentation. ◆ blk. #define blk; (;  ; block, .  ; i . ). Value: ((block)->l[(i)&15] = \; rol((block)->l[((i) + 13) & 15] ^ (block)->l[((i) + 8) & 15] \; ^ (block)->l[((i) + 2) & 15] ^ (block)->l[(i)&15], \; 1)); lTLine lDefinition textangle.C:4. Definition at line 124 of file sha1.inl. ◆ R0. #define R0; (;  ; v, .  ; w, .  ; x, .  ; y, .  ; z, .  ; i . ). Value: z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \; w = rol(w, 30);; blk0#define blk0(i)Definition RSha256.hxx:93; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; v@ vDefinition rootcling_impl.cxx:3699; rol#define rol(value, bits)Definition sha1.inl:100. Definition at line 131 of file sha1.inl. ◆ R1. #define R1; (;  ; v, .  ; w, .  ; x, .  ; y, .  ; z, .  ; i . ). Value: z += ((w & (x ^ y)) ^ y) + blk(block, i) + 0x5A827999 + rol(v, 5); \; w ",MatchSource.WIKI,doc/master/sha1_8inl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sha1_8inl.html
https://root.cern/doc/master/SMatrix_8h_source.html:17231,Availability,error,error,17231,"; 488 Return true if inversion is successful.; 489 The method used is based on direct inversion using the Cramer rule for; 490 matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; 491 Note that this method is faster but can suffer from much larger numerical accuracy; 492 when the condition of the matrix is large; 493 */; 494 bool InvertFast();; 495 ; 496 /**; 497 Invert a square Matrix and returns a new matrix. In case the inversion fails; 498 the current matrix is returned.; 499 \param ifail . ifail will be set to 0 when inversion is successful.; 500 See ROOT::Math::SMatrix::InvertFast for the inversion algorithm; 501 */; 502 SMatrix<T,D1,D2,R> InverseFast(int & ifail ) const;; 503 ; 504 /**; 505 Inversion of a symmetric positive defined Matrix using Choleski decomposition.; 506 ( this method changes the current matrix).; 507 Return true if inversion is successful.; 508 The method used is based on Choleski decomposition; 509 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 510 matrix is not positive defined.; 511 For solving a linear system, it is possible to use also the function; 512 ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion; 513 */; 514 bool InvertChol();; 515 ; 516 /**; 517 Invert of a symmetric positive defined Matrix using Choleski decomposition.; 518 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 519 matrix is not positive defined.; 520 In case the inversion fails the current matrix is returned.; 521 \param ifail . ifail will be set to 0 when inversion is successful.; 522 See ROOT::Math::SMatrix::InvertChol for the inversion algorithm; 523 */; 524 SMatrix<T,D1,D2,R> InverseChol(int & ifail ) const;; 525 ; 526 /**; 527 determinant of square Matrix via Dfact.; 528 Return true when the calculation is successful.; 529 \param det will contain the calculated determinant value; 530 \b Note: this will ",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:17300,Availability,failure,failure,17300,"; 488 Return true if inversion is successful.; 489 The method used is based on direct inversion using the Cramer rule for; 490 matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; 491 Note that this method is faster but can suffer from much larger numerical accuracy; 492 when the condition of the matrix is large; 493 */; 494 bool InvertFast();; 495 ; 496 /**; 497 Invert a square Matrix and returns a new matrix. In case the inversion fails; 498 the current matrix is returned.; 499 \param ifail . ifail will be set to 0 when inversion is successful.; 500 See ROOT::Math::SMatrix::InvertFast for the inversion algorithm; 501 */; 502 SMatrix<T,D1,D2,R> InverseFast(int & ifail ) const;; 503 ; 504 /**; 505 Inversion of a symmetric positive defined Matrix using Choleski decomposition.; 506 ( this method changes the current matrix).; 507 Return true if inversion is successful.; 508 The method used is based on Choleski decomposition; 509 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 510 matrix is not positive defined.; 511 For solving a linear system, it is possible to use also the function; 512 ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion; 513 */; 514 bool InvertChol();; 515 ; 516 /**; 517 Invert of a symmetric positive defined Matrix using Choleski decomposition.; 518 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 519 matrix is not positive defined.; 520 In case the inversion fails the current matrix is returned.; 521 \param ifail . ifail will be set to 0 when inversion is successful.; 522 See ROOT::Math::SMatrix::InvertChol for the inversion algorithm; 523 */; 524 SMatrix<T,D1,D2,R> InverseChol(int & ifail ) const;; 525 ; 526 /**; 527 determinant of square Matrix via Dfact.; 528 Return true when the calculation is successful.; 529 \param det will contain the calculated determinant value; 530 \b Note: this will ",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:17663,Availability,error,error,17663,"on fails; 498 the current matrix is returned.; 499 \param ifail . ifail will be set to 0 when inversion is successful.; 500 See ROOT::Math::SMatrix::InvertFast for the inversion algorithm; 501 */; 502 SMatrix<T,D1,D2,R> InverseFast(int & ifail ) const;; 503 ; 504 /**; 505 Inversion of a symmetric positive defined Matrix using Choleski decomposition.; 506 ( this method changes the current matrix).; 507 Return true if inversion is successful.; 508 The method used is based on Choleski decomposition; 509 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 510 matrix is not positive defined.; 511 For solving a linear system, it is possible to use also the function; 512 ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion; 513 */; 514 bool InvertChol();; 515 ; 516 /**; 517 Invert of a symmetric positive defined Matrix using Choleski decomposition.; 518 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 519 matrix is not positive defined.; 520 In case the inversion fails the current matrix is returned.; 521 \param ifail . ifail will be set to 0 when inversion is successful.; 522 See ROOT::Math::SMatrix::InvertChol for the inversion algorithm; 523 */; 524 SMatrix<T,D1,D2,R> InverseChol(int & ifail ) const;; 525 ; 526 /**; 527 determinant of square Matrix via Dfact.; 528 Return true when the calculation is successful.; 529 \param det will contain the calculated determinant value; 530 \b Note: this will destroy the contents of the Matrix!; 531 */; 532 bool Det(T& det);; 533 ; 534 /**; 535 determinant of square Matrix via Dfact.; 536 Return true when the calculation is successful.; 537 \param det will contain the calculated determinant value; 538 \b Note: this will preserve the content of the Matrix!; 539 */; 540 bool Det2(T& det) const;; 541 ; 542 ; 543 /** @name --- Matrix Slice Functions --- */; 544 ; 545 /// place a vector in a Matrix row; 546 template",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:17732,Availability,failure,failure,17732,"on fails; 498 the current matrix is returned.; 499 \param ifail . ifail will be set to 0 when inversion is successful.; 500 See ROOT::Math::SMatrix::InvertFast for the inversion algorithm; 501 */; 502 SMatrix<T,D1,D2,R> InverseFast(int & ifail ) const;; 503 ; 504 /**; 505 Inversion of a symmetric positive defined Matrix using Choleski decomposition.; 506 ( this method changes the current matrix).; 507 Return true if inversion is successful.; 508 The method used is based on Choleski decomposition; 509 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 510 matrix is not positive defined.; 511 For solving a linear system, it is possible to use also the function; 512 ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion; 513 */; 514 bool InvertChol();; 515 ; 516 /**; 517 Invert of a symmetric positive defined Matrix using Choleski decomposition.; 518 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 519 matrix is not positive defined.; 520 In case the inversion fails the current matrix is returned.; 521 \param ifail . ifail will be set to 0 when inversion is successful.; 522 See ROOT::Math::SMatrix::InvertChol for the inversion algorithm; 523 */; 524 SMatrix<T,D1,D2,R> InverseChol(int & ifail ) const;; 525 ; 526 /**; 527 determinant of square Matrix via Dfact.; 528 Return true when the calculation is successful.; 529 \param det will contain the calculated determinant value; 530 \b Note: this will destroy the contents of the Matrix!; 531 */; 532 bool Det(T& det);; 533 ; 534 /**; 535 determinant of square Matrix via Dfact.; 536 Return true when the calculation is successful.; 537 \param det will contain the calculated determinant value; 538 \b Note: this will preserve the content of the Matrix!; 539 */; 540 bool Det2(T& det) const;; 541 ; 542 ; 543 /** @name --- Matrix Slice Functions --- */; 544 ; 545 /// place a vector in a Matrix row; 546 template",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:21312,Availability,error,error,21312,"g at the row value row0 until row0+Dsub.; 596 where N is the size of the vector (SVector::kSize ); 597 Condition row0+N <= D1; 598 */; 599 template <class SubVector>; 600 SubVector SubCol(unsigned int thecol, unsigned int row0 = 0) const;; 601 ; 602 /**; 603 return a submatrix with the upper left corner at the values (row0, col0) and with sizes N1, N2; 604 where N1 and N2 are the dimension of the sub-matrix (SubMatrix::kRows and SubMatrix::kCols ); 605 Condition row0+N1 <= D1 && col0+N2 <=D2; 606 */; 607 template <class SubMatrix >; 608 SubMatrix Sub(unsigned int row0, unsigned int col0) const;; 609 ; 610 /**; 611 return diagonal elements of a matrix as a Vector.; 612 It works only for squared matrices D1 == D2, otherwise it will produce a compile error; 613 */; 614 SVector<T,D1> Diagonal() const;; 615 ; 616 /**; 617 Set the diagonal elements from a Vector; 618 Require that vector implements SVector::kSize since a check (statically) is done on; 619 diagonal size == vector size; 620 */; 621 template <class Vector>; 622 void SetDiagonal(const Vector & v);; 623 ; 624 /**; 625 return the trace of a matrix; 626 Sum of the diagonal elements; 627 */; 628 T Trace() const;; 629 ; 630 ; 631 /**; 632 return the upper Triangular block of the matrices (including the diagonal) as; 633 a vector of sizes N = D1 * (D1 + 1)/2.; 634 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 635 */; 636#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 637 SVector<T, D1 * (D2 +1)/2> UpperBlock() const;; 638#else; 639 template<class SubVector>; 640 SubVector UpperBlock() const;; 641#endif; 642 ; 643 /**; 644 return the lower Triangular block of the matrices (including the diagonal) as; 645 a vector of sizes N = D1 * (D1 + 1)/2.; 646 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 647 */; 648#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 649 SVector<T, D1 * (D2 +1)/2> LowerBlock() const;; 650#else; 651 template<class SubVector>; 652",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:21973,Availability,error,error,21973,"SubMatrix Sub(unsigned int row0, unsigned int col0) const;; 609 ; 610 /**; 611 return diagonal elements of a matrix as a Vector.; 612 It works only for squared matrices D1 == D2, otherwise it will produce a compile error; 613 */; 614 SVector<T,D1> Diagonal() const;; 615 ; 616 /**; 617 Set the diagonal elements from a Vector; 618 Require that vector implements SVector::kSize since a check (statically) is done on; 619 diagonal size == vector size; 620 */; 621 template <class Vector>; 622 void SetDiagonal(const Vector & v);; 623 ; 624 /**; 625 return the trace of a matrix; 626 Sum of the diagonal elements; 627 */; 628 T Trace() const;; 629 ; 630 ; 631 /**; 632 return the upper Triangular block of the matrices (including the diagonal) as; 633 a vector of sizes N = D1 * (D1 + 1)/2.; 634 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 635 */; 636#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 637 SVector<T, D1 * (D2 +1)/2> UpperBlock() const;; 638#else; 639 template<class SubVector>; 640 SubVector UpperBlock() const;; 641#endif; 642 ; 643 /**; 644 return the lower Triangular block of the matrices (including the diagonal) as; 645 a vector of sizes N = D1 * (D1 + 1)/2.; 646 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 647 */; 648#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 649 SVector<T, D1 * (D2 +1)/2> LowerBlock() const;; 650#else; 651 template<class SubVector>; 652 SubVector LowerBlock() const;; 653#endif; 654 ; 655 ; 656 /** @name --- Other Functions --- */; 657 ; 658 /**; 659 Function to check if a matrix is sharing same memory location of the passed pointer; 660 This function is used by the expression templates to avoid the alias problem during; 661 expression evaluation. When the matrix is in use, for example in operations; 662 like A = B * A, a temporary object storing the intermediate result is automatically; 663 created when evaluating the expression.; 664 ; 665 */; 666 bool IsInUse(const T",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:22400,Availability,error,error,22400,"d SetDiagonal(const Vector & v);; 623 ; 624 /**; 625 return the trace of a matrix; 626 Sum of the diagonal elements; 627 */; 628 T Trace() const;; 629 ; 630 ; 631 /**; 632 return the upper Triangular block of the matrices (including the diagonal) as; 633 a vector of sizes N = D1 * (D1 + 1)/2.; 634 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 635 */; 636#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 637 SVector<T, D1 * (D2 +1)/2> UpperBlock() const;; 638#else; 639 template<class SubVector>; 640 SubVector UpperBlock() const;; 641#endif; 642 ; 643 /**; 644 return the lower Triangular block of the matrices (including the diagonal) as; 645 a vector of sizes N = D1 * (D1 + 1)/2.; 646 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 647 */; 648#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 649 SVector<T, D1 * (D2 +1)/2> LowerBlock() const;; 650#else; 651 template<class SubVector>; 652 SubVector LowerBlock() const;; 653#endif; 654 ; 655 ; 656 /** @name --- Other Functions --- */; 657 ; 658 /**; 659 Function to check if a matrix is sharing same memory location of the passed pointer; 660 This function is used by the expression templates to avoid the alias problem during; 661 expression evaluation. When the matrix is in use, for example in operations; 662 like A = B * A, a temporary object storing the intermediate result is automatically; 663 created when evaluating the expression.; 664 ; 665 */; 666 bool IsInUse(const T* p) const;; 667 ; 668 // submatrices; 669 ; 670 /// Print: used by operator<<(); 671 std::ostream& Print(std::ostream& os) const;; 672 ; 673 ; 674 ; 675 ; 676public:; 677 ; 678 /** @name --- Data Member --- */; 679 ; 680 /**; 681 Matrix Storage Object containing matrix data; 682 */; 683 R fRep;; 684 ; 685}; // end of class SMatrix; 686 ; 687 ; 688 ; 689 ; 690//==============================================================================; 691// operator<<; 692//==========================",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:1554,Deployability,configurat,configurations,1554," source code; 12//; 13// created: 20. Mar 2001; 14//; 15// author: Thorsten Glebe; 16// HERA-B Collaboration; 17// Max-Planck-Institut fuer Kernphysik; 18// Saupfercheckweg 1; 19// 69117 Heidelberg; 20// Germany; 21// E-mail: T.Glebe@mpi-hd.mpg.de; 22//; 23// Description: A fixed size two dimensional Matrix class; 24//; 25// changes:; 26// 20 Mar 2001 (TG) creation; 27// 21 Mar 2001 (TG) added operators +=, -=, *=, /=; 28// 26 Mar 2001 (TG) place_in_row(), place_in_col() added; 29// 02 Apr 2001 (TG) non-const Array() added; 30// 03 Apr 2001 (TG) invert() added; 31// 07 Apr 2001 (TG) CTOR from SVertex (dyadic product) added; 32// 09 Apr 2001 (TG) CTOR from array added; 33// 11 Apr 2001 (TG) rows(), cols(), size() replaced by rows, cols, size; 34// 25 Mai 2001 (TG) row(), col() added; 35// 04 Sep 2001 (TG) moved inlined functions to .icc file; 36// 11 Jan 2002 (TG) added operator==(), operator!=(); 37// 14 Jan 2002 (TG) added more operator==(), operator!=(), operator>(), operator<(); 38//; 39***************************************************************************/; 40// for platform specific configurations; 41 ; 42#include ""Math/MConfig.h""; 43 ; 44#include <iosfwd>; 45 ; 46 ; 47/**; 48\defgroup SMatrixSVector Matrix and Vector classes; 49\ingroup SMatrixGroup; 50 ; 51Classes representing Matrices and Vectors of arbitrary type and dimension.; 52For a detailed description and usage examples see:; 53 ; 54 - \ref SVectorDoc; 55 - \ref SMatrixDoc; 56 - \ref MatVecFunctions; 57 ; 58*/; 59 ; 60 ; 61#include ""Math/Expression.h""; 62#include ""Math/MatrixRepresentationsStatic.h""; 63 ; 64 ; 65namespace ROOT {; 66 ; 67namespace Math {; 68 ; 69 ; 70template <class T, unsigned int D> class SVector;; 71 ; 72struct SMatrixIdentity { };; 73struct SMatrixNoInit { };; 74 ; 75//__________________________________________________________________________; 76/**; 77 SMatrix: a generic fixed size D1 x D2 Matrix class.; 78 The class is template on the scalar type, on the matrix sizes:; 79 D1",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:3485,Integrability,interface,interface,3485,"NoInit { };; 74 ; 75//__________________________________________________________________________; 76/**; 77 SMatrix: a generic fixed size D1 x D2 Matrix class.; 78 The class is template on the scalar type, on the matrix sizes:; 79 D1 = number of rows and D2 = number of columns; 80 amd on the representation storage type.; 81 By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; 82 but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; 83 D*(D+1)/2.; 84 ; 85 See \ref SMatrixDoc.; 86 ; 87 Original author is Thorsten Glebe; 88 HERA-B Collaboration, MPI Heidelberg (Germany); 89 ; 90 @ingroup SMatrixSVector; 91 ; 92 @authors T. Glebe, L. Moneta and J. Palacios; 93*/; 94//==============================================================================; 95// SMatrix: column-wise storage; 96//==============================================================================; 97template <class T,; 98 unsigned int D1,; 99 unsigned int D2 = D1,; 100 class R=MatRepStd<T, D1, D2> >; 101class SMatrix {; 102public:; 103 /** @name --- Typedefs --- */; 104 ; 105 /** contained scalar type */; 106 typedef T value_type;; 107 ; 108 /** storage representation type */; 109 typedef R rep_type;; 110 ; 111 /** STL iterator interface. */; 112 typedef T* iterator;; 113 ; 114 /** STL const_iterator interface. */; 115 typedef const T* const_iterator;; 116 ; 117 ; 118 ; 119 /** @name --- Constructors and Assignment --- */; 120 ; 121 /**; 122 Default constructor:; 123 */; 124 SMatrix();; 125 ///; 126 /**; 127 construct from without initialization; 128 */; 129 inline SMatrix( SMatrixNoInit ){}; 130 ; 131 /**; 132 construct from an identity matrix; 133 */; 134 SMatrix( SMatrixIdentity );; 135 /**; 136 copy constructor (from a matrix of the same representation; 137 */; 138 SMatrix(const SMatrix<T,D1,D2,R>& rhs);; 139 /**; 140 construct from a matrix with different representation.; 141 Works only from symmetric to general and not viceversa.; 142 ",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:3559,Integrability,interface,interface,3559,"; 81 By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; 82 but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; 83 D*(D+1)/2.; 84 ; 85 See \ref SMatrixDoc.; 86 ; 87 Original author is Thorsten Glebe; 88 HERA-B Collaboration, MPI Heidelberg (Germany); 89 ; 90 @ingroup SMatrixSVector; 91 ; 92 @authors T. Glebe, L. Moneta and J. Palacios; 93*/; 94//==============================================================================; 95// SMatrix: column-wise storage; 96//==============================================================================; 97template <class T,; 98 unsigned int D1,; 99 unsigned int D2 = D1,; 100 class R=MatRepStd<T, D1, D2> >; 101class SMatrix {; 102public:; 103 /** @name --- Typedefs --- */; 104 ; 105 /** contained scalar type */; 106 typedef T value_type;; 107 ; 108 /** storage representation type */; 109 typedef R rep_type;; 110 ; 111 /** STL iterator interface. */; 112 typedef T* iterator;; 113 ; 114 /** STL const_iterator interface. */; 115 typedef const T* const_iterator;; 116 ; 117 ; 118 ; 119 /** @name --- Constructors and Assignment --- */; 120 ; 121 /**; 122 Default constructor:; 123 */; 124 SMatrix();; 125 ///; 126 /**; 127 construct from without initialization; 128 */; 129 inline SMatrix( SMatrixNoInit ){}; 130 ; 131 /**; 132 construct from an identity matrix; 133 */; 134 SMatrix( SMatrixIdentity );; 135 /**; 136 copy constructor (from a matrix of the same representation; 137 */; 138 SMatrix(const SMatrix<T,D1,D2,R>& rhs);; 139 /**; 140 construct from a matrix with different representation.; 141 Works only from symmetric to general and not viceversa.; 142 */; 143 template <class R2>; 144 SMatrix(const SMatrix<T,D1,D2,R2>& rhs);; 145 ; 146 /**; 147 Construct from an expression.; 148 In case of symmetric matrices does not work if expression is of type general; 149 matrices. In case one needs to force the assignment from general to symmetric, one can use the; 150 ROOT::Mat",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:4708,Integrability,interface,interface,4708,"me --- Constructors and Assignment --- */; 120 ; 121 /**; 122 Default constructor:; 123 */; 124 SMatrix();; 125 ///; 126 /**; 127 construct from without initialization; 128 */; 129 inline SMatrix( SMatrixNoInit ){}; 130 ; 131 /**; 132 construct from an identity matrix; 133 */; 134 SMatrix( SMatrixIdentity );; 135 /**; 136 copy constructor (from a matrix of the same representation; 137 */; 138 SMatrix(const SMatrix<T,D1,D2,R>& rhs);; 139 /**; 140 construct from a matrix with different representation.; 141 Works only from symmetric to general and not viceversa.; 142 */; 143 template <class R2>; 144 SMatrix(const SMatrix<T,D1,D2,R2>& rhs);; 145 ; 146 /**; 147 Construct from an expression.; 148 In case of symmetric matrices does not work if expression is of type general; 149 matrices. In case one needs to force the assignment from general to symmetric, one can use the; 150 ROOT::Math::AssignSym::Evaluate function.; 151 */; 152 template <class A, class R2>; 153 SMatrix(const Expr<A,T,D1,D2,R2>& rhs);; 154 ; 155 ; 156 /**; 157 Constructor with STL iterator interface. The data will be copied into the matrix; 158 \param begin start iterator position; 159 \param end end iterator position; 160 \param triang if true only the triangular lower/upper part of the matrix is filled from the iterators; 161 \param lower if true the lower triangular part is filled; 162 ; 163 Size of the matrix must match size of the iterators, if triang is false, otherwise the size of the; 164 triangular block. In the case of symmetric matrices triang is considered always to be true; 165 (what-ever the user specifies) and the size of the iterators must be equal to the size of the; 166 triangular block, which is the number of independent elements of a symmetric matrix: N*(N+1)/2; 167 ; 168 */; 169 template<class InputIterator>; 170 SMatrix(InputIterator begin, InputIterator end, bool triang = false, bool lower = true);; 171 ; 172 /**; 173 Constructor with STL iterator interface. The data will be copied ",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:5606,Integrability,interface,interface,5606,"t work if expression is of type general; 149 matrices. In case one needs to force the assignment from general to symmetric, one can use the; 150 ROOT::Math::AssignSym::Evaluate function.; 151 */; 152 template <class A, class R2>; 153 SMatrix(const Expr<A,T,D1,D2,R2>& rhs);; 154 ; 155 ; 156 /**; 157 Constructor with STL iterator interface. The data will be copied into the matrix; 158 \param begin start iterator position; 159 \param end end iterator position; 160 \param triang if true only the triangular lower/upper part of the matrix is filled from the iterators; 161 \param lower if true the lower triangular part is filled; 162 ; 163 Size of the matrix must match size of the iterators, if triang is false, otherwise the size of the; 164 triangular block. In the case of symmetric matrices triang is considered always to be true; 165 (what-ever the user specifies) and the size of the iterators must be equal to the size of the; 166 triangular block, which is the number of independent elements of a symmetric matrix: N*(N+1)/2; 167 ; 168 */; 169 template<class InputIterator>; 170 SMatrix(InputIterator begin, InputIterator end, bool triang = false, bool lower = true);; 171 ; 172 /**; 173 Constructor with STL iterator interface. The data will be copied into the matrix; 174 \param begin start iterator position; 175 \param size iterator size; 176 \param triang if true only the triangular lower/upper part of the matrix is filled from the iterators; 177 \param lower if true the lower triangular part is filled; 178 ; 179 Size of the iterators must not be larger than the size of the matrix representation.; 180 In the case of symmetric matrices the size is N*(N+1)/2.; 181 ; 182 */; 183 template<class InputIterator>; 184 SMatrix(InputIterator begin, unsigned int size, bool triang = false, bool lower = true);; 185 ; 186 /**; 187 constructor of a symmetrix a matrix from a SVector containing the lower (upper); 188 triangular part.; 189 */; 190#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 191",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:8210,Integrability,interface,interface,8210,"y matrix; 220 */; 221 SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity );; 222 ; 223 /**; 224 Assign from a scalar value (only for size 1 matrices); 225 */; 226 SMatrix<T,D1,D2,R>& operator=(const T& rhs);; 227 ; 228 /** @name --- Matrix dimension --- */; 229 ; 230 /**; 231 Enumeration defining the matrix dimension,; 232 number of rows, columns and size = rows*columns); 233 */; 234 enum {; 235 /// return no. of matrix rows; 236 kRows = D1,; 237 /// return no. of matrix columns; 238 kCols = D2,; 239 /// return no of elements: rows*columns; 240 kSize = D1*D2; 241 };; 242 ; 243 /** @name --- Access functions --- */; 244 ; 245 /** access the parse tree with the index starting from zero and; 246 following the C convention for the order in accessing; 247 the matrix elements.; 248 Same convention for general and symmetric matrices.; 249 */; 250 T apply(unsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273 ; 274 /** STL iterator interface. */; 275 iterator end();; 276 ; 277 /** STL const_iterator interface. */; 278 const_iterator begin() const;; 279 ; 280 /** STL const_iterator interface. */; 281 const_iterator end() const;; 282 ; 283 /**; 284 Set matrix elements with STL iterator interface. The data will be copied into the matrix; 285 \param begin start iterator position; 286 \p",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:8729,Integrability,interface,interface,8729,"ls = D2,; 239 /// return no of elements: rows*columns; 240 kSize = D1*D2; 241 };; 242 ; 243 /** @name --- Access functions --- */; 244 ; 245 /** access the parse tree with the index starting from zero and; 246 following the C convention for the order in accessing; 247 the matrix elements.; 248 Same convention for general and symmetric matrices.; 249 */; 250 T apply(unsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273 ; 274 /** STL iterator interface. */; 275 iterator end();; 276 ; 277 /** STL const_iterator interface. */; 278 const_iterator begin() const;; 279 ; 280 /** STL const_iterator interface. */; 281 const_iterator end() const;; 282 ; 283 /**; 284 Set matrix elements with STL iterator interface. The data will be copied into the matrix; 285 \param begin start iterator position; 286 \param end end iterator position; 287 \param triang if true only the triangular lower/upper part of the matrix is filled from the iterators; 288 \param lower if true the lower triangular part is filled; 289 ; 290 Size of the matrix must match size of the iterators, if triang is false, otherwise the size of the; 291 triangular block. In the case of symmetric matrices triang is considered always to be true; 292 (what-ever the user specifies) and the size of the iterators must be equal to",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:8794,Integrability,interface,interface,8794,"44 ; 245 /** access the parse tree with the index starting from zero and; 246 following the C convention for the order in accessing; 247 the matrix elements.; 248 Same convention for general and symmetric matrices.; 249 */; 250 T apply(unsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273 ; 274 /** STL iterator interface. */; 275 iterator end();; 276 ; 277 /** STL const_iterator interface. */; 278 const_iterator begin() const;; 279 ; 280 /** STL const_iterator interface. */; 281 const_iterator end() const;; 282 ; 283 /**; 284 Set matrix elements with STL iterator interface. The data will be copied into the matrix; 285 \param begin start iterator position; 286 \param end end iterator position; 287 \param triang if true only the triangular lower/upper part of the matrix is filled from the iterators; 288 \param lower if true the lower triangular part is filled; 289 ; 290 Size of the matrix must match size of the iterators, if triang is false, otherwise the size of the; 291 triangular block. In the case of symmetric matrices triang is considered always to be true; 292 (what-ever the user specifies) and the size of the iterators must be equal to the size of the; 293 triangular block, which is the number of independent elements of a symmetric matrix: N*(N+1)/2; 294 ; 295 */; 2",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:8863,Integrability,interface,interface,8863,"o and; 246 following the C convention for the order in accessing; 247 the matrix elements.; 248 Same convention for general and symmetric matrices.; 249 */; 250 T apply(unsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273 ; 274 /** STL iterator interface. */; 275 iterator end();; 276 ; 277 /** STL const_iterator interface. */; 278 const_iterator begin() const;; 279 ; 280 /** STL const_iterator interface. */; 281 const_iterator end() const;; 282 ; 283 /**; 284 Set matrix elements with STL iterator interface. The data will be copied into the matrix; 285 \param begin start iterator position; 286 \param end end iterator position; 287 \param triang if true only the triangular lower/upper part of the matrix is filled from the iterators; 288 \param lower if true the lower triangular part is filled; 289 ; 290 Size of the matrix must match size of the iterators, if triang is false, otherwise the size of the; 291 triangular block. In the case of symmetric matrices triang is considered always to be true; 292 (what-ever the user specifies) and the size of the iterators must be equal to the size of the; 293 triangular block, which is the number of independent elements of a symmetric matrix: N*(N+1)/2; 294 ; 295 */; 296 template<class InputIterator>; 297 void SetElements(InputIterato",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:8946,Integrability,interface,interface,8946,"trix elements.; 248 Same convention for general and symmetric matrices.; 249 */; 250 T apply(unsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273 ; 274 /** STL iterator interface. */; 275 iterator end();; 276 ; 277 /** STL const_iterator interface. */; 278 const_iterator begin() const;; 279 ; 280 /** STL const_iterator interface. */; 281 const_iterator end() const;; 282 ; 283 /**; 284 Set matrix elements with STL iterator interface. The data will be copied into the matrix; 285 \param begin start iterator position; 286 \param end end iterator position; 287 \param triang if true only the triangular lower/upper part of the matrix is filled from the iterators; 288 \param lower if true the lower triangular part is filled; 289 ; 290 Size of the matrix must match size of the iterators, if triang is false, otherwise the size of the; 291 triangular block. In the case of symmetric matrices triang is considered always to be true; 292 (what-ever the user specifies) and the size of the iterators must be equal to the size of the; 293 triangular block, which is the number of independent elements of a symmetric matrix: N*(N+1)/2; 294 ; 295 */; 296 template<class InputIterator>; 297 void SetElements(InputIterator begin, InputIterator end, bool triang = false, bool lower = true);; 298 ; ",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:9051,Integrability,interface,interface,9051,"nsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273 ; 274 /** STL iterator interface. */; 275 iterator end();; 276 ; 277 /** STL const_iterator interface. */; 278 const_iterator begin() const;; 279 ; 280 /** STL const_iterator interface. */; 281 const_iterator end() const;; 282 ; 283 /**; 284 Set matrix elements with STL iterator interface. The data will be copied into the matrix; 285 \param begin start iterator position; 286 \param end end iterator position; 287 \param triang if true only the triangular lower/upper part of the matrix is filled from the iterators; 288 \param lower if true the lower triangular part is filled; 289 ; 290 Size of the matrix must match size of the iterators, if triang is false, otherwise the size of the; 291 triangular block. In the case of symmetric matrices triang is considered always to be true; 292 (what-ever the user specifies) and the size of the iterators must be equal to the size of the; 293 triangular block, which is the number of independent elements of a symmetric matrix: N*(N+1)/2; 294 ; 295 */; 296 template<class InputIterator>; 297 void SetElements(InputIterator begin, InputIterator end, bool triang = false, bool lower = true);; 298 ; 299 /**; 300 Constructor with STL iterator interface. The data will be copied into the matrix;",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:9958,Integrability,interface,interface,9958,"tor interface. */; 272 iterator begin();; 273 ; 274 /** STL iterator interface. */; 275 iterator end();; 276 ; 277 /** STL const_iterator interface. */; 278 const_iterator begin() const;; 279 ; 280 /** STL const_iterator interface. */; 281 const_iterator end() const;; 282 ; 283 /**; 284 Set matrix elements with STL iterator interface. The data will be copied into the matrix; 285 \param begin start iterator position; 286 \param end end iterator position; 287 \param triang if true only the triangular lower/upper part of the matrix is filled from the iterators; 288 \param lower if true the lower triangular part is filled; 289 ; 290 Size of the matrix must match size of the iterators, if triang is false, otherwise the size of the; 291 triangular block. In the case of symmetric matrices triang is considered always to be true; 292 (what-ever the user specifies) and the size of the iterators must be equal to the size of the; 293 triangular block, which is the number of independent elements of a symmetric matrix: N*(N+1)/2; 294 ; 295 */; 296 template<class InputIterator>; 297 void SetElements(InputIterator begin, InputIterator end, bool triang = false, bool lower = true);; 298 ; 299 /**; 300 Constructor with STL iterator interface. The data will be copied into the matrix; 301 \param begin start iterator position; 302 \param size iterator size; 303 \param triang if true only the triangular lower/upper part of the matrix is filled from the iterators; 304 \param lower if true the lower triangular part is filled; 305 ; 306 Size of the iterators must not be larger than the size of the matrix representation.; 307 In the case of symmetric matrices the size is N*(N+1)/2.; 308 ; 309 */; 310 template<class InputIterator>; 311 void SetElements(InputIterator begin, unsigned int size, bool triang = false, bool lower = true);; 312 ; 313 ; 314 /** @name --- Operators --- */; 315 /// element wise comparison; 316 bool operator==(const T& rhs) const;; 317 /// element wise comparison; 318 bool",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:15584,Integrability,rout,routine,15584,"plication with another compatible matrix (it is a real matrix multiplication); 447 Note that this operation does not avid to create a temporary to store intermediate result; 448 */; 449 template <class R2>; 450 SMatrix<T,D1,D2,R>& operator*=(const SMatrix<T,D1,D2,R2>& rhs);; 451 ; 452 /**; 453 multiplication with a compatible matrix expression (it is a real matrix multiplication); 454 */; 455 template <class A, class R2>; 456 SMatrix<T,D1,D2,R>& operator*=(const Expr<A,T,D1,D2,R2>& rhs);; 457 ; 458 ; 459 /**; 460 division with a scalar; 461 */; 462 SMatrix<T,D1,D2,R>& operator/=(const T& rhs);; 463 ; 464 ; 465 ; 466 /** @name --- Linear Algebra Functions --- */; 467 ; 468 /**; 469 Invert a square Matrix ( this method changes the current matrix).; 470 Return true if inversion is successful.; 471 The method used for general square matrices is the LU factorization taken from Dinv routine; 472 from the CERNLIB (written in C++ from CLHEP authors); 473 In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; 474 (The implementation is the one written by the CLHEP authors); 475 */; 476 bool Invert();; 477 ; 478 /**; 479 Invert a square Matrix and returns a new matrix. In case the inversion fails; 480 the current matrix is returned.; 481 \param ifail . ifail will be set to 0 when inversion is successful.; 482 See ROOT::Math::SMatrix::Invert for the inversion algorithm; 483 */; 484 SMatrix<T,D1,D2,R> Inverse(int & ifail ) const;; 485 ; 486 /**; 487 Fast inversion of a square Matrix ( this method changes the current matrix).; 488 Return true if inversion is successful.; 489 The method used is based on direct inversion using the Cramer rule for; 490 matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; 491 Note that this method is faster but can suffer from much larger numerical accuracy; 492 when the condition of the matrix is large; 493 */; 494 bool InvertFast();; 495 ; 496 /**; 497 Invert a square Matrix and returns a new matrix",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:24459,Integrability,wrap,wrapper,24459," 690//==============================================================================; 691// operator<<; 692//==============================================================================; 693template <class T, unsigned int D1, unsigned int D2, class R>; 694inline std::ostream& operator<<(std::ostream& os, const ROOT::Math::SMatrix<T,D1,D2,R>& rhs) {; 695 return rhs.Print(os);; 696}; 697 ; 698 ; 699 } // namespace Math; 700 ; 701} // namespace ROOT; 702 ; 703 ; 704 ; 705#include ""Math/SMatrix.icc""; 706 ; 707#include ""Math/MatrixFunctions.h""; 708 ; 709#endif /* ROOT_Math_SMatrix */; Expression.h; MConfig.h; MatrixFunctions.h; MatrixRepresentationsStatic.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; operator<<TBuffer & operator<<(TBuffer &buf, const Tmpl *obj)Definition TBuffer.h:397; SMatrix.icc; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::ExprDefinition Expression.h:138; ROOT::Math::MatRepStdExpression wrapper class for Matrix objects.Definition MatrixRepresentationsStatic.h:54; ROOT::Math::SMatrix::SMatrixRow_constDefinition SMatrix.h:382; ROOT::Math::SMatrix::SMatrixRow_const::fMatconst SMatrix< T, D1, D2, R > * fMatDefinition SMatrix.h:391; ROOT::Math::SMatrix::SMatrixRow_const::operator[]const T & operator[](int j) constDefinition SMatrix.h:388; ROOT::Math::SMatrix::SMatrixRow_const::SMatrixRow_constSMatrixRow_const(const SMatrix< T, D1, D2, R > &rhs, unsigned int i)Definition SMatrix.h:384; ROOT::Math::SMatrix::SMatrixRow_const::fRowunsigned int fRowDefinition SMatrix.h:392; ROOT::Math::SMatrix::SMatrixRowDefinition SMatrix.h:371; ROOT::Math::SMatrix::SMatrixRow::fRowunsigned int fRowDefinition SMatrix.h:379; ROOT::Math::SMatrix::SMatrixRow::operator[]T & operator[](int j)Definition SMatrix.h:376; ROOT::Math::SMatrix::SMatrixRow::fMatSMatrix< T, D1, D2, R > * fMatDefinition SMatrix.h:378; ROOT::Math::SMatrix::SMatrixRow::SMatrixRowSMatrixRow(SMatrix< T, D1, D2, R > &rhs, unsi",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:26541,Integrability,interface,interface,26541,"rix: a generic fixed size D1 x D2 Matrix class.Definition SMatrix.h:101; ROOT::Math::SMatrix::ColSVector< T, D1 > Col(unsigned int thecol) constreturn a full Matrix column as a vector (copy the content in a new vector)Definition SMatrix.icc:590; ROOT::Math::SMatrix::SMatrixSMatrix()Default constructor:Definition SMatrix.icc:72; ROOT::Math::SMatrix::operator-=SMatrix< T, D1, D2, R > & operator-=(const T &rhs)subtraction with a scalarDefinition SMatrix.icc:228; ROOT::Math::SMatrix::applyT apply(unsigned int i) constaccess the parse tree with the index starting from zero and following the C convention for the order ...Definition SMatrix.icc:627; ROOT::Math::SMatrix::Det2bool Det2(T &det) constdeterminant of square Matrix via Dfact.Definition SMatrix.icc:473; ROOT::Math::SMatrix::UpperBlockSVector< T, D1 *(D2+1)/2 > UpperBlock() constreturn the upper Triangular block of the matrices (including the diagonal) as a vector of sizes N = D...Definition SMatrix.icc:797; ROOT::Math::SMatrix::enditerator end()STL iterator interface.Definition SMatrix.icc:675; ROOT::Math::SMatrix::Atconst T & At(unsigned int i, unsigned int j) constread only access to matrix element, with indices starting from 0.Definition SMatrix.icc:653; ROOT::Math::SMatrix::Detbool Det(T &det)determinant of square Matrix via Dfact.Definition SMatrix.icc:466; ROOT::Math::SMatrix::SubColSubVector SubCol(unsigned int thecol, unsigned int row0=0) constreturn a slice of the column as a vector starting at the row value row0 until row0+Dsub.Definition SMatrix.icc:728; ROOT::Math::SMatrix::operator>bool operator>(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:347; ROOT::Math::SMatrix::Printstd::ostream & Print(std::ostream &os) constPrint: used by operator<<()Definition SMatrix.icc:603; ROOT::Math::SMatrix::operator=SMatrix< T, D1, D2, R > & operator=(const M &rhs)Assign from another compatible matrix.Definition SMatrix.icc:155; ROOT::Math::SMatrix::Place_atSMatrix< T, D1, D2, R > & Place_at(const SM",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:28468,Integrability,interface,interface,28468,"5; ROOT::Math::SMatrix::Place_atSMatrix< T, D1, D2, R > & Place_at(const SMatrix< T, D3, D4, R2 > &rhs, unsigned int row, unsigned int col)place a matrix in this matrixDefinition SMatrix.icc:552; ROOT::Math::SMatrix::InverseSMatrix< T, D1, D2, R > Inverse(int &ifail) constInvert a square Matrix and returns a new matrix.Definition SMatrix.icc:419; ROOT::Math::SMatrix::operator[]SMatrixRow operator[](unsigned int i)read/write access to matrix element with indices starting from 0 : m[i][j]Definition SMatrix.h:402; ROOT::Math::SMatrix::SubSubMatrix Sub(unsigned int row0, unsigned int col0) constreturn a submatrix with the upper left corner at the values (row0, col0) and with sizes N1,...Definition SMatrix.icc:745; ROOT::Math::SMatrix::operator*=SMatrix< T, D1, D2, R > & operator*=(const T &rhs)multiplication with a scalarDefinition SMatrix.icc:258; ROOT::Math::SMatrix::operator<bool operator<(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:379; ROOT::Math::SMatrix::beginiterator begin()STL iterator interface.Definition SMatrix.icc:670; ROOT::Math::SMatrix::SetElementsvoid SetElements(InputIterator begin, InputIterator end, bool triang=false, bool lower=true)Set matrix elements with STL iterator interface.Definition SMatrix.icc:692; ROOT::Math::SMatrix::fRepR fRepMatrix Storage Object containing matrix data.Definition SMatrix.h:683; ROOT::Math::SMatrix::SMatrixSMatrix(SMatrixNoInit)construct from without initializationDefinition SMatrix.h:129; ROOT::Math::SMatrix::InverseFastSMatrix< T, D1, D2, R > InverseFast(int &ifail) constInvert a square Matrix and returns a new matrix.Definition SMatrix.icc:436; ROOT::Math::SMatrix::operator==bool operator==(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:299; ROOT::Math::SMatrix::operator[]SMatrixRow_const operator[](unsigned int i) constread only access to matrix element, with indices starting from 0 : m[i][j]Definition SMatrix.h:398; ROOT::Math::SMatrix::Place_in_rowSMatrix< T, D1, D2, R > & Pla",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:28668,Integrability,interface,interface,28668," matrix in this matrixDefinition SMatrix.icc:552; ROOT::Math::SMatrix::InverseSMatrix< T, D1, D2, R > Inverse(int &ifail) constInvert a square Matrix and returns a new matrix.Definition SMatrix.icc:419; ROOT::Math::SMatrix::operator[]SMatrixRow operator[](unsigned int i)read/write access to matrix element with indices starting from 0 : m[i][j]Definition SMatrix.h:402; ROOT::Math::SMatrix::SubSubMatrix Sub(unsigned int row0, unsigned int col0) constreturn a submatrix with the upper left corner at the values (row0, col0) and with sizes N1,...Definition SMatrix.icc:745; ROOT::Math::SMatrix::operator*=SMatrix< T, D1, D2, R > & operator*=(const T &rhs)multiplication with a scalarDefinition SMatrix.icc:258; ROOT::Math::SMatrix::operator<bool operator<(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:379; ROOT::Math::SMatrix::beginiterator begin()STL iterator interface.Definition SMatrix.icc:670; ROOT::Math::SMatrix::SetElementsvoid SetElements(InputIterator begin, InputIterator end, bool triang=false, bool lower=true)Set matrix elements with STL iterator interface.Definition SMatrix.icc:692; ROOT::Math::SMatrix::fRepR fRepMatrix Storage Object containing matrix data.Definition SMatrix.h:683; ROOT::Math::SMatrix::SMatrixSMatrix(SMatrixNoInit)construct from without initializationDefinition SMatrix.h:129; ROOT::Math::SMatrix::InverseFastSMatrix< T, D1, D2, R > InverseFast(int &ifail) constInvert a square Matrix and returns a new matrix.Definition SMatrix.icc:436; ROOT::Math::SMatrix::operator==bool operator==(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:299; ROOT::Math::SMatrix::operator[]SMatrixRow_const operator[](unsigned int i) constread only access to matrix element, with indices starting from 0 : m[i][j]Definition SMatrix.h:398; ROOT::Math::SMatrix::Place_in_rowSMatrix< T, D1, D2, R > & Place_in_row(const SVector< T, D > &rhs, unsigned int row, unsigned int col)place a vector in a Matrix rowDefinition SMatrix.icc:484; ROOT::Math::SMat",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:30267,Integrability,interface,interface,30267,"_const operator[](unsigned int i) constread only access to matrix element, with indices starting from 0 : m[i][j]Definition SMatrix.h:398; ROOT::Math::SMatrix::Place_in_rowSMatrix< T, D1, D2, R > & Place_in_row(const SVector< T, D > &rhs, unsigned int row, unsigned int col)place a vector in a Matrix rowDefinition SMatrix.icc:484; ROOT::Math::SMatrix::DiagonalSVector< T, D1 > Diagonal() constreturn diagonal elements of a matrix as a Vector.Definition SMatrix.icc:755; ROOT::Math::SMatrix::InverseCholSMatrix< T, D1, D2, R > InverseChol(int &ifail) constInvert of a symmetric positive defined Matrix using Choleski decomposition.Definition SMatrix.icc:452; ROOT::Math::SMatrix::SetDiagonalvoid SetDiagonal(const Vector &v)Set the diagonal elements from a Vector Require that vector implements SVector::kSize since a check (...Definition SMatrix.icc:770; ROOT::Math::SMatrix::operator!=bool operator!=(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:327; ROOT::Math::SMatrix::iteratorT * iteratorSTL iterator interface.Definition SMatrix.h:112; ROOT::Math::SMatrix::const_iteratorconst T * const_iteratorSTL const_iterator interface.Definition SMatrix.h:115; ROOT::Math::SMatrix::operator+=SMatrix< T, D1, D2, R > & operator+=(const T &rhs)addition with a scalarDefinition SMatrix.icc:197; ROOT::Math::SMatrix::InvertCholbool InvertChol()Inversion of a symmetric positive defined Matrix using Choleski decomposition.Definition SMatrix.icc:446; ROOT::Math::SMatrix::Invertbool Invert()Invert a square Matrix ( this method changes the current matrix).Definition SMatrix.icc:412; ROOT::Math::SMatrix::IsInUsebool IsInUse(const T *p) constFunction to check if a matrix is sharing same memory location of the passed pointer This function is ...Definition SMatrix.icc:895; ROOT::Math::SMatrix::rep_typeR rep_typestorage representation typeDefinition SMatrix.h:109; ROOT::Math::SMatrix::kCols@ kColsreturn no. of matrix columnsDefinition SMatrix.h:238; ROOT::Math::SMatrix::kRows@ kRowsretu",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:30381,Integrability,interface,interface,30381," : m[i][j]Definition SMatrix.h:398; ROOT::Math::SMatrix::Place_in_rowSMatrix< T, D1, D2, R > & Place_in_row(const SVector< T, D > &rhs, unsigned int row, unsigned int col)place a vector in a Matrix rowDefinition SMatrix.icc:484; ROOT::Math::SMatrix::DiagonalSVector< T, D1 > Diagonal() constreturn diagonal elements of a matrix as a Vector.Definition SMatrix.icc:755; ROOT::Math::SMatrix::InverseCholSMatrix< T, D1, D2, R > InverseChol(int &ifail) constInvert of a symmetric positive defined Matrix using Choleski decomposition.Definition SMatrix.icc:452; ROOT::Math::SMatrix::SetDiagonalvoid SetDiagonal(const Vector &v)Set the diagonal elements from a Vector Require that vector implements SVector::kSize since a check (...Definition SMatrix.icc:770; ROOT::Math::SMatrix::operator!=bool operator!=(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:327; ROOT::Math::SMatrix::iteratorT * iteratorSTL iterator interface.Definition SMatrix.h:112; ROOT::Math::SMatrix::const_iteratorconst T * const_iteratorSTL const_iterator interface.Definition SMatrix.h:115; ROOT::Math::SMatrix::operator+=SMatrix< T, D1, D2, R > & operator+=(const T &rhs)addition with a scalarDefinition SMatrix.icc:197; ROOT::Math::SMatrix::InvertCholbool InvertChol()Inversion of a symmetric positive defined Matrix using Choleski decomposition.Definition SMatrix.icc:446; ROOT::Math::SMatrix::Invertbool Invert()Invert a square Matrix ( this method changes the current matrix).Definition SMatrix.icc:412; ROOT::Math::SMatrix::IsInUsebool IsInUse(const T *p) constFunction to check if a matrix is sharing same memory location of the passed pointer This function is ...Definition SMatrix.icc:895; ROOT::Math::SMatrix::rep_typeR rep_typestorage representation typeDefinition SMatrix.h:109; ROOT::Math::SMatrix::kCols@ kColsreturn no. of matrix columnsDefinition SMatrix.h:238; ROOT::Math::SMatrix::kRows@ kRowsreturn no. of matrix rowsDefinition SMatrix.h:236; ROOT::Math::SMatrix::kSize@ kSizereturn no of elements: ",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:33078,Integrability,wrap,wrapper,33078,"th::SMatrix::InvertFastbool InvertFast()Fast inversion of a square Matrix ( this method changes the current matrix).Definition SMatrix.icc:429; ROOT::Math::SMatrix::LowerBlockSVector< T, D1 *(D2+1)/2 > LowerBlock() constreturn the lower Triangular block of the matrices (including the diagonal) as a vector of sizes N = D...Definition SMatrix.icc:826; ROOT::Math::SMatrix::TraceT Trace() constreturn the trace of a matrix Sum of the diagonal elementsDefinition SMatrix.icc:784; ROOT::Math::SMatrix::SubRowSubVector SubRow(unsigned int therow, unsigned int col0=0) constreturn a slice of therow as a vector starting at the column value col0 until col0+N,...Definition SMatrix.icc:712; ROOT::Math::SMatrix::operator()const T & operator()(unsigned int i, unsigned int j) constread only access to matrix element, with indices starting from 0Definition SMatrix.icc:639; ROOT::Math::SMatrix::RowSVector< T, D2 > Row(unsigned int therow) constreturn a full Matrix row as a vector (copy the content in a new vector)Definition SMatrix.icc:575; ROOT::Math::SMatrix::Arrayconst T * Array() constreturn read-only pointer to internal arrayDefinition SMatrix.icc:630; ROOT::Math::SMatrix::Place_in_colSMatrix< T, D1, D2, R > & Place_in_col(const SVector< T, D > &rhs, unsigned int row, unsigned int col)place a vector in a Matrix columnDefinition SMatrix.icc:518; ROOT::Math::SVectorSVector: a generic fixed size Vector class.Definition SVector.h:75; ROOT::Math::VecExprExpression wrapper class for Vector objects.Definition Expression.h:64; R; MathNamespace for new Math classes and functions.; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; v@ vDefinition rootcling_impl.cxx:3699; ROOT::Math::SMatrixIdentityDefinition SMatrix.h:72; ROOT::Math::SMatrixNoInitDefinition SMatrix.h:73. mathsmatrixincMathSMatrix.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:45 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:1554,Modifiability,config,configurations,1554," source code; 12//; 13// created: 20. Mar 2001; 14//; 15// author: Thorsten Glebe; 16// HERA-B Collaboration; 17// Max-Planck-Institut fuer Kernphysik; 18// Saupfercheckweg 1; 19// 69117 Heidelberg; 20// Germany; 21// E-mail: T.Glebe@mpi-hd.mpg.de; 22//; 23// Description: A fixed size two dimensional Matrix class; 24//; 25// changes:; 26// 20 Mar 2001 (TG) creation; 27// 21 Mar 2001 (TG) added operators +=, -=, *=, /=; 28// 26 Mar 2001 (TG) place_in_row(), place_in_col() added; 29// 02 Apr 2001 (TG) non-const Array() added; 30// 03 Apr 2001 (TG) invert() added; 31// 07 Apr 2001 (TG) CTOR from SVertex (dyadic product) added; 32// 09 Apr 2001 (TG) CTOR from array added; 33// 11 Apr 2001 (TG) rows(), cols(), size() replaced by rows, cols, size; 34// 25 Mai 2001 (TG) row(), col() added; 35// 04 Sep 2001 (TG) moved inlined functions to .icc file; 36// 11 Jan 2002 (TG) added operator==(), operator!=(); 37// 14 Jan 2002 (TG) added more operator==(), operator!=(), operator>(), operator<(); 38//; 39***************************************************************************/; 40// for platform specific configurations; 41 ; 42#include ""Math/MConfig.h""; 43 ; 44#include <iosfwd>; 45 ; 46 ; 47/**; 48\defgroup SMatrixSVector Matrix and Vector classes; 49\ingroup SMatrixGroup; 50 ; 51Classes representing Matrices and Vectors of arbitrary type and dimension.; 52For a detailed description and usage examples see:; 53 ; 54 - \ref SVectorDoc; 55 - \ref SMatrixDoc; 56 - \ref MatVecFunctions; 57 ; 58*/; 59 ; 60 ; 61#include ""Math/Expression.h""; 62#include ""Math/MatrixRepresentationsStatic.h""; 63 ; 64 ; 65namespace ROOT {; 66 ; 67namespace Math {; 68 ; 69 ; 70template <class T, unsigned int D> class SVector;; 71 ; 72struct SMatrixIdentity { };; 73struct SMatrixNoInit { };; 74 ; 75//__________________________________________________________________________; 76/**; 77 SMatrix: a generic fixed size D1 x D2 Matrix class.; 78 The class is template on the scalar type, on the matrix sizes:; 79 D1",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:17495,Performance,perform,performing,17495,"t can suffer from much larger numerical accuracy; 492 when the condition of the matrix is large; 493 */; 494 bool InvertFast();; 495 ; 496 /**; 497 Invert a square Matrix and returns a new matrix. In case the inversion fails; 498 the current matrix is returned.; 499 \param ifail . ifail will be set to 0 when inversion is successful.; 500 See ROOT::Math::SMatrix::InvertFast for the inversion algorithm; 501 */; 502 SMatrix<T,D1,D2,R> InverseFast(int & ifail ) const;; 503 ; 504 /**; 505 Inversion of a symmetric positive defined Matrix using Choleski decomposition.; 506 ( this method changes the current matrix).; 507 Return true if inversion is successful.; 508 The method used is based on Choleski decomposition; 509 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 510 matrix is not positive defined.; 511 For solving a linear system, it is possible to use also the function; 512 ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion; 513 */; 514 bool InvertChol();; 515 ; 516 /**; 517 Invert of a symmetric positive defined Matrix using Choleski decomposition.; 518 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 519 matrix is not positive defined.; 520 In case the inversion fails the current matrix is returned.; 521 \param ifail . ifail will be set to 0 when inversion is successful.; 522 See ROOT::Math::SMatrix::InvertChol for the inversion algorithm; 523 */; 524 SMatrix<T,D1,D2,R> InverseChol(int & ifail ) const;; 525 ; 526 /**; 527 determinant of square Matrix via Dfact.; 528 Return true when the calculation is successful.; 529 \param det will contain the calculated determinant value; 530 \b Note: this will destroy the contents of the Matrix!; 531 */; 532 bool Det(T& det);; 533 ; 534 /**; 535 determinant of square Matrix via Dfact.; 536 Return true when the calculation is successful.; 537 \param det will contain the calculated determinant value; 5",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:22813,Safety,avoid,avoid,22813,"d SetDiagonal(const Vector & v);; 623 ; 624 /**; 625 return the trace of a matrix; 626 Sum of the diagonal elements; 627 */; 628 T Trace() const;; 629 ; 630 ; 631 /**; 632 return the upper Triangular block of the matrices (including the diagonal) as; 633 a vector of sizes N = D1 * (D1 + 1)/2.; 634 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 635 */; 636#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 637 SVector<T, D1 * (D2 +1)/2> UpperBlock() const;; 638#else; 639 template<class SubVector>; 640 SubVector UpperBlock() const;; 641#endif; 642 ; 643 /**; 644 return the lower Triangular block of the matrices (including the diagonal) as; 645 a vector of sizes N = D1 * (D1 + 1)/2.; 646 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 647 */; 648#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 649 SVector<T, D1 * (D2 +1)/2> LowerBlock() const;; 650#else; 651 template<class SubVector>; 652 SubVector LowerBlock() const;; 653#endif; 654 ; 655 ; 656 /** @name --- Other Functions --- */; 657 ; 658 /**; 659 Function to check if a matrix is sharing same memory location of the passed pointer; 660 This function is used by the expression templates to avoid the alias problem during; 661 expression evaluation. When the matrix is in use, for example in operations; 662 like A = B * A, a temporary object storing the intermediate result is automatically; 663 created when evaluating the expression.; 664 ; 665 */; 666 bool IsInUse(const T* p) const;; 667 ; 668 // submatrices; 669 ; 670 /// Print: used by operator<<(); 671 std::ostream& Print(std::ostream& os) const;; 672 ; 673 ; 674 ; 675 ; 676public:; 677 ; 678 /** @name --- Data Member --- */; 679 ; 680 /**; 681 Matrix Storage Object containing matrix data; 682 */; 683 R fRep;; 684 ; 685}; // end of class SMatrix; 686 ; 687 ; 688 ; 689 ; 690//==============================================================================; 691// operator<<; 692//==========================",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:7784,Security,access,access,7784,"ral but NOT vice-versa; 206 */; 207 template <class M>; 208 SMatrix<T,D1,D2,R>& operator=(const M& rhs);; 209 ; 210 SMatrix<T,D1,D2,R>& operator=(const SMatrix<T,D1,D2,R>& rhs);; 211 ; 212 /**; 213 Assign from a matrix expression; 214 */; 215 template <class A, class R2>; 216 SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs);; 217 ; 218 /**; 219 Assign from an identity matrix; 220 */; 221 SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity );; 222 ; 223 /**; 224 Assign from a scalar value (only for size 1 matrices); 225 */; 226 SMatrix<T,D1,D2,R>& operator=(const T& rhs);; 227 ; 228 /** @name --- Matrix dimension --- */; 229 ; 230 /**; 231 Enumeration defining the matrix dimension,; 232 number of rows, columns and size = rows*columns); 233 */; 234 enum {; 235 /// return no. of matrix rows; 236 kRows = D1,; 237 /// return no. of matrix columns; 238 kCols = D2,; 239 /// return no of elements: rows*columns; 240 kSize = D1*D2; 241 };; 242 ; 243 /** @name --- Access functions --- */; 244 ; 245 /** access the parse tree with the index starting from zero and; 246 following the C convention for the order in accessing; 247 the matrix elements.; 248 Same convention for general and symmetric matrices.; 249 */; 250 T apply(unsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:7893,Security,access,accessing,7893,"ral but NOT vice-versa; 206 */; 207 template <class M>; 208 SMatrix<T,D1,D2,R>& operator=(const M& rhs);; 209 ; 210 SMatrix<T,D1,D2,R>& operator=(const SMatrix<T,D1,D2,R>& rhs);; 211 ; 212 /**; 213 Assign from a matrix expression; 214 */; 215 template <class A, class R2>; 216 SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs);; 217 ; 218 /**; 219 Assign from an identity matrix; 220 */; 221 SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity );; 222 ; 223 /**; 224 Assign from a scalar value (only for size 1 matrices); 225 */; 226 SMatrix<T,D1,D2,R>& operator=(const T& rhs);; 227 ; 228 /** @name --- Matrix dimension --- */; 229 ; 230 /**; 231 Enumeration defining the matrix dimension,; 232 number of rows, columns and size = rows*columns); 233 */; 234 enum {; 235 /// return no. of matrix rows; 236 kRows = D1,; 237 /// return no. of matrix columns; 238 kCols = D2,; 239 /// return no of elements: rows*columns; 240 kSize = D1*D2; 241 };; 242 ; 243 /** @name --- Access functions --- */; 244 ; 245 /** access the parse tree with the index starting from zero and; 246 following the C convention for the order in accessing; 247 the matrix elements.; 248 Same convention for general and symmetric matrices.; 249 */; 250 T apply(unsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:8243,Security,access,access,8243,"y matrix; 220 */; 221 SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity );; 222 ; 223 /**; 224 Assign from a scalar value (only for size 1 matrices); 225 */; 226 SMatrix<T,D1,D2,R>& operator=(const T& rhs);; 227 ; 228 /** @name --- Matrix dimension --- */; 229 ; 230 /**; 231 Enumeration defining the matrix dimension,; 232 number of rows, columns and size = rows*columns); 233 */; 234 enum {; 235 /// return no. of matrix rows; 236 kRows = D1,; 237 /// return no. of matrix columns; 238 kCols = D2,; 239 /// return no of elements: rows*columns; 240 kSize = D1*D2; 241 };; 242 ; 243 /** @name --- Access functions --- */; 244 ; 245 /** access the parse tree with the index starting from zero and; 246 following the C convention for the order in accessing; 247 the matrix elements.; 248 Same convention for general and symmetric matrices.; 249 */; 250 T apply(unsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273 ; 274 /** STL iterator interface. */; 275 iterator end();; 276 ; 277 /** STL const_iterator interface. */; 278 const_iterator begin() const;; 279 ; 280 /** STL const_iterator interface. */; 281 const_iterator end() const;; 282 ; 283 /**; 284 Set matrix elements with STL iterator interface. The data will be copied into the matrix; 285 \param begin start iterator position; 286 \p",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:11889,Security,access,access,11889,"matrix representation.; 307 In the case of symmetric matrices the size is N*(N+1)/2.; 308 ; 309 */; 310 template<class InputIterator>; 311 void SetElements(InputIterator begin, unsigned int size, bool triang = false, bool lower = true);; 312 ; 313 ; 314 /** @name --- Operators --- */; 315 /// element wise comparison; 316 bool operator==(const T& rhs) const;; 317 /// element wise comparison; 318 bool operator!=(const T& rhs) const;; 319 /// element wise comparison; 320 template <class R2>; 321 bool operator==(const SMatrix<T,D1,D2,R2>& rhs) const;; 322 /// element wise comparison; 323 bool operator!=(const SMatrix<T,D1,D2,R>& rhs) const;; 324 /// element wise comparison; 325 template <class A, class R2>; 326 bool operator==(const Expr<A,T,D1,D2,R2>& rhs) const;; 327 /// element wise comparison; 328 template <class A, class R2>; 329 bool operator!=(const Expr<A,T,D1,D2,R2>& rhs) const;; 330 ; 331 /// element wise comparison; 332 bool operator>(const T& rhs) const;; 333 /// element wise comparison; 334 bool operator<(const T& rhs) const;; 335 /// element wise comparison; 336 template <class R2>; 337 bool operator>(const SMatrix<T,D1,D2,R2>& rhs) const;; 338 /// element wise comparison; 339 template <class R2>; 340 bool operator<(const SMatrix<T,D1,D2,R2>& rhs) const;; 341 /// element wise comparison; 342 template <class A, class R2>; 343 bool operator>(const Expr<A,T,D1,D2,R2>& rhs) const;; 344 /// element wise comparison; 345 template <class A, class R2>; 346 bool operator<(const Expr<A,T,D1,D2,R2>& rhs) const;; 347 ; 348 /**; 349 read only access to matrix element, with indices starting from 0; 350 */; 351 const T& operator()(unsigned int i, unsigned int j) const;; 352 /**; 353 read/write access to matrix element with indices starting from 0; 354 */; 355 T& operator()(unsigned int i, unsigned int j);; 356 ; 357 /**; 358 read only access to matrix element, with indices starting from 0.; 359 Function will check index values and it will assert if they are wrong; 360 */;",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:12041,Security,access,access,12041,"matrix representation.; 307 In the case of symmetric matrices the size is N*(N+1)/2.; 308 ; 309 */; 310 template<class InputIterator>; 311 void SetElements(InputIterator begin, unsigned int size, bool triang = false, bool lower = true);; 312 ; 313 ; 314 /** @name --- Operators --- */; 315 /// element wise comparison; 316 bool operator==(const T& rhs) const;; 317 /// element wise comparison; 318 bool operator!=(const T& rhs) const;; 319 /// element wise comparison; 320 template <class R2>; 321 bool operator==(const SMatrix<T,D1,D2,R2>& rhs) const;; 322 /// element wise comparison; 323 bool operator!=(const SMatrix<T,D1,D2,R>& rhs) const;; 324 /// element wise comparison; 325 template <class A, class R2>; 326 bool operator==(const Expr<A,T,D1,D2,R2>& rhs) const;; 327 /// element wise comparison; 328 template <class A, class R2>; 329 bool operator!=(const Expr<A,T,D1,D2,R2>& rhs) const;; 330 ; 331 /// element wise comparison; 332 bool operator>(const T& rhs) const;; 333 /// element wise comparison; 334 bool operator<(const T& rhs) const;; 335 /// element wise comparison; 336 template <class R2>; 337 bool operator>(const SMatrix<T,D1,D2,R2>& rhs) const;; 338 /// element wise comparison; 339 template <class R2>; 340 bool operator<(const SMatrix<T,D1,D2,R2>& rhs) const;; 341 /// element wise comparison; 342 template <class A, class R2>; 343 bool operator>(const Expr<A,T,D1,D2,R2>& rhs) const;; 344 /// element wise comparison; 345 template <class A, class R2>; 346 bool operator<(const Expr<A,T,D1,D2,R2>& rhs) const;; 347 ; 348 /**; 349 read only access to matrix element, with indices starting from 0; 350 */; 351 const T& operator()(unsigned int i, unsigned int j) const;; 352 /**; 353 read/write access to matrix element with indices starting from 0; 354 */; 355 T& operator()(unsigned int i, unsigned int j);; 356 ; 357 /**; 358 read only access to matrix element, with indices starting from 0.; 359 Function will check index values and it will assert if they are wrong; 360 */;",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:12185,Security,access,access,12185,"matrix representation.; 307 In the case of symmetric matrices the size is N*(N+1)/2.; 308 ; 309 */; 310 template<class InputIterator>; 311 void SetElements(InputIterator begin, unsigned int size, bool triang = false, bool lower = true);; 312 ; 313 ; 314 /** @name --- Operators --- */; 315 /// element wise comparison; 316 bool operator==(const T& rhs) const;; 317 /// element wise comparison; 318 bool operator!=(const T& rhs) const;; 319 /// element wise comparison; 320 template <class R2>; 321 bool operator==(const SMatrix<T,D1,D2,R2>& rhs) const;; 322 /// element wise comparison; 323 bool operator!=(const SMatrix<T,D1,D2,R>& rhs) const;; 324 /// element wise comparison; 325 template <class A, class R2>; 326 bool operator==(const Expr<A,T,D1,D2,R2>& rhs) const;; 327 /// element wise comparison; 328 template <class A, class R2>; 329 bool operator!=(const Expr<A,T,D1,D2,R2>& rhs) const;; 330 ; 331 /// element wise comparison; 332 bool operator>(const T& rhs) const;; 333 /// element wise comparison; 334 bool operator<(const T& rhs) const;; 335 /// element wise comparison; 336 template <class R2>; 337 bool operator>(const SMatrix<T,D1,D2,R2>& rhs) const;; 338 /// element wise comparison; 339 template <class R2>; 340 bool operator<(const SMatrix<T,D1,D2,R2>& rhs) const;; 341 /// element wise comparison; 342 template <class A, class R2>; 343 bool operator>(const Expr<A,T,D1,D2,R2>& rhs) const;; 344 /// element wise comparison; 345 template <class A, class R2>; 346 bool operator<(const Expr<A,T,D1,D2,R2>& rhs) const;; 347 ; 348 /**; 349 read only access to matrix element, with indices starting from 0; 350 */; 351 const T& operator()(unsigned int i, unsigned int j) const;; 352 /**; 353 read/write access to matrix element with indices starting from 0; 354 */; 355 T& operator()(unsigned int i, unsigned int j);; 356 ; 357 /**; 358 read only access to matrix element, with indices starting from 0.; 359 Function will check index values and it will assert if they are wrong; 360 */;",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:12405,Security,access,access,12405,"tor<(const T& rhs) const;; 335 /// element wise comparison; 336 template <class R2>; 337 bool operator>(const SMatrix<T,D1,D2,R2>& rhs) const;; 338 /// element wise comparison; 339 template <class R2>; 340 bool operator<(const SMatrix<T,D1,D2,R2>& rhs) const;; 341 /// element wise comparison; 342 template <class A, class R2>; 343 bool operator>(const Expr<A,T,D1,D2,R2>& rhs) const;; 344 /// element wise comparison; 345 template <class A, class R2>; 346 bool operator<(const Expr<A,T,D1,D2,R2>& rhs) const;; 347 ; 348 /**; 349 read only access to matrix element, with indices starting from 0; 350 */; 351 const T& operator()(unsigned int i, unsigned int j) const;; 352 /**; 353 read/write access to matrix element with indices starting from 0; 354 */; 355 T& operator()(unsigned int i, unsigned int j);; 356 ; 357 /**; 358 read only access to matrix element, with indices starting from 0.; 359 Function will check index values and it will assert if they are wrong; 360 */; 361 const T& At(unsigned int i, unsigned int j) const;; 362 /**; 363 read/write access to matrix element with indices starting from 0.; 364 Function will check index values and it will assert if they are wrong; 365 */; 366 T& At(unsigned int i, unsigned int j);; 367 ; 368 ; 369 // helper class for implementing the m[i][j] operator; 370 ; 371 class SMatrixRow {; 372 public:; 373 SMatrixRow ( SMatrix<T,D1,D2,R> & rhs, unsigned int i ) :; 374 fMat(&rhs), fRow(i); 375 {}; 376 T & operator[](int j) { return (*fMat)(fRow,j); }; 377 private:; 378 SMatrix<T,D1,D2,R> * fMat;; 379 unsigned int fRow;; 380 };; 381 ; 382 class SMatrixRow_const {; 383 public:; 384 SMatrixRow_const ( const SMatrix<T,D1,D2,R> & rhs, unsigned int i ) :; 385 fMat(&rhs), fRow(i); 386 {}; 387 ; 388 const T & operator[](int j) const { return (*fMat)(fRow, j); }; 389 ; 390 private:; 391 const SMatrix<T,D1,D2,R> * fMat;; 392 unsigned int fRow;; 393 };; 394 ; 395 /**; 396 read only access to matrix element, with indices starting from 0 : m[i][j]; 397",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:13281,Security,access,access,13281,,MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:13473,Security,access,access,13473,"ll check index values and it will assert if they are wrong; 365 */; 366 T& At(unsigned int i, unsigned int j);; 367 ; 368 ; 369 // helper class for implementing the m[i][j] operator; 370 ; 371 class SMatrixRow {; 372 public:; 373 SMatrixRow ( SMatrix<T,D1,D2,R> & rhs, unsigned int i ) :; 374 fMat(&rhs), fRow(i); 375 {}; 376 T & operator[](int j) { return (*fMat)(fRow,j); }; 377 private:; 378 SMatrix<T,D1,D2,R> * fMat;; 379 unsigned int fRow;; 380 };; 381 ; 382 class SMatrixRow_const {; 383 public:; 384 SMatrixRow_const ( const SMatrix<T,D1,D2,R> & rhs, unsigned int i ) :; 385 fMat(&rhs), fRow(i); 386 {}; 387 ; 388 const T & operator[](int j) const { return (*fMat)(fRow, j); }; 389 ; 390 private:; 391 const SMatrix<T,D1,D2,R> * fMat;; 392 unsigned int fRow;; 393 };; 394 ; 395 /**; 396 read only access to matrix element, with indices starting from 0 : m[i][j]; 397 */; 398 SMatrixRow_const operator[](unsigned int i) const { return SMatrixRow_const(*this, i); }; 399 /**; 400 read/write access to matrix element with indices starting from 0 : m[i][j]; 401 */; 402 SMatrixRow operator[](unsigned int i) { return SMatrixRow(*this, i); }; 403 ; 404 ; 405 /**; 406 addition with a scalar; 407 */; 408 SMatrix<T,D1,D2,R>&operator+=(const T& rhs);; 409 ; 410 /**; 411 addition with another matrix of any compatible representation; 412 */; 413 template <class R2>; 414 SMatrix<T,D1,D2,R>&operator+=(const SMatrix<T,D1,D2,R2>& rhs);; 415 ; 416 /**; 417 addition with a compatible matrix expression; 418 */; 419 template <class A, class R2>; 420 SMatrix<T,D1,D2,R>& operator+=(const Expr<A,T,D1,D2,R2>& rhs);; 421 ; 422 /**; 423 subtraction with a scalar; 424 */; 425 SMatrix<T,D1,D2,R>& operator-=(const T& rhs);; 426 ; 427 /**; 428 subtraction with another matrix of any compatible representation; 429 */; 430 template <class R2>; 431 SMatrix<T,D1,D2,R>&operator-=(const SMatrix<T,D1,D2,R2>& rhs);; 432 ; 433 /**; 434 subtraction with a compatible matrix expression; 435 */; 436 template <class A, ",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:26662,Security,access,access,26662,"int thecol) constreturn a full Matrix column as a vector (copy the content in a new vector)Definition SMatrix.icc:590; ROOT::Math::SMatrix::SMatrixSMatrix()Default constructor:Definition SMatrix.icc:72; ROOT::Math::SMatrix::operator-=SMatrix< T, D1, D2, R > & operator-=(const T &rhs)subtraction with a scalarDefinition SMatrix.icc:228; ROOT::Math::SMatrix::applyT apply(unsigned int i) constaccess the parse tree with the index starting from zero and following the C convention for the order ...Definition SMatrix.icc:627; ROOT::Math::SMatrix::Det2bool Det2(T &det) constdeterminant of square Matrix via Dfact.Definition SMatrix.icc:473; ROOT::Math::SMatrix::UpperBlockSVector< T, D1 *(D2+1)/2 > UpperBlock() constreturn the upper Triangular block of the matrices (including the diagonal) as a vector of sizes N = D...Definition SMatrix.icc:797; ROOT::Math::SMatrix::enditerator end()STL iterator interface.Definition SMatrix.icc:675; ROOT::Math::SMatrix::Atconst T & At(unsigned int i, unsigned int j) constread only access to matrix element, with indices starting from 0.Definition SMatrix.icc:653; ROOT::Math::SMatrix::Detbool Det(T &det)determinant of square Matrix via Dfact.Definition SMatrix.icc:466; ROOT::Math::SMatrix::SubColSubVector SubCol(unsigned int thecol, unsigned int row0=0) constreturn a slice of the column as a vector starting at the row value row0 until row0+Dsub.Definition SMatrix.icc:728; ROOT::Math::SMatrix::operator>bool operator>(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:347; ROOT::Math::SMatrix::Printstd::ostream & Print(std::ostream &os) constPrint: used by operator<<()Definition SMatrix.icc:603; ROOT::Math::SMatrix::operator=SMatrix< T, D1, D2, R > & operator=(const M &rhs)Assign from another compatible matrix.Definition SMatrix.icc:155; ROOT::Math::SMatrix::Place_atSMatrix< T, D1, D2, R > & Place_at(const SMatrix< T, D3, D4, R2 > &rhs, unsigned int row, unsigned int col)place a matrix in this matrixDefinition SMatrix.icc:552; ROOT::M",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:27869,Security,access,access,27869,"atrix::SubColSubVector SubCol(unsigned int thecol, unsigned int row0=0) constreturn a slice of the column as a vector starting at the row value row0 until row0+Dsub.Definition SMatrix.icc:728; ROOT::Math::SMatrix::operator>bool operator>(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:347; ROOT::Math::SMatrix::Printstd::ostream & Print(std::ostream &os) constPrint: used by operator<<()Definition SMatrix.icc:603; ROOT::Math::SMatrix::operator=SMatrix< T, D1, D2, R > & operator=(const M &rhs)Assign from another compatible matrix.Definition SMatrix.icc:155; ROOT::Math::SMatrix::Place_atSMatrix< T, D1, D2, R > & Place_at(const SMatrix< T, D3, D4, R2 > &rhs, unsigned int row, unsigned int col)place a matrix in this matrixDefinition SMatrix.icc:552; ROOT::Math::SMatrix::InverseSMatrix< T, D1, D2, R > Inverse(int &ifail) constInvert a square Matrix and returns a new matrix.Definition SMatrix.icc:419; ROOT::Math::SMatrix::operator[]SMatrixRow operator[](unsigned int i)read/write access to matrix element with indices starting from 0 : m[i][j]Definition SMatrix.h:402; ROOT::Math::SMatrix::SubSubMatrix Sub(unsigned int row0, unsigned int col0) constreturn a submatrix with the upper left corner at the values (row0, col0) and with sizes N1,...Definition SMatrix.icc:745; ROOT::Math::SMatrix::operator*=SMatrix< T, D1, D2, R > & operator*=(const T &rhs)multiplication with a scalarDefinition SMatrix.icc:258; ROOT::Math::SMatrix::operator<bool operator<(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:379; ROOT::Math::SMatrix::beginiterator begin()STL iterator interface.Definition SMatrix.icc:670; ROOT::Math::SMatrix::SetElementsvoid SetElements(InputIterator begin, InputIterator end, bool triang=false, bool lower=true)Set matrix elements with STL iterator interface.Definition SMatrix.icc:692; ROOT::Math::SMatrix::fRepR fRepMatrix Storage Object containing matrix data.Definition SMatrix.h:683; ROOT::Math::SMatrix::SMatrixSMatrix(SMatrixNoInit)construc",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:29289,Security,access,access,29289,"SMatrix.icc:258; ROOT::Math::SMatrix::operator<bool operator<(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:379; ROOT::Math::SMatrix::beginiterator begin()STL iterator interface.Definition SMatrix.icc:670; ROOT::Math::SMatrix::SetElementsvoid SetElements(InputIterator begin, InputIterator end, bool triang=false, bool lower=true)Set matrix elements with STL iterator interface.Definition SMatrix.icc:692; ROOT::Math::SMatrix::fRepR fRepMatrix Storage Object containing matrix data.Definition SMatrix.h:683; ROOT::Math::SMatrix::SMatrixSMatrix(SMatrixNoInit)construct from without initializationDefinition SMatrix.h:129; ROOT::Math::SMatrix::InverseFastSMatrix< T, D1, D2, R > InverseFast(int &ifail) constInvert a square Matrix and returns a new matrix.Definition SMatrix.icc:436; ROOT::Math::SMatrix::operator==bool operator==(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:299; ROOT::Math::SMatrix::operator[]SMatrixRow_const operator[](unsigned int i) constread only access to matrix element, with indices starting from 0 : m[i][j]Definition SMatrix.h:398; ROOT::Math::SMatrix::Place_in_rowSMatrix< T, D1, D2, R > & Place_in_row(const SVector< T, D > &rhs, unsigned int row, unsigned int col)place a vector in a Matrix rowDefinition SMatrix.icc:484; ROOT::Math::SMatrix::DiagonalSVector< T, D1 > Diagonal() constreturn diagonal elements of a matrix as a Vector.Definition SMatrix.icc:755; ROOT::Math::SMatrix::InverseCholSMatrix< T, D1, D2, R > InverseChol(int &ifail) constInvert of a symmetric positive defined Matrix using Choleski decomposition.Definition SMatrix.icc:452; ROOT::Math::SMatrix::SetDiagonalvoid SetDiagonal(const Vector &v)Set the diagonal elements from a Vector Require that vector implements SVector::kSize since a check (...Definition SMatrix.icc:770; ROOT::Math::SMatrix::operator!=bool operator!=(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:327; ROOT::Math::SMatrix::iteratorT * iteratorSTL iterator interface.Defi",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:32394,Security,access,access,32394,":240; ROOT::Math::SMatrix::operator/=SMatrix< T, D1, D2, R > & operator/=(const T &rhs)division with a scalarDefinition SMatrix.icc:287; ROOT::Math::SMatrix::value_typeT value_typecontained scalar typeDefinition SMatrix.h:106; ROOT::Math::SMatrix::InvertFastbool InvertFast()Fast inversion of a square Matrix ( this method changes the current matrix).Definition SMatrix.icc:429; ROOT::Math::SMatrix::LowerBlockSVector< T, D1 *(D2+1)/2 > LowerBlock() constreturn the lower Triangular block of the matrices (including the diagonal) as a vector of sizes N = D...Definition SMatrix.icc:826; ROOT::Math::SMatrix::TraceT Trace() constreturn the trace of a matrix Sum of the diagonal elementsDefinition SMatrix.icc:784; ROOT::Math::SMatrix::SubRowSubVector SubRow(unsigned int therow, unsigned int col0=0) constreturn a slice of therow as a vector starting at the column value col0 until col0+N,...Definition SMatrix.icc:712; ROOT::Math::SMatrix::operator()const T & operator()(unsigned int i, unsigned int j) constread only access to matrix element, with indices starting from 0Definition SMatrix.icc:639; ROOT::Math::SMatrix::RowSVector< T, D2 > Row(unsigned int therow) constreturn a full Matrix row as a vector (copy the content in a new vector)Definition SMatrix.icc:575; ROOT::Math::SMatrix::Arrayconst T * Array() constreturn read-only pointer to internal arrayDefinition SMatrix.icc:630; ROOT::Math::SMatrix::Place_in_colSMatrix< T, D1, D2, R > & Place_in_col(const SVector< T, D > &rhs, unsigned int row, unsigned int col)place a vector in a Matrix columnDefinition SMatrix.icc:518; ROOT::Math::SVectorSVector: a generic fixed size Vector class.Definition SVector.h:75; ROOT::Math::VecExprExpression wrapper class for Vector objects.Definition Expression.h:64; R; MathNamespace for new Math classes and functions.; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; v@ vDefinition rootcling_impl.cxx:3699; R",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:12291,Testability,assert,assert,12291,"tor<(const T& rhs) const;; 335 /// element wise comparison; 336 template <class R2>; 337 bool operator>(const SMatrix<T,D1,D2,R2>& rhs) const;; 338 /// element wise comparison; 339 template <class R2>; 340 bool operator<(const SMatrix<T,D1,D2,R2>& rhs) const;; 341 /// element wise comparison; 342 template <class A, class R2>; 343 bool operator>(const Expr<A,T,D1,D2,R2>& rhs) const;; 344 /// element wise comparison; 345 template <class A, class R2>; 346 bool operator<(const Expr<A,T,D1,D2,R2>& rhs) const;; 347 ; 348 /**; 349 read only access to matrix element, with indices starting from 0; 350 */; 351 const T& operator()(unsigned int i, unsigned int j) const;; 352 /**; 353 read/write access to matrix element with indices starting from 0; 354 */; 355 T& operator()(unsigned int i, unsigned int j);; 356 ; 357 /**; 358 read only access to matrix element, with indices starting from 0.; 359 Function will check index values and it will assert if they are wrong; 360 */; 361 const T& At(unsigned int i, unsigned int j) const;; 362 /**; 363 read/write access to matrix element with indices starting from 0.; 364 Function will check index values and it will assert if they are wrong; 365 */; 366 T& At(unsigned int i, unsigned int j);; 367 ; 368 ; 369 // helper class for implementing the m[i][j] operator; 370 ; 371 class SMatrixRow {; 372 public:; 373 SMatrixRow ( SMatrix<T,D1,D2,R> & rhs, unsigned int i ) :; 374 fMat(&rhs), fRow(i); 375 {}; 376 T & operator[](int j) { return (*fMat)(fRow,j); }; 377 private:; 378 SMatrix<T,D1,D2,R> * fMat;; 379 unsigned int fRow;; 380 };; 381 ; 382 class SMatrixRow_const {; 383 public:; 384 SMatrixRow_const ( const SMatrix<T,D1,D2,R> & rhs, unsigned int i ) :; 385 fMat(&rhs), fRow(i); 386 {}; 387 ; 388 const T & operator[](int j) const { return (*fMat)(fRow, j); }; 389 ; 390 private:; 391 const SMatrix<T,D1,D2,R> * fMat;; 392 unsigned int fRow;; 393 };; 394 ; 395 /**; 396 read only access to matrix element, with indices starting from 0 : m[i][j]; 397",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/SMatrix_8h_source.html:12510,Testability,assert,assert,12510,,MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
https://root.cern/doc/master/south__gate_8C.html:20987,Availability,down,down,20987,"++;; }; i++; k=0;; }; ; ; ; ; // 2 ___||____||_____||____||____||____||____||; ; ; k=0; i=0;; ; while (i<5){; while(k<19){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-300+(k*33.3),78,525, new TGeoRotation(""r1"",0,0,0)));; k++;; }; i++; k=0;; }; ; ; ; ; k=0; i=0;; ; while (i<5){; while(k<19){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-300+(k*33.3),-78,525, new TGeoRotation(""r1"",0,0,0)));; k++;; }; i++; k=0;; }; ; ; ; k=0; i=0;; ; while (i<5){; while(k<5){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-300,-78+(k*33),525, new TGeoRotation(""r1"",0,0,0)));; k++;; }; i++; k=0;; }; ; ; ; ; ; k=0; i=0;; ; while (i<5){; while(k<5){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(300,-78+(k*33),525, new TGeoRotation(""r1"",0,0,0)));; k++;; }; i++; k=0;; }; ; ; ; ; // ||// ||// ||// ||//; ; //down; ; k=0; i=0;; ; while (i<5){; while(k<19){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-300+(k*33.3),90,522, new TGeoRotation(""r1"",0,-45,0)));; k++;; }; i++; k=0;; }; ; ; ; ; k=0; i=0;; ; while (i<5){; while(k<19){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-300+(k*33.3),-90,522, new TGeoRotation(""r1"",0,45,0)));; k++;; }; i++; k=0;; }; ; ; k=0; i=0;; ; while (i<5){; while(k<5){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-318,-78+(k*33.3),52",MatchSource.WIKI,doc/master/south__gate_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/south__gate_8C.html
https://root.cern/doc/master/SparseData_8cxx_source.html:1211,Availability,error,error,1211,"/mathcore:$Id$; 2// Author: David Gonzalez Maline Wed Aug 28 15:33:03 2009; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:1217,Availability,error,error,1217,"/mathcore:$Id$; 2// Author: David Gonzalez Maline Wed Aug 28 15:33:03 2009; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:1328,Availability,error,error,1328,"****************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <<(ostream& os, const Box& b);; 66 ; 67 private:; 68 vector<double> fMin;; 69 vector<double> fMax;; 70 double fVal;; 71 doub",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:1388,Availability,error,error,1388,"-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <<(ostream& os, const Box& b);; 66 ; 67 private:; 68 vector<double> fMin;; 69 vector<double> fMax;; 70 double fVal;; 71 double fError;; 72 };; 73 ; 74 // This class is just a helper to be used in std::for_each t",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:1965,Availability,error,error,1965," in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <<(ostream& os, const Box& b);; 66 ; 67 private:; 68 vector<double> fMin;; 69 vector<double> fMax;; 70 double fVal;; 71 double fError;; 72 };; 73 ; 74 // This class is just a helper to be used in std::for_each to; 75 // simplify the code later. It's just a definition of a method; 76 // that will discern whether a Box is included into another one; 77 class BoxContainer; 78 {; 79 private:; 80 const Box& fBox;; 81 public:; 82 //Constructs the BoxContainer object with a Box that is meant; 83 //to include another one that will be provided later; 84 BoxContainer(const Box& b): fBox(b) {}; 85 ; 86 bool operator() (const Box& b1); 87 { return operator()(fBox, b1); }; 88 ; 89 // Looks if b2 is included in b1; 90 bool operator() (const Box& b1, const Box& b2); 91 {; 92 bool isIn = true;; 93 vector<double>::const_iterator boxit = b2.fMin.begin();; 9",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:4866,Availability,error,error,4866," fLimit(8 * std::numeric_limits<double>::epsilon()); 125 {};; 126 ; 127 void operator() (double value); 128 {; 129 if ( fabs(value- (*fIter)) < fLimit ); 130// if ( TMath::AreEqualRel(value, (*fIter), fLimit) ); 131 fThereIsArea = false;; 132 ; 133 ++fIter;; 134 }; 135 ; 136 bool IsThereArea() { return fThereIsArea; }; 137 ; 138 private:; 139 bool fThereIsArea;; 140 vector<double>::iterator fIter;; 141 double fLimit;; 142 };; 143 ; 144 ; 145 // This is the key of the SparseData structure. This method; 146 // will, by recursion, divide the area passed as an argument in; 147 // min and max into pieces to insert the Box defined by bmin and; 148 // bmax. It will do so from the highest dimension until it gets; 149 // to 1 and create the corresponding boxes to divide the; 150 // original space.; 151 void DivideBox( const vector<double>& min, const vector<double>& max,; 152 const vector<double>& bmin, const vector<double>& bmax,; 153 const unsigned int size, const unsigned int n,; 154 list<Box>& l, const double val, const double error); 155 {; 156 vector<double> boxmin(min);; 157 vector<double> boxmax(max);; 158 ; 159 boxmin[n] = min[n];; 160 boxmax[n] = bmin[n];; 161 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 162 l.push_back(Box(boxmin, boxmax));; 163 ; 164 boxmin[n] = bmin[n];; 165 boxmax[n] = bmax[n];; 166 if ( n == 0 ); 167 {; 168 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 169 l.push_back(Box(boxmin, boxmax, val, error));; 170 }; 171 else; 172 DivideBox(boxmin, boxmax, bmin, bmax, size, n-1, l, val, error);; 173 ; 174 boxmin[n] = bmax[n];; 175 boxmax[n] = max[n];; 176 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 177 l.push_back(Box(boxmin, boxmax));; 178 }; 179 ; 180 class ProxyListBox; 181 {; 182 public:; 183 void PushBack(Box& box) { fProxy.push_back(box); }; 184 list<Box>::iterator Begin() { return fProxy.begin(); }; 185 list<",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:5358,Availability,error,error,5358,"eces to insert the Box defined by bmin and; 148 // bmax. It will do so from the highest dimension until it gets; 149 // to 1 and create the corresponding boxes to divide the; 150 // original space.; 151 void DivideBox( const vector<double>& min, const vector<double>& max,; 152 const vector<double>& bmin, const vector<double>& bmax,; 153 const unsigned int size, const unsigned int n,; 154 list<Box>& l, const double val, const double error); 155 {; 156 vector<double> boxmin(min);; 157 vector<double> boxmax(max);; 158 ; 159 boxmin[n] = min[n];; 160 boxmax[n] = bmin[n];; 161 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 162 l.push_back(Box(boxmin, boxmax));; 163 ; 164 boxmin[n] = bmin[n];; 165 boxmax[n] = bmax[n];; 166 if ( n == 0 ); 167 {; 168 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 169 l.push_back(Box(boxmin, boxmax, val, error));; 170 }; 171 else; 172 DivideBox(boxmin, boxmax, bmin, bmax, size, n-1, l, val, error);; 173 ; 174 boxmin[n] = bmax[n];; 175 boxmax[n] = max[n];; 176 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 177 l.push_back(Box(boxmin, boxmax));; 178 }; 179 ; 180 class ProxyListBox; 181 {; 182 public:; 183 void PushBack(Box& box) { fProxy.push_back(box); }; 184 list<Box>::iterator Begin() { return fProxy.begin(); }; 185 list<Box>::iterator End() { return fProxy.end(); }; 186 void Remove(list<Box>::iterator it) { fProxy.erase(it); }; 187 list<Box>& GetList() { return fProxy; }; 188 private:; 189 list<Box> fProxy;; 190 };; 191 ; 192 ; 193 SparseData::SparseData(vector<double>& min, vector<double>& max); 194 {; 195 // Creates a SparseData covering the range defined by min; 196 // and max. For this it will create an empty Box for that; 197 // range.; 198 Box originalBox(min, max);; 199 fList = std::make_unique<ProxyListBox>();; 200 fList->PushBack(originalBox);; 201 }; 202 ; 203 SparseData::SparseData(const unsigned int",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:5446,Availability,error,error,5446,"eces to insert the Box defined by bmin and; 148 // bmax. It will do so from the highest dimension until it gets; 149 // to 1 and create the corresponding boxes to divide the; 150 // original space.; 151 void DivideBox( const vector<double>& min, const vector<double>& max,; 152 const vector<double>& bmin, const vector<double>& bmax,; 153 const unsigned int size, const unsigned int n,; 154 list<Box>& l, const double val, const double error); 155 {; 156 vector<double> boxmin(min);; 157 vector<double> boxmax(max);; 158 ; 159 boxmin[n] = min[n];; 160 boxmax[n] = bmin[n];; 161 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 162 l.push_back(Box(boxmin, boxmax));; 163 ; 164 boxmin[n] = bmin[n];; 165 boxmax[n] = bmax[n];; 166 if ( n == 0 ); 167 {; 168 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 169 l.push_back(Box(boxmin, boxmax, val, error));; 170 }; 171 else; 172 DivideBox(boxmin, boxmax, bmin, bmax, size, n-1, l, val, error);; 173 ; 174 boxmin[n] = bmax[n];; 175 boxmax[n] = max[n];; 176 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 177 l.push_back(Box(boxmin, boxmax));; 178 }; 179 ; 180 class ProxyListBox; 181 {; 182 public:; 183 void PushBack(Box& box) { fProxy.push_back(box); }; 184 list<Box>::iterator Begin() { return fProxy.begin(); }; 185 list<Box>::iterator End() { return fProxy.end(); }; 186 void Remove(list<Box>::iterator it) { fProxy.erase(it); }; 187 list<Box>& GetList() { return fProxy; }; 188 private:; 189 list<Box> fProxy;; 190 };; 191 ; 192 ; 193 SparseData::SparseData(vector<double>& min, vector<double>& max); 194 {; 195 // Creates a SparseData covering the range defined by min; 196 // and max. For this it will create an empty Box for that; 197 // range.; 198 Box originalBox(min, max);; 199 fList = std::make_unique<ProxyListBox>();; 200 fList->PushBack(originalBox);; 201 }; 202 ; 203 SparseData::SparseData(const unsigned int",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:7656,Availability,error,error,7656," 208 vector<double> minv(min,min+dim);; 209 vector<double> maxv(max,max+dim);; 210 Box originalBox(minv, maxv);; 211 fList = std::make_unique<ProxyListBox>();; 212 fList->PushBack(originalBox);; 213 }; 214 ; 215 SparseData::SparseData(const SparseData & rhs) :; 216 FitData(rhs); 217 {; 218 fList = std::make_unique<ProxyListBox>(*rhs.fList);; 219 }; 220 SparseData & SparseData::operator=(const SparseData & rhs); 221 {; 222 FitData::operator=( rhs );; 223 fList = std::make_unique<ProxyListBox>(*rhs.fList);; 224 return *this;; 225 }; 226 ; 227 SparseData::~SparseData() {}; 228 ; 229 unsigned int SparseData::NPoints() const; 230 {; 231 // Returns the number of points stored, including the 0 ones.; 232 return fList->GetList().size();; 233 }; 234 ; 235 unsigned int SparseData::NDim() const; 236 {; 237 // Returns the number of dimension of the SparseData object.; 238 return fList->Begin()->GetMin().size();; 239 }; 240 ; 241 void SparseData::Add(std::vector<double>& min, std::vector<double>& max,; 242 const double content, const double error); 243 {; 244 // Add a box to the stored ones. For that, it will look for; 245 // the box that contains the new data and either replace it; 246 // or updated it.; 247 ; 248 // Little box is the new Bin to be added; 249 Box littleBox(min, max);; 250 list<Box>::iterator it;; 251 // So we look for the Bin already in the list that contains; 252 // littleBox; 253 it = std::find_if(fList->Begin(), fList->End(), BoxContainer(littleBox));; 254 if ( it != fList->End() ); 255// cout << ""Found: "" << *it << endl;; 256 ;; 257 else {; 258 cout << ""SparseData::Add -> FAILED! box not found! "" << endl;; 259 cout << littleBox << endl;; 260 return; // Does not add the box, as it is part of the; 261 // underflow/overflow bin; 262 }; 263 // If it happens to have a value, then we add the value,; 264 if ( it->GetVal() ); 265 it->AddVal( content );; 266 else; 267 {; 268 // otherwise, we divide the container!; 269 DivideBox(it->GetMin(), it->GetMax(),; 270 littl",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:8730,Availability,error,error,8730,"box is the new Bin to be added; 249 Box littleBox(min, max);; 250 list<Box>::iterator it;; 251 // So we look for the Bin already in the list that contains; 252 // littleBox; 253 it = std::find_if(fList->Begin(), fList->End(), BoxContainer(littleBox));; 254 if ( it != fList->End() ); 255// cout << ""Found: "" << *it << endl;; 256 ;; 257 else {; 258 cout << ""SparseData::Add -> FAILED! box not found! "" << endl;; 259 cout << littleBox << endl;; 260 return; // Does not add the box, as it is part of the; 261 // underflow/overflow bin; 262 }; 263 // If it happens to have a value, then we add the value,; 264 if ( it->GetVal() ); 265 it->AddVal( content );; 266 else; 267 {; 268 // otherwise, we divide the container!; 269 DivideBox(it->GetMin(), it->GetMax(),; 270 littleBox.GetMin(), littleBox.GetMax(),; 271 it->GetMin().size(), it->GetMin().size() - 1,; 272 fList->GetList(), content, error );; 273 // and remove it from the list; 274 fList->Remove(it);; 275 }; 276 }; 277 ; 278 void SparseData::GetPoint(const unsigned int i,; 279 std::vector<double>& min, std::vector<double>&max,; 280 double& content, double& error); 281 {; 282 // Get the point number i. This is a method to explore the; 283 // data stored in the class.; 284 ; 285 unsigned int counter = 0;; 286 list<Box>::iterator it = fList->Begin();; 287 while ( it != fList->End() && counter != i ) {; 288 ++it;; 289 ++counter;; 290 }; 291 ; 292 if ( (it == fList->End()) || (counter != i) ); 293 throw std::out_of_range(""SparseData::GetPoint"");; 294 ; 295 min = it->GetMin();; 296 max = it->GetMax();; 297 content = it->GetVal();; 298 error = it->GetError();; 299 }; 300 ; 301 void SparseData::PrintList() const; 302 {; 303 // Debug method to print a list with all the data stored.; 304 copy(fList->Begin(), fList->End(), ostream_iterator<Box>(cout, ""\n------\n""));; 305 }; 306 ; 307 ; 308 void SparseData::GetBinData(BinData& bd) const; 309 {; 310 // Created the corresponding BinData; 311 ; 312 list<Box>::iterator it = fList->Begin();; 3",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:8958,Availability,error,error,8958,"box is the new Bin to be added; 249 Box littleBox(min, max);; 250 list<Box>::iterator it;; 251 // So we look for the Bin already in the list that contains; 252 // littleBox; 253 it = std::find_if(fList->Begin(), fList->End(), BoxContainer(littleBox));; 254 if ( it != fList->End() ); 255// cout << ""Found: "" << *it << endl;; 256 ;; 257 else {; 258 cout << ""SparseData::Add -> FAILED! box not found! "" << endl;; 259 cout << littleBox << endl;; 260 return; // Does not add the box, as it is part of the; 261 // underflow/overflow bin; 262 }; 263 // If it happens to have a value, then we add the value,; 264 if ( it->GetVal() ); 265 it->AddVal( content );; 266 else; 267 {; 268 // otherwise, we divide the container!; 269 DivideBox(it->GetMin(), it->GetMax(),; 270 littleBox.GetMin(), littleBox.GetMax(),; 271 it->GetMin().size(), it->GetMin().size() - 1,; 272 fList->GetList(), content, error );; 273 // and remove it from the list; 274 fList->Remove(it);; 275 }; 276 }; 277 ; 278 void SparseData::GetPoint(const unsigned int i,; 279 std::vector<double>& min, std::vector<double>&max,; 280 double& content, double& error); 281 {; 282 // Get the point number i. This is a method to explore the; 283 // data stored in the class.; 284 ; 285 unsigned int counter = 0;; 286 list<Box>::iterator it = fList->Begin();; 287 while ( it != fList->End() && counter != i ) {; 288 ++it;; 289 ++counter;; 290 }; 291 ; 292 if ( (it == fList->End()) || (counter != i) ); 293 throw std::out_of_range(""SparseData::GetPoint"");; 294 ; 295 min = it->GetMin();; 296 max = it->GetMax();; 297 content = it->GetVal();; 298 error = it->GetError();; 299 }; 300 ; 301 void SparseData::PrintList() const; 302 {; 303 // Debug method to print a list with all the data stored.; 304 copy(fList->Begin(), fList->End(), ostream_iterator<Box>(cout, ""\n------\n""));; 305 }; 306 ; 307 ; 308 void SparseData::GetBinData(BinData& bd) const; 309 {; 310 // Created the corresponding BinData; 311 ; 312 list<Box>::iterator it = fList->Begin();; 3",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:9440,Availability,error,error,9440,"it is part of the; 261 // underflow/overflow bin; 262 }; 263 // If it happens to have a value, then we add the value,; 264 if ( it->GetVal() ); 265 it->AddVal( content );; 266 else; 267 {; 268 // otherwise, we divide the container!; 269 DivideBox(it->GetMin(), it->GetMax(),; 270 littleBox.GetMin(), littleBox.GetMax(),; 271 it->GetMin().size(), it->GetMin().size() - 1,; 272 fList->GetList(), content, error );; 273 // and remove it from the list; 274 fList->Remove(it);; 275 }; 276 }; 277 ; 278 void SparseData::GetPoint(const unsigned int i,; 279 std::vector<double>& min, std::vector<double>&max,; 280 double& content, double& error); 281 {; 282 // Get the point number i. This is a method to explore the; 283 // data stored in the class.; 284 ; 285 unsigned int counter = 0;; 286 list<Box>::iterator it = fList->Begin();; 287 while ( it != fList->End() && counter != i ) {; 288 ++it;; 289 ++counter;; 290 }; 291 ; 292 if ( (it == fList->End()) || (counter != i) ); 293 throw std::out_of_range(""SparseData::GetPoint"");; 294 ; 295 min = it->GetMin();; 296 max = it->GetMax();; 297 content = it->GetVal();; 298 error = it->GetError();; 299 }; 300 ; 301 void SparseData::PrintList() const; 302 {; 303 // Debug method to print a list with all the data stored.; 304 copy(fList->Begin(), fList->End(), ostream_iterator<Box>(cout, ""\n------\n""));; 305 }; 306 ; 307 ; 308 void SparseData::GetBinData(BinData& bd) const; 309 {; 310 // Created the corresponding BinData; 311 ; 312 list<Box>::iterator it = fList->Begin();; 313 const unsigned int dim = it->GetMin().size();; 314 ; 315 bd.Initialize(fList->GetList().size(), dim);; 316 // Visit all the stored Boxes; 317 for ( ; it != fList->End(); ++it ); 318 {; 319 vector<double> mid(dim);; 320 // fill up the vector with the mid point of the Bin; 321 for ( unsigned int i = 0; i < dim; ++i); 322 {; 323 mid[i] = ((it->GetMax()[i] - it->GetMin()[i]) /2) + it->GetMin()[i];; 324 }; 325 // And store it into the BinData structure; 326 bd.Add(&mid[0], it->Get",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:13248,Availability,error,error,13248,"ta.h; b#define b(i)Definition RSha256.hxx:100; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; SparseData.h; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; ROOT::Fit::AreaComparerDefinition SparseData.cxx:119; ROOT::Fit::AreaComparer::operator()void operator()(double value)Definition SparseData.cxx:127; ROOT::Fit::AreaComparer::IsThereAreabool IsThereArea()Definition SparseData.cxx:136; ROOT::Fit::AreaComparer::AreaComparerAreaComparer(vector< double >::iterator iter)Definition SparseData.cxx:121; ROOT::Fit::AreaComparer::fItervector< double >::iterator fIterDefinition SparseData.cxx:140; ROOT::Fit::AreaComparer::fLimitdouble fLimitDefinition SparseData.cxx:141; ROOT::Fit::AreaComparer::fThereIsAreabool fThereIsAreaDefinition SparseData.cxx:139; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::BinData::AddBinUpEdgevoid AddBinUpEdge(const double *xup)add the bin width data, a pointer to an array with the bin upper edge information.Definition BinData.cxx:613; ROOT::Fit::BinData::Addvoid Add(double x, double y)add one dim data with only coordinate and valuesDefinition BinData.cxx:408; ROOT::Fit::BinData::Initializevoid Initialize(unsigned int newPoints, unsigned int dim=1, ErrorType err=kValueError)Preallocate a data set with given size, dimension and error type.Definition BinData.h:122; ROOT::Fit::BoxContainerDefinition SparseData.cxx:78; ROOT::Fit::BoxContainer::operator()bool operator()(const Box &b1)Definition SparseData.cxx:86; ROOT::Fit::BoxContainer::fBoxconst Box & fBoxDefinition SparseData.cxx:80; ROOT::Fit::BoxContainer::BoxContainerBoxContainer(const Box &b)Definition SparseData.cxx:84; ROOT::Fit::BoxDefinition SparseData.cxx:37; ROOT::Fit::Box::fValdouble fValDefini",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:13762,Availability,error,error,13762,"a.cxx:127; ROOT::Fit::AreaComparer::IsThereAreabool IsThereArea()Definition SparseData.cxx:136; ROOT::Fit::AreaComparer::AreaComparerAreaComparer(vector< double >::iterator iter)Definition SparseData.cxx:121; ROOT::Fit::AreaComparer::fItervector< double >::iterator fIterDefinition SparseData.cxx:140; ROOT::Fit::AreaComparer::fLimitdouble fLimitDefinition SparseData.cxx:141; ROOT::Fit::AreaComparer::fThereIsAreabool fThereIsAreaDefinition SparseData.cxx:139; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::BinData::AddBinUpEdgevoid AddBinUpEdge(const double *xup)add the bin width data, a pointer to an array with the bin upper edge information.Definition BinData.cxx:613; ROOT::Fit::BinData::Addvoid Add(double x, double y)add one dim data with only coordinate and valuesDefinition BinData.cxx:408; ROOT::Fit::BinData::Initializevoid Initialize(unsigned int newPoints, unsigned int dim=1, ErrorType err=kValueError)Preallocate a data set with given size, dimension and error type.Definition BinData.h:122; ROOT::Fit::BoxContainerDefinition SparseData.cxx:78; ROOT::Fit::BoxContainer::operator()bool operator()(const Box &b1)Definition SparseData.cxx:86; ROOT::Fit::BoxContainer::fBoxconst Box & fBoxDefinition SparseData.cxx:80; ROOT::Fit::BoxContainer::BoxContainerBoxContainer(const Box &b)Definition SparseData.cxx:84; ROOT::Fit::BoxDefinition SparseData.cxx:37; ROOT::Fit::Box::fValdouble fValDefinition SparseData.cxx:70; ROOT::Fit::Box::fMinvector< double > fMinDefinition SparseData.cxx:68; ROOT::Fit::Box::fMaxvector< double > fMaxDefinition SparseData.cxx:69; ROOT::Fit::Box::GetMaxconst vector< double > & GetMax() constDefinition SparseData.cxx:55; ROOT::Fit::Box::AddValvoid AddVal(const double value)Definition SparseData.cxx:62; ROOT::Fit::Box::operator<<friend ostream & operator<<(ostream &os, const Box &b)Definition SparseData.cxx:374; ROOT::Fit::Box::GetValdouble Ge",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:14988,Availability,error,error,14988,"x & fBoxDefinition SparseData.cxx:80; ROOT::Fit::BoxContainer::BoxContainerBoxContainer(const Box &b)Definition SparseData.cxx:84; ROOT::Fit::BoxDefinition SparseData.cxx:37; ROOT::Fit::Box::fValdouble fValDefinition SparseData.cxx:70; ROOT::Fit::Box::fMinvector< double > fMinDefinition SparseData.cxx:68; ROOT::Fit::Box::fMaxvector< double > fMaxDefinition SparseData.cxx:69; ROOT::Fit::Box::GetMaxconst vector< double > & GetMax() constDefinition SparseData.cxx:55; ROOT::Fit::Box::AddValvoid AddVal(const double value)Definition SparseData.cxx:62; ROOT::Fit::Box::operator<<friend ostream & operator<<(ostream &os, const Box &b)Definition SparseData.cxx:374; ROOT::Fit::Box::GetValdouble GetVal() constDefinition SparseData.cxx:57; ROOT::Fit::Box::operator==bool operator==(const Box &b)Definition SparseData.cxx:48; ROOT::Fit::Box::fErrordouble fErrorDefinition SparseData.cxx:71; ROOT::Fit::Box::BoxBox(const vector< double > &min, const vector< double > &max, const double value=0.0, const double error=1.0)Definition SparseData.cxx:41; ROOT::Fit::Box::GetMinconst vector< double > & GetMin() constDefinition SparseData.cxx:53; ROOT::Fit::Box::GetErrordouble GetError() constDefinition SparseData.cxx:59; ROOT::Fit::FitDataBase class for all the fit data types: Stores the coordinates and the DataOptions.Definition FitData.h:56; ROOT::Fit::FitData::operator=FitData & operator=(const FitData &rhs)Definition FitData.cxx:218; ROOT::Fit::ProxyListBoxDefinition SparseData.cxx:181; ROOT::Fit::ProxyListBox::Beginlist< Box >::iterator Begin()Definition SparseData.cxx:184; ROOT::Fit::ProxyListBox::PushBackvoid PushBack(Box &box)Definition SparseData.cxx:183; ROOT::Fit::ProxyListBox::Removevoid Remove(list< Box >::iterator it)Definition SparseData.cxx:186; ROOT::Fit::ProxyListBox::GetListlist< Box > & GetList()Definition SparseData.cxx:187; ROOT::Fit::ProxyListBox::fProxylist< Box > fProxyDefinition SparseData.cxx:189; ROOT::Fit::ProxyListBox::Endlist< Box >::iterator End()Definition Spars",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:16371,Availability,error,error,16371,"tData.h:56; ROOT::Fit::FitData::operator=FitData & operator=(const FitData &rhs)Definition FitData.cxx:218; ROOT::Fit::ProxyListBoxDefinition SparseData.cxx:181; ROOT::Fit::ProxyListBox::Beginlist< Box >::iterator Begin()Definition SparseData.cxx:184; ROOT::Fit::ProxyListBox::PushBackvoid PushBack(Box &box)Definition SparseData.cxx:183; ROOT::Fit::ProxyListBox::Removevoid Remove(list< Box >::iterator it)Definition SparseData.cxx:186; ROOT::Fit::ProxyListBox::GetListlist< Box > & GetList()Definition SparseData.cxx:187; ROOT::Fit::ProxyListBox::fProxylist< Box > fProxyDefinition SparseData.cxx:189; ROOT::Fit::ProxyListBox::Endlist< Box >::iterator End()Definition SparseData.cxx:185; ROOT::Fit::SparseDataSparseData class representing the data of a THNSparse histogram The data needs to be converted to a B...Definition SparseData.h:35; ROOT::Fit::SparseData::fListstd::unique_ptr< ProxyListBox > fListDefinition SparseData.h:76; ROOT::Fit::SparseData::Addvoid Add(std::vector< double > &min, std::vector< double > &max, const double content, const double error=1.0)Adds a new bin specified by the vectors.Definition SparseData.cxx:241; ROOT::Fit::SparseData::NDimunsigned int NDim() constReturns the dimension of the object (bins)Definition SparseData.cxx:235; ROOT::Fit::SparseData::GetPointvoid GetPoint(const unsigned int i, std::vector< double > &min, std::vector< double > &max, double &content, double &error)Definition SparseData.cxx:278; ROOT::Fit::SparseData::NPointsunsigned int NPoints() constReturns the number of points stored.Definition SparseData.cxx:229; ROOT::Fit::SparseData::GetBinDataNoZerosvoid GetBinDataNoZeros(BinData &) constSame as before, but including zero content bins.Definition SparseData.cxx:348; ROOT::Fit::SparseData::operator=SparseData & operator=(const SparseData &rhs)Assignment operator.Definition SparseData.cxx:220; ROOT::Fit::SparseData::PrintListvoid PrintList() constDebug method to print the list of bins stored.Definition SparseData.cxx:301; ROOT:",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:16725,Availability,error,error,16725,"roxyListBox::Removevoid Remove(list< Box >::iterator it)Definition SparseData.cxx:186; ROOT::Fit::ProxyListBox::GetListlist< Box > & GetList()Definition SparseData.cxx:187; ROOT::Fit::ProxyListBox::fProxylist< Box > fProxyDefinition SparseData.cxx:189; ROOT::Fit::ProxyListBox::Endlist< Box >::iterator End()Definition SparseData.cxx:185; ROOT::Fit::SparseDataSparseData class representing the data of a THNSparse histogram The data needs to be converted to a B...Definition SparseData.h:35; ROOT::Fit::SparseData::fListstd::unique_ptr< ProxyListBox > fListDefinition SparseData.h:76; ROOT::Fit::SparseData::Addvoid Add(std::vector< double > &min, std::vector< double > &max, const double content, const double error=1.0)Adds a new bin specified by the vectors.Definition SparseData.cxx:241; ROOT::Fit::SparseData::NDimunsigned int NDim() constReturns the dimension of the object (bins)Definition SparseData.cxx:235; ROOT::Fit::SparseData::GetPointvoid GetPoint(const unsigned int i, std::vector< double > &min, std::vector< double > &max, double &content, double &error)Definition SparseData.cxx:278; ROOT::Fit::SparseData::NPointsunsigned int NPoints() constReturns the number of points stored.Definition SparseData.cxx:229; ROOT::Fit::SparseData::GetBinDataNoZerosvoid GetBinDataNoZeros(BinData &) constSame as before, but including zero content bins.Definition SparseData.cxx:348; ROOT::Fit::SparseData::operator=SparseData & operator=(const SparseData &rhs)Assignment operator.Definition SparseData.cxx:220; ROOT::Fit::SparseData::PrintListvoid PrintList() constDebug method to print the list of bins stored.Definition SparseData.cxx:301; ROOT::Fit::SparseData::GetBinDatavoid GetBinData(BinData &) constTransforms the data into a ROOT::Fit::BinData structure.Definition SparseData.cxx:308; ROOT::Fit::SparseData::SparseDataSparseData(std::vector< double > &min, std::vector< double > &max)Constructor with a vector.Definition SparseData.cxx:193; ROOT::Fit::SparseData::~SparseData~SparseData() o",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:18495,Availability,error,error,18495,"ints stored.Definition SparseData.cxx:229; ROOT::Fit::SparseData::GetBinDataNoZerosvoid GetBinDataNoZeros(BinData &) constSame as before, but including zero content bins.Definition SparseData.cxx:348; ROOT::Fit::SparseData::operator=SparseData & operator=(const SparseData &rhs)Assignment operator.Definition SparseData.cxx:220; ROOT::Fit::SparseData::PrintListvoid PrintList() constDebug method to print the list of bins stored.Definition SparseData.cxx:301; ROOT::Fit::SparseData::GetBinDatavoid GetBinData(BinData &) constTransforms the data into a ROOT::Fit::BinData structure.Definition SparseData.cxx:308; ROOT::Fit::SparseData::SparseDataSparseData(std::vector< double > &min, std::vector< double > &max)Constructor with a vector.Definition SparseData.cxx:193; ROOT::Fit::SparseData::~SparseData~SparseData() overrideDestructor.Definition SparseData.cxx:227; ROOT::Fit::SparseData::GetBinDataIntegralvoid GetBinDataIntegral(BinData &) constSame as before, but returning a BinData with integral format (containing bin edges)Definition SparseData.cxx:330; double; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; nconst Int_t nDefinition legend1.C:16; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOT::Fit::DivideBoxvoid DivideBox(const vector< double > &min, const vector< double > &max, const vector< double > &bmin, const vector< double > &bmax, const unsigned int size, const unsigned int n, list< Box > &l, const double val, const double error)Definition SparseData.cxx:151; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; lTLine lDefinition textangle.C:4. mathmathcoresrcSparseData.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:7811,Deployability,update,updated,7811,"ox>();; 212 fList->PushBack(originalBox);; 213 }; 214 ; 215 SparseData::SparseData(const SparseData & rhs) :; 216 FitData(rhs); 217 {; 218 fList = std::make_unique<ProxyListBox>(*rhs.fList);; 219 }; 220 SparseData & SparseData::operator=(const SparseData & rhs); 221 {; 222 FitData::operator=( rhs );; 223 fList = std::make_unique<ProxyListBox>(*rhs.fList);; 224 return *this;; 225 }; 226 ; 227 SparseData::~SparseData() {}; 228 ; 229 unsigned int SparseData::NPoints() const; 230 {; 231 // Returns the number of points stored, including the 0 ones.; 232 return fList->GetList().size();; 233 }; 234 ; 235 unsigned int SparseData::NDim() const; 236 {; 237 // Returns the number of dimension of the SparseData object.; 238 return fList->Begin()->GetMin().size();; 239 }; 240 ; 241 void SparseData::Add(std::vector<double>& min, std::vector<double>& max,; 242 const double content, const double error); 243 {; 244 // Add a box to the stored ones. For that, it will look for; 245 // the box that contains the new data and either replace it; 246 // or updated it.; 247 ; 248 // Little box is the new Bin to be added; 249 Box littleBox(min, max);; 250 list<Box>::iterator it;; 251 // So we look for the Bin already in the list that contains; 252 // littleBox; 253 it = std::find_if(fList->Begin(), fList->End(), BoxContainer(littleBox));; 254 if ( it != fList->End() ); 255// cout << ""Found: "" << *it << endl;; 256 ;; 257 else {; 258 cout << ""SparseData::Add -> FAILED! box not found! "" << endl;; 259 cout << littleBox << endl;; 260 return; // Does not add the box, as it is part of the; 261 // underflow/overflow bin; 262 }; 263 // If it happens to have a value, then we add the value,; 264 if ( it->GetVal() ); 265 it->AddVal( content );; 266 else; 267 {; 268 // otherwise, we divide the container!; 269 DivideBox(it->GetMin(), it->GetMax(),; 270 littleBox.GetMin(), littleBox.GetMax(),; 271 it->GetMin().size(), it->GetMin().size() - 1,; 272 fList->GetList(), content, error );; 273 // and remove it from",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:1476,Modifiability,variab,variables,1476,"-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <<(ostream& os, const Box& b);; 66 ; 67 private:; 68 vector<double> fMin;; 69 vector<double> fMax;; 70 double fVal;; 71 double fError;; 72 };; 73 ; 74 // This class is just a helper to be used in std::for_each t",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:1070,Safety,avoid,avoid,1070," master. Reference Guide ; .  . Loading...; Searching...; No Matches. SparseData.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: David Gonzalez Maline Wed Aug 28 15:33:03 2009; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the cont",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:2421,Usability,simpl,simplify,2421," in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <<(ostream& os, const Box& b);; 66 ; 67 private:; 68 vector<double> fMin;; 69 vector<double> fMax;; 70 double fVal;; 71 double fError;; 72 };; 73 ; 74 // This class is just a helper to be used in std::for_each to; 75 // simplify the code later. It's just a definition of a method; 76 // that will discern whether a Box is included into another one; 77 class BoxContainer; 78 {; 79 private:; 80 const Box& fBox;; 81 public:; 82 //Constructs the BoxContainer object with a Box that is meant; 83 //to include another one that will be provided later; 84 BoxContainer(const Box& b): fBox(b) {}; 85 ; 86 bool operator() (const Box& b1); 87 { return operator()(fBox, b1); }; 88 ; 89 // Looks if b2 is included in b1; 90 bool operator() (const Box& b1, const Box& b2); 91 {; 92 bool isIn = true;; 93 vector<double>::const_iterator boxit = b2.fMin.begin();; 9",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/SparseData_8cxx_source.html:3545,Usability,simpl,simplify,3545,"finition of a method; 76 // that will discern whether a Box is included into another one; 77 class BoxContainer; 78 {; 79 private:; 80 const Box& fBox;; 81 public:; 82 //Constructs the BoxContainer object with a Box that is meant; 83 //to include another one that will be provided later; 84 BoxContainer(const Box& b): fBox(b) {}; 85 ; 86 bool operator() (const Box& b1); 87 { return operator()(fBox, b1); }; 88 ; 89 // Looks if b2 is included in b1; 90 bool operator() (const Box& b1, const Box& b2); 91 {; 92 bool isIn = true;; 93 vector<double>::const_iterator boxit = b2.fMin.begin();; 94 vector<double>::const_iterator bigit = b1.fMax.begin();; 95 while ( isIn && boxit != b2.fMin.end() ); 96 {; 97 if ( (*boxit) >= (*bigit) ) isIn = false;; 98 ++boxit;; 99 ++bigit;; 100 }; 101 ; 102 boxit = b2.fMax.begin();; 103 bigit = b1.fMin.begin();; 104 while ( isIn && boxit != b2.fMax.end() ); 105 {; 106 if ( (*boxit) <= (*bigit) ) isIn = false;; 107 ++boxit;; 108 ++bigit;; 109 }; 110 ; 111 return isIn;; 112 }; 113 };; 114 ; 115 // Another helper class to be used in std::for_each to simplify; 116 // the code later. It implements the operator() to know if a; 117 // specified Box is big enough to contain any 'space' inside.; 118 class AreaComparer; 119 {; 120 public:; 121 AreaComparer(vector<double>::iterator iter):; 122 fThereIsArea(true),; 123 fIter(iter),; 124 fLimit(8 * std::numeric_limits<double>::epsilon()); 125 {};; 126 ; 127 void operator() (double value); 128 {; 129 if ( fabs(value- (*fIter)) < fLimit ); 130// if ( TMath::AreEqualRel(value, (*fIter), fLimit) ); 131 fThereIsArea = false;; 132 ; 133 ++fIter;; 134 }; 135 ; 136 bool IsThereArea() { return fThereIsArea; }; 137 ; 138 private:; 139 bool fThereIsArea;; 140 vector<double>::iterator fIter;; 141 double fLimit;; 142 };; 143 ; 144 ; 145 // This is the key of the SparseData structure. This method; 146 // will, by recursion, divide the area passed as an argument in; 147 // min and max into pieces to insert the Box defined",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
https://root.cern/doc/master/sparsehist_8C.html:13223,Availability,error,errors,13223,"tMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TH3F3-D histogram with a float per channel (see TH1 documentation)Definition TH3.h:317; THnSparseEfficient multidimensional histogram.Definition THnSparse.h:37; THnMultidimensional histogram.Definition THn.h:30; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TPad::Dividevoid Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0) overrideAutomatic pad generation by division.Definition TPad.cxx:1249; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Defi",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
https://root.cern/doc/master/sparsehist_8C.html:4031,Energy Efficiency,allocate,allocate,4031,"Stop();; ++rep[h];; } while ((!h && w.RealTime() < 0.1); || (h && rep[0] > 0 && rep[1] < rep[0]));; ; fTime[h][0] = (1.* fNum * rep[h]) / w.RealTime() / 1E6;; fTime[h][1] = (1.* fNum * rep[h]) / w.CpuTime() / 1E6;; ; if (h == 1 && (fTime[h][0] > 1E20 || fTime[h][1] > 1E20)) {; do {; // some more cycles:; w.Start(kFALSE);; Fill((EHist) h);; Check((EHist) h);; w.Stop();; ++rep[h];; } while (w.RealTime() < 0.1);; ; fTime[h][0] = (1.* fNum * rep[h]) / w.RealTime() / 1E6;; fTime[h][1] = (1.* fNum * rep[h]) / w.CpuTime() / 1E6;; }; ; if (fTime[h][0] > 1E20) fTime[h][0] = 1E20;; if (fTime[h][1] > 1E20) fTime[h][1] = 1E20;; }; catch (std::exception&) {; fTime[h][0] = fTime[h][1] = -1.;; check[h] = -1.; // can never be < 1 without exception; rep[h] = -1;; }; }; if (check[0] != check[1]); if (check[0] != -1.); printf(""ERROR: mismatch of histogram (%g) and sparse histogram (%g) for dim=%d, bins=%d!\n"",; check[0], check[1], fDim, fBins);; // else; // printf(""ERROR: cannot allocate histogram for dim=%d, bins=%d - out of memory!\n"",; // fDim, fBins);; return (check[0] == check[1]);; }; ; void TTimeHists::NextValues(); {; for (Int_t d = 0; d < fDim; ++d); fValue[d] = gRandom->Gaus() / 4.;; }; ; void TTimeHists::SetupValues(); {; // define fValue; if (!fValue) fValue = new Double_t[fDim];; gRandom->SetSeed(42);; }; ; void TTimeHists::Fill(EHist hist); {; for (Long_t n = 0; n < fNum; ++n) {; NextValues();; if (fgDebug > 1) {; printf(""%ld: fill %s"", n, hist == kHist? (fDim < 4 ? ""hist"" : ""arr"") : ""sparse"");; for (Int_t d = 0; d < fDim; ++d); printf(""[%g]"", fValue[d]);; printf(""\n"");; }; if (hist == kHist) {; switch (fDim) {; case 1: fHist->Fill(fValue[0]); break;; case 2: ((TH2F*)fHist)->Fill(fValue[0], fValue[1]); break;; case 3: ((TH3F*)fHist)->Fill(fValue[0], fValue[1], fValue[2]); break;; default: fHn->Fill(fValue); break;; }; } else {; fSparse->Fill(fValue);; }; }; }; ; void TTimeHists::SetupHist(EHist hist); {; if (hist == kHist) {; switch (fDim) {; case 1: fHist = new TH1F(""h1",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
https://root.cern/doc/master/sparsehist_8C.html:779,Integrability,depend,depends,779,". ROOT: tutorials/hist/sparsehist.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. sparsehist.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; The script calculates the bandwidth for filling and retrieving bin contents (in million entries per second) for these two histogramming techniques, where ""seconds"" is CPU and real time.; The first line of the plots contains the bandwidth based on the CPU time (THnSpase, TH1/2/3/nF*, ratio), the second line shows the plots for real time, and the third line shows the fraction of filled bins and memory used by THnSparse vs. TH1/2/3/nF.; The timing depends on the distribution and the amount of entries in the histograms; here, a Gaussian distribution (center is contained in the histograms) is used to fill each histogram with 1000 entries. The filling and reading is repeated until enough statistics have been collected.; tutorials/tree/drawsparse.C shows an example for visualizing a THnSparse. It creates a TTree which is then drawn using TParallelCoord.; This macro should be run in compiled mode due to the many nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullpt",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
https://root.cern/doc/master/sparsehist_8C.html:7129,Integrability,wrap,wrapping,7129,"s[d] = fBins;; xmin[d] = -1.;; xmax[d] = 1.;; }; fSparse = new THnSparseF(""hs"", ""hs"", fDim, bins, xmin, xmax);; }; }; ; Double_t TTimeHists::Check(EHist hist); {; // Check bin content of all bins; Double_t check = 0.;; Int_t* x = new Int_t[fDim];; memset(x, 0, sizeof(Int_t) * fDim);; ; if (hist == kHist) {; Long_t idx = 0;; Long_t size = 1;; for (Int_t d = 0; d < fDim; ++d); size *= (fBins + 2);; while (x[0] <= fBins + 1) {; Double_t v = -1.;; if (fDim < 4) {; Long_t histidx = x[0];; if (fDim == 2) histidx = fHist->GetBin(x[0], x[1]);; else if (fDim == 3) histidx = fHist->GetBin(x[0], x[1], x[2]);; v = fHist->GetBinContent(histidx);; }; else v = fHn->GetBinContent(x);; Double_t checkx = 0.;; if (v); for (Int_t d = 0; d < fDim; ++d); checkx += x[d];; check += checkx * v;; ; if (fgDebug > 2 || (fgDebug > 1 && v)) {; printf(""%s%d"", fDim < 4 ? ""hist"" : ""arr"", fDim);; for (Int_t d = 0; d < fDim; ++d); printf(""[%d]"", x[d]);; printf("" = %g\n"", v);; }; ; ++x[fDim - 1];; // Adjust the bin idx; // no wrapping for dim 0 - it's what we break on!; for (Int_t d = fDim - 1; d > 0; --d) {; if (x[d] > fBins + 1) {; x[d] = 0;; ++x[d - 1];; }; }; ++idx;; } // while next bin; } else {; for (Long64_t i = 0; i < fSparse->GetNbins(); ++i) {; Double_t v = fSparse->GetBinContent(i, x);; Double_t checkx = 0.;; for (Int_t d = 0; d < fDim; ++d); checkx += x[d];; check += checkx * v;; ; if (fgDebug > 1) {; printf(""sparse%d"", fDim);; for (Int_t d = 0; d < fDim; ++d); printf(""[%d]"", x[d]);; printf("" = %g\n"", v);; }; }; }; check /= fNum;; if (fgDebug > 0); printf(""check %s%d = %g\n"", hist == kHist ? (fDim < 4 ? ""hist"" : ""arr"") : ""sparse"", fDim, check);; return check;; }; ; ; void sparsehist() {; // Exclude this macro also for Cling as this script requires exception support; // which is not supported in Cling as of v6.00/00.; #if defined (__CLING__); printf(""Please run this script in compiled mode by running \"".x sparsehist.C+\""\n"");; return;; #endif; ; TH2F* htime[TTimeHists::kNumHist][TTimeHists::",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
https://root.cern/doc/master/sparsehist_8C.html:229,Performance,perform,performance,229,". ROOT: tutorials/hist/sparsehist.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. sparsehist.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; The script calculates the bandwidth for filling and retrieving bin contents (in million entries per second) for these two histogramming techniques, where ""seconds"" is CPU and real time.; The first line of the plots contains the bandwidth based on the CPU time (THnSpase, TH1/2/3/nF*, ratio), the second line shows the plots for real time, and the third line shows the fraction of filled bins and memory used by THnSparse vs. TH1/2/3/nF.; The timing depends on the distribution and the amount of entries in the histograms; here, a Gaussian distribution (center is contained in the histograms) is used to fill each histogram with 1000 entries. The filling and reading is repeated until enough statistics have been collected.; tutorials/tree/drawsparse.C shows an example for visualizing a THnSparse. It creates a TTree which is then drawn using TParallelCoord.; This macro should be run in compiled mode due to the many nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullpt",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
https://root.cern/doc/master/sparsehist_8C.html:1293,Performance,optimiz,optimization,1293,"Sparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; The script calculates the bandwidth for filling and retrieving bin contents (in million entries per second) for these two histogramming techniques, where ""seconds"" is CPU and real time.; The first line of the plots contains the bandwidth based on the CPU time (THnSpase, TH1/2/3/nF*, ratio), the second line shows the plots for real time, and the third line shows the fraction of filled bins and memory used by THnSparse vs. TH1/2/3/nF.; The timing depends on the distribution and the amount of entries in the histograms; here, a Gaussian distribution (center is contained in the histograms) is used to fill each histogram with 1000 entries. The filling and reading is repeated until enough statistics have been collected.; tutorials/tree/drawsparse.C shows an example for visualizing a THnSparse. It creates a TTree which is then drawn using TParallelCoord.; This macro should be run in compiled mode due to the many nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullptr), fHn(nullptr) {}; ~TTimeHists();; bool Run();; Double_t GetTime(EHist hist, ETime time) const {; if (time == kReal) return fTime[hist][0];; return fTime[hist][1]; }; static void SetDebug(Int_t lvl) { fgDebug = lvl; }; THnSparse* GetSparse() co",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
https://root.cern/doc/master/sparsehist_8C.html:1340,Testability,benchmark,benchmark,1340,"pt calculates the bandwidth for filling and retrieving bin contents (in million entries per second) for these two histogramming techniques, where ""seconds"" is CPU and real time.; The first line of the plots contains the bandwidth based on the CPU time (THnSpase, TH1/2/3/nF*, ratio), the second line shows the plots for real time, and the third line shows the fraction of filled bins and memory used by THnSparse vs. TH1/2/3/nF.; The timing depends on the distribution and the amount of entries in the histograms; here, a Gaussian distribution (center is contained in the histograms) is used to fill each histogram with 1000 entries. The filling and reading is repeated until enough statistics have been collected.; tutorials/tree/drawsparse.C shows an example for visualizing a THnSparse. It creates a TTree which is then drawn using TParallelCoord.; This macro should be run in compiled mode due to the many nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullptr), fHn(nullptr) {}; ~TTimeHists();; bool Run();; Double_t GetTime(EHist hist, ETime time) const {; if (time == kReal) return fTime[hist][0];; return fTime[hist][1]; }; static void SetDebug(Int_t lvl) { fgDebug = lvl; }; THnSparse* GetSparse() const { return fSparse; }; ; protected:; void Fill(EHist hist);; Double_t Check(EHist hist);;",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
https://root.cern/doc/master/sparsehist_8C.html:2749,Testability,test,tests,2749,"ny nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullptr), fHn(nullptr) {}; ~TTimeHists();; bool Run();; Double_t GetTime(EHist hist, ETime time) const {; if (time == kReal) return fTime[hist][0];; return fTime[hist][1]; }; static void SetDebug(Int_t lvl) { fgDebug = lvl; }; THnSparse* GetSparse() const { return fSparse; }; ; protected:; void Fill(EHist hist);; Double_t Check(EHist hist);; void SetupHist(EHist hist);; void NextValues();; void SetupValues();; ; private:; Double_t* fValue;; Int_t fDim;; Int_t fBins;; Long_t fNum;; Double_t fTime[2][2];; THnSparse* fSparse;; TH1* fHist;; THn* fHn;; static Int_t fgDebug;; };; ; Int_t TTimeHists::fgDebug = 0;; ; TTimeHists::~TTimeHists(); {; delete [] fValue;; delete fSparse;; delete fHist;; delete fHn;; }; ; bool TTimeHists::Run(); {; // run all tests with current settings, and check for identity of content.; ; Double_t check[2];; Long64_t rep[2];; for (int h = 0; h < 2; ++h) {; rep[h] = 0;; SetupValues();; try {; TStopwatch w;; w.Start();; SetupHist((EHist) h);; w.Stop();; do {; w.Start(kFALSE);; Fill((EHist) h);; check[h] = Check((EHist) h);; w.Stop();; ++rep[h];; } while ((!h && w.RealTime() < 0.1); || (h && rep[0] > 0 && rep[1] < rep[0]));; ; fTime[h][0] = (1.* fNum * rep[h]) / w.RealTime() / 1E6;; fTime[h][1] = (1.* fNum * rep[",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:10383,Availability,error,error,10383,"--------------------------------------------------------------------------*/; 435/* implementation of the incomplete beta function */; 436/**; 437 * DESCRIPTION:; 438 *; 439 * Returns incomplete beta integral of the arguments, evaluated; 440 * from zero to x. The function is defined as; 441 *; 442 * x; 443 * - -; 444 * | (a+b) | | a-1 b-1; 445 * ----------- | t (1-t) dt.; 446 * - - | |; 447 * | (a) | (b) -; 448 * 0; 449 *; 450 * The domain of definition is 0 <= x <= 1. In this; 451 * implementation a and b are restricted to positive values.; 452 * The integral from x to 1 may be obtained by the symmetry; 453 * relation; 454 *; 455 * 1 - incbet( a, b, x ) = incbet( b, a, 1-x ).; 456 *; 457 * The integral is evaluated by a continued fraction expansion; 458 * or, when b*x is small, by a power series.; 459 *; 460 * ACCURACY:; 461 *; 462 * Tested at uniformly distributed random points (a,b,x) with a and b; 463 * in ""domain"" and x between 0 and 1.; 464 * Relative error; 465 * arithmetic domain # trials peak rms; 466 * IEEE 0,5 10000 6.9e-15 4.5e-16; 467 * IEEE 0,85 250000 2.2e-13 1.7e-14; 468 * IEEE 0,1000 30000 5.3e-12 6.3e-13; 469 * IEEE 0,10000 250000 9.3e-11 7.1e-12; 470 * IEEE 0,100000 10000 8.7e-10 4.8e-11; 471 * Outputs smaller than the IEEE gradual underflow threshold; 472 * were excluded from these statistics.; 473 *; 474 * ERROR MESSAGES:; 475 * message condition value returned; 476 * incbet domain x<0, x>1 0.0; 477 * incbet underflow 0.0; 478 *; 479 * Cephes Math Library, Release 2.8: June, 2000; 480 * Copyright 1984, 1995, 2000 by Stephen L. Moshier; 481 */; 482 ; 483 ; 484double incbet( double aa, double bb, double xx ); 485{; 486 double a, b, t, x, xc, w, y;; 487 int flag;; 488 ; 489 if( aa <= 0.0 || bb <= 0.0 ); 490 return( 0.0 );; 491 ; 492 // LM: changed: for X > 1 return 1.; 493 if (xx <= 0.0) return( 0.0 );; 494 if ( xx >= 1.0) return( 1.0 );; 495 ; 496 flag = 0;; 497 ; 498/* - to test if that way is better for large b/ (comment out from Cephes version)",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:17616,Availability,error,error,17616,"2 ; 763/* Power series for incomplete beta integral.; 764 Use when b*x is small and x not too close to 1. */; 765 ; 766double pseries( double a, double b, double x ); 767{; 768 double s, t, u, v, n, t1, z, ai;; 769 ; 770 ai = 1.0 / a;; 771 u = (1.0 - b) * x;; 772 v = u / (a + 1.0);; 773 t1 = v;; 774 t = u;; 775 n = 2.0;; 776 s = 0.0;; 777 z = kMACHEP * ai;; 778 while( std::abs(v) > z ); 779 {; 780 u = (n - b) * x / n;; 781 t *= u;; 782 v = t / (a + n);; 783 s += v;; 784 n += 1.0;; 785 }; 786 s += t1;; 787 s += ai;; 788 ; 789 u = a * log(x);; 790 if( (a+b) < kMAXSTIR && std::abs(u) < kMAXLOG ); 791 {; 792 t = gamma(a+b)/(gamma(a)*gamma(b));; 793 s = s * t * pow(x,a);; 794 }; 795 else; 796 {; 797 t = lgam(a+b) - lgam(a) - lgam(b) + u + std::log(s);; 798 if( t < kMINLOG ); 799 s = 0.0;; 800 else; 801 s = std::exp(t);; 802 }; 803 return(s);; 804}; 805 ; 806/*---------------------------------------------------------------------------*/; 807 ; 808 ; 809/*---------------------------------------------------------------------------*/; 810/* for evaluation of error function */; 811/*---------------------------------------------------------------------------*/; 812 ; 813static double erfP[] = {; 814 2.46196981473530512524E-10,; 815 5.64189564831068821977E-1,; 816 7.46321056442269912687E0,; 817 4.86371970985681366614E1,; 818 1.96520832956077098242E2,; 819 5.26445194995477358631E2,; 820 9.34528527171957607540E2,; 821 1.02755188689515710272E3,; 822 5.57535335369399327526E2; 823};; 824static double erfQ[] = {; 825/* 1.00000000000000000000E0,*/; 826 1.32281951154744992508E1,; 827 8.67072140885989742329E1,; 828 3.54937778887819891062E2,; 829 9.75708501743205489753E2,; 830 1.82390916687909736289E3,; 831 2.24633760818710981792E3,; 832 1.65666309194161350182E3,; 833 5.57535340817727675546E2; 834};; 835static double erfR[] = {; 836 5.64189583547755073984E-1,; 837 1.27536670759978104416E0,; 838 5.01905042251180477414E0,; 839 6.16021097993053585195E0,; 840 7.40974269950448939160E0,; 841 2.",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:19363,Availability,error,error,19363,"; 834};; 835static double erfR[] = {; 836 5.64189583547755073984E-1,; 837 1.27536670759978104416E0,; 838 5.01905042251180477414E0,; 839 6.16021097993053585195E0,; 840 7.40974269950448939160E0,; 841 2.97886665372100240670E0; 842};; 843static double erfS[] = {; 844/* 1.00000000000000000000E0,*/; 845 2.26052863220117276590E0,; 846 9.39603524938001434673E0,; 847 1.20489539808096656605E1,; 848 1.70814450747565897222E1,; 849 9.60896809063285878198E0,; 850 3.36907645100081516050E0; 851};; 852static double erfT[] = {; 853 9.60497373987051638749E0,; 854 9.00260197203842689217E1,; 855 2.23200534594684319226E3,; 856 7.00332514112805075473E3,; 857 5.55923013010394962768E4; 858};; 859static double erfU[] = {; 860/* 1.00000000000000000000E0,*/; 861 3.35617141647503099647E1,; 862 5.21357949780152679795E2,; 863 4.59432382970980127987E3,; 864 2.26290000613890934246E4,; 865 4.92673942608635921086E4; 866};; 867 ; 868/*---------------------------------------------------------------------------*/; 869/* complementary error function */; 870/* For small x, erfc(x) = 1 - erf(x); otherwise rational */; 871/* approximations are computed. */; 872 ; 873 ; 874double erfc( double a ); 875{; 876 double p,q,x,y,z;; 877 ; 878 ; 879 if( a < 0.0 ); 880 x = -a;; 881 else; 882 x = a;; 883 ; 884 if( x < 1.0 ); 885 return( 1.0 - ROOT::Math::Cephes::erf(a) );; 886 ; 887 z = -a * a;; 888 ; 889 if( z < -kMAXLOG ); 890 {; 891 under:; 892 if( a < 0 ); 893 return( 2.0 );; 894 else; 895 return( 0.0 );; 896 }; 897 ; 898 z = exp(z);; 899 ; 900 if( x < 8.0 ); 901 {; 902 p = Polynomialeval( x, erfP, 8 );; 903 q = Polynomial1eval( x, erfQ, 8 );; 904 }; 905 else; 906 {; 907 p = Polynomialeval( x, erfR, 5 );; 908 q = Polynomial1eval( x, erfS, 6 );; 909 }; 910 y = (z * p)/q;; 911 ; 912 if( a < 0 ); 913 y = 2.0 - y;; 914 ; 915 if( y == 0 ); 916 goto under;; 917 ; 918 return(y);; 919}; 920 ; 921/*---------------------------------------------------------------------------*/; 922/* error function */; 923/* For 0 <= |x| < 1",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:20310,Availability,error,error,20310,"----------------------------------------------------------*/; 869/* complementary error function */; 870/* For small x, erfc(x) = 1 - erf(x); otherwise rational */; 871/* approximations are computed. */; 872 ; 873 ; 874double erfc( double a ); 875{; 876 double p,q,x,y,z;; 877 ; 878 ; 879 if( a < 0.0 ); 880 x = -a;; 881 else; 882 x = a;; 883 ; 884 if( x < 1.0 ); 885 return( 1.0 - ROOT::Math::Cephes::erf(a) );; 886 ; 887 z = -a * a;; 888 ; 889 if( z < -kMAXLOG ); 890 {; 891 under:; 892 if( a < 0 ); 893 return( 2.0 );; 894 else; 895 return( 0.0 );; 896 }; 897 ; 898 z = exp(z);; 899 ; 900 if( x < 8.0 ); 901 {; 902 p = Polynomialeval( x, erfP, 8 );; 903 q = Polynomial1eval( x, erfQ, 8 );; 904 }; 905 else; 906 {; 907 p = Polynomialeval( x, erfR, 5 );; 908 q = Polynomial1eval( x, erfS, 6 );; 909 }; 910 y = (z * p)/q;; 911 ; 912 if( a < 0 ); 913 y = 2.0 - y;; 914 ; 915 if( y == 0 ); 916 goto under;; 917 ; 918 return(y);; 919}; 920 ; 921/*---------------------------------------------------------------------------*/; 922/* error function */; 923/* For 0 <= |x| < 1, erf(x) = x * P4(x**2)/Q5(x**2); otherwise */; 924/* erf(x) = 1 - erfc(x). */; 925 ; 926double erf( double x); 927{; 928 double y, z;; 929 ; 930 if( std::abs(x) > 1.0 ); 931 return( 1.0 - ROOT::Math::Cephes::erfc(x) );; 932 z = x * x;; 933 y = x * Polynomialeval( z, erfT, 4 ) / Polynomial1eval( z, erfU, 5 );; 934 return( y );; 935 ; 936}; 937 ; 938} // end namespace Cephes; 939 ; 940 ; 941/*---------------------------------------------------------------------------*/; 942 ; 943/*---------------------------------------------------------------------------*/; 944/* Routines used within this implementation */; 945 ; 946 ; 947/*; 948 * calculates a value of a polynomial of the form:; 949 * a[0]x^N+a[1]x^(N-1) + ... + a[N]; 950*/; 951double Polynomialeval(double x, double* a, unsigned int N); 952{; 953 if (N==0) return a[0];; 954 else; 955 {; 956 double pom = a[0];; 957 for (unsigned int i=1; i <= N; i++); 958 pom = pom *x",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:1082,Energy Efficiency,power,power,1082,".; Searching...; No Matches. SpecFuncCephes.cxx. Go to the documentation of this file. 1//; 2//; 3// gamma and related functions from Cephes library; 4// see: http://www.netlib.org/cephes; 5//; 6// Copyright 1985, 1987, 2000 by Stephen L. Moshier; 7//; 8//; 9 ; 10#include ""SpecFuncCephes.h""; 11#include ""Math/Math.h""; 12 ; 13 ; 14#include <cmath>; 15 ; 16#include <limits>; 17 ; 18 ; 19 ; 20namespace ROOT {; 21namespace Math {; 22 ; 23namespace Cephes {; 24 ; 25 ; 26static double kBig = 4.503599627370496e15;; 27static double kBiginv = 2.22044604925031308085e-16;; 28 ; 29/* log( sqrt( 2*pi ) ) */; 30static double LS2PI = 0.91893853320467274178;; 31 ; 32 ; 33// incomplete gamma function (complement integral); 34// igamc(a,x) = 1 - igam(a,x); 35//; 36// inf.; 37// -; 38// 1 | | -t a-1; 39// = ----- | e t dt.; 40// - | |; 41// | (a) -; 42// x; 43//; 44//; 45 ; 46// In this implementation both arguments must be positive.; 47// The integral is evaluated by either a power series or; 48// continued fraction expansion, depending on the relative; 49// values of a and x.; 50 ; 51double igamc( double a, double x ); 52{; 53 ; 54 double ans, ax, c, yc, r, t, y, z;; 55 double pk, pkm1, pkm2, qk, qkm1, qkm2;; 56 ; 57 // LM: for negative values returns 0.0; 58 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 59 if (a <= 0) return 0.0;; 60 ; 61 if (x <= 0) return 1.0;; 62 ; 63 if( (x < 1.0) || (x < a) ); 64 return( 1.0 - igam(a,x) );; 65 ; 66 ax = a * std::log(x) - x - lgam(a);; 67 if( ax < -kMAXLOG ); 68 return( 0.0 );; 69 ; 70 ax = std::exp(ax);; 71 ; 72/* continued fraction */; 73 y = 1.0 - a;; 74 z = x + y + 1.0;; 75 c = 0.0;; 76 pkm2 = 1.0;; 77 qkm2 = x;; 78 pkm1 = x + 1.0;; 79 qkm1 = z * x;; 80 ans = pkm1/qkm1;; 81 ; 82 do; 83 {; 84 c += 1.0;; 85 y += 1.0;; 86 z += 2.0;; 87 yc = y * c;; 88 pk = pkm1 * z - pkm2 * yc;; 89 qk = qkm1 * z - qkm2 * yc;; 90 if(qk); 91 {; 92 r = pk/qk;; 93 t = std::abs( (ans - r)/r );; 94 ans = r;; 95 }; 96 else; 97 t = 1.0;; 98 pk",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:3083,Energy Efficiency,power,power,3083,"95 }; 96 else; 97 t = 1.0;; 98 pkm2 = pkm1;; 99 pkm1 = pk;; 100 qkm2 = qkm1;; 101 qkm1 = qk;; 102 if( std::abs(pk) > kBig ); 103 {; 104 pkm2 *= kBiginv;; 105 pkm1 *= kBiginv;; 106 qkm2 *= kBiginv;; 107 qkm1 *= kBiginv;; 108 }; 109 }; 110 while( t > kMACHEP );; 111 ; 112 return( ans * ax );; 113}; 114 ; 115 ; 116 ; 117/* left tail of incomplete gamma function:; 118 *; 119 * inf. k; 120 * a -x - x; 121 * x e > ----------; 122 * - -; 123 * k=0 | (a+k+1); 124 *; 125 */; 126 ; 127double igam( double a, double x ); 128{; 129 double ans, ax, c, r;; 130 ; 131 // LM: for negative values returns 1.0 instead of zero; 132 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 133 if (a <= 0) return 1.0;; 134 ; 135 if (x <= 0) return 0.0;; 136 ; 137 if( (x > 1.0) && (x > a ) ); 138 return( 1.0 - igamc(a,x) );; 139 ; 140/* Compute x**a * exp(-x) / gamma(a) */; 141 ax = a * std::log(x) - x - lgam(a);; 142 if( ax < -kMAXLOG ); 143 return( 0.0 );; 144 ; 145 ax = std::exp(ax);; 146 ; 147/* power series */; 148 r = a;; 149 c = 1.0;; 150 ans = 1.0;; 151 ; 152 do; 153 {; 154 r += 1.0;; 155 c *= x/r;; 156 ans += c;; 157 }; 158 while( c/ans > kMACHEP );; 159 ; 160 return( ans * ax/a );; 161}; 162 ; 163/*---------------------------------------------------------------------------*/; 164 ; 165/* Logarithm of gamma function */; 166/* A[]: Stirling's formula expansion of log gamma; 167 * B[], C[]: log gamma function between 2 and 3; 168 */; 169 ; 170static double A[] = {; 171 8.11614167470508450300E-4,; 172 -5.95061904284301438324E-4,; 173 7.93650340457716943945E-4,; 174 -2.77777777730099687205E-3,; 175 8.33333333333331927722E-2; 176};; 177 ; 178static double B[] = {; 179 -1.37825152569120859100E3,; 180 -3.88016315134637840924E4,; 181 -3.31612992738871184744E5,; 182 -1.16237097492762307383E6,; 183 -1.72173700820839662146E6,; 184 -8.53555664245765465627E5; 185};; 186 ; 187static double C[] = {; 188/* 1.00000000000000000000E0, */; 189 -3.51815701436523470549E2,; 190 -1.706421066",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:10206,Energy Efficiency,power,power,10206,"--------------------*/; 427/* implementation based on cephes log gamma */; 428double beta(double z, double w); 429{; 430 return std::exp(ROOT::Math::Cephes::lgam(z) + ROOT::Math::Cephes::lgam(w)- ROOT::Math::Cephes::lgam(z+w) );; 431}; 432 ; 433 ; 434/*---------------------------------------------------------------------------*/; 435/* implementation of the incomplete beta function */; 436/**; 437 * DESCRIPTION:; 438 *; 439 * Returns incomplete beta integral of the arguments, evaluated; 440 * from zero to x. The function is defined as; 441 *; 442 * x; 443 * - -; 444 * | (a+b) | | a-1 b-1; 445 * ----------- | t (1-t) dt.; 446 * - - | |; 447 * | (a) | (b) -; 448 * 0; 449 *; 450 * The domain of definition is 0 <= x <= 1. In this; 451 * implementation a and b are restricted to positive values.; 452 * The integral from x to 1 may be obtained by the symmetry; 453 * relation; 454 *; 455 * 1 - incbet( a, b, x ) = incbet( b, a, 1-x ).; 456 *; 457 * The integral is evaluated by a continued fraction expansion; 458 * or, when b*x is small, by a power series.; 459 *; 460 * ACCURACY:; 461 *; 462 * Tested at uniformly distributed random points (a,b,x) with a and b; 463 * in ""domain"" and x between 0 and 1.; 464 * Relative error; 465 * arithmetic domain # trials peak rms; 466 * IEEE 0,5 10000 6.9e-15 4.5e-16; 467 * IEEE 0,85 250000 2.2e-13 1.7e-14; 468 * IEEE 0,1000 30000 5.3e-12 6.3e-13; 469 * IEEE 0,10000 250000 9.3e-11 7.1e-12; 470 * IEEE 0,100000 10000 8.7e-10 4.8e-11; 471 * Outputs smaller than the IEEE gradual underflow threshold; 472 * were excluded from these statistics.; 473 *; 474 * ERROR MESSAGES:; 475 * message condition value returned; 476 * incbet domain x<0, x>1 0.0; 477 * incbet underflow 0.0; 478 *; 479 * Cephes Math Library, Release 2.8: June, 2000; 480 * Copyright 1984, 1995, 2000 by Stephen L. Moshier; 481 */; 482 ; 483 ; 484double incbet( double aa, double bb, double xx ); 485{; 486 double a, b, t, x, xc, w, y;; 487 int flag;; 488 ; 489 if( aa <= 0.0 || bb <= 0.0",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:1134,Integrability,depend,depending,1134,".; Searching...; No Matches. SpecFuncCephes.cxx. Go to the documentation of this file. 1//; 2//; 3// gamma and related functions from Cephes library; 4// see: http://www.netlib.org/cephes; 5//; 6// Copyright 1985, 1987, 2000 by Stephen L. Moshier; 7//; 8//; 9 ; 10#include ""SpecFuncCephes.h""; 11#include ""Math/Math.h""; 12 ; 13 ; 14#include <cmath>; 15 ; 16#include <limits>; 17 ; 18 ; 19 ; 20namespace ROOT {; 21namespace Math {; 22 ; 23namespace Cephes {; 24 ; 25 ; 26static double kBig = 4.503599627370496e15;; 27static double kBiginv = 2.22044604925031308085e-16;; 28 ; 29/* log( sqrt( 2*pi ) ) */; 30static double LS2PI = 0.91893853320467274178;; 31 ; 32 ; 33// incomplete gamma function (complement integral); 34// igamc(a,x) = 1 - igam(a,x); 35//; 36// inf.; 37// -; 38// 1 | | -t a-1; 39// = ----- | e t dt.; 40// - | |; 41// | (a) -; 42// x; 43//; 44//; 45 ; 46// In this implementation both arguments must be positive.; 47// The integral is evaluated by either a power series or; 48// continued fraction expansion, depending on the relative; 49// values of a and x.; 50 ; 51double igamc( double a, double x ); 52{; 53 ; 54 double ans, ax, c, yc, r, t, y, z;; 55 double pk, pkm1, pkm2, qk, qkm1, qkm2;; 56 ; 57 // LM: for negative values returns 0.0; 58 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 59 if (a <= 0) return 0.0;; 60 ; 61 if (x <= 0) return 1.0;; 62 ; 63 if( (x < 1.0) || (x < a) ); 64 return( 1.0 - igam(a,x) );; 65 ; 66 ax = a * std::log(x) - x - lgam(a);; 67 if( ax < -kMAXLOG ); 68 return( 0.0 );; 69 ; 70 ax = std::exp(ax);; 71 ; 72/* continued fraction */; 73 y = 1.0 - a;; 74 z = x + y + 1.0;; 75 c = 0.0;; 76 pkm2 = 1.0;; 77 qkm2 = x;; 78 pkm1 = x + 1.0;; 79 qkm1 = z * x;; 80 ans = pkm1/qkm1;; 81 ; 82 do; 83 {; 84 c += 1.0;; 85 y += 1.0;; 86 z += 2.0;; 87 yc = y * c;; 88 pk = pkm1 * z - pkm2 * yc;; 89 qk = qkm1 * z - qkm2 * yc;; 90 if(qk); 91 {; 92 r = pk/qk;; 93 t = std::abs( (ans - r)/r );; 94 ans = r;; 95 }; 96 else; 97 t = 1.0;; 98 pk",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:10783,Integrability,message,message,10783,"| |; 447 * | (a) | (b) -; 448 * 0; 449 *; 450 * The domain of definition is 0 <= x <= 1. In this; 451 * implementation a and b are restricted to positive values.; 452 * The integral from x to 1 may be obtained by the symmetry; 453 * relation; 454 *; 455 * 1 - incbet( a, b, x ) = incbet( b, a, 1-x ).; 456 *; 457 * The integral is evaluated by a continued fraction expansion; 458 * or, when b*x is small, by a power series.; 459 *; 460 * ACCURACY:; 461 *; 462 * Tested at uniformly distributed random points (a,b,x) with a and b; 463 * in ""domain"" and x between 0 and 1.; 464 * Relative error; 465 * arithmetic domain # trials peak rms; 466 * IEEE 0,5 10000 6.9e-15 4.5e-16; 467 * IEEE 0,85 250000 2.2e-13 1.7e-14; 468 * IEEE 0,1000 30000 5.3e-12 6.3e-13; 469 * IEEE 0,10000 250000 9.3e-11 7.1e-12; 470 * IEEE 0,100000 10000 8.7e-10 4.8e-11; 471 * Outputs smaller than the IEEE gradual underflow threshold; 472 * were excluded from these statistics.; 473 *; 474 * ERROR MESSAGES:; 475 * message condition value returned; 476 * incbet domain x<0, x>1 0.0; 477 * incbet underflow 0.0; 478 *; 479 * Cephes Math Library, Release 2.8: June, 2000; 480 * Copyright 1984, 1995, 2000 by Stephen L. Moshier; 481 */; 482 ; 483 ; 484double incbet( double aa, double bb, double xx ); 485{; 486 double a, b, t, x, xc, w, y;; 487 int flag;; 488 ; 489 if( aa <= 0.0 || bb <= 0.0 ); 490 return( 0.0 );; 491 ; 492 // LM: changed: for X > 1 return 1.; 493 if (xx <= 0.0) return( 0.0 );; 494 if ( xx >= 1.0) return( 1.0 );; 495 ; 496 flag = 0;; 497 ; 498/* - to test if that way is better for large b/ (comment out from Cephes version); 499 if( (bb * xx) <= 1.0 && xx <= 0.95); 500 {; 501 t = pseries(aa, bb, xx);; 502 goto done;; 503 }; 504 ; 505**/; 506 w = 1.0 - xx;; 507 ; 508/* Reverse a and b if x is greater than the mean. */; 509/* aa,bb > 1 -> sharp rise at x=aa/(aa+bb) */; 510 if( xx > (aa/(aa+bb)) ); 511 {; 512 flag = 1;; 513 a = bb;; 514 b = aa;; 515 xc = xx;; 516 x = w;; 517 }; 518 else; 519 {; 520 a = aa",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:688,Testability,log,log,688,". ROOT: math/mathcore/src/SpecFuncCephes.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. SpecFuncCephes.cxx. Go to the documentation of this file. 1//; 2//; 3// gamma and related functions from Cephes library; 4// see: http://www.netlib.org/cephes; 5//; 6// Copyright 1985, 1987, 2000 by Stephen L. Moshier; 7//; 8//; 9 ; 10#include ""SpecFuncCephes.h""; 11#include ""Math/Math.h""; 12 ; 13 ; 14#include <cmath>; 15 ; 16#include <limits>; 17 ; 18 ; 19 ; 20namespace ROOT {; 21namespace Math {; 22 ; 23namespace Cephes {; 24 ; 25 ; 26static double kBig = 4.503599627370496e15;; 27static double kBiginv = 2.22044604925031308085e-16;; 28 ; 29/* log( sqrt( 2*pi ) ) */; 30static double LS2PI = 0.91893853320467274178;; 31 ; 32 ; 33// incomplete gamma function (complement integral); 34// igamc(a,x) = 1 - igam(a,x); 35//; 36// inf.; 37// -; 38// 1 | | -t a-1; 39// = ----- | e t dt.; 40// - | |; 41// | (a) -; 42// x; 43//; 44//; 45 ; 46// In this implementation both arguments must be positive.; 47// The integral is evaluated by either a power series or; 48// continued fraction expansion, depending on the relative; 49// values of a and x.; 50 ; 51double igamc( double a, double x ); 52{; 53 ; 54 double ans, ax, c, yc, r, t, y, z;; 55 double pk, pkm1, pkm2, qk, qkm1, qkm2;; 56 ; 57 // LM: for negative values returns 0.0; 58 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 59 if (a <= 0) return 0.0;; 60 ; 61 if (x <= 0) return 1.0;; 62 ; 63 if( (x < 1.0) || (x < a) ); 64 return( 1.0 - igam(a,x) );; 65 ; 66 ax = a * std::log(x) - x - lgam(a);; 67 if( ax < -kMAXLOG ); 68 return( 0.0 );; 69 ; 70 ax = std::exp(ax);; 71 ; 72/* continued fraction */; 73 y = 1.0 - a;; 74 z = x + y + 1.0;; 75 c = 0.0;; 76 pkm2 = 1.0;; 77 qkm2 = x;; 78 pkm1 = x + 1.0;; 79 qkm1 = z * x;; 80 ans = pkm1/qkm1;; 81 ; 82 do; 83 {; 84 c += 1.0;; 85 y += 1.0;; 86 z += 2.0;; 87 yc = y * c;; 88 pk = pkm1 * z - pkm2 * yc;; 89 qk = qkm1 * z - qkm2 * yc;; 9",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:1595,Testability,log,log,1595,"599627370496e15;; 27static double kBiginv = 2.22044604925031308085e-16;; 28 ; 29/* log( sqrt( 2*pi ) ) */; 30static double LS2PI = 0.91893853320467274178;; 31 ; 32 ; 33// incomplete gamma function (complement integral); 34// igamc(a,x) = 1 - igam(a,x); 35//; 36// inf.; 37// -; 38// 1 | | -t a-1; 39// = ----- | e t dt.; 40// - | |; 41// | (a) -; 42// x; 43//; 44//; 45 ; 46// In this implementation both arguments must be positive.; 47// The integral is evaluated by either a power series or; 48// continued fraction expansion, depending on the relative; 49// values of a and x.; 50 ; 51double igamc( double a, double x ); 52{; 53 ; 54 double ans, ax, c, yc, r, t, y, z;; 55 double pk, pkm1, pkm2, qk, qkm1, qkm2;; 56 ; 57 // LM: for negative values returns 0.0; 58 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 59 if (a <= 0) return 0.0;; 60 ; 61 if (x <= 0) return 1.0;; 62 ; 63 if( (x < 1.0) || (x < a) ); 64 return( 1.0 - igam(a,x) );; 65 ; 66 ax = a * std::log(x) - x - lgam(a);; 67 if( ax < -kMAXLOG ); 68 return( 0.0 );; 69 ; 70 ax = std::exp(ax);; 71 ; 72/* continued fraction */; 73 y = 1.0 - a;; 74 z = x + y + 1.0;; 75 c = 0.0;; 76 pkm2 = 1.0;; 77 qkm2 = x;; 78 pkm1 = x + 1.0;; 79 qkm1 = z * x;; 80 ans = pkm1/qkm1;; 81 ; 82 do; 83 {; 84 c += 1.0;; 85 y += 1.0;; 86 z += 2.0;; 87 yc = y * c;; 88 pk = pkm1 * z - pkm2 * yc;; 89 qk = qkm1 * z - qkm2 * yc;; 90 if(qk); 91 {; 92 r = pk/qk;; 93 t = std::abs( (ans - r)/r );; 94 ans = r;; 95 }; 96 else; 97 t = 1.0;; 98 pkm2 = pkm1;; 99 pkm1 = pk;; 100 qkm2 = qkm1;; 101 qkm1 = qk;; 102 if( std::abs(pk) > kBig ); 103 {; 104 pkm2 *= kBiginv;; 105 pkm1 *= kBiginv;; 106 qkm2 *= kBiginv;; 107 qkm1 *= kBiginv;; 108 }; 109 }; 110 while( t > kMACHEP );; 111 ; 112 return( ans * ax );; 113}; 114 ; 115 ; 116 ; 117/* left tail of incomplete gamma function:; 118 *; 119 * inf. k; 120 * a -x - x; 121 * x e > ----------; 122 * - -; 123 * k=0 | (a+k+1); 124 *; 125 */; 126 ; 127double igam( double a, double x ); 128{; 129 do",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:2973,Testability,log,log,2973,"2 * yc;; 89 qk = qkm1 * z - qkm2 * yc;; 90 if(qk); 91 {; 92 r = pk/qk;; 93 t = std::abs( (ans - r)/r );; 94 ans = r;; 95 }; 96 else; 97 t = 1.0;; 98 pkm2 = pkm1;; 99 pkm1 = pk;; 100 qkm2 = qkm1;; 101 qkm1 = qk;; 102 if( std::abs(pk) > kBig ); 103 {; 104 pkm2 *= kBiginv;; 105 pkm1 *= kBiginv;; 106 qkm2 *= kBiginv;; 107 qkm1 *= kBiginv;; 108 }; 109 }; 110 while( t > kMACHEP );; 111 ; 112 return( ans * ax );; 113}; 114 ; 115 ; 116 ; 117/* left tail of incomplete gamma function:; 118 *; 119 * inf. k; 120 * a -x - x; 121 * x e > ----------; 122 * - -; 123 * k=0 | (a+k+1); 124 *; 125 */; 126 ; 127double igam( double a, double x ); 128{; 129 double ans, ax, c, r;; 130 ; 131 // LM: for negative values returns 1.0 instead of zero; 132 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 133 if (a <= 0) return 1.0;; 134 ; 135 if (x <= 0) return 0.0;; 136 ; 137 if( (x > 1.0) && (x > a ) ); 138 return( 1.0 - igamc(a,x) );; 139 ; 140/* Compute x**a * exp(-x) / gamma(a) */; 141 ax = a * std::log(x) - x - lgam(a);; 142 if( ax < -kMAXLOG ); 143 return( 0.0 );; 144 ; 145 ax = std::exp(ax);; 146 ; 147/* power series */; 148 r = a;; 149 c = 1.0;; 150 ans = 1.0;; 151 ; 152 do; 153 {; 154 r += 1.0;; 155 c *= x/r;; 156 ans += c;; 157 }; 158 while( c/ans > kMACHEP );; 159 ; 160 return( ans * ax/a );; 161}; 162 ; 163/*---------------------------------------------------------------------------*/; 164 ; 165/* Logarithm of gamma function */; 166/* A[]: Stirling's formula expansion of log gamma; 167 * B[], C[]: log gamma function between 2 and 3; 168 */; 169 ; 170static double A[] = {; 171 8.11614167470508450300E-4,; 172 -5.95061904284301438324E-4,; 173 7.93650340457716943945E-4,; 174 -2.77777777730099687205E-3,; 175 8.33333333333331927722E-2; 176};; 177 ; 178static double B[] = {; 179 -1.37825152569120859100E3,; 180 -3.88016315134637840924E4,; 181 -3.31612992738871184744E5,; 182 -1.16237097492762307383E6,; 183 -1.72173700820839662146E6,; 184 -8.53555664245765465627E5; 185};",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:3462,Testability,log,log,3462,"3}; 114 ; 115 ; 116 ; 117/* left tail of incomplete gamma function:; 118 *; 119 * inf. k; 120 * a -x - x; 121 * x e > ----------; 122 * - -; 123 * k=0 | (a+k+1); 124 *; 125 */; 126 ; 127double igam( double a, double x ); 128{; 129 double ans, ax, c, r;; 130 ; 131 // LM: for negative values returns 1.0 instead of zero; 132 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 133 if (a <= 0) return 1.0;; 134 ; 135 if (x <= 0) return 0.0;; 136 ; 137 if( (x > 1.0) && (x > a ) ); 138 return( 1.0 - igamc(a,x) );; 139 ; 140/* Compute x**a * exp(-x) / gamma(a) */; 141 ax = a * std::log(x) - x - lgam(a);; 142 if( ax < -kMAXLOG ); 143 return( 0.0 );; 144 ; 145 ax = std::exp(ax);; 146 ; 147/* power series */; 148 r = a;; 149 c = 1.0;; 150 ans = 1.0;; 151 ; 152 do; 153 {; 154 r += 1.0;; 155 c *= x/r;; 156 ans += c;; 157 }; 158 while( c/ans > kMACHEP );; 159 ; 160 return( ans * ax/a );; 161}; 162 ; 163/*---------------------------------------------------------------------------*/; 164 ; 165/* Logarithm of gamma function */; 166/* A[]: Stirling's formula expansion of log gamma; 167 * B[], C[]: log gamma function between 2 and 3; 168 */; 169 ; 170static double A[] = {; 171 8.11614167470508450300E-4,; 172 -5.95061904284301438324E-4,; 173 7.93650340457716943945E-4,; 174 -2.77777777730099687205E-3,; 175 8.33333333333331927722E-2; 176};; 177 ; 178static double B[] = {; 179 -1.37825152569120859100E3,; 180 -3.88016315134637840924E4,; 181 -3.31612992738871184744E5,; 182 -1.16237097492762307383E6,; 183 -1.72173700820839662146E6,; 184 -8.53555664245765465627E5; 185};; 186 ; 187static double C[] = {; 188/* 1.00000000000000000000E0, */; 189 -3.51815701436523470549E2,; 190 -1.70642106651881159223E4,; 191 -2.20528590553854454839E5,; 192 -1.13933444367982507207E6,; 193 -2.53252307177582951285E6,; 194 -2.01889141433532773231E6; 195};; 196 ; 197double lgam( double x ); 198{; 199 double p, q, u, w, z;; 200 int i;; 201 ; 202 int sgngam = 1;; 203 ; 204 if (x >= std::numeric_limits",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:3489,Testability,log,log,3489,"3}; 114 ; 115 ; 116 ; 117/* left tail of incomplete gamma function:; 118 *; 119 * inf. k; 120 * a -x - x; 121 * x e > ----------; 122 * - -; 123 * k=0 | (a+k+1); 124 *; 125 */; 126 ; 127double igam( double a, double x ); 128{; 129 double ans, ax, c, r;; 130 ; 131 // LM: for negative values returns 1.0 instead of zero; 132 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 133 if (a <= 0) return 1.0;; 134 ; 135 if (x <= 0) return 0.0;; 136 ; 137 if( (x > 1.0) && (x > a ) ); 138 return( 1.0 - igamc(a,x) );; 139 ; 140/* Compute x**a * exp(-x) / gamma(a) */; 141 ax = a * std::log(x) - x - lgam(a);; 142 if( ax < -kMAXLOG ); 143 return( 0.0 );; 144 ; 145 ax = std::exp(ax);; 146 ; 147/* power series */; 148 r = a;; 149 c = 1.0;; 150 ans = 1.0;; 151 ; 152 do; 153 {; 154 r += 1.0;; 155 c *= x/r;; 156 ans += c;; 157 }; 158 while( c/ans > kMACHEP );; 159 ; 160 return( ans * ax/a );; 161}; 162 ; 163/*---------------------------------------------------------------------------*/; 164 ; 165/* Logarithm of gamma function */; 166/* A[]: Stirling's formula expansion of log gamma; 167 * B[], C[]: log gamma function between 2 and 3; 168 */; 169 ; 170static double A[] = {; 171 8.11614167470508450300E-4,; 172 -5.95061904284301438324E-4,; 173 7.93650340457716943945E-4,; 174 -2.77777777730099687205E-3,; 175 8.33333333333331927722E-2; 176};; 177 ; 178static double B[] = {; 179 -1.37825152569120859100E3,; 180 -3.88016315134637840924E4,; 181 -3.31612992738871184744E5,; 182 -1.16237097492762307383E6,; 183 -1.72173700820839662146E6,; 184 -8.53555664245765465627E5; 185};; 186 ; 187static double C[] = {; 188/* 1.00000000000000000000E0, */; 189 -3.51815701436523470549E2,; 190 -1.70642106651881159223E4,; 191 -2.20528590553854454839E5,; 192 -1.13933444367982507207E6,; 193 -2.53252307177582951285E6,; 194 -2.01889141433532773231E6; 195};; 196 ; 197double lgam( double x ); 198{; 199 double p, q, u, w, z;; 200 int i;; 201 ; 202 int sgngam = 1;; 203 ; 204 if (x >= std::numeric_limits",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:4927,Testability,log,log,4927,"E6,; 184 -8.53555664245765465627E5; 185};; 186 ; 187static double C[] = {; 188/* 1.00000000000000000000E0, */; 189 -3.51815701436523470549E2,; 190 -1.70642106651881159223E4,; 191 -2.20528590553854454839E5,; 192 -1.13933444367982507207E6,; 193 -2.53252307177582951285E6,; 194 -2.01889141433532773231E6; 195};; 196 ; 197double lgam( double x ); 198{; 199 double p, q, u, w, z;; 200 int i;; 201 ; 202 int sgngam = 1;; 203 ; 204 if (x >= std::numeric_limits<double>::infinity()); 205 return(std::numeric_limits<double>::infinity());; 206 ; 207 if( x < -34.0 ); 208 {; 209 q = -x;; 210 w = lgam(q);; 211 p = std::floor(q);; 212 if( p==q )//_unur_FP_same(p,q); 213 return (std::numeric_limits<double>::infinity());; 214 i = (int) p;; 215 if( (i & 1) == 0 ); 216 sgngam = -1;; 217 else; 218 sgngam = 1;; 219 z = q - p;; 220 if( z > 0.5 ); 221 {; 222 p += 1.0;; 223 z = p - q;; 224 }; 225 z = q * std::sin( ROOT::Math::Pi() * z );; 226 if( z == 0 ); 227 return (std::numeric_limits<double>::infinity());; 228/* z = log(ROOT::Math::Pi()) - log( z ) - w;*/; 229 z = std::log(ROOT::Math::Pi()) - std::log( z ) - w;; 230 return( z );; 231 }; 232 ; 233 if( x < 13.0 ); 234 {; 235 z = 1.0;; 236 p = 0.0;; 237 u = x;; 238 while( u >= 3.0 ); 239 {; 240 p -= 1.0;; 241 u = x + p;; 242 z *= u;; 243 }; 244 while( u < 2.0 ); 245 {; 246 if( u == 0 ); 247 return (std::numeric_limits<double>::infinity());; 248 z /= u;; 249 p += 1.0;; 250 u = x + p;; 251 }; 252 if( z < 0.0 ); 253 {; 254 sgngam = -1;; 255 z = -z;; 256 }; 257 else; 258 sgngam = 1;; 259 if( u == 2.0 ); 260 return( std::log(z) );; 261 p -= 2.0;; 262 x = x + p;; 263 p = x * Polynomialeval(x, B, 5 ) / Polynomial1eval( x, C, 6);; 264 return( std::log(z) + p );; 265 }; 266 ; 267 if( x > kMAXLGM ); 268 return( sgngam * std::numeric_limits<double>::infinity() );; 269 ; 270 q = ( x - 0.5 ) * std::log(x) - x + LS2PI;; 271 if( x > 1.0e8 ); 272 return( q );; 273 ; 274 p = 1.0/(x*x);; 275 if( x >= 1000.0 ); 276 q += (( 7.9365079365079365079365e-4 * p; 277 - 2",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:4951,Testability,log,log,4951,"E6,; 184 -8.53555664245765465627E5; 185};; 186 ; 187static double C[] = {; 188/* 1.00000000000000000000E0, */; 189 -3.51815701436523470549E2,; 190 -1.70642106651881159223E4,; 191 -2.20528590553854454839E5,; 192 -1.13933444367982507207E6,; 193 -2.53252307177582951285E6,; 194 -2.01889141433532773231E6; 195};; 196 ; 197double lgam( double x ); 198{; 199 double p, q, u, w, z;; 200 int i;; 201 ; 202 int sgngam = 1;; 203 ; 204 if (x >= std::numeric_limits<double>::infinity()); 205 return(std::numeric_limits<double>::infinity());; 206 ; 207 if( x < -34.0 ); 208 {; 209 q = -x;; 210 w = lgam(q);; 211 p = std::floor(q);; 212 if( p==q )//_unur_FP_same(p,q); 213 return (std::numeric_limits<double>::infinity());; 214 i = (int) p;; 215 if( (i & 1) == 0 ); 216 sgngam = -1;; 217 else; 218 sgngam = 1;; 219 z = q - p;; 220 if( z > 0.5 ); 221 {; 222 p += 1.0;; 223 z = p - q;; 224 }; 225 z = q * std::sin( ROOT::Math::Pi() * z );; 226 if( z == 0 ); 227 return (std::numeric_limits<double>::infinity());; 228/* z = log(ROOT::Math::Pi()) - log( z ) - w;*/; 229 z = std::log(ROOT::Math::Pi()) - std::log( z ) - w;; 230 return( z );; 231 }; 232 ; 233 if( x < 13.0 ); 234 {; 235 z = 1.0;; 236 p = 0.0;; 237 u = x;; 238 while( u >= 3.0 ); 239 {; 240 p -= 1.0;; 241 u = x + p;; 242 z *= u;; 243 }; 244 while( u < 2.0 ); 245 {; 246 if( u == 0 ); 247 return (std::numeric_limits<double>::infinity());; 248 z /= u;; 249 p += 1.0;; 250 u = x + p;; 251 }; 252 if( z < 0.0 ); 253 {; 254 sgngam = -1;; 255 z = -z;; 256 }; 257 else; 258 sgngam = 1;; 259 if( u == 2.0 ); 260 return( std::log(z) );; 261 p -= 2.0;; 262 x = x + p;; 263 p = x * Polynomialeval(x, B, 5 ) / Polynomial1eval( x, C, 6);; 264 return( std::log(z) + p );; 265 }; 266 ; 267 if( x > kMAXLGM ); 268 return( sgngam * std::numeric_limits<double>::infinity() );; 269 ; 270 q = ( x - 0.5 ) * std::log(x) - x + LS2PI;; 271 if( x > 1.0e8 ); 272 return( q );; 273 ; 274 p = 1.0/(x*x);; 275 if( x >= 1000.0 ); 276 q += (( 7.9365079365079365079365e-4 * p; 277 - 2",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:4981,Testability,log,log,4981,"E6,; 184 -8.53555664245765465627E5; 185};; 186 ; 187static double C[] = {; 188/* 1.00000000000000000000E0, */; 189 -3.51815701436523470549E2,; 190 -1.70642106651881159223E4,; 191 -2.20528590553854454839E5,; 192 -1.13933444367982507207E6,; 193 -2.53252307177582951285E6,; 194 -2.01889141433532773231E6; 195};; 196 ; 197double lgam( double x ); 198{; 199 double p, q, u, w, z;; 200 int i;; 201 ; 202 int sgngam = 1;; 203 ; 204 if (x >= std::numeric_limits<double>::infinity()); 205 return(std::numeric_limits<double>::infinity());; 206 ; 207 if( x < -34.0 ); 208 {; 209 q = -x;; 210 w = lgam(q);; 211 p = std::floor(q);; 212 if( p==q )//_unur_FP_same(p,q); 213 return (std::numeric_limits<double>::infinity());; 214 i = (int) p;; 215 if( (i & 1) == 0 ); 216 sgngam = -1;; 217 else; 218 sgngam = 1;; 219 z = q - p;; 220 if( z > 0.5 ); 221 {; 222 p += 1.0;; 223 z = p - q;; 224 }; 225 z = q * std::sin( ROOT::Math::Pi() * z );; 226 if( z == 0 ); 227 return (std::numeric_limits<double>::infinity());; 228/* z = log(ROOT::Math::Pi()) - log( z ) - w;*/; 229 z = std::log(ROOT::Math::Pi()) - std::log( z ) - w;; 230 return( z );; 231 }; 232 ; 233 if( x < 13.0 ); 234 {; 235 z = 1.0;; 236 p = 0.0;; 237 u = x;; 238 while( u >= 3.0 ); 239 {; 240 p -= 1.0;; 241 u = x + p;; 242 z *= u;; 243 }; 244 while( u < 2.0 ); 245 {; 246 if( u == 0 ); 247 return (std::numeric_limits<double>::infinity());; 248 z /= u;; 249 p += 1.0;; 250 u = x + p;; 251 }; 252 if( z < 0.0 ); 253 {; 254 sgngam = -1;; 255 z = -z;; 256 }; 257 else; 258 sgngam = 1;; 259 if( u == 2.0 ); 260 return( std::log(z) );; 261 p -= 2.0;; 262 x = x + p;; 263 p = x * Polynomialeval(x, B, 5 ) / Polynomial1eval( x, C, 6);; 264 return( std::log(z) + p );; 265 }; 266 ; 267 if( x > kMAXLGM ); 268 return( sgngam * std::numeric_limits<double>::infinity() );; 269 ; 270 q = ( x - 0.5 ) * std::log(x) - x + LS2PI;; 271 if( x > 1.0e8 ); 272 return( q );; 273 ; 274 p = 1.0/(x*x);; 275 if( x >= 1000.0 ); 276 q += (( 7.9365079365079365079365e-4 * p; 277 - 2",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:5010,Testability,log,log,5010,"E6,; 184 -8.53555664245765465627E5; 185};; 186 ; 187static double C[] = {; 188/* 1.00000000000000000000E0, */; 189 -3.51815701436523470549E2,; 190 -1.70642106651881159223E4,; 191 -2.20528590553854454839E5,; 192 -1.13933444367982507207E6,; 193 -2.53252307177582951285E6,; 194 -2.01889141433532773231E6; 195};; 196 ; 197double lgam( double x ); 198{; 199 double p, q, u, w, z;; 200 int i;; 201 ; 202 int sgngam = 1;; 203 ; 204 if (x >= std::numeric_limits<double>::infinity()); 205 return(std::numeric_limits<double>::infinity());; 206 ; 207 if( x < -34.0 ); 208 {; 209 q = -x;; 210 w = lgam(q);; 211 p = std::floor(q);; 212 if( p==q )//_unur_FP_same(p,q); 213 return (std::numeric_limits<double>::infinity());; 214 i = (int) p;; 215 if( (i & 1) == 0 ); 216 sgngam = -1;; 217 else; 218 sgngam = 1;; 219 z = q - p;; 220 if( z > 0.5 ); 221 {; 222 p += 1.0;; 223 z = p - q;; 224 }; 225 z = q * std::sin( ROOT::Math::Pi() * z );; 226 if( z == 0 ); 227 return (std::numeric_limits<double>::infinity());; 228/* z = log(ROOT::Math::Pi()) - log( z ) - w;*/; 229 z = std::log(ROOT::Math::Pi()) - std::log( z ) - w;; 230 return( z );; 231 }; 232 ; 233 if( x < 13.0 ); 234 {; 235 z = 1.0;; 236 p = 0.0;; 237 u = x;; 238 while( u >= 3.0 ); 239 {; 240 p -= 1.0;; 241 u = x + p;; 242 z *= u;; 243 }; 244 while( u < 2.0 ); 245 {; 246 if( u == 0 ); 247 return (std::numeric_limits<double>::infinity());; 248 z /= u;; 249 p += 1.0;; 250 u = x + p;; 251 }; 252 if( z < 0.0 ); 253 {; 254 sgngam = -1;; 255 z = -z;; 256 }; 257 else; 258 sgngam = 1;; 259 if( u == 2.0 ); 260 return( std::log(z) );; 261 p -= 2.0;; 262 x = x + p;; 263 p = x * Polynomialeval(x, B, 5 ) / Polynomial1eval( x, C, 6);; 264 return( std::log(z) + p );; 265 }; 266 ; 267 if( x > kMAXLGM ); 268 return( sgngam * std::numeric_limits<double>::infinity() );; 269 ; 270 q = ( x - 0.5 ) * std::log(x) - x + LS2PI;; 271 if( x > 1.0e8 ); 272 return( q );; 273 ; 274 p = 1.0/(x*x);; 275 if( x >= 1000.0 ); 276 q += (( 7.9365079365079365079365e-4 * p; 277 - 2",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:5485,Testability,log,log,5485,"09 q = -x;; 210 w = lgam(q);; 211 p = std::floor(q);; 212 if( p==q )//_unur_FP_same(p,q); 213 return (std::numeric_limits<double>::infinity());; 214 i = (int) p;; 215 if( (i & 1) == 0 ); 216 sgngam = -1;; 217 else; 218 sgngam = 1;; 219 z = q - p;; 220 if( z > 0.5 ); 221 {; 222 p += 1.0;; 223 z = p - q;; 224 }; 225 z = q * std::sin( ROOT::Math::Pi() * z );; 226 if( z == 0 ); 227 return (std::numeric_limits<double>::infinity());; 228/* z = log(ROOT::Math::Pi()) - log( z ) - w;*/; 229 z = std::log(ROOT::Math::Pi()) - std::log( z ) - w;; 230 return( z );; 231 }; 232 ; 233 if( x < 13.0 ); 234 {; 235 z = 1.0;; 236 p = 0.0;; 237 u = x;; 238 while( u >= 3.0 ); 239 {; 240 p -= 1.0;; 241 u = x + p;; 242 z *= u;; 243 }; 244 while( u < 2.0 ); 245 {; 246 if( u == 0 ); 247 return (std::numeric_limits<double>::infinity());; 248 z /= u;; 249 p += 1.0;; 250 u = x + p;; 251 }; 252 if( z < 0.0 ); 253 {; 254 sgngam = -1;; 255 z = -z;; 256 }; 257 else; 258 sgngam = 1;; 259 if( u == 2.0 ); 260 return( std::log(z) );; 261 p -= 2.0;; 262 x = x + p;; 263 p = x * Polynomialeval(x, B, 5 ) / Polynomial1eval( x, C, 6);; 264 return( std::log(z) + p );; 265 }; 266 ; 267 if( x > kMAXLGM ); 268 return( sgngam * std::numeric_limits<double>::infinity() );; 269 ; 270 q = ( x - 0.5 ) * std::log(x) - x + LS2PI;; 271 if( x > 1.0e8 ); 272 return( q );; 273 ; 274 p = 1.0/(x*x);; 275 if( x >= 1000.0 ); 276 q += (( 7.9365079365079365079365e-4 * p; 277 - 2.7777777777777777777778e-3) *p; 278 + 0.0833333333333333333333) / x;; 279 else; 280 q += Polynomialeval( p, A, 4 ) / x;; 281 return( q );; 282}; 283 ; 284/*---------------------------------------------------------------------------*/; 285static double P[] = {; 286 1.60119522476751861407E-4,; 287 1.19135147006586384913E-3,; 288 1.04213797561761569935E-2,; 289 4.76367800457137231464E-2,; 290 2.07448227648435975150E-1,; 291 4.94214826801497100753E-1,; 292 9.99999999999999996796E-1; 293};; 294static double Q[] = {; 295 -2.31581873324120129819E-5,; 296 5.39605580",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:5611,Testability,log,log,5611,"; 214 i = (int) p;; 215 if( (i & 1) == 0 ); 216 sgngam = -1;; 217 else; 218 sgngam = 1;; 219 z = q - p;; 220 if( z > 0.5 ); 221 {; 222 p += 1.0;; 223 z = p - q;; 224 }; 225 z = q * std::sin( ROOT::Math::Pi() * z );; 226 if( z == 0 ); 227 return (std::numeric_limits<double>::infinity());; 228/* z = log(ROOT::Math::Pi()) - log( z ) - w;*/; 229 z = std::log(ROOT::Math::Pi()) - std::log( z ) - w;; 230 return( z );; 231 }; 232 ; 233 if( x < 13.0 ); 234 {; 235 z = 1.0;; 236 p = 0.0;; 237 u = x;; 238 while( u >= 3.0 ); 239 {; 240 p -= 1.0;; 241 u = x + p;; 242 z *= u;; 243 }; 244 while( u < 2.0 ); 245 {; 246 if( u == 0 ); 247 return (std::numeric_limits<double>::infinity());; 248 z /= u;; 249 p += 1.0;; 250 u = x + p;; 251 }; 252 if( z < 0.0 ); 253 {; 254 sgngam = -1;; 255 z = -z;; 256 }; 257 else; 258 sgngam = 1;; 259 if( u == 2.0 ); 260 return( std::log(z) );; 261 p -= 2.0;; 262 x = x + p;; 263 p = x * Polynomialeval(x, B, 5 ) / Polynomial1eval( x, C, 6);; 264 return( std::log(z) + p );; 265 }; 266 ; 267 if( x > kMAXLGM ); 268 return( sgngam * std::numeric_limits<double>::infinity() );; 269 ; 270 q = ( x - 0.5 ) * std::log(x) - x + LS2PI;; 271 if( x > 1.0e8 ); 272 return( q );; 273 ; 274 p = 1.0/(x*x);; 275 if( x >= 1000.0 ); 276 q += (( 7.9365079365079365079365e-4 * p; 277 - 2.7777777777777777777778e-3) *p; 278 + 0.0833333333333333333333) / x;; 279 else; 280 q += Polynomialeval( p, A, 4 ) / x;; 281 return( q );; 282}; 283 ; 284/*---------------------------------------------------------------------------*/; 285static double P[] = {; 286 1.60119522476751861407E-4,; 287 1.19135147006586384913E-3,; 288 1.04213797561761569935E-2,; 289 4.76367800457137231464E-2,; 290 2.07448227648435975150E-1,; 291 4.94214826801497100753E-1,; 292 9.99999999999999996796E-1; 293};; 294static double Q[] = {; 295 -2.31581873324120129819E-5,; 296 5.39605580493303397842E-4,; 297 -4.45641913851797240494E-3,; 298 1.18139785222060435552E-2,; 299 3.58236398605498653373E-2,; 300 -2.34591795718243348568E",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:5760,Testability,log,log,5760,"; 223 z = p - q;; 224 }; 225 z = q * std::sin( ROOT::Math::Pi() * z );; 226 if( z == 0 ); 227 return (std::numeric_limits<double>::infinity());; 228/* z = log(ROOT::Math::Pi()) - log( z ) - w;*/; 229 z = std::log(ROOT::Math::Pi()) - std::log( z ) - w;; 230 return( z );; 231 }; 232 ; 233 if( x < 13.0 ); 234 {; 235 z = 1.0;; 236 p = 0.0;; 237 u = x;; 238 while( u >= 3.0 ); 239 {; 240 p -= 1.0;; 241 u = x + p;; 242 z *= u;; 243 }; 244 while( u < 2.0 ); 245 {; 246 if( u == 0 ); 247 return (std::numeric_limits<double>::infinity());; 248 z /= u;; 249 p += 1.0;; 250 u = x + p;; 251 }; 252 if( z < 0.0 ); 253 {; 254 sgngam = -1;; 255 z = -z;; 256 }; 257 else; 258 sgngam = 1;; 259 if( u == 2.0 ); 260 return( std::log(z) );; 261 p -= 2.0;; 262 x = x + p;; 263 p = x * Polynomialeval(x, B, 5 ) / Polynomial1eval( x, C, 6);; 264 return( std::log(z) + p );; 265 }; 266 ; 267 if( x > kMAXLGM ); 268 return( sgngam * std::numeric_limits<double>::infinity() );; 269 ; 270 q = ( x - 0.5 ) * std::log(x) - x + LS2PI;; 271 if( x > 1.0e8 ); 272 return( q );; 273 ; 274 p = 1.0/(x*x);; 275 if( x >= 1000.0 ); 276 q += (( 7.9365079365079365079365e-4 * p; 277 - 2.7777777777777777777778e-3) *p; 278 + 0.0833333333333333333333) / x;; 279 else; 280 q += Polynomialeval( p, A, 4 ) / x;; 281 return( q );; 282}; 283 ; 284/*---------------------------------------------------------------------------*/; 285static double P[] = {; 286 1.60119522476751861407E-4,; 287 1.19135147006586384913E-3,; 288 1.04213797561761569935E-2,; 289 4.76367800457137231464E-2,; 290 2.07448227648435975150E-1,; 291 4.94214826801497100753E-1,; 292 9.99999999999999996796E-1; 293};; 294static double Q[] = {; 295 -2.31581873324120129819E-5,; 296 5.39605580493303397842E-4,; 297 -4.45641913851797240494E-3,; 298 1.18139785222060435552E-2,; 299 3.58236398605498653373E-2,; 300 -2.34591795718243348568E-1,; 301 7.14304917030273074085E-2,; 302 1.00000000000000000320E0; 303};; 304 ; 305/* Stirling's formula for the gamma function */; 306static do",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:7267,Testability,log,log,7267,"5E-2,; 289 4.76367800457137231464E-2,; 290 2.07448227648435975150E-1,; 291 4.94214826801497100753E-1,; 292 9.99999999999999996796E-1; 293};; 294static double Q[] = {; 295 -2.31581873324120129819E-5,; 296 5.39605580493303397842E-4,; 297 -4.45641913851797240494E-3,; 298 1.18139785222060435552E-2,; 299 3.58236398605498653373E-2,; 300 -2.34591795718243348568E-1,; 301 7.14304917030273074085E-2,; 302 1.00000000000000000320E0; 303};; 304 ; 305/* Stirling's formula for the gamma function */; 306static double STIR[5] = {; 307 7.87311395793093628397E-4,; 308 -2.29549961613378126380E-4,; 309 -2.68132617805781232825E-3,; 310 3.47222221605458667310E-3,; 311 8.33333333333482257126E-2,; 312};; 313 ; 314#define SQTPI std::sqrt(2*ROOT::Math::Pi()) /* sqrt(2*pi) */; 315/* Stirling formula for the gamma function */; 316static double stirf( double x); 317{; 318 double y, w, v;; 319 ; 320 w = 1.0/x;; 321 w = 1.0 + w * Polynomialeval( w, STIR, 4 );; 322 y = exp(x);; 323 ; 324/* #define kMAXSTIR kMAXLOG/log(kMAXLOG) */; 325 ; 326 if( x > kMAXSTIR ); 327 { /* Avoid overflow in pow() */; 328 v = pow( x, 0.5 * x - 0.25 );; 329 y = v * (v / y);; 330 }; 331 else; 332 {; 333 y = pow( x, x - 0.5 ) / y;; 334 }; 335 y = SQTPI * y * w;; 336 return( y );; 337}; 338 ; 339double gamma( double x ); 340{; 341 double p, q, z;; 342 int i;; 343 ; 344 int sgngam = 1;; 345 ; 346 if (x >=std::numeric_limits<double>::infinity()); 347 return(x);; 348 ; 349 q = std::abs(x);; 350 ; 351 if( q > 33.0 ); 352 {; 353 if( x < 0.0 ); 354 {; 355 p = std::floor(q);; 356 if( p == q ); 357 {; 358 return( sgngam * std::numeric_limits<double>::infinity());; 359 }; 360 i = (int) p;; 361 if( (i & 1) == 0 ); 362 sgngam = -1;; 363 z = q - p;; 364 if( z > 0.5 ); 365 {; 366 p += 1.0;; 367 z = q - p;; 368 }; 369 z = q * std::sin( ROOT::Math::Pi() * z );; 370 if( z == 0 ); 371 {; 372 return( sgngam * std::numeric_limits<double>::infinity());; 373 }; 374 z = std::abs(z);; 375 z = ROOT::Math::Pi()/(z * stirf(q) );; 376 }; 377 else; 378 ",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:9218,Testability,log,log,9218," ); 386 {; 387 x -= 1.0;; 388 z *= x;; 389 }; 390 ; 391 while( x < 0.0 ); 392 {; 393 if( x > -1.E-9 ); 394 goto small;; 395 z /= x;; 396 x += 1.0;; 397 }; 398 ; 399 while( x < 2.0 ); 400 {; 401 if( x < 1.e-9 ); 402 goto small;; 403 z /= x;; 404 x += 1.0;; 405 }; 406 ; 407 if( x == 2.0 ); 408 return(z);; 409 ; 410 x -= 2.0;; 411 p = Polynomialeval( x, P, 6 );; 412 q = Polynomialeval( x, Q, 7 );; 413 return( z * p / q );; 414 ; 415small:; 416 if( x == 0 ); 417 return( std::numeric_limits<double>::infinity() );; 418 else; 419 return( z/((1.0 + 0.5772156649015329 * x) * x) );; 420}; 421 ; 422/*---------------------------------------------------------------------------*/; 423 ; 424//#define kMAXLGM 2.556348e305; 425 ; 426/*---------------------------------------------------------------------------*/; 427/* implementation based on cephes log gamma */; 428double beta(double z, double w); 429{; 430 return std::exp(ROOT::Math::Cephes::lgam(z) + ROOT::Math::Cephes::lgam(w)- ROOT::Math::Cephes::lgam(z+w) );; 431}; 432 ; 433 ; 434/*---------------------------------------------------------------------------*/; 435/* implementation of the incomplete beta function */; 436/**; 437 * DESCRIPTION:; 438 *; 439 * Returns incomplete beta integral of the arguments, evaluated; 440 * from zero to x. The function is defined as; 441 *; 442 * x; 443 * - -; 444 * | (a+b) | | a-1 b-1; 445 * ----------- | t (1-t) dt.; 446 * - - | |; 447 * | (a) | (b) -; 448 * 0; 449 *; 450 * The domain of definition is 0 <= x <= 1. In this; 451 * implementation a and b are restricted to positive values.; 452 * The integral from x to 1 may be obtained by the symmetry; 453 * relation; 454 *; 455 * 1 - incbet( a, b, x ) = incbet( b, a, 1-x ).; 456 *; 457 * The integral is evaluated by a continued fraction expansion; 458 * or, when b*x is small, by a power series.; 459 *; 460 * ACCURACY:; 461 *; 462 * Tested at uniformly distributed random points (a,b,x) with a and b; 463 * in ""domain"" and x between 0 and 1.; 464 * R",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:11338,Testability,test,test,11338,".; 464 * Relative error; 465 * arithmetic domain # trials peak rms; 466 * IEEE 0,5 10000 6.9e-15 4.5e-16; 467 * IEEE 0,85 250000 2.2e-13 1.7e-14; 468 * IEEE 0,1000 30000 5.3e-12 6.3e-13; 469 * IEEE 0,10000 250000 9.3e-11 7.1e-12; 470 * IEEE 0,100000 10000 8.7e-10 4.8e-11; 471 * Outputs smaller than the IEEE gradual underflow threshold; 472 * were excluded from these statistics.; 473 *; 474 * ERROR MESSAGES:; 475 * message condition value returned; 476 * incbet domain x<0, x>1 0.0; 477 * incbet underflow 0.0; 478 *; 479 * Cephes Math Library, Release 2.8: June, 2000; 480 * Copyright 1984, 1995, 2000 by Stephen L. Moshier; 481 */; 482 ; 483 ; 484double incbet( double aa, double bb, double xx ); 485{; 486 double a, b, t, x, xc, w, y;; 487 int flag;; 488 ; 489 if( aa <= 0.0 || bb <= 0.0 ); 490 return( 0.0 );; 491 ; 492 // LM: changed: for X > 1 return 1.; 493 if (xx <= 0.0) return( 0.0 );; 494 if ( xx >= 1.0) return( 1.0 );; 495 ; 496 flag = 0;; 497 ; 498/* - to test if that way is better for large b/ (comment out from Cephes version); 499 if( (bb * xx) <= 1.0 && xx <= 0.95); 500 {; 501 t = pseries(aa, bb, xx);; 502 goto done;; 503 }; 504 ; 505**/; 506 w = 1.0 - xx;; 507 ; 508/* Reverse a and b if x is greater than the mean. */; 509/* aa,bb > 1 -> sharp rise at x=aa/(aa+bb) */; 510 if( xx > (aa/(aa+bb)) ); 511 {; 512 flag = 1;; 513 a = bb;; 514 b = aa;; 515 xc = xx;; 516 x = w;; 517 }; 518 else; 519 {; 520 a = aa;; 521 b = bb;; 522 xc = w;; 523 x = xx;; 524 }; 525 ; 526 if( flag == 1 && (b * x) <= 1.0 && x <= 0.95); 527 {; 528 t = pseries(a, b, x);; 529 goto done;; 530 }; 531 ; 532/* Choose expansion for better convergence. */; 533 y = x * (a+b-2.0) - (a-1.0);; 534 if( y < 0.0 ); 535 w = incbcf( a, b, x );; 536 else; 537 w = incbd( a, b, x ) / xc;; 538 ; 539/* Multiply w by the factor; 540 a b _ _ _; 541 x (1-x) | (a+b) / ( a | (a) | (b) ) . */; 542 ; 543 y = a * std::log(x);; 544 t = b * std::log(xc);; 545 if( (a+b) < kMAXSTIR && std::abs(y) < kMAXLOG && std::abs(t) < ",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:12262,Testability,log,log,12262,"( (bb * xx) <= 1.0 && xx <= 0.95); 500 {; 501 t = pseries(aa, bb, xx);; 502 goto done;; 503 }; 504 ; 505**/; 506 w = 1.0 - xx;; 507 ; 508/* Reverse a and b if x is greater than the mean. */; 509/* aa,bb > 1 -> sharp rise at x=aa/(aa+bb) */; 510 if( xx > (aa/(aa+bb)) ); 511 {; 512 flag = 1;; 513 a = bb;; 514 b = aa;; 515 xc = xx;; 516 x = w;; 517 }; 518 else; 519 {; 520 a = aa;; 521 b = bb;; 522 xc = w;; 523 x = xx;; 524 }; 525 ; 526 if( flag == 1 && (b * x) <= 1.0 && x <= 0.95); 527 {; 528 t = pseries(a, b, x);; 529 goto done;; 530 }; 531 ; 532/* Choose expansion for better convergence. */; 533 y = x * (a+b-2.0) - (a-1.0);; 534 if( y < 0.0 ); 535 w = incbcf( a, b, x );; 536 else; 537 w = incbd( a, b, x ) / xc;; 538 ; 539/* Multiply w by the factor; 540 a b _ _ _; 541 x (1-x) | (a+b) / ( a | (a) | (b) ) . */; 542 ; 543 y = a * std::log(x);; 544 t = b * std::log(xc);; 545 if( (a+b) < kMAXSTIR && std::abs(y) < kMAXLOG && std::abs(t) < kMAXLOG ); 546 {; 547 t = pow(xc,b);; 548 t *= pow(x,a);; 549 t /= a;; 550 t *= w;; 551 t *= ROOT::Math::Cephes::gamma(a+b) / (ROOT::Math::Cephes::gamma(a) * ROOT::Math::Cephes::gamma(b));; 552 goto done;; 553 }; 554/* Resort to logarithms. */; 555 y += t + lgam(a+b) - lgam(a) - lgam(b);; 556 y += std::log(w/a);; 557 if( y < kMINLOG ); 558 t = 0.0;; 559 else; 560 t = std::exp(y);; 561 ; 562done:; 563 ; 564 if( flag == 1 ); 565 {; 566 if( t <= kMACHEP ); 567 t = 1.0 - kMACHEP;; 568 else; 569 t = 1.0 - t;; 570 }; 571 return( t );; 572}; 573/*---------------------------------------------------------------------------*/; 574 ; 575/*---------------------------------------------------------------------------*/; 576 ; 577/* Continued fraction expansion #1; 578 * for incomplete beta integral; 579 */; 580 ; 581double incbcf( double a, double b, double x ); 582{; 583 double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;; 584 double k1, k2, k3, k4, k5, k6, k7, k8;; 585 double r, t, ans, thresh;; 586 int n;; 587 ; 588 k1 = a;; 589 k2 = a + b;; 590 k3 = a;; 591 k",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:12288,Testability,log,log,12288,"( (bb * xx) <= 1.0 && xx <= 0.95); 500 {; 501 t = pseries(aa, bb, xx);; 502 goto done;; 503 }; 504 ; 505**/; 506 w = 1.0 - xx;; 507 ; 508/* Reverse a and b if x is greater than the mean. */; 509/* aa,bb > 1 -> sharp rise at x=aa/(aa+bb) */; 510 if( xx > (aa/(aa+bb)) ); 511 {; 512 flag = 1;; 513 a = bb;; 514 b = aa;; 515 xc = xx;; 516 x = w;; 517 }; 518 else; 519 {; 520 a = aa;; 521 b = bb;; 522 xc = w;; 523 x = xx;; 524 }; 525 ; 526 if( flag == 1 && (b * x) <= 1.0 && x <= 0.95); 527 {; 528 t = pseries(a, b, x);; 529 goto done;; 530 }; 531 ; 532/* Choose expansion for better convergence. */; 533 y = x * (a+b-2.0) - (a-1.0);; 534 if( y < 0.0 ); 535 w = incbcf( a, b, x );; 536 else; 537 w = incbd( a, b, x ) / xc;; 538 ; 539/* Multiply w by the factor; 540 a b _ _ _; 541 x (1-x) | (a+b) / ( a | (a) | (b) ) . */; 542 ; 543 y = a * std::log(x);; 544 t = b * std::log(xc);; 545 if( (a+b) < kMAXSTIR && std::abs(y) < kMAXLOG && std::abs(t) < kMAXLOG ); 546 {; 547 t = pow(xc,b);; 548 t *= pow(x,a);; 549 t /= a;; 550 t *= w;; 551 t *= ROOT::Math::Cephes::gamma(a+b) / (ROOT::Math::Cephes::gamma(a) * ROOT::Math::Cephes::gamma(b));; 552 goto done;; 553 }; 554/* Resort to logarithms. */; 555 y += t + lgam(a+b) - lgam(a) - lgam(b);; 556 y += std::log(w/a);; 557 if( y < kMINLOG ); 558 t = 0.0;; 559 else; 560 t = std::exp(y);; 561 ; 562done:; 563 ; 564 if( flag == 1 ); 565 {; 566 if( t <= kMACHEP ); 567 t = 1.0 - kMACHEP;; 568 else; 569 t = 1.0 - t;; 570 }; 571 return( t );; 572}; 573/*---------------------------------------------------------------------------*/; 574 ; 575/*---------------------------------------------------------------------------*/; 576 ; 577/* Continued fraction expansion #1; 578 * for incomplete beta integral; 579 */; 580 ; 581double incbcf( double a, double b, double x ); 582{; 583 double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;; 584 double k1, k2, k3, k4, k5, k6, k7, k8;; 585 double r, t, ans, thresh;; 586 int n;; 587 ; 588 k1 = a;; 589 k2 = a + b;; 590 k3 = a;; 591 k",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:12594,Testability,log,logarithms,12594,"( (bb * xx) <= 1.0 && xx <= 0.95); 500 {; 501 t = pseries(aa, bb, xx);; 502 goto done;; 503 }; 504 ; 505**/; 506 w = 1.0 - xx;; 507 ; 508/* Reverse a and b if x is greater than the mean. */; 509/* aa,bb > 1 -> sharp rise at x=aa/(aa+bb) */; 510 if( xx > (aa/(aa+bb)) ); 511 {; 512 flag = 1;; 513 a = bb;; 514 b = aa;; 515 xc = xx;; 516 x = w;; 517 }; 518 else; 519 {; 520 a = aa;; 521 b = bb;; 522 xc = w;; 523 x = xx;; 524 }; 525 ; 526 if( flag == 1 && (b * x) <= 1.0 && x <= 0.95); 527 {; 528 t = pseries(a, b, x);; 529 goto done;; 530 }; 531 ; 532/* Choose expansion for better convergence. */; 533 y = x * (a+b-2.0) - (a-1.0);; 534 if( y < 0.0 ); 535 w = incbcf( a, b, x );; 536 else; 537 w = incbd( a, b, x ) / xc;; 538 ; 539/* Multiply w by the factor; 540 a b _ _ _; 541 x (1-x) | (a+b) / ( a | (a) | (b) ) . */; 542 ; 543 y = a * std::log(x);; 544 t = b * std::log(xc);; 545 if( (a+b) < kMAXSTIR && std::abs(y) < kMAXLOG && std::abs(t) < kMAXLOG ); 546 {; 547 t = pow(xc,b);; 548 t *= pow(x,a);; 549 t /= a;; 550 t *= w;; 551 t *= ROOT::Math::Cephes::gamma(a+b) / (ROOT::Math::Cephes::gamma(a) * ROOT::Math::Cephes::gamma(b));; 552 goto done;; 553 }; 554/* Resort to logarithms. */; 555 y += t + lgam(a+b) - lgam(a) - lgam(b);; 556 y += std::log(w/a);; 557 if( y < kMINLOG ); 558 t = 0.0;; 559 else; 560 t = std::exp(y);; 561 ; 562done:; 563 ; 564 if( flag == 1 ); 565 {; 566 if( t <= kMACHEP ); 567 t = 1.0 - kMACHEP;; 568 else; 569 t = 1.0 - t;; 570 }; 571 return( t );; 572}; 573/*---------------------------------------------------------------------------*/; 574 ; 575/*---------------------------------------------------------------------------*/; 576 ; 577/* Continued fraction expansion #1; 578 * for incomplete beta integral; 579 */; 580 ; 581double incbcf( double a, double b, double x ); 582{; 583 double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;; 584 double k1, k2, k3, k4, k5, k6, k7, k8;; 585 double r, t, ans, thresh;; 586 int n;; 587 ; 588 k1 = a;; 589 k2 = a + b;; 590 k3 = a;; 591 k",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:12669,Testability,log,log,12669," 510 if( xx > (aa/(aa+bb)) ); 511 {; 512 flag = 1;; 513 a = bb;; 514 b = aa;; 515 xc = xx;; 516 x = w;; 517 }; 518 else; 519 {; 520 a = aa;; 521 b = bb;; 522 xc = w;; 523 x = xx;; 524 }; 525 ; 526 if( flag == 1 && (b * x) <= 1.0 && x <= 0.95); 527 {; 528 t = pseries(a, b, x);; 529 goto done;; 530 }; 531 ; 532/* Choose expansion for better convergence. */; 533 y = x * (a+b-2.0) - (a-1.0);; 534 if( y < 0.0 ); 535 w = incbcf( a, b, x );; 536 else; 537 w = incbd( a, b, x ) / xc;; 538 ; 539/* Multiply w by the factor; 540 a b _ _ _; 541 x (1-x) | (a+b) / ( a | (a) | (b) ) . */; 542 ; 543 y = a * std::log(x);; 544 t = b * std::log(xc);; 545 if( (a+b) < kMAXSTIR && std::abs(y) < kMAXLOG && std::abs(t) < kMAXLOG ); 546 {; 547 t = pow(xc,b);; 548 t *= pow(x,a);; 549 t /= a;; 550 t *= w;; 551 t *= ROOT::Math::Cephes::gamma(a+b) / (ROOT::Math::Cephes::gamma(a) * ROOT::Math::Cephes::gamma(b));; 552 goto done;; 553 }; 554/* Resort to logarithms. */; 555 y += t + lgam(a+b) - lgam(a) - lgam(b);; 556 y += std::log(w/a);; 557 if( y < kMINLOG ); 558 t = 0.0;; 559 else; 560 t = std::exp(y);; 561 ; 562done:; 563 ; 564 if( flag == 1 ); 565 {; 566 if( t <= kMACHEP ); 567 t = 1.0 - kMACHEP;; 568 else; 569 t = 1.0 - t;; 570 }; 571 return( t );; 572}; 573/*---------------------------------------------------------------------------*/; 574 ; 575/*---------------------------------------------------------------------------*/; 576 ; 577/* Continued fraction expansion #1; 578 * for incomplete beta integral; 579 */; 580 ; 581double incbcf( double a, double b, double x ); 582{; 583 double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;; 584 double k1, k2, k3, k4, k5, k6, k7, k8;; 585 double r, t, ans, thresh;; 586 int n;; 587 ; 588 k1 = a;; 589 k2 = a + b;; 590 k3 = a;; 591 k4 = a + 1.0;; 592 k5 = 1.0;; 593 k6 = b - 1.0;; 594 k7 = k4;; 595 k8 = a + 2.0;; 596 ; 597 pkm2 = 0.0;; 598 qkm2 = 1.0;; 599 pkm1 = 1.0;; 600 qkm1 = 1.0;; 601 ans = 1.0;; 602 r = 1.0;; 603 n = 0;; 604 thresh = 3.0 * kMACHEP;; 605 do; 606 {",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:17089,Testability,log,log,17089,"m2 *= kBiginv;; 745 qkm1 *= kBiginv;; 746 }; 747 if( (std::abs(qk) < kBiginv) || (std::abs(pk) < kBiginv) ); 748 {; 749 pkm2 *= kBig;; 750 pkm1 *= kBig;; 751 qkm2 *= kBig;; 752 qkm1 *= kBig;; 753 }; 754 }; 755 while( ++n < 300 );; 756cdone:; 757 return(ans);; 758}; 759 ; 760 ; 761/*---------------------------------------------------------------------------*/; 762 ; 763/* Power series for incomplete beta integral.; 764 Use when b*x is small and x not too close to 1. */; 765 ; 766double pseries( double a, double b, double x ); 767{; 768 double s, t, u, v, n, t1, z, ai;; 769 ; 770 ai = 1.0 / a;; 771 u = (1.0 - b) * x;; 772 v = u / (a + 1.0);; 773 t1 = v;; 774 t = u;; 775 n = 2.0;; 776 s = 0.0;; 777 z = kMACHEP * ai;; 778 while( std::abs(v) > z ); 779 {; 780 u = (n - b) * x / n;; 781 t *= u;; 782 v = t / (a + n);; 783 s += v;; 784 n += 1.0;; 785 }; 786 s += t1;; 787 s += ai;; 788 ; 789 u = a * log(x);; 790 if( (a+b) < kMAXSTIR && std::abs(u) < kMAXLOG ); 791 {; 792 t = gamma(a+b)/(gamma(a)*gamma(b));; 793 s = s * t * pow(x,a);; 794 }; 795 else; 796 {; 797 t = lgam(a+b) - lgam(a) - lgam(b) + u + std::log(s);; 798 if( t < kMINLOG ); 799 s = 0.0;; 800 else; 801 s = std::exp(t);; 802 }; 803 return(s);; 804}; 805 ; 806/*---------------------------------------------------------------------------*/; 807 ; 808 ; 809/*---------------------------------------------------------------------------*/; 810/* for evaluation of error function */; 811/*---------------------------------------------------------------------------*/; 812 ; 813static double erfP[] = {; 814 2.46196981473530512524E-10,; 815 5.64189564831068821977E-1,; 816 7.46321056442269912687E0,; 817 4.86371970985681366614E1,; 818 1.96520832956077098242E2,; 819 5.26445194995477358631E2,; 820 9.34528527171957607540E2,; 821 1.02755188689515710272E3,; 822 5.57535335369399327526E2; 823};; 824static double erfQ[] = {; 825/* 1.00000000000000000000E0,*/; 826 1.32281951154744992508E1,; 827 8.67072140885989742329E1,; 828 3.5493777888781",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:17299,Testability,log,log,17299,"m2 *= kBiginv;; 745 qkm1 *= kBiginv;; 746 }; 747 if( (std::abs(qk) < kBiginv) || (std::abs(pk) < kBiginv) ); 748 {; 749 pkm2 *= kBig;; 750 pkm1 *= kBig;; 751 qkm2 *= kBig;; 752 qkm1 *= kBig;; 753 }; 754 }; 755 while( ++n < 300 );; 756cdone:; 757 return(ans);; 758}; 759 ; 760 ; 761/*---------------------------------------------------------------------------*/; 762 ; 763/* Power series for incomplete beta integral.; 764 Use when b*x is small and x not too close to 1. */; 765 ; 766double pseries( double a, double b, double x ); 767{; 768 double s, t, u, v, n, t1, z, ai;; 769 ; 770 ai = 1.0 / a;; 771 u = (1.0 - b) * x;; 772 v = u / (a + 1.0);; 773 t1 = v;; 774 t = u;; 775 n = 2.0;; 776 s = 0.0;; 777 z = kMACHEP * ai;; 778 while( std::abs(v) > z ); 779 {; 780 u = (n - b) * x / n;; 781 t *= u;; 782 v = t / (a + n);; 783 s += v;; 784 n += 1.0;; 785 }; 786 s += t1;; 787 s += ai;; 788 ; 789 u = a * log(x);; 790 if( (a+b) < kMAXSTIR && std::abs(u) < kMAXLOG ); 791 {; 792 t = gamma(a+b)/(gamma(a)*gamma(b));; 793 s = s * t * pow(x,a);; 794 }; 795 else; 796 {; 797 t = lgam(a+b) - lgam(a) - lgam(b) + u + std::log(s);; 798 if( t < kMINLOG ); 799 s = 0.0;; 800 else; 801 s = std::exp(t);; 802 }; 803 return(s);; 804}; 805 ; 806/*---------------------------------------------------------------------------*/; 807 ; 808 ; 809/*---------------------------------------------------------------------------*/; 810/* for evaluation of error function */; 811/*---------------------------------------------------------------------------*/; 812 ; 813static double erfP[] = {; 814 2.46196981473530512524E-10,; 815 5.64189564831068821977E-1,; 816 7.46321056442269912687E0,; 817 4.86371970985681366614E1,; 818 1.96520832956077098242E2,; 819 5.26445194995477358631E2,; 820 9.34528527171957607540E2,; 821 1.02755188689515710272E3,; 822 5.57535335369399327526E2; 823};; 824static double erfQ[] = {; 825/* 1.00000000000000000000E0,*/; 826 1.32281951154744992508E1,; 827 8.67072140885989742329E1,; 828 3.5493777888781",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx.html:1099,Availability,error,error,1099,"ter. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros ; SpecFuncMathCore.cxx File Reference. #include ""SpecFuncCephes.h""; #include <cmath>; #include <limits>. Include dependency graph for SpecFuncMathCore.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  . Macros; #define PI   3.14159265358979323846264338328 /* pi */;  ; #define USE_CEPHES;  . Functions; Special Functions from MathCore; double ROOT::Math::beta (double x, double y);  Calculates the beta function. ;  ; double ROOT::Math::cosint (double x);  Calculates the real part of the cosine integral Re(Ci). ;  ; double ROOT::Math::erf (double x);  Error function encountered in integrating the normal distribution. ;  ; double ROOT::Math::erfc (double x);  Complementary error function. ;  ; double ROOT::Math::inc_beta (double x, double a, double b);  Calculates the normalized (regularized) incomplete beta function. ;  ; double ROOT::Math::inc_gamma (double a, double x);  Calculates the normalized (regularized) lower incomplete gamma function (lower integral) ;  ; double ROOT::Math::inc_gamma_c (double a, double x);  Calculates the normalized (regularized) upper incomplete gamma function (upper integral) ;  ; double ROOT::Math::lgamma (double x);  Calculates the logarithm of the gamma function. ;  ; double ROOT::Math::sinint (double x);  Calculates the sine integral. ;  ; double ROOT::Math::tgamma (double x);  The gamma function is defined to be the extension of the factorial to real numbers. ;  . Macro Definition Documentation. ◆ PI. #define PI   3.14159265358979323846264338328 /* pi */. Definition at line 23 of file SpecFuncMathCore.cxx. ◆ USE_CEPHES. #define USE_CEPHES. Definition at line 27 of file SpecFuncMathCore.cxx. mathmat",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx.html:1006,Deployability,integrat,integrating,1006,". ROOT: math/mathcore/src/SpecFuncMathCore.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros ; SpecFuncMathCore.cxx File Reference. #include ""SpecFuncCephes.h""; #include <cmath>; #include <limits>. Include dependency graph for SpecFuncMathCore.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  . Macros; #define PI   3.14159265358979323846264338328 /* pi */;  ; #define USE_CEPHES;  . Functions; Special Functions from MathCore; double ROOT::Math::beta (double x, double y);  Calculates the beta function. ;  ; double ROOT::Math::cosint (double x);  Calculates the real part of the cosine integral Re(Ci). ;  ; double ROOT::Math::erf (double x);  Error function encountered in integrating the normal distribution. ;  ; double ROOT::Math::erfc (double x);  Complementary error function. ;  ; double ROOT::Math::inc_beta (double x, double a, double b);  Calculates the normalized (regularized) incomplete beta function. ;  ; double ROOT::Math::inc_gamma (double a, double x);  Calculates the normalized (regularized) lower incomplete gamma function (lower integral) ;  ; double ROOT::Math::inc_gamma_c (double a, double x);  Calculates the normalized (regularized) upper incomplete gamma function (upper integral) ;  ; double ROOT::Math::lgamma (double x);  Calculates the logarithm of the gamma function. ;  ; double ROOT::Math::sinint (double x);  Calculates the sine integral. ;  ; double ROOT::Math::tgamma (double x);  The gamma function is defined to be the extension of the factorial to real numbers. ;  . Macro Definition Documentation. ◆ PI. #define PI   3.14159265358979323846264338328 /* pi */. Definition at line 23 of file SpecFuncMathCore.cxx. ◆ USE_CEPHES. #d",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx.html:278,Integrability,depend,dependency,278,". ROOT: math/mathcore/src/SpecFuncMathCore.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros ; SpecFuncMathCore.cxx File Reference. #include ""SpecFuncCephes.h""; #include <cmath>; #include <limits>. Include dependency graph for SpecFuncMathCore.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  . Macros; #define PI   3.14159265358979323846264338328 /* pi */;  ; #define USE_CEPHES;  . Functions; Special Functions from MathCore; double ROOT::Math::beta (double x, double y);  Calculates the beta function. ;  ; double ROOT::Math::cosint (double x);  Calculates the real part of the cosine integral Re(Ci). ;  ; double ROOT::Math::erf (double x);  Error function encountered in integrating the normal distribution. ;  ; double ROOT::Math::erfc (double x);  Complementary error function. ;  ; double ROOT::Math::inc_beta (double x, double a, double b);  Calculates the normalized (regularized) incomplete beta function. ;  ; double ROOT::Math::inc_gamma (double a, double x);  Calculates the normalized (regularized) lower incomplete gamma function (lower integral) ;  ; double ROOT::Math::inc_gamma_c (double a, double x);  Calculates the normalized (regularized) upper incomplete gamma function (upper integral) ;  ; double ROOT::Math::lgamma (double x);  Calculates the logarithm of the gamma function. ;  ; double ROOT::Math::sinint (double x);  Calculates the sine integral. ;  ; double ROOT::Math::tgamma (double x);  The gamma function is defined to be the extension of the factorial to real numbers. ;  . Macro Definition Documentation. ◆ PI. #define PI   3.14159265358979323846264338328 /* pi */. Definition at line 23 of file SpecFuncMathCore.cxx. ◆ USE_CEPHES. #d",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx.html:1006,Integrability,integrat,integrating,1006,". ROOT: math/mathcore/src/SpecFuncMathCore.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros ; SpecFuncMathCore.cxx File Reference. #include ""SpecFuncCephes.h""; #include <cmath>; #include <limits>. Include dependency graph for SpecFuncMathCore.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  . Macros; #define PI   3.14159265358979323846264338328 /* pi */;  ; #define USE_CEPHES;  . Functions; Special Functions from MathCore; double ROOT::Math::beta (double x, double y);  Calculates the beta function. ;  ; double ROOT::Math::cosint (double x);  Calculates the real part of the cosine integral Re(Ci). ;  ; double ROOT::Math::erf (double x);  Error function encountered in integrating the normal distribution. ;  ; double ROOT::Math::erfc (double x);  Complementary error function. ;  ; double ROOT::Math::inc_beta (double x, double a, double b);  Calculates the normalized (regularized) incomplete beta function. ;  ; double ROOT::Math::inc_gamma (double a, double x);  Calculates the normalized (regularized) lower incomplete gamma function (lower integral) ;  ; double ROOT::Math::inc_gamma_c (double a, double x);  Calculates the normalized (regularized) upper incomplete gamma function (upper integral) ;  ; double ROOT::Math::lgamma (double x);  Calculates the logarithm of the gamma function. ;  ; double ROOT::Math::sinint (double x);  Calculates the sine integral. ;  ; double ROOT::Math::tgamma (double x);  The gamma function is defined to be the extension of the factorial to real numbers. ;  . Macro Definition Documentation. ◆ PI. #define PI   3.14159265358979323846264338328 /* pi */. Definition at line 23 of file SpecFuncMathCore.cxx. ◆ USE_CEPHES. #d",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx.html:1600,Testability,log,logarithm,1600," ""SpecFuncCephes.h""; #include <cmath>; #include <limits>. Include dependency graph for SpecFuncMathCore.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  . Macros; #define PI   3.14159265358979323846264338328 /* pi */;  ; #define USE_CEPHES;  . Functions; Special Functions from MathCore; double ROOT::Math::beta (double x, double y);  Calculates the beta function. ;  ; double ROOT::Math::cosint (double x);  Calculates the real part of the cosine integral Re(Ci). ;  ; double ROOT::Math::erf (double x);  Error function encountered in integrating the normal distribution. ;  ; double ROOT::Math::erfc (double x);  Complementary error function. ;  ; double ROOT::Math::inc_beta (double x, double a, double b);  Calculates the normalized (regularized) incomplete beta function. ;  ; double ROOT::Math::inc_gamma (double a, double x);  Calculates the normalized (regularized) lower incomplete gamma function (lower integral) ;  ; double ROOT::Math::inc_gamma_c (double a, double x);  Calculates the normalized (regularized) upper incomplete gamma function (upper integral) ;  ; double ROOT::Math::lgamma (double x);  Calculates the logarithm of the gamma function. ;  ; double ROOT::Math::sinint (double x);  Calculates the sine integral. ;  ; double ROOT::Math::tgamma (double x);  The gamma function is defined to be the extension of the factorial to real numbers. ;  . Macro Definition Documentation. ◆ PI. #define PI   3.14159265358979323846264338328 /* pi */. Definition at line 23 of file SpecFuncMathCore.cxx. ◆ USE_CEPHES. #define USE_CEPHES. Definition at line 27 of file SpecFuncMathCore.cxx. mathmathcoresrcSpecFuncMathCore.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html:1144,Availability,error,error,1144,"as Zsenei & Lorenzo Moneta 06/2005; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11#if defined(__sun) || defined(__sgi) || defined(_WIN32) || defined(_AIX); 12#define NOT_HAVE_TGAMMA; 13#endif; 14 ; 15 ; 16#include ""SpecFuncCephes.h""; 17 ; 18 ; 19#include <cmath>; 20#include <limits>; 21 ; 22#ifndef PI; 23#define PI 3.14159265358979323846264338328 /* pi */; 24#endif; 25 ; 26// use cephes for functions which are also in C99; 27#define USE_CEPHES; 28 ; 29// platforms not implemening C99; 30// #if defined(__sun) || defined(__sgi) || defined(_WIN32) || defined(_AIX); 31// #define USE_CEPHES; 32// #endif; 33 ; 34 ; 35namespace ROOT {; 36namespace Math {; 37 ; 38 ; 39 ; 40 ; 41 ; 42// (26.x.21.2) complementary error function; 43 ; 44double erfc(double x) {; 45 ; 46 ; 47#ifdef USE_CEPHES; 48 // use cephes implementation; 49 return ROOT::Math::Cephes::erfc(x);; 50#else; 51 return ::erfc(x);; 52#endif; 53 ; 54}; 55 ; 56 ; 57// (26.x.21.1) error function; 58 ; 59double erf(double x) {; 60 ; 61 ; 62#ifdef USE_CEPHES; 63 return ROOT::Math::Cephes::erf(x);; 64#else; 65 return ::erf(x);; 66#endif; 67 ; 68 ; 69}; 70 ; 71 ; 72 ; 73 ; 74double lgamma(double z) {; 75 ; 76#ifdef USE_CEPHES; 77 return ROOT::Math::Cephes::lgam(z);; 78#else; 79 return ::lgamma(z);; 80#endif; 81 ; 82}; 83 ; 84 ; 85 ; 86 ; 87// (26.x.18) gamma function; 88 ; 89double tgamma(double x) {; 90 ; 91#ifdef USE_CEPHES; 92 return ROOT::Math::Cephes::gamma(x);; 93#else; 94 return ::tgamma(x);; 95#endif; 96 ; 97}; 98 ; 99double inc_gamma( double a, double x) {; 100 return ROOT::Math::Cephes::igam(a,x);; 101}; 102 ; 103double inc_gamma_c( double a, double x) {; 104 return ROOT::Math::Cephes::igamc(a,x);; 105}; 106 ; 107 ; 108// [5.2.1.3] beta function; 109// (26.x.19); 110 ; 111double beta(double x, double y) {; 112 return std::exp(lgamm",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html:1374,Availability,error,error,1374,"ned(_WIN32) || defined(_AIX); 12#define NOT_HAVE_TGAMMA; 13#endif; 14 ; 15 ; 16#include ""SpecFuncCephes.h""; 17 ; 18 ; 19#include <cmath>; 20#include <limits>; 21 ; 22#ifndef PI; 23#define PI 3.14159265358979323846264338328 /* pi */; 24#endif; 25 ; 26// use cephes for functions which are also in C99; 27#define USE_CEPHES; 28 ; 29// platforms not implemening C99; 30// #if defined(__sun) || defined(__sgi) || defined(_WIN32) || defined(_AIX); 31// #define USE_CEPHES; 32// #endif; 33 ; 34 ; 35namespace ROOT {; 36namespace Math {; 37 ; 38 ; 39 ; 40 ; 41 ; 42// (26.x.21.2) complementary error function; 43 ; 44double erfc(double x) {; 45 ; 46 ; 47#ifdef USE_CEPHES; 48 // use cephes implementation; 49 return ROOT::Math::Cephes::erfc(x);; 50#else; 51 return ::erfc(x);; 52#endif; 53 ; 54}; 55 ; 56 ; 57// (26.x.21.1) error function; 58 ; 59double erf(double x) {; 60 ; 61 ; 62#ifdef USE_CEPHES; 63 return ROOT::Math::Cephes::erf(x);; 64#else; 65 return ::erf(x);; 66#endif; 67 ; 68 ; 69}; 70 ; 71 ; 72 ; 73 ; 74double lgamma(double z) {; 75 ; 76#ifdef USE_CEPHES; 77 return ROOT::Math::Cephes::lgam(z);; 78#else; 79 return ::lgamma(z);; 80#endif; 81 ; 82}; 83 ; 84 ; 85 ; 86 ; 87// (26.x.18) gamma function; 88 ; 89double tgamma(double x) {; 90 ; 91#ifdef USE_CEPHES; 92 return ROOT::Math::Cephes::gamma(x);; 93#else; 94 return ::tgamma(x);; 95#endif; 96 ; 97}; 98 ; 99double inc_gamma( double a, double x) {; 100 return ROOT::Math::Cephes::igam(a,x);; 101}; 102 ; 103double inc_gamma_c( double a, double x) {; 104 return ROOT::Math::Cephes::igamc(a,x);; 105}; 106 ; 107 ; 108// [5.2.1.3] beta function; 109// (26.x.19); 110 ; 111double beta(double x, double y) {; 112 return std::exp(lgamma(x)+lgamma(y)-lgamma(x+y));; 113}; 114 ; 115double inc_beta( double x, double a, double b) {; 116 return ROOT::Math::Cephes::incbet(a,b,x);; 117}; 118 ; 119// Sine integral; 120// Translated from CERNLIB SININT (C336) by B. List 29.4.2010; 121 ; 122double sinint(double x) {; 123 ; 124 static const double z1 ",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html:9423,Availability,error,error,9423,"tion RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; SpecFuncCephes.h; PI#define PIDefinition SpecFuncMathCore.cxx:23; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; qfloat * qDefinition THbookFile.cxx:89; ROOT::Math::inc_gamma_cdouble inc_gamma_c(double a, double x)Calculates the normalized (regularized) upper incomplete gamma function (upper integral)Definition SpecFuncMathCore.cxx:103; ROOT::Math::betadouble beta(double x, double y)Calculates the beta function.Definition SpecFuncMathCore.cxx:111; ROOT::Math::inc_betadouble inc_beta(double x, double a, double b)Calculates the normalized (regularized) incomplete beta function.Definition SpecFuncMathCore.cxx:115; ROOT::Math::erfcdouble erfc(double x)Complementary error function.Definition SpecFuncMathCore.cxx:44; ROOT::Math::sinintdouble sinint(double x)Calculates the sine integral.Definition SpecFuncMathCore.cxx:122; ROOT::Math::tgammadouble tgamma(double x)The gamma function is defined to be the extension of the factorial to real numbers.Definition SpecFuncMathCore.cxx:89; ROOT::Math::lgammadouble lgamma(double x)Calculates the logarithm of the gamma function.Definition SpecFuncMathCore.cxx:74; ROOT::Math::cosintdouble cosint(double x)Calculates the real part of the cosine integral Re(Ci).Definition SpecFuncMathCore.cxx:212; ROOT::Math::inc_gammadouble inc_gamma(double a, double x)Calculates the normalized (regularized) lower incomplete gamma function (lower integral)Definition SpecFuncMathCore.cxx:99; ROOT::Math::erfdouble erf(double x)Error function encountered in integrating the normal distribution.Definition SpecFuncMathCore.cxx:59; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; MathNam",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html:10244,Deployability,integrat,integrating,10244,"double inc_beta(double x, double a, double b)Calculates the normalized (regularized) incomplete beta function.Definition SpecFuncMathCore.cxx:115; ROOT::Math::erfcdouble erfc(double x)Complementary error function.Definition SpecFuncMathCore.cxx:44; ROOT::Math::sinintdouble sinint(double x)Calculates the sine integral.Definition SpecFuncMathCore.cxx:122; ROOT::Math::tgammadouble tgamma(double x)The gamma function is defined to be the extension of the factorial to real numbers.Definition SpecFuncMathCore.cxx:89; ROOT::Math::lgammadouble lgamma(double x)Calculates the logarithm of the gamma function.Definition SpecFuncMathCore.cxx:74; ROOT::Math::cosintdouble cosint(double x)Calculates the real part of the cosine integral Re(Ci).Definition SpecFuncMathCore.cxx:212; ROOT::Math::inc_gammadouble inc_gamma(double a, double x)Calculates the normalized (regularized) lower incomplete gamma function (lower integral)Definition SpecFuncMathCore.cxx:99; ROOT::Math::erfdouble erf(double x)Error function encountered in integrating the normal distribution.Definition SpecFuncMathCore.cxx:59; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::Cephes::erfcdouble erfc(double a)Definition SpecFuncCephes.cxx:874; ROOT::Math::Cephes::erfdouble erf(double x)Definition SpecFuncCephes.cxx:926; ROOT::Math::Cephes::incbetdouble incbet(double aa, double bb, double xx)DESCRIPTION:Definition SpecFuncCephes.cxx:484; ROOT::Math::Cephes::igamdouble igam(double a, double x)Definition SpecFuncCephes.cxx:127; ROOT::Math::Cephes::lgamdouble lgam(double x)Definition SpecFuncCephes.cxx:197; ROOT::Math::Cephes::igamcdouble igamc(double a, double x)incomplete complementary gamma function igamc(a, x) = 1 - igam(a, x)Definition SpecFuncCephes.cxx:51; ROOT::Math::Cephes::gammadouble gamma(double x)Definition SpecFuncCephes.cxx:339; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forwar",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html:10244,Integrability,integrat,integrating,10244,"double inc_beta(double x, double a, double b)Calculates the normalized (regularized) incomplete beta function.Definition SpecFuncMathCore.cxx:115; ROOT::Math::erfcdouble erfc(double x)Complementary error function.Definition SpecFuncMathCore.cxx:44; ROOT::Math::sinintdouble sinint(double x)Calculates the sine integral.Definition SpecFuncMathCore.cxx:122; ROOT::Math::tgammadouble tgamma(double x)The gamma function is defined to be the extension of the factorial to real numbers.Definition SpecFuncMathCore.cxx:89; ROOT::Math::lgammadouble lgamma(double x)Calculates the logarithm of the gamma function.Definition SpecFuncMathCore.cxx:74; ROOT::Math::cosintdouble cosint(double x)Calculates the real part of the cosine integral Re(Ci).Definition SpecFuncMathCore.cxx:212; ROOT::Math::inc_gammadouble inc_gamma(double a, double x)Calculates the normalized (regularized) lower incomplete gamma function (lower integral)Definition SpecFuncMathCore.cxx:99; ROOT::Math::erfdouble erf(double x)Error function encountered in integrating the normal distribution.Definition SpecFuncMathCore.cxx:59; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::Cephes::erfcdouble erfc(double a)Definition SpecFuncCephes.cxx:874; ROOT::Math::Cephes::erfdouble erf(double x)Definition SpecFuncCephes.cxx:926; ROOT::Math::Cephes::incbetdouble incbet(double aa, double bb, double xx)DESCRIPTION:Definition SpecFuncCephes.cxx:484; ROOT::Math::Cephes::igamdouble igam(double a, double x)Definition SpecFuncCephes.cxx:127; ROOT::Math::Cephes::lgamdouble lgam(double x)Definition SpecFuncCephes.cxx:197; ROOT::Math::Cephes::igamcdouble igamc(double a, double x)incomplete complementary gamma function igamc(a, x) = 1 - igam(a, x)Definition SpecFuncCephes.cxx:51; ROOT::Math::Cephes::gammadouble gamma(double x)Definition SpecFuncCephes.cxx:339; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forwar",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html:7700,Testability,log,log,7700,"; 248 +0.00000313199197601, -0.00000042110196496,; 249 +0.00000006907244830, -0.00000001318321290,; 250 +0.00000000283697433, -0.00000000067329234,; 251 +0.00000000017339687, -0.00000000004786939,; 252 +0.00000000001403235, -0.00000000000433496,; 253 +0.00000000000140273, -0.00000000000047306,; 254 +0.00000000000016558, -0.00000000000005994,; 255 +0.00000000000002237, -0.00000000000000859,; 256 +0.00000000000000338, -0.00000000000000136,; 257 +0.00000000000000056, -0.00000000000000024,; 258 +0.00000000000000010};; 259 ; 260 double h = 0;; 261 if(x == 0) {; 262 h = - std::numeric_limits<double>::infinity();; 263 } else if (std::abs(x) <= 8) {; 264 h = r32*x*x-1;; 265 double alfa = h+h;; 266 double b0 = 0;; 267 double b1 = 0;; 268 double b2 = 0;; 269 for (int i = 15; i >= 0; --i) {; 270 b0 = c[i]+alfa*b1-b2;; 271 b2 = b1;; 272 b1 = b0;; 273 }; 274 h = ce+std::log(std::abs(x))-b0+h*b2;; 275 } else {; 276 double r = 1/x;; 277 h = 128*r*r-1;; 278 double alfa = h+h;; 279 double b0 = 0;; 280 double b1 = 0;; 281 double b2 = 0;; 282 for (int i = 28; i >= 0; --i) {; 283 b0 = p[i]+alfa*b1-b2;; 284 b2 = b1;; 285 b1 = b0;; 286 }; 287 double pp = b0-h*b2;; 288 b1 = 0;; 289 b2 = 0;; 290 for (int i = 24; i >= 0; --i) {; 291 b0 = q[i]+alfa*b1-b2;; 292 b2 = b1;; 293 b1 = b0;; 294 }; 295 h = r*((b0-h*b2)*std::sin(x)-r*pp*std::cos(x));; 296 }; 297 return h;; 298}; 299 ; 300 ; 301 ; 302 ; 303} // namespace Math; 304} // namespace ROOT; 305 ; 306 ; 307 ; 308 ; 309 ; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; SpecFuncCephes.h; PI#define PIDefinition SpecFuncMathCore.cxx:23; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefin",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html
https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html:9797,Testability,log,logarithm,9797,"t_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; qfloat * qDefinition THbookFile.cxx:89; ROOT::Math::inc_gamma_cdouble inc_gamma_c(double a, double x)Calculates the normalized (regularized) upper incomplete gamma function (upper integral)Definition SpecFuncMathCore.cxx:103; ROOT::Math::betadouble beta(double x, double y)Calculates the beta function.Definition SpecFuncMathCore.cxx:111; ROOT::Math::inc_betadouble inc_beta(double x, double a, double b)Calculates the normalized (regularized) incomplete beta function.Definition SpecFuncMathCore.cxx:115; ROOT::Math::erfcdouble erfc(double x)Complementary error function.Definition SpecFuncMathCore.cxx:44; ROOT::Math::sinintdouble sinint(double x)Calculates the sine integral.Definition SpecFuncMathCore.cxx:122; ROOT::Math::tgammadouble tgamma(double x)The gamma function is defined to be the extension of the factorial to real numbers.Definition SpecFuncMathCore.cxx:89; ROOT::Math::lgammadouble lgamma(double x)Calculates the logarithm of the gamma function.Definition SpecFuncMathCore.cxx:74; ROOT::Math::cosintdouble cosint(double x)Calculates the real part of the cosine integral Re(Ci).Definition SpecFuncMathCore.cxx:212; ROOT::Math::inc_gammadouble inc_gamma(double a, double x)Calculates the normalized (regularized) lower incomplete gamma function (lower integral)Definition SpecFuncMathCore.cxx:99; ROOT::Math::erfdouble erf(double x)Error function encountered in integrating the normal distribution.Definition SpecFuncMathCore.cxx:59; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::Cephes::erfcdouble erfc(double a)Definition SpecFuncCephes.cxx:874; ROOT::Math::Cephes::erfdouble erf(double x)Definition SpecFuncCephes.cxx:926; ROOT::Math::Cephes::incbetdouble incbet(double aa, double bb, double xx)DESCRIPTION:Definition SpecFuncCephes.cxx:484; ROOT::Math::Cephes::igamdouble igam(double a, double x)Defi",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html
https://root.cern/doc/master/spider_8C.html:1198,Modifiability,variab,variables,1198,". ROOT: tutorials/tree/spider.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. spider.C File ReferenceTutorials » Tree tutorials. Detailed Description; TSpider example. ; ; #include ""TFile.h""; #include ""TCanvas.h""; #include ""TNtuple.h""; #include ""TSpider.h""; ; void spider() {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selection = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selection.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; }; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TFile.h; TNtuple.h; TSpider.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; c1return c1Definition legend1.C:41; AuthorBastien Dallapiazza ; Definition in file spider.C. tutorialstreespider.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/spider_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/spider_8C.html
https://root.cern/doc/master/spider_8C.html:630,Testability,log,log,630,". ROOT: tutorials/tree/spider.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. spider.C File ReferenceTutorials » Tree tutorials. Detailed Description; TSpider example. ; ; #include ""TFile.h""; #include ""TCanvas.h""; #include ""TNtuple.h""; #include ""TSpider.h""; ; void spider() {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selection = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selection.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; }; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TFile.h; TNtuple.h; TSpider.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; c1return c1Definition legend1.C:41; AuthorBastien Dallapiazza ; Definition in file spider.C. tutorialstreespider.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/spider_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/spider_8C.html
https://root.cern/doc/master/spider_8C.html:641,Testability,log,log,641,". ROOT: tutorials/tree/spider.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. spider.C File ReferenceTutorials » Tree tutorials. Detailed Description; TSpider example. ; ; #include ""TFile.h""; #include ""TCanvas.h""; #include ""TNtuple.h""; #include ""TSpider.h""; ; void spider() {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selection = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selection.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; }; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TFile.h; TNtuple.h; TSpider.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; c1return c1Definition legend1.C:41; AuthorBastien Dallapiazza ; Definition in file spider.C. tutorialstreespider.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/spider_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/spider_8C.html
https://root.cern/doc/master/spider_8C.html:1155,Usability,simpl,simple,1155,". ROOT: tutorials/tree/spider.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. spider.C File ReferenceTutorials » Tree tutorials. Detailed Description; TSpider example. ; ; #include ""TFile.h""; #include ""TCanvas.h""; #include ""TNtuple.h""; #include ""TSpider.h""; ; void spider() {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selection = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selection.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; }; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TFile.h; TNtuple.h; TSpider.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; c1return c1Definition legend1.C:41; AuthorBastien Dallapiazza ; Definition in file spider.C. tutorialstreespider.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/spider_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/spider_8C.html
https://root.cern/doc/master/splines__test_8C.html:501,Energy Efficiency,power,power,501,". ROOT: tutorials/graphs/splines_test.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. splines_test.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Examples of use of the spline classes. . ; void splines_test(Int_t np=23, Double_t a=-0.5, Double_t b=31); {; // array of points; Double_t *xx=0, *yy=0;; TSpline3 *spline3=0;; TSpline5 *spline5=0;; TLine *line5, *line3;; TText *text5, *text3, *textn;; char text[20];; const Double_t power=0.75;; ; // Define the original function; TF1 *f=new TF1(""f"",""sin(x)*sin(x/10)"",; a-0.05*(b-a),b+0.05*(b-a));; // Draw function; f->Draw(""lc"");; ; // Create text and legend; Double_t xx1, yy1, xx2, yy2, dx, dy;; gPad->Update();; gPad->GetRangeAxis(xx1,yy1,xx2,yy2);; dx = xx2-xx1;; dy = yy2-yy1;; line5=new TLine(xx1+dx*0.3,yy1+dy*1.02,; xx1+dx*0.38,yy1+dy*1.02);; line5->SetLineColor(kRed);; line5->SetLineWidth(2);; text5 = new TText(xx1+dx*0.4,; yy1+dy*1.03,""quintic spline"");; text5->SetTextAlign(12);; text5->SetTextSize(0.04);; line3=new TLine(xx1+dx*0.67,yy1+dy*1.02,; xx1+dx*0.75,yy1+dy*1.02);; line3->SetLineColor(kGreen);; line3->SetLineWidth(2);; text3 = new TText(xx1+dx*0.77,; yy1+dy*1.03,""third spline"");; text3->SetTextAlign(12);; text3->SetTextSize(0.04);; textn = new TText(xx1+dx*0.8,yy1+dy*0.91,"" "");; textn->SetTextAlign(12);; textn->SetTextSize(0.04);; textn->Draw();; ; // Draw legenda; line5->Draw();; text5->Draw();; line3->Draw();; text3->Draw();; ; for(Int_t nnp=2; nnp<=np; ++nnp) {; ; // Calculate the knots; if(xx) delete[] xx;; xx = new Double_t[nnp];; if(yy) delete[] yy;; yy = new Double_t[nnp];; for (Int_t i=0; i<nnp; ++i) {; xx[i]=a+(b-a)*TMath::Power(i/Double_t (nnp-1),power);; yy[i]=f->Eval(xx[i]);; }; ; // Evaluate fifth spline coefficients; Double_t eps=(b-a)*1.e-5;; if(spline5) delete spline5;; spline5 = new TSpline5(""Test"",xx,f,nnp,""b1e1b2e2"",; f->Derivative(a),f->Derivative(b),; (f->Derivative(a+eps)-f->Derivative(a))/eps,; (f->Derivative(b)-f->D",MatchSource.WIKI,doc/master/splines__test_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/splines__test_8C.html
https://root.cern/doc/master/splines__test_8C.html:1713,Energy Efficiency,power,power,1713,".05*(b-a),b+0.05*(b-a));; // Draw function; f->Draw(""lc"");; ; // Create text and legend; Double_t xx1, yy1, xx2, yy2, dx, dy;; gPad->Update();; gPad->GetRangeAxis(xx1,yy1,xx2,yy2);; dx = xx2-xx1;; dy = yy2-yy1;; line5=new TLine(xx1+dx*0.3,yy1+dy*1.02,; xx1+dx*0.38,yy1+dy*1.02);; line5->SetLineColor(kRed);; line5->SetLineWidth(2);; text5 = new TText(xx1+dx*0.4,; yy1+dy*1.03,""quintic spline"");; text5->SetTextAlign(12);; text5->SetTextSize(0.04);; line3=new TLine(xx1+dx*0.67,yy1+dy*1.02,; xx1+dx*0.75,yy1+dy*1.02);; line3->SetLineColor(kGreen);; line3->SetLineWidth(2);; text3 = new TText(xx1+dx*0.77,; yy1+dy*1.03,""third spline"");; text3->SetTextAlign(12);; text3->SetTextSize(0.04);; textn = new TText(xx1+dx*0.8,yy1+dy*0.91,"" "");; textn->SetTextAlign(12);; textn->SetTextSize(0.04);; textn->Draw();; ; // Draw legenda; line5->Draw();; text5->Draw();; line3->Draw();; text3->Draw();; ; for(Int_t nnp=2; nnp<=np; ++nnp) {; ; // Calculate the knots; if(xx) delete[] xx;; xx = new Double_t[nnp];; if(yy) delete[] yy;; yy = new Double_t[nnp];; for (Int_t i=0; i<nnp; ++i) {; xx[i]=a+(b-a)*TMath::Power(i/Double_t (nnp-1),power);; yy[i]=f->Eval(xx[i]);; }; ; // Evaluate fifth spline coefficients; Double_t eps=(b-a)*1.e-5;; if(spline5) delete spline5;; spline5 = new TSpline5(""Test"",xx,f,nnp,""b1e1b2e2"",; f->Derivative(a),f->Derivative(b),; (f->Derivative(a+eps)-f->Derivative(a))/eps,; (f->Derivative(b)-f->Derivative(b-eps))/eps);; ; spline5->SetLineColor(kRed);; spline5->SetLineWidth(3);; ; // Draw the quintic spline; spline5->Draw(""lcsame"");; ; // Evaluate third spline coefficients; if(spline3) delete spline3;; spline3 = new TSpline3(""Test"",xx,yy,nnp,""b1e1"",; f->Derivative(a),f->Derivative(b));; ; spline3->SetLineColor(kGreen);; spline3->SetLineWidth(3);; spline3->SetMarkerColor(kBlue);; spline3->SetMarkerStyle(20);; spline3->SetMarkerSize(1.5);; ; // Draw the third spline; spline3->Draw(""lcpsame"");; ; sprintf(text,""%3d knots"",nnp);; textn->SetTitle(text);; gPad->Update();; ; //; gSyste",MatchSource.WIKI,doc/master/splines__test_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/splines__test_8C.html
https://root.cern/doc/master/splines__test_8C.html:5484,Energy Efficiency,power,power,5484,"oid SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TF11-Dim function classDefinition TF1.h:233; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TSpline3Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first a...Definition TSpline.h:182; TSpline5Class to create quintic natural splines to interpolate knots Arbitrary conditions can be introduced f...Definition TSpline.h:238; TSpline::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TSpline.cxx:101; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TTextBase class for several text objects.Definition TText.h:22; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; AuthorFederico Carminati ; Definition in file splines_test.C. tutorialsgraphssplines_test.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/splines__test_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/splines__test_8C.html
https://root.cern/doc/master/splines__test_8C.html:4561,Usability,simpl,simple,4561,"tion TGWin32VirtualXProxy.cxx:68; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TF11-Dim function classDefinition TF1.h:233; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TSpline3Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first a...Definition TSpline.h:182; TSpline5Class to create quintic natural splines to interpolate knots Arbitrary conditions can be introduced f...Definition TSpline.h:238; TSpline::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TSpline.cxx:101; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TTextBase class for several text objects.Definition TText.h:22; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; AuthorFederico Carminati ;",MatchSource.WIKI,doc/master/splines__test_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/splines__test_8C.html
https://root.cern/doc/master/staff_8py.html:665,Security,access,access,665,". ROOT: tutorials/pyroot/staff.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; staff.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; example of macro to read data from an ascii file and create a root file with a Tree. ; NOTE: comparing the results of this macro with those of staff.C, you'll notice that the resultant file is a couple of bytes smaller, because the code below strips all white-spaces, whereas the .C version does not.; ; import re, array, os; import ROOT; from ROOT import TFile, TTree, gROOT, addressof; ; ## A C/C++ structure is required, to allow memory based access; gROOT.ProcessLine(; ""struct staff_t {\; Int_t Category;\; UInt_t Flag;\; Int_t Age;\; Int_t Service;\; Int_t Children;\; Int_t Grade;\; Int_t Step;\; Int_t Hrweek;\; Int_t Cost;\; Char_t Division[4];\; Char_t Nation[3];\; };"" );; ; ## Function to read in data from ASCII file and fill the ROOT tree; def staff():; ; staff = ROOT.staff_t(); ; # The input file cern.dat is a copy of the CERN staff data base; # from 1988; ; f = TFile( 'staff.root', 'RECREATE' ); tree = TTree( 'T', 'staff data from ascii file' ); tree.Branch( 'staff', staff, 'Category/I:Flag:Age:Service:Children:Grade:Step:Hrweek:Cost' ); tree.Branch( 'Divisions', addressof( staff, 'Division' ), 'Division/C' ); tree.Branch( 'Nation', addressof( staff, 'Nation' ), 'Nation/C' ); ; # note that the branches Division and Nation cannot be on the first branch; fname = os.path.join(str(ROOT.gROOT.GetTutorialDir()), 'tree', 'cernstaff.dat'); for line in open(fname).readlines():; t = list(filter( lambda x: x, re.split( '\s+', line ) ) ); staff.Category = int(t[0]) # assign as integers; staff.Flag = int(t[1]); staff.Age = int(t[2]); staff.Service = int(t[3]); staff.Children = int(t[4]); staff.Grade = int(t[5]); staff.Step = int(t[6]); staff.Hrweek = int(t[7]); staff.Cost = int(t[8]); staff.Division = t[9] # assign as strings; staff.Nation = t[10]; ; tree.Fil",MatchSource.WIKI,doc/master/staff_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/staff_8py.html
https://root.cern/doc/master/statsEditing_8C.html:1073,Safety,avoid,avoid,1073,"; .  . Loading...; Searching...; No Matches. statsEditing.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Edit statistics box. ; This example shows:; how to remove a stat element from the stat box; how to add a new one. ; TCanvas *statsEditing() {; // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();; ; // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *listOfLines = ps->GetListOfLines();; ; // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; listOfLines->Remove(tconst);; ; // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; listOfLines->Add(myt);; ; // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);; ; se->Modified();; return se;; }; h#define h(i)Definition RSha256.hxx:106; kRed@ kRedDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object f",MatchSource.WIKI,doc/master/statsEditing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/statsEditing_8C.html
https://root.cern/doc/master/statsEditing_8C.html:384,Testability,test,test,384,". ROOT: tutorials/hist/statsEditing.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. statsEditing.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Edit statistics box. ; This example shows:; how to remove a stat element from the stat box; how to add a new one. ; TCanvas *statsEditing() {; // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();; ; // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *listOfLines = ps->GetListOfLines();; ; // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; listOfLines->Remove(tconst);; ; // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; listOfLines->Add(myt);; ; // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);; ; se->Modified();; return se;; }; h#define h(i)Definition RSha256.hxx:106; kRed@ kRedDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideD",MatchSource.WIKI,doc/master/statsEditing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/statsEditing_8C.html
https://root.cern/doc/master/statsEditing_8C.html:463,Testability,test,test,463,". ROOT: tutorials/hist/statsEditing.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. statsEditing.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Edit statistics box. ; This example shows:; how to remove a stat element from the stat box; how to add a new one. ; TCanvas *statsEditing() {; // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();; ; // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *listOfLines = ps->GetListOfLines();; ; // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; listOfLines->Remove(tconst);; ; // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; listOfLines->Add(myt);; ; // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);; ; se->Modified();; return se;; }; h#define h(i)Definition RSha256.hxx:106; kRed@ kRedDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideD",MatchSource.WIKI,doc/master/statsEditing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/statsEditing_8C.html
https://root.cern/doc/master/stlLoader_8cc.html:268,Integrability,depend,dependency,268,". ROOT: core/clingutils/src/stlLoader.cc File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; stlLoader.cc File Reference. #include ""G__ci.h""; #include ""Api.h""; #include ""FastAllocString.h"". Include dependency graph for stlLoader.cc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; static int stlLoader ();  . Variables; static int sltLoad = stlLoader();  ; static const char * what = WHAT;  . Function Documentation. ◆ stlLoader(). static int stlLoader ; (; ). static . Definition at line 7 of file stlLoader.cc. Variable Documentation. ◆ sltLoad. int sltLoad = stlLoader(). static . Definition at line 29 of file stlLoader.cc. ◆ what. const char* what = WHAT. static . Definition at line 5 of file stlLoader.cc. coreclingutilssrcstlLoader.cc. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/stlLoader_8cc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/stlLoader_8cc.html
https://root.cern/doc/master/StringConv_8hxx_source.html:3410,Availability,failure,failure,3410," the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_limits<T>::max()) {; 102 value = (T)v;; 103 return EFromHumanReadableSize::kSuccess;; 104 } else {; 105 return EFromHumanReadableSize::kOverflow;; 106 }; 107 };; 108 if (cur==size) return result();; 109 ; 110 switch (toupper(str[cur])) {; 111 case 'B': exp = 0; break;; 112 case 'K': exp = 3; break;; 113 case 'M': exp = 6; break;; ",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
https://root.cern/doc/master/StringConv_8hxx_source.html:5221,Availability,error,error,5221,"std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_limits<T>::max()) {; 102 value = (T)v;; 103 return EFromHumanReadableSize::kSuccess;; 104 } else {; 105 return EFromHumanReadableSize::kOverflow;; 106 }; 107 };; 108 if (cur==size) return result();; 109 ; 110 switch (toupper(str[cur])) {; 111 case 'B': exp = 0; break;; 112 case 'K': exp = 3; break;; 113 case 'M': exp = 6; break;; 114 case 'G': exp = 9; break;; 115 case 'T': exp = 12; break;; 116 case 'E': exp = 15; break;; 117 case 'Z': exp = 18; break;; 118 case 'Y': exp = 21; break;; 119 ; 120 default: return EFromHumanReadableSize::kParseFail;; 121 }; 122 ++cur;; 123 ; 124 // If an 'i' or 'I' is present use non-SI factor-of-1024 units; 125 if (cur<size && toupper(str[cur]) == 'I') {; 126 ++cur;; 127 unit = 1024;; 128 }; 129 ; 130 if (cur==size) return result();; 131 ; 132 // Next character must be one of B/empty/whitespace; 133 switch (toupper(str[cur])) {; 134 case 'B':; 135 case ' ':; 136 case '\t': ++cur; break;; 137 ; 138 case '\0': return result();; 139 ; 140 default: return EFromHumanReadableSize::kParseFail;; 141 }; 142 ; 143 // Skip any remaining white space; 144 // while (cur<size && isspace(str[cur])) ++cur;; 145 ; 146 // Do not:; 147 // Parse error on anything but a null terminator; 148 // if (cur<size) return -1;; 149 ; 150 return result();; 151 } catch (...) {; 152 return EFromHumanReadableSize::kParseFail;; 153 }; 154 ; 155}; 156 ; 157} // namespace ROOT.; 158 ; 159#endif // ROOT_StringConv; sizesize_t size(const MatrixT &matr",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
https://root.cern/doc/master/StringConv_8hxx_source.html:3218,Deployability,update,updated,3218,"nt) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_limits<T>::max()) {; 102 value = (T)v;; 103 return EFromHumanReadableSize::kSuccess;; 104 } else {; 105 return EFromHumanReadableSize::kOverflow;; 106 }; 107 };; 108 if (cur==size) return re",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
https://root.cern/doc/master/StringConv_8hxx_source.html:3091,Energy Efficiency,power,power,3091,"B"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_lim",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
https://root.cern/doc/master/StringConv_8hxx_source.html:3005,Integrability,rout,routine,3005,"B"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_lim",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
https://root.cern/doc/master/StringConv_8hxx_source.html:2246,Testability,log,log,2246,"/info-stuff/bytecalc.html for example.; 30 ; 31///////////////////////////////////////////////////////////////////////////////; 32/// Return the size expressed in 'human readable' format.; 33/// \param bytes the size in bytes to be converted; 34/// \param si whether to use the SI units or not.; 35/// \param coeff return the size expressed in the new unit.; 36/// \param units return a pointer to the string representation of the new unit; 37template <typename value_type>; 38void ToHumanReadableSize(value_type bytes,; 39 Bool_t si,; 40 Double_t *coeff,; 41 const char **units); 42{; 43 // Static lookup table of byte-based SI units; 44 static const char *const suffix[][2] =; 45 { { ""B"", ""B"" },; 46 { ""KB"", ""KiB"" },; 47 { ""MB"", ""MiB"" },; 48 { ""GB"", ""GiB"" },; 49 { ""TB"", ""TiB"" },; 50 { ""EB"", ""EiB"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and onl",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
https://root.cern/doc/master/StringConv_8hxx_source.html:2264,Testability,log,log,2264,"/info-stuff/bytecalc.html for example.; 30 ; 31///////////////////////////////////////////////////////////////////////////////; 32/// Return the size expressed in 'human readable' format.; 33/// \param bytes the size in bytes to be converted; 34/// \param si whether to use the SI units or not.; 35/// \param coeff return the size expressed in the new unit.; 36/// \param units return a pointer to the string representation of the new unit; 37template <typename value_type>; 38void ToHumanReadableSize(value_type bytes,; 39 Bool_t si,; 40 Double_t *coeff,; 41 const char **units); 42{; 43 // Static lookup table of byte-based SI units; 44 static const char *const suffix[][2] =; 45 { { ""B"", ""B"" },; 46 { ""KB"", ""KiB"" },; 47 { ""MB"", ""MiB"" },; 48 { ""GB"", ""GiB"" },; 49 { ""TB"", ""TiB"" },; 50 { ""EB"", ""EiB"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and onl",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
https://root.cern/doc/master/StringConv_8hxx_source.html:2463,Testability,log,log,2463,"/info-stuff/bytecalc.html for example.; 30 ; 31///////////////////////////////////////////////////////////////////////////////; 32/// Return the size expressed in 'human readable' format.; 33/// \param bytes the size in bytes to be converted; 34/// \param si whether to use the SI units or not.; 35/// \param coeff return the size expressed in the new unit.; 36/// \param units return a pointer to the string representation of the new unit; 37template <typename value_type>; 38void ToHumanReadableSize(value_type bytes,; 39 Bool_t si,; 40 Double_t *coeff,; 41 const char **units); 42{; 43 // Static lookup table of byte-based SI units; 44 static const char *const suffix[][2] =; 45 { { ""B"", ""B"" },; 46 { ""KB"", ""KiB"" },; 47 { ""MB"", ""MiB"" },; 48 { ""GB"", ""GiB"" },; 49 { ""TB"", ""TiB"" },; 50 { ""EB"", ""EiB"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and onl",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
https://root.cern/doc/master/StringConv_8hxx_source.html:2481,Testability,log,log,2481,"/info-stuff/bytecalc.html for example.; 30 ; 31///////////////////////////////////////////////////////////////////////////////; 32/// Return the size expressed in 'human readable' format.; 33/// \param bytes the size in bytes to be converted; 34/// \param si whether to use the SI units or not.; 35/// \param coeff return the size expressed in the new unit.; 36/// \param units return a pointer to the string representation of the new unit; 37template <typename value_type>; 38void ToHumanReadableSize(value_type bytes,; 39 Bool_t si,; 40 Double_t *coeff,; 41 const char **units); 42{; 43 // Static lookup table of byte-based SI units; 44 static const char *const suffix[][2] =; 45 { { ""B"", ""B"" },; 46 { ""KB"", ""KiB"" },; 47 { ""MB"", ""MiB"" },; 48 { ""GB"", ""GiB"" },; 49 { ""TB"", ""TiB"" },; 50 { ""EB"", ""EiB"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and onl",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
https://root.cern/doc/master/structColorStruct__t.html:398,Availability,mask,mask,398,". ROOT: ColorStruct_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; ColorStruct_t Struct Reference. . Definition at line 310 of file GuiTypes.h. Public Attributes; UShort_t fBlue;  blue component (0..65535) ;  ; UShort_t fGreen;  green component (0..65535) ;  ; UShort_t fMask;  mask telling which color components are valid ;  ; ULong_t fPixel;  color pixel value (index in color table) ;  ; UShort_t fRed;  red component (0..65535) ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fBlue. UShort_t ColorStruct_t::fBlue. blue component (0..65535) ; Definition at line 314 of file GuiTypes.h. ◆ fGreen. UShort_t ColorStruct_t::fGreen. green component (0..65535) ; Definition at line 313 of file GuiTypes.h. ◆ fMask. UShort_t ColorStruct_t::fMask. mask telling which color components are valid ; Definition at line 315 of file GuiTypes.h. ◆ fPixel. ULong_t ColorStruct_t::fPixel. color pixel value (index in color table) ; Definition at line 311 of file GuiTypes.h. ◆ fRed. UShort_t ColorStruct_t::fRed. red component (0..65535) ; Definition at line 312 of file GuiTypes.h. Collaboration diagram for ColorStruct_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. ColorStruct_t. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structColorStruct__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structColorStruct__t.html
https://root.cern/doc/master/structColorStruct__t.html:873,Availability,mask,mask,873,". ROOT: ColorStruct_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; ColorStruct_t Struct Reference. . Definition at line 310 of file GuiTypes.h. Public Attributes; UShort_t fBlue;  blue component (0..65535) ;  ; UShort_t fGreen;  green component (0..65535) ;  ; UShort_t fMask;  mask telling which color components are valid ;  ; ULong_t fPixel;  color pixel value (index in color table) ;  ; UShort_t fRed;  red component (0..65535) ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fBlue. UShort_t ColorStruct_t::fBlue. blue component (0..65535) ; Definition at line 314 of file GuiTypes.h. ◆ fGreen. UShort_t ColorStruct_t::fGreen. green component (0..65535) ; Definition at line 313 of file GuiTypes.h. ◆ fMask. UShort_t ColorStruct_t::fMask. mask telling which color components are valid ; Definition at line 315 of file GuiTypes.h. ◆ fPixel. ULong_t ColorStruct_t::fPixel. color pixel value (index in color table) ; Definition at line 311 of file GuiTypes.h. ◆ fRed. UShort_t ColorStruct_t::fRed. red component (0..65535) ; Definition at line 312 of file GuiTypes.h. Collaboration diagram for ColorStruct_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. ColorStruct_t. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structColorStruct__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structColorStruct__t.html
https://root.cern/doc/master/structColorStruct__t.html:349,Energy Efficiency,green,green,349,". ROOT: ColorStruct_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; ColorStruct_t Struct Reference. . Definition at line 310 of file GuiTypes.h. Public Attributes; UShort_t fBlue;  blue component (0..65535) ;  ; UShort_t fGreen;  green component (0..65535) ;  ; UShort_t fMask;  mask telling which color components are valid ;  ; ULong_t fPixel;  color pixel value (index in color table) ;  ; UShort_t fRed;  red component (0..65535) ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fBlue. UShort_t ColorStruct_t::fBlue. blue component (0..65535) ; Definition at line 314 of file GuiTypes.h. ◆ fGreen. UShort_t ColorStruct_t::fGreen. green component (0..65535) ; Definition at line 313 of file GuiTypes.h. ◆ fMask. UShort_t ColorStruct_t::fMask. mask telling which color components are valid ; Definition at line 315 of file GuiTypes.h. ◆ fPixel. ULong_t ColorStruct_t::fPixel. color pixel value (index in color table) ; Definition at line 311 of file GuiTypes.h. ◆ fRed. UShort_t ColorStruct_t::fRed. red component (0..65535) ; Definition at line 312 of file GuiTypes.h. Collaboration diagram for ColorStruct_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. ColorStruct_t. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structColorStruct__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structColorStruct__t.html
https://root.cern/doc/master/structColorStruct__t.html:761,Energy Efficiency,green,green,761,". ROOT: ColorStruct_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; ColorStruct_t Struct Reference. . Definition at line 310 of file GuiTypes.h. Public Attributes; UShort_t fBlue;  blue component (0..65535) ;  ; UShort_t fGreen;  green component (0..65535) ;  ; UShort_t fMask;  mask telling which color components are valid ;  ; ULong_t fPixel;  color pixel value (index in color table) ;  ; UShort_t fRed;  red component (0..65535) ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fBlue. UShort_t ColorStruct_t::fBlue. blue component (0..65535) ; Definition at line 314 of file GuiTypes.h. ◆ fGreen. UShort_t ColorStruct_t::fGreen. green component (0..65535) ; Definition at line 313 of file GuiTypes.h. ◆ fMask. UShort_t ColorStruct_t::fMask. mask telling which color components are valid ; Definition at line 315 of file GuiTypes.h. ◆ fPixel. ULong_t ColorStruct_t::fPixel. color pixel value (index in color table) ; Definition at line 311 of file GuiTypes.h. ◆ fRed. UShort_t ColorStruct_t::fRed. red component (0..65535) ; Definition at line 312 of file GuiTypes.h. Collaboration diagram for ColorStruct_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. ColorStruct_t. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structColorStruct__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structColorStruct__t.html
https://root.cern/doc/master/structEvent__t.html:681,Availability,mask,mask,681,". ROOT: Event_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; Event_t Struct Reference. ; Event structure. ; Definition at line 174 of file GuiTypes.h. Public Attributes; UInt_t fCode;  key or button code ;  ; Int_t fCount;  if non-zero, at least this many more exposes ;  ; Int_t fFormat;  Next fields only used by kClientMessageEvent. ;  ; Handle_t fHandle;  general resource handle (used for atoms or windows) ;  ; UInt_t fHeight;  width and height of exposed area ;  ; Bool_t fSendEvent;  true if event came from SendEvent ;  ; UInt_t fState;  key or button mask ;  ; Time_t fTime;  time event event occurred in ms ;  ; EGEventType fType;  of event (see EGEventType) ;  ; Longptr_t fUser [5];  5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ;  ; UInt_t fWidth;  ; Window_t fWindow;  window reported event is relative to ;  ; Int_t fX;  ; Int_t fXRoot;  ; Int_t fY;  pointer x, y coordinates in event window ;  ; Int_t fYRoot;  coordinates relative to root ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCode. UInt_t Event_t::fCode. key or button code ; Definition at line 180 of file GuiTypes.h. ◆ fCount. Int_t Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t",MatchSource.WIKI,doc/master/structEvent__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structEvent__t.html
https://root.cern/doc/master/structEvent__t.html:1936,Availability,mask,mask,1936,"reported event is relative to ;  ; Int_t fX;  ; Int_t fXRoot;  ; Int_t fY;  pointer x, y coordinates in event window ;  ; Int_t fYRoot;  coordinates relative to root ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCode. UInt_t Event_t::fCode. key or button code ; Definition at line 180 of file GuiTypes.h. ◆ fCount. Int_t Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t Event_t::fTime. time event event occurred in ms ; Definition at line 177 of file GuiTypes.h. ◆ fType. EGEventType Event_t::fType. of event (see EGEventType) ; Definition at line 175 of file GuiTypes.h. ◆ fUser. Longptr_t Event_t::fUser[5]. 5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ; [1] and [2] may contain >32 bit quantities (i.e. pointers on 64 bit machines) ; Definition at line 187 of file GuiTypes.h. ◆ fWidth. UInt_t Event_t::fWidth. Definition at line 182 of file GuiTypes.h. ◆ fWindow. Window_t Event_t::fWindow. window reported event is relative to ; Definition at line 176 of file GuiTypes.h. ◆ fX. Int_t Event_t::fX. Definition at line 178 of file GuiTypes.h. ◆ fXRoot. Int_t Event_t::fXRoot. Definition at line 179 of file GuiTypes.h. ◆ fY. Int_t Event_t::fY. pointer x, y coordinates in event window ; Definition at line 178 of file GuiTypes.h. ◆ fYRoot. Int_t Event_t::fYRoot. coordinates re",MatchSource.WIKI,doc/master/structEvent__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structEvent__t.html
https://root.cern/doc/master/structEvent__t.html:847,Integrability,message,message,847,". ROOT: Event_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; Event_t Struct Reference. ; Event structure. ; Definition at line 174 of file GuiTypes.h. Public Attributes; UInt_t fCode;  key or button code ;  ; Int_t fCount;  if non-zero, at least this many more exposes ;  ; Int_t fFormat;  Next fields only used by kClientMessageEvent. ;  ; Handle_t fHandle;  general resource handle (used for atoms or windows) ;  ; UInt_t fHeight;  width and height of exposed area ;  ; Bool_t fSendEvent;  true if event came from SendEvent ;  ; UInt_t fState;  key or button mask ;  ; Time_t fTime;  time event event occurred in ms ;  ; EGEventType fType;  of event (see EGEventType) ;  ; Longptr_t fUser [5];  5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ;  ; UInt_t fWidth;  ; Window_t fWindow;  window reported event is relative to ;  ; Int_t fX;  ; Int_t fXRoot;  ; Int_t fY;  pointer x, y coordinates in event window ;  ; Int_t fYRoot;  coordinates relative to root ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCode. UInt_t Event_t::fCode. key or button code ; Definition at line 180 of file GuiTypes.h. ◆ fCount. Int_t Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t",MatchSource.WIKI,doc/master/structEvent__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structEvent__t.html
https://root.cern/doc/master/structEvent__t.html:2272,Integrability,message,message,2272," Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t Event_t::fTime. time event event occurred in ms ; Definition at line 177 of file GuiTypes.h. ◆ fType. EGEventType Event_t::fType. of event (see EGEventType) ; Definition at line 175 of file GuiTypes.h. ◆ fUser. Longptr_t Event_t::fUser[5]. 5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ; [1] and [2] may contain >32 bit quantities (i.e. pointers on 64 bit machines) ; Definition at line 187 of file GuiTypes.h. ◆ fWidth. UInt_t Event_t::fWidth. Definition at line 182 of file GuiTypes.h. ◆ fWindow. Window_t Event_t::fWindow. window reported event is relative to ; Definition at line 176 of file GuiTypes.h. ◆ fX. Int_t Event_t::fX. Definition at line 178 of file GuiTypes.h. ◆ fXRoot. Int_t Event_t::fXRoot. Definition at line 179 of file GuiTypes.h. ◆ fY. Int_t Event_t::fY. pointer x, y coordinates in event window ; Definition at line 178 of file GuiTypes.h. ◆ fYRoot. Int_t Event_t::fYRoot. coordinates relative to root ; Definition at line 179 of file GuiTypes.h. Collaboration diagram for Event_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. Event_t. ROOT master - Reference Guide Ge",MatchSource.WIKI,doc/master/structEvent__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structEvent__t.html
https://root.cern/doc/master/structEvent__t.html:381,Security,expose,exposes,381,". ROOT: Event_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; Event_t Struct Reference. ; Event structure. ; Definition at line 174 of file GuiTypes.h. Public Attributes; UInt_t fCode;  key or button code ;  ; Int_t fCount;  if non-zero, at least this many more exposes ;  ; Int_t fFormat;  Next fields only used by kClientMessageEvent. ;  ; Handle_t fHandle;  general resource handle (used for atoms or windows) ;  ; UInt_t fHeight;  width and height of exposed area ;  ; Bool_t fSendEvent;  true if event came from SendEvent ;  ; UInt_t fState;  key or button mask ;  ; Time_t fTime;  time event event occurred in ms ;  ; EGEventType fType;  of event (see EGEventType) ;  ; Longptr_t fUser [5];  5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ;  ; UInt_t fWidth;  ; Window_t fWindow;  window reported event is relative to ;  ; Int_t fX;  ; Int_t fXRoot;  ; Int_t fY;  pointer x, y coordinates in event window ;  ; Int_t fYRoot;  coordinates relative to root ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCode. UInt_t Event_t::fCode. key or button code ; Definition at line 180 of file GuiTypes.h. ◆ fCount. Int_t Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t",MatchSource.WIKI,doc/master/structEvent__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structEvent__t.html
https://root.cern/doc/master/structEvent__t.html:574,Security,expose,exposed,574,". ROOT: Event_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; Event_t Struct Reference. ; Event structure. ; Definition at line 174 of file GuiTypes.h. Public Attributes; UInt_t fCode;  key or button code ;  ; Int_t fCount;  if non-zero, at least this many more exposes ;  ; Int_t fFormat;  Next fields only used by kClientMessageEvent. ;  ; Handle_t fHandle;  general resource handle (used for atoms or windows) ;  ; UInt_t fHeight;  width and height of exposed area ;  ; Bool_t fSendEvent;  true if event came from SendEvent ;  ; UInt_t fState;  key or button mask ;  ; Time_t fTime;  time event event occurred in ms ;  ; EGEventType fType;  of event (see EGEventType) ;  ; Longptr_t fUser [5];  5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ;  ; UInt_t fWidth;  ; Window_t fWindow;  window reported event is relative to ;  ; Int_t fX;  ; Int_t fXRoot;  ; Int_t fY;  pointer x, y coordinates in event window ;  ; Int_t fYRoot;  coordinates relative to root ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCode. UInt_t Event_t::fCode. key or button code ; Definition at line 180 of file GuiTypes.h. ◆ fCount. Int_t Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t",MatchSource.WIKI,doc/master/structEvent__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structEvent__t.html
https://root.cern/doc/master/structEvent__t.html:1339,Security,expose,exposes,1339,"f non-zero, at least this many more exposes ;  ; Int_t fFormat;  Next fields only used by kClientMessageEvent. ;  ; Handle_t fHandle;  general resource handle (used for atoms or windows) ;  ; UInt_t fHeight;  width and height of exposed area ;  ; Bool_t fSendEvent;  true if event came from SendEvent ;  ; UInt_t fState;  key or button mask ;  ; Time_t fTime;  time event event occurred in ms ;  ; EGEventType fType;  of event (see EGEventType) ;  ; Longptr_t fUser [5];  5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ;  ; UInt_t fWidth;  ; Window_t fWindow;  window reported event is relative to ;  ; Int_t fX;  ; Int_t fXRoot;  ; Int_t fY;  pointer x, y coordinates in event window ;  ; Int_t fYRoot;  coordinates relative to root ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCode. UInt_t Event_t::fCode. key or button code ; Definition at line 180 of file GuiTypes.h. ◆ fCount. Int_t Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t Event_t::fTime. time event event occurred in ms ; Definition at line 177 of file GuiTypes.h. ◆ fType. EGEventType Event_t::fType. of event (see EGEventType) ; Definition at line 175 of file GuiTypes.h. ◆ fUser. Longptr_t Event_t::fUser[5]. 5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ; [1] and [2] may",MatchSource.WIKI,doc/master/structEvent__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structEvent__t.html
https://root.cern/doc/master/structEvent__t.html:1709,Security,expose,exposed,1709,"urred in ms ;  ; EGEventType fType;  of event (see EGEventType) ;  ; Longptr_t fUser [5];  5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ;  ; UInt_t fWidth;  ; Window_t fWindow;  window reported event is relative to ;  ; Int_t fX;  ; Int_t fXRoot;  ; Int_t fY;  pointer x, y coordinates in event window ;  ; Int_t fYRoot;  coordinates relative to root ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCode. UInt_t Event_t::fCode. key or button code ; Definition at line 180 of file GuiTypes.h. ◆ fCount. Int_t Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t Event_t::fTime. time event event occurred in ms ; Definition at line 177 of file GuiTypes.h. ◆ fType. EGEventType Event_t::fType. of event (see EGEventType) ; Definition at line 175 of file GuiTypes.h. ◆ fUser. Longptr_t Event_t::fUser[5]. 5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ; [1] and [2] may contain >32 bit quantities (i.e. pointers on 64 bit machines) ; Definition at line 187 of file GuiTypes.h. ◆ fWidth. UInt_t Event_t::fWidth. Definition at line 182 of file GuiTypes.h. ◆ fWindow. Window_t Event_t::fWindow. window reported event is relative to ; Definition at line 176 of file GuiTypes.h. ◆ fX. Int_t Event_t::fX. Definition at line 178 of file GuiTypes.h. ◆ fXRoot",MatchSource.WIKI,doc/master/structEvent__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structEvent__t.html
https://root.cern/doc/master/structGCValues__t.html:1392,Availability,mask,mask,1392,". master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; GCValues_t Struct Reference. ; Graphics context structure. ; Definition at line 224 of file GuiTypes.h. Public Member Functions;  GCValues_t ();  . Public Attributes; Int_t fArcMode;  kArcChord, kArcPieSlice ;  ; ULong_t fBackground;  background pixel ;  ; Int_t fCapStyle;  kCapNotLast, kCapButt, kCapRound, kCapProjecting ;  ; Pixmap_t fClipMask;  bitmap clipping; other calls for rects ;  ; Int_t fClipXOrigin;  origin for clipping ;  ; Int_t fClipYOrigin;  ; Char_t fDashes [8];  dash pattern list (dash length per byte) ;  ; Int_t fDashLen;  number of dashes in fDashes ;  ; Int_t fDashOffset;  patterned/dashed line information ;  ; Int_t fFillRule;  kEvenOddRule, kWindingRule ;  ; Int_t fFillStyle;  kFillSolid, kFillTiled, kFillStippled, kFillOpaeueStippled ;  ; FontH_t fFont;  default text font for text operations ;  ; ULong_t fForeground;  foreground pixel ;  ; EGraphicsFunction fFunction;  logical operation ;  ; Bool_t fGraphicsExposures;  boolean, should exposures be generated ;  ; Int_t fJoinStyle;  kJoinMiter, kJoinRound, kJoinBevel ;  ; Int_t fLineStyle;  kLineSolid, kLineOnOffDash, kLineDoubleDash ;  ; Int_t fLineWidth;  line width ;  ; Mask_t fMask;  bit mask specifying which fields are valid ;  ; ULong_t fPlaneMask;  plane mask ;  ; Pixmap_t fStipple;  stipple 1 plane pixmap for stippling ;  ; Int_t fSubwindowMode;  kClipByChildren, kIncludeInferiors ;  ; Pixmap_t fTile;  tile pixmap for tiling operations ;  ; Int_t fTsXOrigin;  offset for tile or stipple operations ;  ; Int_t fTsYOrigin;  . #include <GuiTypes.h>; Constructor & Destructor Documentation. ◆ GCValues_t(). GCValues_t::GCValues_t ; (; ). inline . Definition at line 253 of file GuiTypes.h. Member Data Documentation. ◆ fArcMode. Int_t GCValues_t::fArcMode. kArcChord, kArcPieSlice ; Definition at line 237 of file GuiTypes.h. ◆ fBackgroun",MatchSource.WIKI,doc/master/structGCValues__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structGCValues__t.html
https://root.cern/doc/master/structGCValues__t.html:1463,Availability,mask,mask,1463,". master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; GCValues_t Struct Reference. ; Graphics context structure. ; Definition at line 224 of file GuiTypes.h. Public Member Functions;  GCValues_t ();  . Public Attributes; Int_t fArcMode;  kArcChord, kArcPieSlice ;  ; ULong_t fBackground;  background pixel ;  ; Int_t fCapStyle;  kCapNotLast, kCapButt, kCapRound, kCapProjecting ;  ; Pixmap_t fClipMask;  bitmap clipping; other calls for rects ;  ; Int_t fClipXOrigin;  origin for clipping ;  ; Int_t fClipYOrigin;  ; Char_t fDashes [8];  dash pattern list (dash length per byte) ;  ; Int_t fDashLen;  number of dashes in fDashes ;  ; Int_t fDashOffset;  patterned/dashed line information ;  ; Int_t fFillRule;  kEvenOddRule, kWindingRule ;  ; Int_t fFillStyle;  kFillSolid, kFillTiled, kFillStippled, kFillOpaeueStippled ;  ; FontH_t fFont;  default text font for text operations ;  ; ULong_t fForeground;  foreground pixel ;  ; EGraphicsFunction fFunction;  logical operation ;  ; Bool_t fGraphicsExposures;  boolean, should exposures be generated ;  ; Int_t fJoinStyle;  kJoinMiter, kJoinRound, kJoinBevel ;  ; Int_t fLineStyle;  kLineSolid, kLineOnOffDash, kLineDoubleDash ;  ; Int_t fLineWidth;  line width ;  ; Mask_t fMask;  bit mask specifying which fields are valid ;  ; ULong_t fPlaneMask;  plane mask ;  ; Pixmap_t fStipple;  stipple 1 plane pixmap for stippling ;  ; Int_t fSubwindowMode;  kClipByChildren, kIncludeInferiors ;  ; Pixmap_t fTile;  tile pixmap for tiling operations ;  ; Int_t fTsXOrigin;  offset for tile or stipple operations ;  ; Int_t fTsYOrigin;  . #include <GuiTypes.h>; Constructor & Destructor Documentation. ◆ GCValues_t(). GCValues_t::GCValues_t ; (; ). inline . Definition at line 253 of file GuiTypes.h. Member Data Documentation. ◆ fArcMode. Int_t GCValues_t::fArcMode. kArcChord, kArcPieSlice ; Definition at line 237 of file GuiTypes.h. ◆ fBackgroun",MatchSource.WIKI,doc/master/structGCValues__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structGCValues__t.html
https://root.cern/doc/master/structGCValues__t.html:4129,Availability,mask,mask,4129,"Stippled, kFillOpaeueStippled ; Definition at line 234 of file GuiTypes.h. ◆ fFont. FontH_t GCValues_t::fFont. default text font for text operations ; Definition at line 242 of file GuiTypes.h. ◆ fForeground. ULong_t GCValues_t::fForeground. foreground pixel ; Definition at line 227 of file GuiTypes.h. ◆ fFunction. EGraphicsFunction GCValues_t::fFunction. logical operation ; Definition at line 225 of file GuiTypes.h. ◆ fGraphicsExposures. Bool_t GCValues_t::fGraphicsExposures. boolean, should exposures be generated ; Definition at line 244 of file GuiTypes.h. ◆ fJoinStyle. Int_t GCValues_t::fJoinStyle. kJoinMiter, kJoinRound, kJoinBevel ; Definition at line 233 of file GuiTypes.h. ◆ fLineStyle. Int_t GCValues_t::fLineStyle. kLineSolid, kLineOnOffDash, kLineDoubleDash ; Definition at line 230 of file GuiTypes.h. ◆ fLineWidth. Int_t GCValues_t::fLineWidth. line width ; Definition at line 229 of file GuiTypes.h. ◆ fMask. Mask_t GCValues_t::fMask. bit mask specifying which fields are valid ; Definition at line 251 of file GuiTypes.h. ◆ fPlaneMask. ULong_t GCValues_t::fPlaneMask. plane mask ; Definition at line 226 of file GuiTypes.h. ◆ fStipple. Pixmap_t GCValues_t::fStipple. stipple 1 plane pixmap for stippling ; Definition at line 239 of file GuiTypes.h. ◆ fSubwindowMode. Int_t GCValues_t::fSubwindowMode. kClipByChildren, kIncludeInferiors ; Definition at line 243 of file GuiTypes.h. ◆ fTile. Pixmap_t GCValues_t::fTile. tile pixmap for tiling operations ; Definition at line 238 of file GuiTypes.h. ◆ fTsXOrigin. Int_t GCValues_t::fTsXOrigin. offset for tile or stipple operations ; Definition at line 240 of file GuiTypes.h. ◆ fTsYOrigin. Int_t GCValues_t::fTsYOrigin. Definition at line 241 of file GuiTypes.h. Collaboration diagram for GCValues_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. GCValues_t. ROOT master - Refer",MatchSource.WIKI,doc/master/structGCValues__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structGCValues__t.html
https://root.cern/doc/master/structGCValues__t.html:4265,Availability,mask,mask,4265,"ontH_t GCValues_t::fFont. default text font for text operations ; Definition at line 242 of file GuiTypes.h. ◆ fForeground. ULong_t GCValues_t::fForeground. foreground pixel ; Definition at line 227 of file GuiTypes.h. ◆ fFunction. EGraphicsFunction GCValues_t::fFunction. logical operation ; Definition at line 225 of file GuiTypes.h. ◆ fGraphicsExposures. Bool_t GCValues_t::fGraphicsExposures. boolean, should exposures be generated ; Definition at line 244 of file GuiTypes.h. ◆ fJoinStyle. Int_t GCValues_t::fJoinStyle. kJoinMiter, kJoinRound, kJoinBevel ; Definition at line 233 of file GuiTypes.h. ◆ fLineStyle. Int_t GCValues_t::fLineStyle. kLineSolid, kLineOnOffDash, kLineDoubleDash ; Definition at line 230 of file GuiTypes.h. ◆ fLineWidth. Int_t GCValues_t::fLineWidth. line width ; Definition at line 229 of file GuiTypes.h. ◆ fMask. Mask_t GCValues_t::fMask. bit mask specifying which fields are valid ; Definition at line 251 of file GuiTypes.h. ◆ fPlaneMask. ULong_t GCValues_t::fPlaneMask. plane mask ; Definition at line 226 of file GuiTypes.h. ◆ fStipple. Pixmap_t GCValues_t::fStipple. stipple 1 plane pixmap for stippling ; Definition at line 239 of file GuiTypes.h. ◆ fSubwindowMode. Int_t GCValues_t::fSubwindowMode. kClipByChildren, kIncludeInferiors ; Definition at line 243 of file GuiTypes.h. ◆ fTile. Pixmap_t GCValues_t::fTile. tile pixmap for tiling operations ; Definition at line 238 of file GuiTypes.h. ◆ fTsXOrigin. Int_t GCValues_t::fTsXOrigin. offset for tile or stipple operations ; Definition at line 240 of file GuiTypes.h. ◆ fTsYOrigin. Int_t GCValues_t::fTsYOrigin. Definition at line 241 of file GuiTypes.h. Collaboration diagram for GCValues_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. GCValues_t. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structGCValues__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structGCValues__t.html
https://root.cern/doc/master/structGCValues__t.html:1116,Testability,log,logical,1116,". master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; GCValues_t Struct Reference. ; Graphics context structure. ; Definition at line 224 of file GuiTypes.h. Public Member Functions;  GCValues_t ();  . Public Attributes; Int_t fArcMode;  kArcChord, kArcPieSlice ;  ; ULong_t fBackground;  background pixel ;  ; Int_t fCapStyle;  kCapNotLast, kCapButt, kCapRound, kCapProjecting ;  ; Pixmap_t fClipMask;  bitmap clipping; other calls for rects ;  ; Int_t fClipXOrigin;  origin for clipping ;  ; Int_t fClipYOrigin;  ; Char_t fDashes [8];  dash pattern list (dash length per byte) ;  ; Int_t fDashLen;  number of dashes in fDashes ;  ; Int_t fDashOffset;  patterned/dashed line information ;  ; Int_t fFillRule;  kEvenOddRule, kWindingRule ;  ; Int_t fFillStyle;  kFillSolid, kFillTiled, kFillStippled, kFillOpaeueStippled ;  ; FontH_t fFont;  default text font for text operations ;  ; ULong_t fForeground;  foreground pixel ;  ; EGraphicsFunction fFunction;  logical operation ;  ; Bool_t fGraphicsExposures;  boolean, should exposures be generated ;  ; Int_t fJoinStyle;  kJoinMiter, kJoinRound, kJoinBevel ;  ; Int_t fLineStyle;  kLineSolid, kLineOnOffDash, kLineDoubleDash ;  ; Int_t fLineWidth;  line width ;  ; Mask_t fMask;  bit mask specifying which fields are valid ;  ; ULong_t fPlaneMask;  plane mask ;  ; Pixmap_t fStipple;  stipple 1 plane pixmap for stippling ;  ; Int_t fSubwindowMode;  kClipByChildren, kIncludeInferiors ;  ; Pixmap_t fTile;  tile pixmap for tiling operations ;  ; Int_t fTsXOrigin;  offset for tile or stipple operations ;  ; Int_t fTsYOrigin;  . #include <GuiTypes.h>; Constructor & Destructor Documentation. ◆ GCValues_t(). GCValues_t::GCValues_t ; (; ). inline . Definition at line 253 of file GuiTypes.h. Member Data Documentation. ◆ fArcMode. Int_t GCValues_t::fArcMode. kArcChord, kArcPieSlice ; Definition at line 237 of file GuiTypes.h. ◆ fBackgroun",MatchSource.WIKI,doc/master/structGCValues__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structGCValues__t.html
https://root.cern/doc/master/structGCValues__t.html:3525,Testability,log,logical,3525,"t::fClipYOrigin. Definition at line 246 of file GuiTypes.h. ◆ fDashes. Char_t GCValues_t::fDashes[8]. dash pattern list (dash length per byte) ; Definition at line 249 of file GuiTypes.h. ◆ fDashLen. Int_t GCValues_t::fDashLen. number of dashes in fDashes ; Definition at line 250 of file GuiTypes.h. ◆ fDashOffset. Int_t GCValues_t::fDashOffset. patterned/dashed line information ; Definition at line 248 of file GuiTypes.h. ◆ fFillRule. Int_t GCValues_t::fFillRule. kEvenOddRule, kWindingRule ; Definition at line 236 of file GuiTypes.h. ◆ fFillStyle. Int_t GCValues_t::fFillStyle. kFillSolid, kFillTiled, kFillStippled, kFillOpaeueStippled ; Definition at line 234 of file GuiTypes.h. ◆ fFont. FontH_t GCValues_t::fFont. default text font for text operations ; Definition at line 242 of file GuiTypes.h. ◆ fForeground. ULong_t GCValues_t::fForeground. foreground pixel ; Definition at line 227 of file GuiTypes.h. ◆ fFunction. EGraphicsFunction GCValues_t::fFunction. logical operation ; Definition at line 225 of file GuiTypes.h. ◆ fGraphicsExposures. Bool_t GCValues_t::fGraphicsExposures. boolean, should exposures be generated ; Definition at line 244 of file GuiTypes.h. ◆ fJoinStyle. Int_t GCValues_t::fJoinStyle. kJoinMiter, kJoinRound, kJoinBevel ; Definition at line 233 of file GuiTypes.h. ◆ fLineStyle. Int_t GCValues_t::fLineStyle. kLineSolid, kLineOnOffDash, kLineDoubleDash ; Definition at line 230 of file GuiTypes.h. ◆ fLineWidth. Int_t GCValues_t::fLineWidth. line width ; Definition at line 229 of file GuiTypes.h. ◆ fMask. Mask_t GCValues_t::fMask. bit mask specifying which fields are valid ; Definition at line 251 of file GuiTypes.h. ◆ fPlaneMask. ULong_t GCValues_t::fPlaneMask. plane mask ; Definition at line 226 of file GuiTypes.h. ◆ fStipple. Pixmap_t GCValues_t::fStipple. stipple 1 plane pixmap for stippling ; Definition at line 239 of file GuiTypes.h. ◆ fSubwindowMode. Int_t GCValues_t::fSubwindowMode. kClipByChildren, kIncludeInferiors ; Definition at line 243 of ",MatchSource.WIKI,doc/master/structGCValues__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structGCValues__t.html
https://root.cern/doc/master/structPictureAttributes__t.html:479,Availability,mask,mask,479,. ROOT: PictureAttributes_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; PictureAttributes_t Struct Reference. . Definition at line 323 of file GuiTypes.h. Public Attributes; UInt_t fCloseness;  allowable RGB deviation ;  ; Colormap_t fColormap;  colormap to use ;  ; Int_t fDepth;  depth of window ;  ; UInt_t fHeight;  height of picture ;  ; Mask_t fMask;  mask specifying which attributes are defined ;  ; UInt_t fNpixels;  number of used color pixels ;  ; ULong_t * fPixels;  list of used color pixels (if set use delete[]) ;  ; UInt_t fWidth;  width of picture ;  ; UInt_t fXHotspot;  picture x hotspot coordinate ;  ; UInt_t fYHotspot;  picture y hotspot coordinate ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCloseness. UInt_t PictureAttributes_t::fCloseness. allowable RGB deviation ; Definition at line 332 of file GuiTypes.h. ◆ fColormap. Colormap_t PictureAttributes_t::fColormap. colormap to use ; Definition at line 324 of file GuiTypes.h. ◆ fDepth. Int_t PictureAttributes_t::fDepth. depth of window ; Definition at line 325 of file GuiTypes.h. ◆ fHeight. UInt_t PictureAttributes_t::fHeight. height of picture ; Definition at line 327 of file GuiTypes.h. ◆ fMask. Mask_t PictureAttributes_t::fMask. mask specifying which attributes are defined ; Definition at line 333 of file GuiTypes.h. ◆ fNpixels. UInt_t PictureAttributes_t::fNpixels. number of used color pixels ; Definition at line 331 of file GuiTypes.h. ◆ fPixels. ULong_t* PictureAttributes_t::fPixels. list of used color pixels (if set use delete[]) ; Definition at line 330 of file GuiTypes.h. ◆ fWidth. UInt_t PictureAttributes_t::fWidth. width of picture ; Definition at line 326 of file GuiTypes.h. ◆ fXHotspot. UInt_t PictureAttributes_t::fXHotspot. picture x hotspot coordinate ; Definition at line 328 of file GuiTypes.h. ◆ fYHotspot. UInt_t PictureAttributes_t::fYHotspot. picture y h,MatchSource.WIKI,doc/master/structPictureAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structPictureAttributes__t.html
https://root.cern/doc/master/structPictureAttributes__t.html:1348,Availability,mask,mask,1348,"_t fDepth;  depth of window ;  ; UInt_t fHeight;  height of picture ;  ; Mask_t fMask;  mask specifying which attributes are defined ;  ; UInt_t fNpixels;  number of used color pixels ;  ; ULong_t * fPixels;  list of used color pixels (if set use delete[]) ;  ; UInt_t fWidth;  width of picture ;  ; UInt_t fXHotspot;  picture x hotspot coordinate ;  ; UInt_t fYHotspot;  picture y hotspot coordinate ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCloseness. UInt_t PictureAttributes_t::fCloseness. allowable RGB deviation ; Definition at line 332 of file GuiTypes.h. ◆ fColormap. Colormap_t PictureAttributes_t::fColormap. colormap to use ; Definition at line 324 of file GuiTypes.h. ◆ fDepth. Int_t PictureAttributes_t::fDepth. depth of window ; Definition at line 325 of file GuiTypes.h. ◆ fHeight. UInt_t PictureAttributes_t::fHeight. height of picture ; Definition at line 327 of file GuiTypes.h. ◆ fMask. Mask_t PictureAttributes_t::fMask. mask specifying which attributes are defined ; Definition at line 333 of file GuiTypes.h. ◆ fNpixels. UInt_t PictureAttributes_t::fNpixels. number of used color pixels ; Definition at line 331 of file GuiTypes.h. ◆ fPixels. ULong_t* PictureAttributes_t::fPixels. list of used color pixels (if set use delete[]) ; Definition at line 330 of file GuiTypes.h. ◆ fWidth. UInt_t PictureAttributes_t::fWidth. width of picture ; Definition at line 326 of file GuiTypes.h. ◆ fXHotspot. UInt_t PictureAttributes_t::fXHotspot. picture x hotspot coordinate ; Definition at line 328 of file GuiTypes.h. ◆ fYHotspot. UInt_t PictureAttributes_t::fYHotspot. picture y hotspot coordinate ; Definition at line 329 of file GuiTypes.h. Collaboration diagram for PictureAttributes_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. PictureAttributes_t. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41",MatchSource.WIKI,doc/master/structPictureAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structPictureAttributes__t.html
https://root.cern/doc/master/structRooAbsArg_1_1ProxyListCache.html:337,Performance,cache,cache,337,". ROOT: RooAbsArg::ProxyListCache Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; RooAbsArg::ProxyListCache Struct Reference. . Definition at line 660 of file RooAbsArg.h. Public Attributes; std::vector< RooAbsProxy * > cache;  ; bool isDirty = true;  . #include <RooAbsArg.h>; Member Data Documentation. ◆ cache. std::vector<RooAbsProxy*> RooAbsArg::ProxyListCache::cache. Definition at line 661 of file RooAbsArg.h. ◆ isDirty. bool RooAbsArg::ProxyListCache::isDirty = true. Definition at line 662 of file RooAbsArg.h. Collaboration diagram for RooAbsArg::ProxyListCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; roofit/roofitcore/inc/RooAbsArg.h. RooAbsArgProxyListCache. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:38 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structRooAbsArg_1_1ProxyListCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooAbsArg_1_1ProxyListCache.html
https://root.cern/doc/master/structRooAbsArg_1_1ProxyListCache.html:424,Performance,cache,cache,424,". ROOT: RooAbsArg::ProxyListCache Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; RooAbsArg::ProxyListCache Struct Reference. . Definition at line 660 of file RooAbsArg.h. Public Attributes; std::vector< RooAbsProxy * > cache;  ; bool isDirty = true;  . #include <RooAbsArg.h>; Member Data Documentation. ◆ cache. std::vector<RooAbsProxy*> RooAbsArg::ProxyListCache::cache. Definition at line 661 of file RooAbsArg.h. ◆ isDirty. bool RooAbsArg::ProxyListCache::isDirty = true. Definition at line 662 of file RooAbsArg.h. Collaboration diagram for RooAbsArg::ProxyListCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; roofit/roofitcore/inc/RooAbsArg.h. RooAbsArgProxyListCache. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:38 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structRooAbsArg_1_1ProxyListCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooAbsArg_1_1ProxyListCache.html
https://root.cern/doc/master/structRooAbsArg_1_1ProxyListCache.html:484,Performance,cache,cache,484,". ROOT: RooAbsArg::ProxyListCache Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; RooAbsArg::ProxyListCache Struct Reference. . Definition at line 660 of file RooAbsArg.h. Public Attributes; std::vector< RooAbsProxy * > cache;  ; bool isDirty = true;  . #include <RooAbsArg.h>; Member Data Documentation. ◆ cache. std::vector<RooAbsProxy*> RooAbsArg::ProxyListCache::cache. Definition at line 661 of file RooAbsArg.h. ◆ isDirty. bool RooAbsArg::ProxyListCache::isDirty = true. Definition at line 662 of file RooAbsArg.h. Collaboration diagram for RooAbsArg::ProxyListCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; roofit/roofitcore/inc/RooAbsArg.h. RooAbsArgProxyListCache. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:38 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structRooAbsArg_1_1ProxyListCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooAbsArg_1_1ProxyListCache.html
https://root.cern/doc/master/structRooAbsReal_1_1PlotOpt.html:638,Availability,error,errorFR,638,". ROOT: RooAbsReal::PlotOpt Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; RooAbsReal::PlotOpt Struct Reference. . Definition at line 463 of file RooAbsReal.h. Public Attributes; const char * addToCurveName = nullptr;  ; double addToWgtOther = 1.0;  ; double addToWgtSelf = 1.0;  ; bool binProjData = false;  ; bool curveInvisible = false;  ; const char * curveName = nullptr;  ; const char * curveNameSuffix = """";  ; bool doeeval = false;  ; Option_t * drawOptions = ""L"";  ; double eeval = 0.0;  ; const RooFitResult * errorFR = nullptr;  ; RooFit::MPSplit interleave = RooFit::Interleave;  ; const char * normRangeName = nullptr;  ; Int_t numCPU = 1;  ; Int_t numee = 10;  ; bool postRangeFracScale = false;  ; double precision = 1e-3;  ; bool progress = false;  ; const RooAbsData * projData = nullptr;  ; const RooArgSet * projDataSet = nullptr;  ; const char * projectionRangeName = nullptr;  ; const RooArgSet * projSet = nullptr;  ; double rangeHi = 0.0;  ; double rangeLo = 0.0;  ; double scaleFactor = 1.0;  ; bool shiftToZero = false;  ; ScaleType stype = Relative;  ; RooCurve::WingMode wmode = RooCurve::Extended;  . #include <RooAbsReal.h>; Member Data Documentation. ◆ addToCurveName. const char* RooAbsReal::PlotOpt::addToCurveName = nullptr. Definition at line 481 of file RooAbsReal.h. ◆ addToWgtOther. double RooAbsReal::PlotOpt::addToWgtOther = 1.0. Definition at line 483 of file RooAbsReal.h. ◆ addToWgtSelf. double RooAbsReal::PlotOpt::addToWgtSelf = 1.0. Definition at line 482 of file RooAbsReal.h. ◆ binProjData. bool RooAbsReal::PlotOpt::binProjData = false. Definition at line 468 of file RooAbsReal.h. ◆ curveInvisible. bool RooAbsReal::PlotOpt::curveInvisible = false. Definition at line 479 of file RooAbsReal.h. ◆ curveName. const char* RooAbsReal::PlotOpt::curveName = nullptr. Definition at line 480 of file RooAbsReal.h. ◆ curveNameSuffix. const cha",MatchSource.WIKI,doc/master/structRooAbsReal_1_1PlotOpt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooAbsReal_1_1PlotOpt.html
https://root.cern/doc/master/structRooAbsReal_1_1PlotOpt.html:2398,Availability,error,errorFR,2398,"f file RooAbsReal.h. ◆ addToWgtOther. double RooAbsReal::PlotOpt::addToWgtOther = 1.0. Definition at line 483 of file RooAbsReal.h. ◆ addToWgtSelf. double RooAbsReal::PlotOpt::addToWgtSelf = 1.0. Definition at line 482 of file RooAbsReal.h. ◆ binProjData. bool RooAbsReal::PlotOpt::binProjData = false. Definition at line 468 of file RooAbsReal.h. ◆ curveInvisible. bool RooAbsReal::PlotOpt::curveInvisible = false. Definition at line 479 of file RooAbsReal.h. ◆ curveName. const char* RooAbsReal::PlotOpt::curveName = nullptr. Definition at line 480 of file RooAbsReal.h. ◆ curveNameSuffix. const char* RooAbsReal::PlotOpt::curveNameSuffix = """". Definition at line 486 of file RooAbsReal.h. ◆ doeeval. bool RooAbsReal::PlotOpt::doeeval = false. Definition at line 489 of file RooAbsReal.h. ◆ drawOptions. Option_t* RooAbsReal::PlotOpt::drawOptions = ""L"". Definition at line 464 of file RooAbsReal.h. ◆ eeval. double RooAbsReal::PlotOpt::eeval = 0.0. Definition at line 488 of file RooAbsReal.h. ◆ errorFR. const RooFitResult* RooAbsReal::PlotOpt::errorFR = nullptr. Definition at line 491 of file RooAbsReal.h. ◆ interleave. RooFit::MPSplit RooAbsReal::PlotOpt::interleave = RooFit::Interleave. Definition at line 485 of file RooAbsReal.h. ◆ normRangeName. const char* RooAbsReal::PlotOpt::normRangeName = nullptr. Definition at line 473 of file RooAbsReal.h. ◆ numCPU. Int_t RooAbsReal::PlotOpt::numCPU = 1. Definition at line 484 of file RooAbsReal.h. ◆ numee. Int_t RooAbsReal::PlotOpt::numee = 10. Definition at line 487 of file RooAbsReal.h. ◆ postRangeFracScale. bool RooAbsReal::PlotOpt::postRangeFracScale = false. Definition at line 476 of file RooAbsReal.h. ◆ precision. double RooAbsReal::PlotOpt::precision = 1e-3. Definition at line 470 of file RooAbsReal.h. ◆ progress. bool RooAbsReal::PlotOpt::progress = false. Definition at line 490 of file RooAbsReal.h. ◆ projData. const RooAbsData* RooAbsReal::PlotOpt::projData = nullptr. Definition at line 467 of file RooAbsReal.h. ◆ projDataS",MatchSource.WIKI,doc/master/structRooAbsReal_1_1PlotOpt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooAbsReal_1_1PlotOpt.html
https://root.cern/doc/master/structRooAbsReal_1_1PlotOpt.html:2448,Availability,error,errorFR,2448,". double RooAbsReal::PlotOpt::addToWgtOther = 1.0. Definition at line 483 of file RooAbsReal.h. ◆ addToWgtSelf. double RooAbsReal::PlotOpt::addToWgtSelf = 1.0. Definition at line 482 of file RooAbsReal.h. ◆ binProjData. bool RooAbsReal::PlotOpt::binProjData = false. Definition at line 468 of file RooAbsReal.h. ◆ curveInvisible. bool RooAbsReal::PlotOpt::curveInvisible = false. Definition at line 479 of file RooAbsReal.h. ◆ curveName. const char* RooAbsReal::PlotOpt::curveName = nullptr. Definition at line 480 of file RooAbsReal.h. ◆ curveNameSuffix. const char* RooAbsReal::PlotOpt::curveNameSuffix = """". Definition at line 486 of file RooAbsReal.h. ◆ doeeval. bool RooAbsReal::PlotOpt::doeeval = false. Definition at line 489 of file RooAbsReal.h. ◆ drawOptions. Option_t* RooAbsReal::PlotOpt::drawOptions = ""L"". Definition at line 464 of file RooAbsReal.h. ◆ eeval. double RooAbsReal::PlotOpt::eeval = 0.0. Definition at line 488 of file RooAbsReal.h. ◆ errorFR. const RooFitResult* RooAbsReal::PlotOpt::errorFR = nullptr. Definition at line 491 of file RooAbsReal.h. ◆ interleave. RooFit::MPSplit RooAbsReal::PlotOpt::interleave = RooFit::Interleave. Definition at line 485 of file RooAbsReal.h. ◆ normRangeName. const char* RooAbsReal::PlotOpt::normRangeName = nullptr. Definition at line 473 of file RooAbsReal.h. ◆ numCPU. Int_t RooAbsReal::PlotOpt::numCPU = 1. Definition at line 484 of file RooAbsReal.h. ◆ numee. Int_t RooAbsReal::PlotOpt::numee = 10. Definition at line 487 of file RooAbsReal.h. ◆ postRangeFracScale. bool RooAbsReal::PlotOpt::postRangeFracScale = false. Definition at line 476 of file RooAbsReal.h. ◆ precision. double RooAbsReal::PlotOpt::precision = 1e-3. Definition at line 470 of file RooAbsReal.h. ◆ progress. bool RooAbsReal::PlotOpt::progress = false. Definition at line 490 of file RooAbsReal.h. ◆ projData. const RooAbsData* RooAbsReal::PlotOpt::projData = nullptr. Definition at line 467 of file RooAbsReal.h. ◆ projDataSet. const RooArgSet* RooAbsReal::Pl",MatchSource.WIKI,doc/master/structRooAbsReal_1_1PlotOpt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooAbsReal_1_1PlotOpt.html
https://root.cern/doc/master/structRooFit_1_1UniqueId.html:526,Modifiability,enhance,enhance,526,. ROOT: RooFit::UniqueId< Class > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Static Public Attributes |; Private Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; RooFit::UniqueId< Class > Struct Template Reference. ; template<class Class>; struct RooFit::UniqueId< Class >A UniqueId can be added as a class member to enhance any class with a unique identifier for each instantiated object. ; Example: class MyClass {; ; public:; /// Return unique ID by reference.; /// Please always use the name `uniqueId` for the getter.; UniqueId<MyClass> const& uniqueId() const { return _uniqueId; }; ; private:; const UniqueId<MyClass> _uniqueId; //! should be non-persistent; ; };; RooFit::UniqueIdA UniqueId can be added as a class member to enhance any class with a unique identifier for each inst...Definition UniqueId.h:39. Definition at line 39 of file UniqueId.h. Public Types; using Value_t = unsigned long;  . Public Member Functions;  UniqueId ();  Create a new UniqueId with the next value from the static counter. ;  ;  UniqueId (const UniqueId &)=delete;  ;  UniqueId (UniqueId &&)=delete;  ;  operator Value_t () const;  ; bool operator< (UniqueId const &other) const;  ; UniqueId & operator= (const UniqueId &)=delete;  ; UniqueId & operator= (UniqueId &&)=delete;  ; bool operator== (UniqueId const &other) const;  ; constexpr Value_t value () const;  Return numerical value of ID. ;  . Static Public Member Functions; static UniqueId const & nullid ();  Get an ID that is less than the ID of any object (similar to nullptr). ;  . Static Public Attributes; static constexpr Value_t nullval = 0UL;  The value of the nullid. ;  . Private Member Functions;  UniqueId (Value_t val);  . Private Attributes; Value_t _val;  Numerical value of the ID. ;  . Static Private Attributes; static std:,MatchSource.WIKI,doc/master/structRooFit_1_1UniqueId.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooFit_1_1UniqueId.html
https://root.cern/doc/master/structRooFit_1_1UniqueId.html:942,Modifiability,enhance,enhance,942,. ROOT: RooFit::UniqueId< Class > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Static Public Attributes |; Private Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; RooFit::UniqueId< Class > Struct Template Reference. ; template<class Class>; struct RooFit::UniqueId< Class >A UniqueId can be added as a class member to enhance any class with a unique identifier for each instantiated object. ; Example: class MyClass {; ; public:; /// Return unique ID by reference.; /// Please always use the name `uniqueId` for the getter.; UniqueId<MyClass> const& uniqueId() const { return _uniqueId; }; ; private:; const UniqueId<MyClass> _uniqueId; //! should be non-persistent; ; };; RooFit::UniqueIdA UniqueId can be added as a class member to enhance any class with a unique identifier for each inst...Definition UniqueId.h:39. Definition at line 39 of file UniqueId.h. Public Types; using Value_t = unsigned long;  . Public Member Functions;  UniqueId ();  Create a new UniqueId with the next value from the static counter. ;  ;  UniqueId (const UniqueId &)=delete;  ;  UniqueId (UniqueId &&)=delete;  ;  operator Value_t () const;  ; bool operator< (UniqueId const &other) const;  ; UniqueId & operator= (const UniqueId &)=delete;  ; UniqueId & operator= (UniqueId &&)=delete;  ; bool operator== (UniqueId const &other) const;  ; constexpr Value_t value () const;  Return numerical value of ID. ;  . Static Public Member Functions; static UniqueId const & nullid ();  Get an ID that is less than the ID of any object (similar to nullptr). ;  . Static Public Attributes; static constexpr Value_t nullval = 0UL;  The value of the nullid. ;  . Private Member Functions;  UniqueId (Value_t val);  . Private Attributes; Value_t _val;  Numerical value of the ID. ;  . Static Private Attributes; static std:,MatchSource.WIKI,doc/master/structRooFit_1_1UniqueId.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooFit_1_1UniqueId.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:2342,Availability,error,error,2342,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:2431,Availability,error,error,2431,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:2586,Availability,error,error,2586,";  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title o",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:2883,Availability,error,error,2883,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:7557,Availability,error,error,7557,"ead (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; T * _payload;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWrite",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:2348,Integrability,message,message,2348,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:2889,Integrability,message,message,2889,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:4091,Integrability,message,message,4091,"ived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const ch",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:7563,Integrability,message,message,7563,"ead (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; T * _payload;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWrite",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:7936,Integrability,message,message,7936,"rimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; T * _payload;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Stati",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:581,Modifiability,inherit,inherited,581,". ROOT: RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; template<typename T>; struct RooHelpers::WrapIntoTObject< T >Wrap an object into a TObject. Sometimes needed to avoid reinterpret_cast or enable RTTI. ; Definition at line 57 of file RooHelpers.h. Public Member Functions;  WrapIntoTObject (T &obj);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:1978,Modifiability,inherit,inheritance,1978,"pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:4189,Modifiability,inherit,inherits,4189,"ed by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a b",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:4306,Modifiability,inherit,inherits,4306,"ame of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not pro",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:8298,Modifiability,inherit,inherited,8298,");  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; T * _payload;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObject",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:8954,Modifiability,inherit,inherited,8954,"e current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; T * _payload;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <RooHelpers.h>. Inheritance diagram for RooHelpers::WrapIntoTObject< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ WrapIntoTObject(). template<typename T > . RooHelpers::WrapIntoTObject< T >::WrapIntoTObject ;",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:9457,Modifiability,inherit,inherited,9457," 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <RooHelpers.h>. Inheritance diagram for RooHelpers::WrapIntoTObject< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ WrapIntoTObject(). template<typename T > . RooHelpers::WrapIntoTObject< T >::WrapIntoTObject ; (; T & ; obj). inline . Definition at line 58 of file RooHelpers.h. Member Data Documentation. ◆ _payload. template<typename T > . T* RooHelpers::WrapIntoTObject< T >::_payload. Definition at line 59 of file RooHelpers.h. Collaboration diagram for RooHelpers::WrapIntoTObject< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; roofit/roofitcore/inc/RooHelpers.h. RooHelpersWrapIntoTObject. ",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:9556,Modifiability,inherit,inherited,9556," 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <RooHelpers.h>. Inheritance diagram for RooHelpers::WrapIntoTObject< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ WrapIntoTObject(). template<typename T > . RooHelpers::WrapIntoTObject< T >::WrapIntoTObject ; (; T & ; obj). inline . Definition at line 58 of file RooHelpers.h. Member Data Documentation. ◆ _payload. template<typename T > . T* RooHelpers::WrapIntoTObject< T >::_payload. Definition at line 59 of file RooHelpers.h. Collaboration diagram for RooHelpers::WrapIntoTObject< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; roofit/roofitcore/inc/RooHelpers.h. RooHelpersWrapIntoTObject. ",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:416,Safety,avoid,avoid,416,". ROOT: RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; template<typename T>; struct RooHelpers::WrapIntoTObject< T >Wrap an object into a TObject. Sometimes needed to avoid reinterpret_cast or enable RTTI. ; Definition at line 57 of file RooHelpers.h. Public Member Functions;  WrapIntoTObject (T &obj);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html:3820,Security,hash,hash,3820," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other obje",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
https://root.cern/doc/master/structROOT_1_1Detail_1_1TCollectionProxyInfo_1_1Environ.html:752,Modifiability,inherit,inherited,752,". ROOT: ROOT::Detail::TCollectionProxyInfo::Environ< T > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Public Attributes |; List of all members ; ROOT::Detail::TCollectionProxyInfo::Environ< T > Class Template Reference. ; template<typename T>; class ROOT::Detail::TCollectionProxyInfo::Environ< T >Small helper to save proxy environment in the event of recursive calls. ; AuthorM.Frank ; Version1.0 ; Date10/10/2004 ; Definition at line 244 of file TCollectionProxyInfo.h. Public Types; typedef T Iter_t;  . Public Member Functions;  Environ ();  ; T & iter ();  ;  Public Member Functions inherited from ROOT::Detail::TCollectionProxyInfo::EnvironBase;  EnvironBase ();  ; virtual ~EnvironBase ();  . Static Public Member Functions; static void * Create ();  . Public Attributes; Iter_t fIterator;  ;  Public Attributes inherited from ROOT::Detail::TCollectionProxyInfo::EnvironBase; union { ;  ;    Bool_t   fLastValueVecBool ;  ;    Bool_t   fUseTemp ;  ; };  ;  ; size_t fIdx;  ; void * fObject;  ; int fRefCount;  ; size_t fSize;  ; size_t fSpace;  ; void * fStart;  ; void * fTemp;  . #include <TCollectionProxyInfo.h>. Inheritance diagram for ROOT::Detail::TCollectionProxyInfo::Environ< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Iter_t. template<typename T > . typedef T ROOT::Detail::TCollectionProxyInfo::Environ< T >::Iter_t. Definition at line 246 of file TCollectionProxyInfo.h. Constructor & Destructor Documentation. ◆ Environ(). template<typename T > . ROOT::Detail::TCollectionProxyInfo::Environ< T >::Environ ; (; ). inline . Definition at line 245 of file TCollectionProxyInfo.h. Member Function Documentation. ◆ Create(). template<typename T > . static void * ROOT::Detail::TCollectionProxyInfo::Environ< T >::Create ; (; ). in",MatchSource.WIKI,doc/master/structROOT_1_1Detail_1_1TCollectionProxyInfo_1_1Environ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Detail_1_1TCollectionProxyInfo_1_1Environ.html
https://root.cern/doc/master/structROOT_1_1Detail_1_1TCollectionProxyInfo_1_1Environ.html:983,Modifiability,inherit,inherited,983,"OT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Public Attributes |; List of all members ; ROOT::Detail::TCollectionProxyInfo::Environ< T > Class Template Reference. ; template<typename T>; class ROOT::Detail::TCollectionProxyInfo::Environ< T >Small helper to save proxy environment in the event of recursive calls. ; AuthorM.Frank ; Version1.0 ; Date10/10/2004 ; Definition at line 244 of file TCollectionProxyInfo.h. Public Types; typedef T Iter_t;  . Public Member Functions;  Environ ();  ; T & iter ();  ;  Public Member Functions inherited from ROOT::Detail::TCollectionProxyInfo::EnvironBase;  EnvironBase ();  ; virtual ~EnvironBase ();  . Static Public Member Functions; static void * Create ();  . Public Attributes; Iter_t fIterator;  ;  Public Attributes inherited from ROOT::Detail::TCollectionProxyInfo::EnvironBase; union { ;  ;    Bool_t   fLastValueVecBool ;  ;    Bool_t   fUseTemp ;  ; };  ;  ; size_t fIdx;  ; void * fObject;  ; int fRefCount;  ; size_t fSize;  ; size_t fSpace;  ; void * fStart;  ; void * fTemp;  . #include <TCollectionProxyInfo.h>. Inheritance diagram for ROOT::Detail::TCollectionProxyInfo::Environ< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Iter_t. template<typename T > . typedef T ROOT::Detail::TCollectionProxyInfo::Environ< T >::Iter_t. Definition at line 246 of file TCollectionProxyInfo.h. Constructor & Destructor Documentation. ◆ Environ(). template<typename T > . ROOT::Detail::TCollectionProxyInfo::Environ< T >::Environ ; (; ). inline . Definition at line 245 of file TCollectionProxyInfo.h. Member Function Documentation. ◆ Create(). template<typename T > . static void * ROOT::Detail::TCollectionProxyInfo::Environ< T >::Create ; (; ). inlinestatic . Definition at line 249 of file TCollectionProxyInfo.h. ◆ iter(). template<",MatchSource.WIKI,doc/master/structROOT_1_1Detail_1_1TCollectionProxyInfo_1_1Environ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Detail_1_1TCollectionProxyInfo_1_1Environ.html
https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RCStringTransformation.html:689,Modifiability,inherit,inherited,689,". ROOT: ROOT::Experimental::RNTupleImporter::RCStringTransformation Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; ROOT::Experimental::RNTupleImporter::RCStringTransformation Struct Reference. ; Transform a NULL terminated C string branch into an std::string field. ; Definition at line 196 of file RNTupleImporter.hxx. Public Member Functions;  RCStringTransformation (std::size_t b, std::size_t f);  ;  ~RCStringTransformation () override=default;  ; RResult< void > Transform (const RImportBranch &branch, RImportField &field) final;  ;  Public Member Functions inherited from ROOT::Experimental::RNTupleImporter::RImportTransformation;  RImportTransformation (std::size_t branchIdx, std::size_t fieldIdx);  ; virtual ~RImportTransformation ()=default;  . Additional Inherited Members;  Public Attributes inherited from ROOT::Experimental::RNTupleImporter::RImportTransformation; std::size_t fImportBranchIdx = 0;  ; std::size_t fImportFieldIdx = 0;  . Inheritance diagram for ROOT::Experimental::RNTupleImporter::RCStringTransformation:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RCStringTransformation(). ROOT::Experimental::RNTupleImporter::RCStringTransformation::RCStringTransformation ; (; std::size_t ; b, . std::size_t ; f . ). inline . Definition at line 197 of file RNTupleImporter.hxx. ◆ ~RCStringTransformation(). ROOT::Experimental::RNTupleImporter::RCStringTransformation::~RCStringTransformation ; (; ). overridedefault . Member Function Documentation. ◆ Transform(). ROOT::Experimental::RResult< void > ROOT::Experimental::RNTupleImporter::RCStringTransformation::Transform ; (; const RImportBranch & ; branch, . RImportField & ; field . ). finalvirtual . Implements ROOT::Experimental::RNTupleImporter::RImportTransformation.; Definition at line 73 of file RNTu",MatchSource.WIKI,doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RCStringTransformation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RCStringTransformation.html
https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RCStringTransformation.html:932,Modifiability,inherit,inherited,932,". ROOT: ROOT::Experimental::RNTupleImporter::RCStringTransformation Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; ROOT::Experimental::RNTupleImporter::RCStringTransformation Struct Reference. ; Transform a NULL terminated C string branch into an std::string field. ; Definition at line 196 of file RNTupleImporter.hxx. Public Member Functions;  RCStringTransformation (std::size_t b, std::size_t f);  ;  ~RCStringTransformation () override=default;  ; RResult< void > Transform (const RImportBranch &branch, RImportField &field) final;  ;  Public Member Functions inherited from ROOT::Experimental::RNTupleImporter::RImportTransformation;  RImportTransformation (std::size_t branchIdx, std::size_t fieldIdx);  ; virtual ~RImportTransformation ()=default;  . Additional Inherited Members;  Public Attributes inherited from ROOT::Experimental::RNTupleImporter::RImportTransformation; std::size_t fImportBranchIdx = 0;  ; std::size_t fImportFieldIdx = 0;  . Inheritance diagram for ROOT::Experimental::RNTupleImporter::RCStringTransformation:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RCStringTransformation(). ROOT::Experimental::RNTupleImporter::RCStringTransformation::RCStringTransformation ; (; std::size_t ; b, . std::size_t ; f . ). inline . Definition at line 197 of file RNTupleImporter.hxx. ◆ ~RCStringTransformation(). ROOT::Experimental::RNTupleImporter::RCStringTransformation::~RCStringTransformation ; (; ). overridedefault . Member Function Documentation. ◆ Transform(). ROOT::Experimental::RResult< void > ROOT::Experimental::RNTupleImporter::RCStringTransformation::Transform ; (; const RImportBranch & ; branch, . RImportField & ; field . ). finalvirtual . Implements ROOT::Experimental::RNTupleImporter::RImportTransformation.; Definition at line 73 of file RNTu",MatchSource.WIKI,doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RCStringTransformation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RCStringTransformation.html
https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RImportTransformation.html:360,Performance,perform,perform,360,". ROOT: ROOT::Experimental::RNTupleImporter::RImportTransformation Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Experimental::RNTupleImporter::RImportTransformation Struct Referenceabstract. ; Base class to perform data transformations from TTree branches to RNTuple fields if necessary. ; Definition at line 146 of file RNTupleImporter.hxx. Public Member Functions;  RImportTransformation (std::size_t branchIdx, std::size_t fieldIdx);  ; virtual ~RImportTransformation ()=default;  ; virtual RResult< void > Transform (const RImportBranch &branch, RImportField &field)=0;  . Public Attributes; std::size_t fImportBranchIdx = 0;  ; std::size_t fImportFieldIdx = 0;  . Inheritance diagram for ROOT::Experimental::RNTupleImporter::RImportTransformation:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RImportTransformation(). ROOT::Experimental::RNTupleImporter::RImportTransformation::RImportTransformation ; (; std::size_t ; branchIdx, . std::size_t ; fieldIdx . ). inline . Definition at line 150 of file RNTupleImporter.hxx. ◆ ~RImportTransformation(). virtual ROOT::Experimental::RNTupleImporter::RImportTransformation::~RImportTransformation ; (; ). virtualdefault . Member Function Documentation. ◆ Transform(). virtual RResult< void > ROOT::Experimental::RNTupleImporter::RImportTransformation::Transform ; (; const RImportBranch & ; branch, . RImportField & ; field . ). pure virtual . Implemented in ROOT::Experimental::RNTupleImporter::RCStringTransformation. Member Data Documentation. ◆ fImportBranchIdx. std::size_t ROOT::Experimental::RNTupleImporter::RImportTransformation::fImportBranchIdx = 0. Definition at line 147 of file RNTupleImporter.hxx. ◆ fImportFieldIdx. std::size_t ROOT::Experimental::RNTupleImporter::RImportTransformation::fI",MatchSource.WIKI,doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RImportTransformation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RImportTransformation.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions-members.html:217,Modifiability,inherit,inherited,217,". ROOT: Member List. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOT::Fit::DataOptions Member List. This is the complete list of members for ROOT::Fit::DataOptions, including all inherited members. DataOptions()ROOT::Fit::DataOptionsinline; fAsymErrorsROOT::Fit::DataOptions; fBinVolumeROOT::Fit::DataOptions; fCoordErrorsROOT::Fit::DataOptions; fErrors1ROOT::Fit::DataOptions; fExpErrorsROOT::Fit::DataOptions; fIntegralROOT::Fit::DataOptions; fNormBinVolumeROOT::Fit::DataOptions; fUseEmptyROOT::Fit::DataOptions; fUseRangeROOT::Fit::DataOptions. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:15 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions-members.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions-members.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:608,Availability,error,errors,608,". ROOT: ROOT::Fit::DataOptions Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Fit::DataOptions Struct ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; DataOptions : simple structure holding the options on how the data are filled. ; Definition at line 28 of file DataOptions.h. Public Member Functions;  DataOptions ();  Default constructor: use the default options. ;  . Public Attributes; bool fAsymErrors;  use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ;  ; bool fBinVolume;  normalize data by the bin volume (it is used in the Poisson likelihood fits) ;  ; bool fCoordErrors;  use errors on the x coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. n",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:633,Availability,avail,available,633,". ROOT: ROOT::Fit::DataOptions Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Fit::DataOptions Struct ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; DataOptions : simple structure holding the options on how the data are filled. ; Definition at line 28 of file DataOptions.h. Public Member Functions;  DataOptions ();  Default constructor: use the default options. ;  . Public Attributes; bool fAsymErrors;  use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ;  ; bool fBinVolume;  normalize data by the bin volume (it is used in the Poisson likelihood fits) ;  ; bool fCoordErrors;  use errors on the x coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. n",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:843,Availability,error,errors,843,". ROOT: ROOT::Fit::DataOptions Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Fit::DataOptions Struct ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; DataOptions : simple structure holding the options on how the data are filled. ; Definition at line 28 of file DataOptions.h. Public Member Functions;  DataOptions ();  Default constructor: use the default options. ;  . Public Attributes; bool fAsymErrors;  use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ;  ; bool fBinVolume;  normalize data by the bin volume (it is used in the Poisson likelihood fits) ;  ; bool fCoordErrors;  use errors on the x coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. n",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:876,Availability,avail,available,876,". ROOT: ROOT::Fit::DataOptions Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Fit::DataOptions Struct ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; DataOptions : simple structure holding the options on how the data are filled. ; Definition at line 28 of file DataOptions.h. Public Member Functions;  DataOptions ();  Default constructor: use the default options. ;  . Public Attributes; bool fAsymErrors;  use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ;  ; bool fBinVolume;  normalize data by the bin volume (it is used in the Poisson likelihood fits) ;  ; bool fCoordErrors;  use errors on the x coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. n",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:933,Availability,error,errors,933,". ROOT: ROOT::Fit::DataOptions Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Fit::DataOptions Struct ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; DataOptions : simple structure holding the options on how the data are filled. ; Definition at line 28 of file DataOptions.h. Public Member Functions;  DataOptions ();  Default constructor: use the default options. ;  . Public Attributes; bool fAsymErrors;  use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ;  ; bool fBinVolume;  normalize data by the bin volume (it is used in the Poisson likelihood fits) ;  ; bool fCoordErrors;  use errors on the x coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. n",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:969,Availability,error,errors,969,"f all members ; ROOT::Fit::DataOptions Struct ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; DataOptions : simple structure holding the options on how the data are filled. ; Definition at line 28 of file DataOptions.h. Public Member Functions;  DataOptions ();  Default constructor: use the default options. ;  . Public Attributes; bool fAsymErrors;  use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ;  ; bool fBinVolume;  normalize data by the bin volume (it is used in the Poisson likelihood fits) ;  ; bool fCoordErrors;  use errors on the x coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. normalize data by the bin volume (it is used in the Poisson likelihood fits) ; Definition at line 48 of file DataOptions.h. ◆ fCoordErrors. bool ROOT::Fit::DataOptions::fCoordErrors. use errors on the x coord",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:1031,Availability,error,errors,1031,"f all members ; ROOT::Fit::DataOptions Struct ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; DataOptions : simple structure holding the options on how the data are filled. ; Definition at line 28 of file DataOptions.h. Public Member Functions;  DataOptions ();  Default constructor: use the default options. ;  . Public Attributes; bool fAsymErrors;  use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ;  ; bool fBinVolume;  normalize data by the bin volume (it is used in the Poisson likelihood fits) ;  ; bool fCoordErrors;  use errors on the x coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. normalize data by the bin volume (it is used in the Poisson likelihood fits) ; Definition at line 48 of file DataOptions.h. ◆ fCoordErrors. bool ROOT::Fit::DataOptions::fCoordErrors. use errors on the x coord",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:1353,Availability,error,error,1353,"f all members ; ROOT::Fit::DataOptions Struct ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; DataOptions : simple structure holding the options on how the data are filled. ; Definition at line 28 of file DataOptions.h. Public Member Functions;  DataOptions ();  Default constructor: use the default options. ;  . Public Attributes; bool fAsymErrors;  use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ;  ; bool fBinVolume;  normalize data by the bin volume (it is used in the Poisson likelihood fits) ;  ; bool fCoordErrors;  use errors on the x coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. normalize data by the bin volume (it is used in the Poisson likelihood fits) ; Definition at line 48 of file DataOptions.h. ◆ fCoordErrors. bool ROOT::Fit::DataOptions::fCoordErrors. use errors on the x coord",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:1792,Availability,error,errors,1792,"coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. normalize data by the bin volume (it is used in the Poisson likelihood fits) ; Definition at line 48 of file DataOptions.h. ◆ fCoordErrors. bool ROOT::Fit::DataOptions::fCoordErrors. use errors on the x coordinates when available (default is true) ; Definition at line 54 of file DataOptions.h. ◆ fErrors1. bool ROOT::Fit::DataOptions::fErrors1. use all errors equal to 1, i.e. fit without errors (default is false) ; Definition at line 52 of file DataOptions.h. ◆ fExpErrors. bool ROOT::Fit::DataOptions::fExpErrors. use expected errors from the function and not from the data ; Definition at line 53 of file DataOptions.h. ◆ fIntegral. bool ROOT::Fit::DataOptions::fIntegral. use integral of bin content instead of bin center (default is false) ; Definition at line 47 of file DataOptions.h. ◆ fNormBinVolume. bool ROOT::Fit::DataOptions::fNormBinVolume. no",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:1817,Availability,avail,available,1817,"coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. normalize data by the bin volume (it is used in the Poisson likelihood fits) ; Definition at line 48 of file DataOptions.h. ◆ fCoordErrors. bool ROOT::Fit::DataOptions::fCoordErrors. use errors on the x coordinates when available (default is true) ; Definition at line 54 of file DataOptions.h. ◆ fErrors1. bool ROOT::Fit::DataOptions::fErrors1. use all errors equal to 1, i.e. fit without errors (default is false) ; Definition at line 52 of file DataOptions.h. ◆ fExpErrors. bool ROOT::Fit::DataOptions::fExpErrors. use expected errors from the function and not from the data ; Definition at line 53 of file DataOptions.h. ◆ fIntegral. bool ROOT::Fit::DataOptions::fIntegral. use integral of bin content instead of bin center (default is false) ; Definition at line 47 of file DataOptions.h. ◆ fNormBinVolume. bool ROOT::Fit::DataOptions::fNormBinVolume. no",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:2187,Availability,error,errors,2187,"lume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. normalize data by the bin volume (it is used in the Poisson likelihood fits) ; Definition at line 48 of file DataOptions.h. ◆ fCoordErrors. bool ROOT::Fit::DataOptions::fCoordErrors. use errors on the x coordinates when available (default is true) ; Definition at line 54 of file DataOptions.h. ◆ fErrors1. bool ROOT::Fit::DataOptions::fErrors1. use all errors equal to 1, i.e. fit without errors (default is false) ; Definition at line 52 of file DataOptions.h. ◆ fExpErrors. bool ROOT::Fit::DataOptions::fExpErrors. use expected errors from the function and not from the data ; Definition at line 53 of file DataOptions.h. ◆ fIntegral. bool ROOT::Fit::DataOptions::fIntegral. use integral of bin content instead of bin center (default is false) ; Definition at line 47 of file DataOptions.h. ◆ fNormBinVolume. bool ROOT::Fit::DataOptions::fNormBinVolume. normalize data by a normalized the bin volume (bin volume divided by a reference value) ; Definition at line 49 of file DataOptions.h. ◆ fUseEmpty. bool ROOT::Fit::DataOptions::fUseEmpty. use empty bins (default is false) with a fixed error of 1 ; Definition at line 50 of file DataOptions.h. ◆ fUseRange. bool ROOT::Fit::DataOptions::fUseRange. use the function range when creati",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:2220,Availability,avail,available,2220,"lume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. normalize data by the bin volume (it is used in the Poisson likelihood fits) ; Definition at line 48 of file DataOptions.h. ◆ fCoordErrors. bool ROOT::Fit::DataOptions::fCoordErrors. use errors on the x coordinates when available (default is true) ; Definition at line 54 of file DataOptions.h. ◆ fErrors1. bool ROOT::Fit::DataOptions::fErrors1. use all errors equal to 1, i.e. fit without errors (default is false) ; Definition at line 52 of file DataOptions.h. ◆ fExpErrors. bool ROOT::Fit::DataOptions::fExpErrors. use expected errors from the function and not from the data ; Definition at line 53 of file DataOptions.h. ◆ fIntegral. bool ROOT::Fit::DataOptions::fIntegral. use integral of bin content instead of bin center (default is false) ; Definition at line 47 of file DataOptions.h. ◆ fNormBinVolume. bool ROOT::Fit::DataOptions::fNormBinVolume. normalize data by a normalized the bin volume (bin volume divided by a reference value) ; Definition at line 49 of file DataOptions.h. ◆ fUseEmpty. bool ROOT::Fit::DataOptions::fUseEmpty. use empty bins (default is false) with a fixed error of 1 ; Definition at line 50 of file DataOptions.h. ◆ fUseRange. bool ROOT::Fit::DataOptions::fUseRange. use the function range when creati",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:2354,Availability,error,errors,2354,"f 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. normalize data by the bin volume (it is used in the Poisson likelihood fits) ; Definition at line 48 of file DataOptions.h. ◆ fCoordErrors. bool ROOT::Fit::DataOptions::fCoordErrors. use errors on the x coordinates when available (default is true) ; Definition at line 54 of file DataOptions.h. ◆ fErrors1. bool ROOT::Fit::DataOptions::fErrors1. use all errors equal to 1, i.e. fit without errors (default is false) ; Definition at line 52 of file DataOptions.h. ◆ fExpErrors. bool ROOT::Fit::DataOptions::fExpErrors. use expected errors from the function and not from the data ; Definition at line 53 of file DataOptions.h. ◆ fIntegral. bool ROOT::Fit::DataOptions::fIntegral. use integral of bin content instead of bin center (default is false) ; Definition at line 47 of file DataOptions.h. ◆ fNormBinVolume. bool ROOT::Fit::DataOptions::fNormBinVolume. normalize data by a normalized the bin volume (bin volume divided by a reference value) ; Definition at line 49 of file DataOptions.h. ◆ fUseEmpty. bool ROOT::Fit::DataOptions::fUseEmpty. use empty bins (default is false) with a fixed error of 1 ; Definition at line 50 of file DataOptions.h. ◆ fUseRange. bool ROOT::Fit::DataOptions::fUseRange. use the function range when creating the fit data (default is false) ; Definition at line 51 of file DataOptions.h. Collaboration diagram for ROOT::Fit::Data",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:2390,Availability,error,errors,2390,"ting the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. normalize data by the bin volume (it is used in the Poisson likelihood fits) ; Definition at line 48 of file DataOptions.h. ◆ fCoordErrors. bool ROOT::Fit::DataOptions::fCoordErrors. use errors on the x coordinates when available (default is true) ; Definition at line 54 of file DataOptions.h. ◆ fErrors1. bool ROOT::Fit::DataOptions::fErrors1. use all errors equal to 1, i.e. fit without errors (default is false) ; Definition at line 52 of file DataOptions.h. ◆ fExpErrors. bool ROOT::Fit::DataOptions::fExpErrors. use expected errors from the function and not from the data ; Definition at line 53 of file DataOptions.h. ◆ fIntegral. bool ROOT::Fit::DataOptions::fIntegral. use integral of bin content instead of bin center (default is false) ; Definition at line 47 of file DataOptions.h. ◆ fNormBinVolume. bool ROOT::Fit::DataOptions::fNormBinVolume. normalize data by a normalized the bin volume (bin volume divided by a reference value) ; Definition at line 49 of file DataOptions.h. ◆ fUseEmpty. bool ROOT::Fit::DataOptions::fUseEmpty. use empty bins (default is false) with a fixed error of 1 ; Definition at line 50 of file DataOptions.h. ◆ fUseRange. bool ROOT::Fit::DataOptions::fUseRange. use the function range when creating the fit data (default is false) ; Definition at line 51 of file DataOptions.h. Collaboration diagram for ROOT::Fit::DataOptions:. This browser is not able to show SVG: try Firefox",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:2531,Availability,error,errors,2531,"::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. normalize data by the bin volume (it is used in the Poisson likelihood fits) ; Definition at line 48 of file DataOptions.h. ◆ fCoordErrors. bool ROOT::Fit::DataOptions::fCoordErrors. use errors on the x coordinates when available (default is true) ; Definition at line 54 of file DataOptions.h. ◆ fErrors1. bool ROOT::Fit::DataOptions::fErrors1. use all errors equal to 1, i.e. fit without errors (default is false) ; Definition at line 52 of file DataOptions.h. ◆ fExpErrors. bool ROOT::Fit::DataOptions::fExpErrors. use expected errors from the function and not from the data ; Definition at line 53 of file DataOptions.h. ◆ fIntegral. bool ROOT::Fit::DataOptions::fIntegral. use integral of bin content instead of bin center (default is false) ; Definition at line 47 of file DataOptions.h. ◆ fNormBinVolume. bool ROOT::Fit::DataOptions::fNormBinVolume. normalize data by a normalized the bin volume (bin volume divided by a reference value) ; Definition at line 49 of file DataOptions.h. ◆ fUseEmpty. bool ROOT::Fit::DataOptions::fUseEmpty. use empty bins (default is false) with a fixed error of 1 ; Definition at line 50 of file DataOptions.h. ◆ fUseRange. bool ROOT::Fit::DataOptions::fUseRange. use the function range when creating the fit data (default is false) ; Definition at line 51 of file DataOptions.h. Collaboration diagram for ROOT::Fit::DataOptions:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; math/mathcore/inc/Fit/DataOpti",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:3092,Availability,error,error,3092,"ata Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. normalize data by the bin volume (it is used in the Poisson likelihood fits) ; Definition at line 48 of file DataOptions.h. ◆ fCoordErrors. bool ROOT::Fit::DataOptions::fCoordErrors. use errors on the x coordinates when available (default is true) ; Definition at line 54 of file DataOptions.h. ◆ fErrors1. bool ROOT::Fit::DataOptions::fErrors1. use all errors equal to 1, i.e. fit without errors (default is false) ; Definition at line 52 of file DataOptions.h. ◆ fExpErrors. bool ROOT::Fit::DataOptions::fExpErrors. use expected errors from the function and not from the data ; Definition at line 53 of file DataOptions.h. ◆ fIntegral. bool ROOT::Fit::DataOptions::fIntegral. use integral of bin content instead of bin center (default is false) ; Definition at line 47 of file DataOptions.h. ◆ fNormBinVolume. bool ROOT::Fit::DataOptions::fNormBinVolume. normalize data by a normalized the bin volume (bin volume divided by a reference value) ; Definition at line 49 of file DataOptions.h. ◆ fUseEmpty. bool ROOT::Fit::DataOptions::fUseEmpty. use empty bins (default is false) with a fixed error of 1 ; Definition at line 50 of file DataOptions.h. ◆ fUseRange. bool ROOT::Fit::DataOptions::fUseRange. use the function range when creating the fit data (default is false) ; Definition at line 51 of file DataOptions.h. Collaboration diagram for ROOT::Fit::DataOptions:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; math/mathcore/inc/Fit/DataOptions.h. ROOTFitDataOptions. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:15 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html:349,Usability,simpl,simple,349,". ROOT: ROOT::Fit::DataOptions Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Fit::DataOptions Struct ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; DataOptions : simple structure holding the options on how the data are filled. ; Definition at line 28 of file DataOptions.h. Public Member Functions;  DataOptions ();  Default constructor: use the default options. ;  . Public Attributes; bool fAsymErrors;  use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ;  ; bool fBinVolume;  normalize data by the bin volume (it is used in the Poisson likelihood fits) ;  ; bool fCoordErrors;  use errors on the x coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. n",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html:490,Energy Efficiency,allocate,allocate,490,. ROOT: ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Attributes |; Static Private Attributes |; List of all members ; ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; template<typename T>; struct ROOT::Internal::VecOps::RVecInlineStorageSize< T >The size of the inline storage of an RVec. ; Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline) unless the size of the buffer with 8 elements would be over a certain maximum size. ; Definition at line 512 of file RVec.hxx. Static Public Attributes; static constexpr unsigned value;  . Static Private Attributes; static constexpr std::size_t cacheLineSize = 64;  ; static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);  ; static constexpr unsigned maxInlineByteSize = 1024;  . #include <ROOT/RVec.hxx>; Member Data Documentation. ◆ cacheLineSize. template<typename T > . constexpr std::size_t ROOT::Internal::VecOps::RVecInlineStorageSize< T >::cacheLineSize = 64. staticconstexprprivate . Definition at line 518 of file RVec.hxx. ◆ elementsPerCacheLine. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T). staticconstexprprivate . Definition at line 520 of file RVec.hxx. ◆ maxInlineByteSize. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::maxInlineByteSize = 1024. staticconstexprprivate . Definition at line 521 of file RVec.hxx. ◆ value. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::value. staticconstexpr . Initial value:=; elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8); ROOT::Internal::VecOps::RVecInlineStorag,MatchSource.WIKI,doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html
https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html:553,Performance,cache,cacheline,553,. ROOT: ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Attributes |; Static Private Attributes |; List of all members ; ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; template<typename T>; struct ROOT::Internal::VecOps::RVecInlineStorageSize< T >The size of the inline storage of an RVec. ; Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline) unless the size of the buffer with 8 elements would be over a certain maximum size. ; Definition at line 512 of file RVec.hxx. Static Public Attributes; static constexpr unsigned value;  . Static Private Attributes; static constexpr std::size_t cacheLineSize = 64;  ; static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);  ; static constexpr unsigned maxInlineByteSize = 1024;  . #include <ROOT/RVec.hxx>; Member Data Documentation. ◆ cacheLineSize. template<typename T > . constexpr std::size_t ROOT::Internal::VecOps::RVecInlineStorageSize< T >::cacheLineSize = 64. staticconstexprprivate . Definition at line 518 of file RVec.hxx. ◆ elementsPerCacheLine. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T). staticconstexprprivate . Definition at line 520 of file RVec.hxx. ◆ maxInlineByteSize. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::maxInlineByteSize = 1024. staticconstexprprivate . Definition at line 521 of file RVec.hxx. ◆ value. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::value. staticconstexpr . Initial value:=; elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8); ROOT::Internal::VecOps::RVecInlineStorag,MatchSource.WIKI,doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html
https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html:809,Performance,cache,cacheLineSize,809,. ROOT: ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Attributes |; Static Private Attributes |; List of all members ; ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; template<typename T>; struct ROOT::Internal::VecOps::RVecInlineStorageSize< T >The size of the inline storage of an RVec. ; Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline) unless the size of the buffer with 8 elements would be over a certain maximum size. ; Definition at line 512 of file RVec.hxx. Static Public Attributes; static constexpr unsigned value;  . Static Private Attributes; static constexpr std::size_t cacheLineSize = 64;  ; static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);  ; static constexpr unsigned maxInlineByteSize = 1024;  . #include <ROOT/RVec.hxx>; Member Data Documentation. ◆ cacheLineSize. template<typename T > . constexpr std::size_t ROOT::Internal::VecOps::RVecInlineStorageSize< T >::cacheLineSize = 64. staticconstexprprivate . Definition at line 518 of file RVec.hxx. ◆ elementsPerCacheLine. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T). staticconstexprprivate . Definition at line 520 of file RVec.hxx. ◆ maxInlineByteSize. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::maxInlineByteSize = 1024. staticconstexprprivate . Definition at line 521 of file RVec.hxx. ◆ value. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::value. staticconstexpr . Initial value:=; elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8); ROOT::Internal::VecOps::RVecInlineStorag,MatchSource.WIKI,doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html
https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html:882,Performance,cache,cacheLineSize,882,. ROOT: ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Attributes |; Static Private Attributes |; List of all members ; ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; template<typename T>; struct ROOT::Internal::VecOps::RVecInlineStorageSize< T >The size of the inline storage of an RVec. ; Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline) unless the size of the buffer with 8 elements would be over a certain maximum size. ; Definition at line 512 of file RVec.hxx. Static Public Attributes; static constexpr unsigned value;  . Static Private Attributes; static constexpr std::size_t cacheLineSize = 64;  ; static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);  ; static constexpr unsigned maxInlineByteSize = 1024;  . #include <ROOT/RVec.hxx>; Member Data Documentation. ◆ cacheLineSize. template<typename T > . constexpr std::size_t ROOT::Internal::VecOps::RVecInlineStorageSize< T >::cacheLineSize = 64. staticconstexprprivate . Definition at line 518 of file RVec.hxx. ◆ elementsPerCacheLine. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T). staticconstexprprivate . Definition at line 520 of file RVec.hxx. ◆ maxInlineByteSize. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::maxInlineByteSize = 1024. staticconstexprprivate . Definition at line 521 of file RVec.hxx. ◆ value. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::value. staticconstexpr . Initial value:=; elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8); ROOT::Internal::VecOps::RVecInlineStorag,MatchSource.WIKI,doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html
https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html:1049,Performance,cache,cacheLineSize,1049, T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Attributes |; Static Private Attributes |; List of all members ; ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; template<typename T>; struct ROOT::Internal::VecOps::RVecInlineStorageSize< T >The size of the inline storage of an RVec. ; Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline) unless the size of the buffer with 8 elements would be over a certain maximum size. ; Definition at line 512 of file RVec.hxx. Static Public Attributes; static constexpr unsigned value;  . Static Private Attributes; static constexpr std::size_t cacheLineSize = 64;  ; static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);  ; static constexpr unsigned maxInlineByteSize = 1024;  . #include <ROOT/RVec.hxx>; Member Data Documentation. ◆ cacheLineSize. template<typename T > . constexpr std::size_t ROOT::Internal::VecOps::RVecInlineStorageSize< T >::cacheLineSize = 64. staticconstexprprivate . Definition at line 518 of file RVec.hxx. ◆ elementsPerCacheLine. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T). staticconstexprprivate . Definition at line 520 of file RVec.hxx. ◆ maxInlineByteSize. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::maxInlineByteSize = 1024. staticconstexprprivate . Definition at line 521 of file RVec.hxx. ◆ value. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::value. staticconstexpr . Initial value:=; elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8); ROOT::Internal::VecOps::RVecInlineStorageSize::maxInlineByteSizestatic constexpr unsigned maxI,MatchSource.WIKI,doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html
https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html:1162,Performance,cache,cacheLineSize,1162,ng...; Searching...; No Matches. List of all members |; Static Public Attributes |; Static Private Attributes |; List of all members ; ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; template<typename T>; struct ROOT::Internal::VecOps::RVecInlineStorageSize< T >The size of the inline storage of an RVec. ; Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline) unless the size of the buffer with 8 elements would be over a certain maximum size. ; Definition at line 512 of file RVec.hxx. Static Public Attributes; static constexpr unsigned value;  . Static Private Attributes; static constexpr std::size_t cacheLineSize = 64;  ; static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);  ; static constexpr unsigned maxInlineByteSize = 1024;  . #include <ROOT/RVec.hxx>; Member Data Documentation. ◆ cacheLineSize. template<typename T > . constexpr std::size_t ROOT::Internal::VecOps::RVecInlineStorageSize< T >::cacheLineSize = 64. staticconstexprprivate . Definition at line 518 of file RVec.hxx. ◆ elementsPerCacheLine. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T). staticconstexprprivate . Definition at line 520 of file RVec.hxx. ◆ maxInlineByteSize. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::maxInlineByteSize = 1024. staticconstexprprivate . Definition at line 521 of file RVec.hxx. ◆ value. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::value. staticconstexpr . Initial value:=; elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8); ROOT::Internal::VecOps::RVecInlineStorageSize::maxInlineByteSizestatic constexpr unsigned maxInlineByteSizeDefinition RVec.hxx:521; ROOT::Internal::VecOps::RVecInlineStorage,MatchSource.WIKI,doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html
https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html:1391,Performance,cache,cacheLineSize,1391,; struct ROOT::Internal::VecOps::RVecInlineStorageSize< T >The size of the inline storage of an RVec. ; Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline) unless the size of the buffer with 8 elements would be over a certain maximum size. ; Definition at line 512 of file RVec.hxx. Static Public Attributes; static constexpr unsigned value;  . Static Private Attributes; static constexpr std::size_t cacheLineSize = 64;  ; static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);  ; static constexpr unsigned maxInlineByteSize = 1024;  . #include <ROOT/RVec.hxx>; Member Data Documentation. ◆ cacheLineSize. template<typename T > . constexpr std::size_t ROOT::Internal::VecOps::RVecInlineStorageSize< T >::cacheLineSize = 64. staticconstexprprivate . Definition at line 518 of file RVec.hxx. ◆ elementsPerCacheLine. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T). staticconstexprprivate . Definition at line 520 of file RVec.hxx. ◆ maxInlineByteSize. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::maxInlineByteSize = 1024. staticconstexprprivate . Definition at line 521 of file RVec.hxx. ◆ value. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::value. staticconstexpr . Initial value:=; elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8); ROOT::Internal::VecOps::RVecInlineStorageSize::maxInlineByteSizestatic constexpr unsigned maxInlineByteSizeDefinition RVec.hxx:521; ROOT::Internal::VecOps::RVecInlineStorageSize::elementsPerCacheLinestatic constexpr unsigned elementsPerCacheLineDefinition RVec.hxx:520. Definition at line 524 of file RVec.hxx. Collaboration diagram for ROOT::Internal::VecOps::RVecInlineStorageSize< T >:. This browser is not,MatchSource.WIKI,doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html
https://root.cern/doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html:560,Availability,error,error,560,". ROOT: ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Dummy Structure which flags an error to avoid assignment from expression based on a general matrix to a symmetric matrix. ; Definition at line 131 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &, const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > &);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; , . const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > & ;  . ). inlinestatic . Definition at line 133 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathAssign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:19 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html
https://root.cern/doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html:569,Safety,avoid,avoid,569,". ROOT: ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Dummy Structure which flags an error to avoid assignment from expression based on a general matrix to a symmetric matrix. ; Definition at line 131 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &, const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > &);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; , . const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > & ;  . ). inlinestatic . Definition at line 133 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathAssign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:19 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html
https://root.cern/doc/master/structROOT_1_1Math_1_1CDFWrapper.html:662,Modifiability,inherit,inherited,662,". ROOT: ROOT::Math::CDFWrapper Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::CDFWrapper Struct Reference. . Definition at line 40 of file GoFTest.cxx. Public Member Functions;  CDFWrapper (const IGenFunction &cdf, Double_t xmin=0, Double_t xmax=-1);  ;  ~CDFWrapper () override;  ; IGenFunction * Clone () const override;  Clone a function. ;  ; Double_t DoEval (Double_t x) const override;  implementation of the evaluation function. Must be implemented by derived classes ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  . Public Attributes; const IGenFunction * fCDF;  ; Double_t fNorm;  ; Double_t fXmax;  ; Double_t fXmin;  . Additional Inherited Members;  Public Types inherited from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  . Inheritance diagram for ROOT::Math::CDFWrapper:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~CDFWrapper(). ROOT::Math::CDFWrapper::~CDFWrapper ; (; ). inlineoverride . Definition at line 48 of file GoFTest.cxx. ◆ CDFWrapper(). ROOT::Math::CDFWrapper::CDFWrapper ; (; const IGenFunction & ; cdf, . Double_t ; xmin = 0, . Double_t ; xmax = -1 . ). inline . Definition at line 50 of file GoFTest.cxx. Member Function Documentation. ◆ Clone(). IGenFunction * ROOT::Math::CDFWrapper::Clone ; (; ); const. inlineoverridevirtual . Clone a function. ; Each derived class will implement their version of the private DoClone method. ; Implements ROOT::Math::IBaseFunctionOneDim.; Definition at line 71 of file GoFTest.cx",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1CDFWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1CDFWrapper.html
https://root.cern/doc/master/structROOT_1_1Math_1_1CDFWrapper.html:1107,Modifiability,inherit,inherited,1107,". List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::CDFWrapper Struct Reference. . Definition at line 40 of file GoFTest.cxx. Public Member Functions;  CDFWrapper (const IGenFunction &cdf, Double_t xmin=0, Double_t xmax=-1);  ;  ~CDFWrapper () override;  ; IGenFunction * Clone () const override;  Clone a function. ;  ; Double_t DoEval (Double_t x) const override;  implementation of the evaluation function. Must be implemented by derived classes ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  . Public Attributes; const IGenFunction * fCDF;  ; Double_t fNorm;  ; Double_t fXmax;  ; Double_t fXmin;  . Additional Inherited Members;  Public Types inherited from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  . Inheritance diagram for ROOT::Math::CDFWrapper:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~CDFWrapper(). ROOT::Math::CDFWrapper::~CDFWrapper ; (; ). inlineoverride . Definition at line 48 of file GoFTest.cxx. ◆ CDFWrapper(). ROOT::Math::CDFWrapper::CDFWrapper ; (; const IGenFunction & ; cdf, . Double_t ; xmin = 0, . Double_t ; xmax = -1 . ). inline . Definition at line 50 of file GoFTest.cxx. Member Function Documentation. ◆ Clone(). IGenFunction * ROOT::Math::CDFWrapper::Clone ; (; ); const. inlineoverridevirtual . Clone a function. ; Each derived class will implement their version of the private DoClone method. ; Implements ROOT::Math::IBaseFunctionOneDim.; Definition at line 71 of file GoFTest.cxx. ◆ DoEval(). Double_t ROOT::Math::CDFWrapper::DoEval ; (; Double_t ; x); const. inlineoverridevirtual . implementation of the ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1CDFWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1CDFWrapper.html
https://root.cern/doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation.html:886,Availability,error,error,886,". ROOT: ROOT::Math::GeneralLinearFunctionDerivation< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::GeneralLinearFunctionDerivation< T > Struct Template Reference. ; template<class T>; struct ROOT::Math::GeneralLinearFunctionDerivation< T >Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar. ; WrappedMultiTF1Templ::DoParameterDerivation calls TFormula::EvalPar in the case of a general linear function built with TFormula using ++; as EvalPar is not vectorized, in order to generalize DoParameterDerivative with a general type T, we use this auxiliar class to branch the code in compile time with the double specialization (that can call EvalPar) and the general implementation (that throws an error in the case of general linear function). ; Definition at line 203 of file WrappedMultiTF1.h. Static Public Member Functions; static T DoParameterDerivative (const WrappedMultiTF1Templ< T > *, const T *, unsigned int);  . #include <Math/WrappedMultiTF1.h>; Member Function Documentation. ◆ DoParameterDerivative(). template<class T > . static T ROOT::Math::GeneralLinearFunctionDerivation< T >::DoParameterDerivative ; (; const WrappedMultiTF1Templ< T > * ; , . const T * ; , . unsigned int ;  . ). inlinestatic . Definition at line 204 of file WrappedMultiTF1.h. The documentation for this struct was generated from the following file:; hist/hist/inc/Math/WrappedMultiTF1.h. ROOTMathGeneralLinearFunctionDerivation. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation.html
https://root.cern/doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation_3_01double_01_4.html:471,Integrability,wrap,wrappedFunc,471,". ROOT: ROOT::Math::GeneralLinearFunctionDerivation< double > Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::GeneralLinearFunctionDerivation< double > Struct Reference. . Definition at line 214 of file WrappedMultiTF1.h. Static Public Member Functions; static double DoParameterDerivative (const WrappedMultiTF1Templ< double > *wrappedFunc, const double *x, unsigned int ipar);  . #include <Math/WrappedMultiTF1.h>; Member Function Documentation. ◆ DoParameterDerivative(). static double ROOT::Math::GeneralLinearFunctionDerivation< double >::DoParameterDerivative ; (; const WrappedMultiTF1Templ< double > * ; wrappedFunc, . const double * ; x, . unsigned int ; ipar . ). inlinestatic . Definition at line 216 of file WrappedMultiTF1.h. The documentation for this struct was generated from the following file:; hist/hist/inc/Math/WrappedMultiTF1.h. ROOTMathGeneralLinearFunctionDerivation< double >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation_3_01double_01_4.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation_3_01double_01_4.html
https://root.cern/doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation_3_01double_01_4.html:754,Integrability,wrap,wrappedFunc,754,". ROOT: ROOT::Math::GeneralLinearFunctionDerivation< double > Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::GeneralLinearFunctionDerivation< double > Struct Reference. . Definition at line 214 of file WrappedMultiTF1.h. Static Public Member Functions; static double DoParameterDerivative (const WrappedMultiTF1Templ< double > *wrappedFunc, const double *x, unsigned int ipar);  . #include <Math/WrappedMultiTF1.h>; Member Function Documentation. ◆ DoParameterDerivative(). static double ROOT::Math::GeneralLinearFunctionDerivation< double >::DoParameterDerivative ; (; const WrappedMultiTF1Templ< double > * ; wrappedFunc, . const double * ; x, . unsigned int ; ipar . ). inlinestatic . Definition at line 216 of file WrappedMultiTF1.h. The documentation for this struct was generated from the following file:; hist/hist/inc/Math/WrappedMultiTF1.h. ROOTMathGeneralLinearFunctionDerivation< double >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation_3_01double_01_4.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation_3_01double_01_4.html
https://root.cern/doc/master/structROOT_1_1Math_1_1GSLMultiMinFunctionAdapter.html:508,Energy Efficiency,adapt,adapting,508,". ROOT: ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc > Struct Template ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Multi-dimensional Minimization. ; template<class UserFunc>; struct ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. ; The templated C++ function class must implement:; double operator( const double * x) and if the derivatives are required: void Gradient( const double * x, double * g); This class defines static methods with will be used to fill the gsl_multimin_function and gsl_multimin_function_fdf structs used by GSL. See for examples the GSL online manual ; Definition at line 66 of file GSLMultiMinFunctionAdapter.h. Static Public Member Functions; static void Df (const gsl_vector *x, void *p, gsl_vector *g);  ; static double F (const gsl_vector *x, void *p);  ; static void Fdf (const gsl_vector *x, void *p, double *f, gsl_vector *g);  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLMultiMinFunctionAdapter.h>; Member Function Documentation. ◆ Df(). template<class UserFunc > . static void ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::Df ; (; const gsl_vector * ; x, . void * ; p, . gsl_vector * ; g . ). inlinestatic . Definition at line 76 of file GSLMultiMinFunctionAdapter.h. ◆ F(). template<class UserFunc > . static double ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::F ; (; const gsl_vector * ; x, . void * ; p . ). inlinestatic . Definition at line 68 of file GSLMultiMinFunctionAdapter.h. ◆ Fdf(). template<class UserFunc > . static void ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::Fdf ; (; const gsl_ve",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GSLMultiMinFunctionAdapter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GSLMultiMinFunctionAdapter.html
https://root.cern/doc/master/structROOT_1_1Math_1_1GSLMultiMinFunctionAdapter.html:508,Modifiability,adapt,adapting,508,". ROOT: ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc > Struct Template ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Multi-dimensional Minimization. ; template<class UserFunc>; struct ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. ; The templated C++ function class must implement:; double operator( const double * x) and if the derivatives are required: void Gradient( const double * x, double * g); This class defines static methods with will be used to fill the gsl_multimin_function and gsl_multimin_function_fdf structs used by GSL. See for examples the GSL online manual ; Definition at line 66 of file GSLMultiMinFunctionAdapter.h. Static Public Member Functions; static void Df (const gsl_vector *x, void *p, gsl_vector *g);  ; static double F (const gsl_vector *x, void *p);  ; static void Fdf (const gsl_vector *x, void *p, double *f, gsl_vector *g);  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLMultiMinFunctionAdapter.h>; Member Function Documentation. ◆ Df(). template<class UserFunc > . static void ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::Df ; (; const gsl_vector * ; x, . void * ; p, . gsl_vector * ; g . ). inlinestatic . Definition at line 76 of file GSLMultiMinFunctionAdapter.h. ◆ F(). template<class UserFunc > . static double ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::F ; (; const gsl_vector * ; x, . void * ; p . ). inlinestatic . Definition at line 68 of file GSLMultiMinFunctionAdapter.h. ◆ Fdf(). template<class UserFunc > . static void ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::Fdf ; (; const gsl_ve",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GSLMultiMinFunctionAdapter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GSLMultiMinFunctionAdapter.html
https://root.cern/doc/master/structROOT_1_1Math_1_1GSLRngROOTWrapper.html:731,Energy Efficiency,allocate,allocated,731,". ROOT: ROOT::Math::GSLRngROOTWrapper< Engine > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::GSLRngROOTWrapper< Engine > Struct Template Reference. ; template<class Engine>; struct ROOT::Math::GSLRngROOTWrapper< Engine >class for wrapping ROOT Engines in gsl_rng types which can be used as extra GSL random number generators For this we need to implement functions which will be called by gsl_rng. ; The functions (Seed, Rndm, IntRndm) are passed in the gsl_rng_type and used to build a gsl_rng object. When gsl_rng is alloacated, only the memory state is allocated using calloc(1,size), which gives a memory block of the given bytes and it initializes to zero. Therefore no constructor of GSLRngROOTWrapper can be called and also we cannot call non-static member function of the class. The underlined ROOT engine is then built and deleted using the functions CreateEngine() and FreeEngine(), called by the specific GSLRandomEngine class that instantiates for the the generator (e.g. GSLRngMixMax) ; Definition at line 39 of file GSLRngROOTWrapper.h. Static Public Member Functions; static void CreateEngine (gsl_rng *r);  ; static void FreeEngine (gsl_rng *r);  ; static unsigned long IntRndm (void *p);  ; static unsigned long Max ();  ; static unsigned long Min ();  ; static std::string Name ();  ; static double Rndm (void *p);  ; static void Seed (void *p, unsigned long seed);  ; static size_t Size ();  . Public Attributes; Engine * fEngine = nullptr;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLRngROOTWrapper.h>; Member Function Documentation. ◆ CreateEngine(). template<class Engine > . static void ROOT::Math::GSLRngROOTWrapper< Engine >::CreateEngine ; (; gsl_rng * ; r). inlinestatic . Definition at line 46 of file GSLRngROOTWrapper.h. ◆ FreeEngi",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GSLRngROOTWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GSLRngROOTWrapper.html
https://root.cern/doc/master/structROOT_1_1Math_1_1GSLRngROOTWrapper.html:405,Integrability,wrap,wrapping,405,". ROOT: ROOT::Math::GSLRngROOTWrapper< Engine > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::GSLRngROOTWrapper< Engine > Struct Template Reference. ; template<class Engine>; struct ROOT::Math::GSLRngROOTWrapper< Engine >class for wrapping ROOT Engines in gsl_rng types which can be used as extra GSL random number generators For this we need to implement functions which will be called by gsl_rng. ; The functions (Seed, Rndm, IntRndm) are passed in the gsl_rng_type and used to build a gsl_rng object. When gsl_rng is alloacated, only the memory state is allocated using calloc(1,size), which gives a memory block of the given bytes and it initializes to zero. Therefore no constructor of GSLRngROOTWrapper can be called and also we cannot call non-static member function of the class. The underlined ROOT engine is then built and deleted using the functions CreateEngine() and FreeEngine(), called by the specific GSLRandomEngine class that instantiates for the the generator (e.g. GSLRngMixMax) ; Definition at line 39 of file GSLRngROOTWrapper.h. Static Public Member Functions; static void CreateEngine (gsl_rng *r);  ; static void FreeEngine (gsl_rng *r);  ; static unsigned long IntRndm (void *p);  ; static unsigned long Max ();  ; static unsigned long Min ();  ; static std::string Name ();  ; static double Rndm (void *p);  ; static void Seed (void *p, unsigned long seed);  ; static size_t Size ();  . Public Attributes; Engine * fEngine = nullptr;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLRngROOTWrapper.h>; Member Function Documentation. ◆ CreateEngine(). template<class Engine > . static void ROOT::Math::GSLRngROOTWrapper< Engine >::CreateEngine ; (; gsl_rng * ; r). inlinestatic . Definition at line 46 of file GSLRngROOTWrapper.h. ◆ FreeEngi",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GSLRngROOTWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GSLRngROOTWrapper.html
https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals.html:480,Performance,perform,performing,480,". ROOT: ROOT::Math::MinusEquals< T, D1, D2, A, R1, R2 > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::MinusEquals< T, D1, D2, A, R1, R2 > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A, class R1, class R2>; struct ROOT::Math::MinusEquals< T, D1, D2, A, R1, R2 >Evaluate the expression performing a -= operation Need to check whether creating a temporary object with the expression result (like in op: A -= A * B ) ; Definition at line 279 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, R1 > &lhs, const Expr< A, T, D1, D2, R2 > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A , class R1 , class R2 > . static void ROOT::Math::MinusEquals< T, D1, D2, A, R1, R2 >::Evaluate ; (; SMatrix< T, D1, D2, R1 > & ; lhs, . const Expr< A, T, D1, D2, R2 > & ; rhs . ). inlinestatic . Definition at line 281 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathMinusEquals. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1MinusEquals.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals.html
https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html:597,Performance,perform,performing,597,". ROOT: ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices. ; Evaluate the expression performing a -= operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A -= A + B ) ; Definition at line 315 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 317 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathMinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html
https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html:683,Safety,avoid,avoid,683,". ROOT: ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices. ; Evaluate the expression performing a -= operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A -= A + B ) ; Definition at line 315 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 317 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathMinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html
https://root.cern/doc/master/structROOT_1_1Math_1_1MiserParameters.html:459,Deployability,integrat,integration,459,". ROOT: ROOT::Math::MiserParameters Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::MiserParameters Struct ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration » Numerical Monte Carlo Integration Classes. ; Structure collecting parameters for MISER multidimensional integration. ; Definition at line 77 of file MCParameters.h. Public Member Functions;  MiserParameters (const ROOT::Math::IOptions &opt, size_t dim=10);  ;  MiserParameters (size_t dim=10);  ; std::unique_ptr< ROOT::Math::IOptions > MakeIOptions () const;  convert to options (return object is managed by the user) ;  ; MiserParameters & operator= (const ROOT::Math::IOptions &opt);  ; void SetDefaultValues (size_t dim=10);  default MISER parameters (copied from gsl/monte/vegas.c) ;  . Public Attributes; double alpha;  ; double dither;  ; double estimate_frac;  ; size_t min_calls;  ; size_t min_calls_per_bisection;  . #include <Math/MCParameters.h>; Constructor & Destructor Documentation. ◆ MiserParameters() [1/2]. ROOT::Math::MiserParameters::MiserParameters ; (; size_t ; dim = 10). inline . Definition at line 86 of file MCParameters.h. ◆ MiserParameters() [2/2]. ROOT::Math::MiserParameters::MiserParameters ; (; const ROOT::Math::IOptions & ; opt, . size_t ; dim = 10 . ). Definition at line 98 of file MCParameters.cxx. Member Function Documentation. ◆ MakeIOptions(). std::unique_ptr< ROOT::Math::IOptions > ROOT::Math::MiserParameters::MakeIOptions ; (; ); const. convert to options (return object is managed by the user) ; Definition at line 122 of file MCParameters.cxx. ◆ operator=(). MiserParameters & ROOT::Math::MiserParameters::operator= ; (; const ROOT::Math::IOptions & ; opt). Definition at line 103 of file MCParameters.cxx. ◆ SetDefaultValues(). void ROOT::Math::MiserParameters::SetDefaultValues ; (; size_t ; dim ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1MiserParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MiserParameters.html
https://root.cern/doc/master/structROOT_1_1Math_1_1MiserParameters.html:459,Integrability,integrat,integration,459,". ROOT: ROOT::Math::MiserParameters Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::MiserParameters Struct ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration » Numerical Monte Carlo Integration Classes. ; Structure collecting parameters for MISER multidimensional integration. ; Definition at line 77 of file MCParameters.h. Public Member Functions;  MiserParameters (const ROOT::Math::IOptions &opt, size_t dim=10);  ;  MiserParameters (size_t dim=10);  ; std::unique_ptr< ROOT::Math::IOptions > MakeIOptions () const;  convert to options (return object is managed by the user) ;  ; MiserParameters & operator= (const ROOT::Math::IOptions &opt);  ; void SetDefaultValues (size_t dim=10);  default MISER parameters (copied from gsl/monte/vegas.c) ;  . Public Attributes; double alpha;  ; double dither;  ; double estimate_frac;  ; size_t min_calls;  ; size_t min_calls_per_bisection;  . #include <Math/MCParameters.h>; Constructor & Destructor Documentation. ◆ MiserParameters() [1/2]. ROOT::Math::MiserParameters::MiserParameters ; (; size_t ; dim = 10). inline . Definition at line 86 of file MCParameters.h. ◆ MiserParameters() [2/2]. ROOT::Math::MiserParameters::MiserParameters ; (; const ROOT::Math::IOptions & ; opt, . size_t ; dim = 10 . ). Definition at line 98 of file MCParameters.cxx. Member Function Documentation. ◆ MakeIOptions(). std::unique_ptr< ROOT::Math::IOptions > ROOT::Math::MiserParameters::MakeIOptions ; (; ); const. convert to options (return object is managed by the user) ; Definition at line 122 of file MCParameters.cxx. ◆ operator=(). MiserParameters & ROOT::Math::MiserParameters::operator= ; (; const ROOT::Math::IOptions & ; opt). Definition at line 103 of file MCParameters.cxx. ◆ SetDefaultValues(). void ROOT::Math::MiserParameters::SetDefaultValues ; (; size_t ; dim ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1MiserParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MiserParameters.html
https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals.html:477,Performance,perform,performing,477,". ROOT: ROOT::Math::PlusEquals< T, D1, D2, A, R1, R2 > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::PlusEquals< T, D1, D2, A, R1, R2 > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A, class R1, class R2>; struct ROOT::Math::PlusEquals< T, D1, D2, A, R1, R2 >Evaluate the expression performing a += operation Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ; Definition at line 195 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, R1 > &lhs, const Expr< A, T, D1, D2, R2 > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A , class R1 , class R2 > . static void ROOT::Math::PlusEquals< T, D1, D2, A, R1, R2 >::Evaluate ; (; SMatrix< T, D1, D2, R1 > & ; lhs, . const Expr< A, T, D1, D2, R2 > & ; rhs . ). inlinestatic . Definition at line 197 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathPlusEquals. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:23 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1PlusEquals.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals.html
https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html:591,Performance,perform,performing,591,". ROOT: ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ; Definition at line 232 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 234 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:23 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html
https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html:677,Safety,avoid,avoid,677,". ROOT: ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ; Definition at line 232 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 234 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:23 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html
https://root.cern/doc/master/structROOT_1_1Math_1_1VegasParameters.html:460,Deployability,integrat,integration,460,. ROOT: ROOT::Math::VegasParameters Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::VegasParameters Struct ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration » Numerical Monte Carlo Integration Classes. ; Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. ; Definition at line 46 of file MCParameters.h. Public Member Functions;  VegasParameters ();  ;  VegasParameters (const ROOT::Math::IOptions &opt);  ; std::unique_ptr< ROOT::Math::IOptions > MakeIOptions () const;  Convert to options. ;  ; VegasParameters & operator= (const ROOT::Math::IOptions &opt);  ; void SetDefaultValues ();  default VEGAS parameters (copied from gsl/monte/vegas.c) ;  . Public Attributes; double alpha;  ; size_t iterations;  ; int mode;  ; int stage;  ; int verbose;  . #include <Math/MCParameters.h>; Constructor & Destructor Documentation. ◆ VegasParameters() [1/2]. ROOT::Math::VegasParameters::VegasParameters ; (; ). inline . Definition at line 54 of file MCParameters.h. ◆ VegasParameters() [2/2]. ROOT::Math::VegasParameters::VegasParameters ; (; const ROOT::Math::IOptions & ; opt). Definition at line 48 of file MCParameters.cxx. Member Function Documentation. ◆ MakeIOptions(). std::unique_ptr< ROOT::Math::IOptions > ROOT::Math::VegasParameters::MakeIOptions ; (; ); const. Convert to options. ; Definition at line 72 of file MCParameters.cxx. ◆ operator=(). VegasParameters & ROOT::Math::VegasParameters::operator= ; (; const ROOT::Math::IOptions & ; opt). Definition at line 53 of file MCParameters.cxx. ◆ SetDefaultValues(). void ROOT::Math::VegasParameters::SetDefaultValues ; (; ). default VEGAS parameters (copied from gsl/monte/vegas.c) ; Definition at line 39 of file MCParameters.cxx. Membe,MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1VegasParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1VegasParameters.html
https://root.cern/doc/master/structROOT_1_1Math_1_1VegasParameters.html:460,Integrability,integrat,integration,460,. ROOT: ROOT::Math::VegasParameters Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::VegasParameters Struct ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration » Numerical Monte Carlo Integration Classes. ; Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. ; Definition at line 46 of file MCParameters.h. Public Member Functions;  VegasParameters ();  ;  VegasParameters (const ROOT::Math::IOptions &opt);  ; std::unique_ptr< ROOT::Math::IOptions > MakeIOptions () const;  Convert to options. ;  ; VegasParameters & operator= (const ROOT::Math::IOptions &opt);  ; void SetDefaultValues ();  default VEGAS parameters (copied from gsl/monte/vegas.c) ;  . Public Attributes; double alpha;  ; size_t iterations;  ; int mode;  ; int stage;  ; int verbose;  . #include <Math/MCParameters.h>; Constructor & Destructor Documentation. ◆ VegasParameters() [1/2]. ROOT::Math::VegasParameters::VegasParameters ; (; ). inline . Definition at line 54 of file MCParameters.h. ◆ VegasParameters() [2/2]. ROOT::Math::VegasParameters::VegasParameters ; (; const ROOT::Math::IOptions & ; opt). Definition at line 48 of file MCParameters.cxx. Member Function Documentation. ◆ MakeIOptions(). std::unique_ptr< ROOT::Math::IOptions > ROOT::Math::VegasParameters::MakeIOptions ; (; ); const. Convert to options. ; Definition at line 72 of file MCParameters.cxx. ◆ operator=(). VegasParameters & ROOT::Math::VegasParameters::operator= ; (; const ROOT::Math::IOptions & ; opt). Definition at line 53 of file MCParameters.cxx. ◆ SetDefaultValues(). void ROOT::Math::VegasParameters::SetDefaultValues ; (; ). default VEGAS parameters (copied from gsl/monte/vegas.c) ; Definition at line 39 of file MCParameters.cxx. Membe,MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1VegasParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1VegasParameters.html
https://root.cern/doc/master/structROOT_1_1RCompressionSetting.html:599,Availability,avail,available,599,". ROOT: ROOT::RCompressionSetting Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Static Public Member Functions |; List of all members ; ROOT::RCompressionSetting Struct Reference. ; The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. ; Both are defined in Bits.h. The default is to use the global setting and the default of the global setting is to use the ZLIB compression algorithm.; The LZMA algorithm (from the XZ package) is also available. The LZMA compression usually results in greater compression factors, but takes more CPU time and memory when compressing. LZMA memory usage is particularly high for compression levels 8 and 9.; Finally, the LZ4 package results in worse compression ratios than ZLIB but achieves much faster decompression rates. The current algorithms support level 1 to 9. The higher the level the greater the compression and more CPU time and memory resources used during compression. Level 0 means no compression.; Recommendation for the compression algorithm's levels:; ZLIB is recommended to be used with compression level 1 [101]; LZMA is recommended to be used with compression level 7-8 (higher is better, since in the case of LZMA we don't care about compression/decompression speed) [207 - 208]; LZ4 is recommended to be used with compression level 4 [404]; ZSTD is recommended to be used with compression level 5 [505] . Definition at line 46 of file Compression.h. Classes; struct  EAlgorithm;  ; struct  EDefaults;  ; struct  ELevel;  . Static Public Member Functions; static EAlgorithm::EValues AlgorithmFromCompressionSettings (int compSettings);  ; static std::string AlgorithmToString (EAlgorithm::EValues algorithm);  . #include <Compression.h>; Member Function Documentation. ◆ AlgorithmFromCompressionSettings(). static EAlgorithm::EValues ROOT::RCompressionSetting::AlgorithmFromCompressi",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting.html
https://root.cern/doc/master/structROOT_1_1RCompressionSetting.html:289,Integrability,depend,depend,289,". ROOT: ROOT::RCompressionSetting Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Static Public Member Functions |; List of all members ; ROOT::RCompressionSetting Struct Reference. ; The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. ; Both are defined in Bits.h. The default is to use the global setting and the default of the global setting is to use the ZLIB compression algorithm.; The LZMA algorithm (from the XZ package) is also available. The LZMA compression usually results in greater compression factors, but takes more CPU time and memory when compressing. LZMA memory usage is particularly high for compression levels 8 and 9.; Finally, the LZ4 package results in worse compression ratios than ZLIB but achieves much faster decompression rates. The current algorithms support level 1 to 9. The higher the level the greater the compression and more CPU time and memory resources used during compression. Level 0 means no compression.; Recommendation for the compression algorithm's levels:; ZLIB is recommended to be used with compression level 1 [101]; LZMA is recommended to be used with compression level 7-8 (higher is better, since in the case of LZMA we don't care about compression/decompression speed) [207 - 208]; LZ4 is recommended to be used with compression level 4 [404]; ZSTD is recommended to be used with compression level 5 [505] . Definition at line 46 of file Compression.h. Classes; struct  EAlgorithm;  ; struct  EDefaults;  ; struct  ELevel;  . Static Public Member Functions; static EAlgorithm::EValues AlgorithmFromCompressionSettings (int compSettings);  ; static std::string AlgorithmToString (EAlgorithm::EValues algorithm);  . #include <Compression.h>; Member Function Documentation. ◆ AlgorithmFromCompressionSettings(). static EAlgorithm::EValues ROOT::RCompressionSetting::AlgorithmFromCompressi",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting.html
https://root.cern/doc/master/structROOT_1_1RCompressionSetting.html:308,Modifiability,variab,variable,308,". ROOT: ROOT::RCompressionSetting Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Static Public Member Functions |; List of all members ; ROOT::RCompressionSetting Struct Reference. ; The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. ; Both are defined in Bits.h. The default is to use the global setting and the default of the global setting is to use the ZLIB compression algorithm.; The LZMA algorithm (from the XZ package) is also available. The LZMA compression usually results in greater compression factors, but takes more CPU time and memory when compressing. LZMA memory usage is particularly high for compression levels 8 and 9.; Finally, the LZ4 package results in worse compression ratios than ZLIB but achieves much faster decompression rates. The current algorithms support level 1 to 9. The higher the level the greater the compression and more CPU time and memory resources used during compression. Level 0 means no compression.; Recommendation for the compression algorithm's levels:; ZLIB is recommended to be used with compression level 1 [101]; LZMA is recommended to be used with compression level 7-8 (higher is better, since in the case of LZMA we don't care about compression/decompression speed) [207 - 208]; LZ4 is recommended to be used with compression level 4 [404]; ZSTD is recommended to be used with compression level 5 [505] . Definition at line 46 of file Compression.h. Classes; struct  EAlgorithm;  ; struct  EDefaults;  ; struct  ELevel;  . Static Public Member Functions; static EAlgorithm::EValues AlgorithmFromCompressionSettings (int compSettings);  ; static std::string AlgorithmToString (EAlgorithm::EValues algorithm);  . #include <Compression.h>; Member Function Documentation. ◆ AlgorithmFromCompressionSettings(). static EAlgorithm::EValues ROOT::RCompressionSetting::AlgorithmFromCompressi",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting.html
https://root.cern/doc/master/structROOT_1_1RCompressionSetting_1_1EAlgorithm-members.html:247,Modifiability,inherit,inherited,247,". ROOT: Member List. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOT::RCompressionSetting::EAlgorithm Member List. This is the complete list of members for ROOT::RCompressionSetting::EAlgorithm, including all inherited members. EValues enum nameROOT::RCompressionSetting::EAlgorithm; kInherit enum valueROOT::RCompressionSetting::EAlgorithm; kLZ4 enum valueROOT::RCompressionSetting::EAlgorithm; kLZMA enum valueROOT::RCompressionSetting::EAlgorithm; kOldCompressionAlgo enum valueROOT::RCompressionSetting::EAlgorithm; kUndefined enum valueROOT::RCompressionSetting::EAlgorithm; kUseGlobal enum valueROOT::RCompressionSetting::EAlgorithm; kZLIB enum valueROOT::RCompressionSetting::EAlgorithm; kZSTD enum valueROOT::RCompressionSetting::EAlgorithm. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:58 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting_1_1EAlgorithm-members.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting_1_1EAlgorithm-members.html
https://root.cern/doc/master/structROOT_1_1RCompressionSetting_1_1EAlgorithm.html:894,Modifiability,inherit,inherited,894,". ROOT: ROOT::RCompressionSetting::EAlgorithm Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; List of all members ; ROOT::RCompressionSetting::EAlgorithm Struct Reference. . Definition at line 86 of file Compression.h. Public Types; enum  EValues { ;   kInherit = -1; , kUseGlobal = 0; , kZLIB; , kLZMA; , ;   kOldCompressionAlgo; , kLZ4; , kZSTD; , kUndefined. };  Note: this is only temporarily a struct and will become a enum class hence the name convention used. More...;  . #include <Compression.h>; Member Enumeration Documentation. ◆ EValues. enum ROOT::RCompressionSetting::EAlgorithm::EValues. Note: this is only temporarily a struct and will become a enum class hence the name convention used. . EnumeratorkInherit Some objects use this value to denote that the compression algorithm should be inherited from the parent object (e.g., TBranch should get the algorithm from the TTree) . kUseGlobal Use the global compression algorithm. . kZLIB Use ZLIB compression. . kLZMA Use LZMA compression. . kOldCompressionAlgo Use the old compression algorithm. . kLZ4 Use LZ4 compression. . kZSTD Use ZSTD compression. . kUndefined Undefined compression algorithm (must be kept the last of the list in case a new algorithm is added). . Definition at line 88 of file Compression.h. The documentation for this struct was generated from the following file:; core/zip/inc/Compression.h. ROOTRCompressionSettingEAlgorithm. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:58 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting_1_1EAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting_1_1EAlgorithm.html
https://root.cern/doc/master/structROOT_1_1RCompressionSetting_1_1ELevel.html:926,Modifiability,inherit,inherited,926,". ROOT: ROOT::RCompressionSetting::ELevel Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; List of all members ; ROOT::RCompressionSetting::ELevel Struct Reference. . Definition at line 63 of file Compression.h. Public Types; enum  EValues { ;   kInherit = -1; , kUncompressed = 0; , kUseMin = 1; , kDefaultZLIB = 1; , ;   kDefaultLZ4 = 4; , kDefaultZSTD = 5; , kDefaultOld = 6; , kDefaultLZMA = 7. };  Note: this is only temporarily a struct and will become a enum class hence the name convention used. More...;  . #include <Compression.h>; Member Enumeration Documentation. ◆ EValues. enum ROOT::RCompressionSetting::ELevel::EValues. Note: this is only temporarily a struct and will become a enum class hence the name convention used. . EnumeratorkInherit Some objects use this value to denote that the compression algorithm should be inherited from the parent object. . kUncompressed Compression level reserved for ""uncompressed state"". . kUseMin Compression level reserved when we are not sure what to use (1 is for the fastest compression) . kDefaultZLIB Compression level reserved for ZLIB compression algorithm (fastest compression) . kDefaultLZ4 Compression level reserved for LZ4 compression algorithm (trade-off between file ratio/decompression speed) . kDefaultZSTD Compression level reserved for ZSTD compression algorithm (trade-off between file ratio/decompression speed) . kDefaultOld Compression level reserved for old ROOT compression algorithm. . kDefaultLZMA Compression level reserved for LZMA compression algorithm (slowest compression with smallest files) . Definition at line 65 of file Compression.h. The documentation for this struct was generated from the following file:; core/zip/inc/Compression.h. ROOTRCompressionSettingELevel. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:58 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting_1_1ELevel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting_1_1ELevel.html
https://root.cern/doc/master/structROOT_1_1TNumSlots.html:282,Integrability,interface,interfaces,282,". ROOT: ROOT::TNumSlots Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; Friends |; List of all members ; ROOT::TNumSlots Class Reference. ; Defines the number of threads in some of ROOT's interfaces. ; Definition at line 42 of file TThreadedObject.hxx. Public Attributes; unsigned int fVal;  . Friends; bool operator!= (TNumSlots lhs, TNumSlots rhs);  ; bool operator== (TNumSlots lhs, TNumSlots rhs);  . #include <ROOT/TThreadedObject.hxx>; Friends And Related Symbol Documentation. ◆ operator!=. bool operator!= ; (; TNumSlots ; lhs, . TNumSlots ; rhs . ). friend . Definition at line 45 of file TThreadedObject.hxx. ◆ operator==. bool operator== ; (; TNumSlots ; lhs, . TNumSlots ; rhs . ). friend . Definition at line 44 of file TThreadedObject.hxx. Member Data Documentation. ◆ fVal. unsigned int ROOT::TNumSlots::fVal. Definition at line 43 of file TThreadedObject.hxx. Collaboration diagram for ROOT::TNumSlots:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this class was generated from the following file:; core/thread/inc/ROOT/TThreadedObject.hxx. ROOTTNumSlots. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:00 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1TNumSlots.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1TNumSlots.html
https://root.cern/doc/master/structROOT_1_1TypeTraits_1_1TypeList.html:486,Performance,perform,performed,486,". ROOT: ROOT::TypeTraits::TypeList< Types > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Attributes |; List of all members ; ROOT::TypeTraits::TypeList< Types > Struct Template Reference. ; template<typename... Types>; struct ROOT::TypeTraits::TypeList< Types >Lightweight storage for a collection of types. ; Differently from std::tuple, no instantiation of objects of stored types is performed ; Definition at line 25 of file TypeTraits.hxx. Static Public Attributes; static constexpr std::size_t list_size = sizeof...(Types);  . #include <ROOT/TypeTraits.hxx>; Member Data Documentation. ◆ list_size. template<typename... Types> . constexpr std::size_t ROOT::TypeTraits::TypeList< Types >::list_size = sizeof...(Types). staticconstexpr . Definition at line 26 of file TypeTraits.hxx. Collaboration diagram for ROOT::TypeTraits::TypeList< Types >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/foundation/inc/ROOT/TypeTraits.hxx. ROOTTypeTraitsTypeList. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1TypeTraits_1_1TypeList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1TypeTraits_1_1TypeList.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:8275,Availability,error,error,8275,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:8364,Availability,error,error,8364,"ecord whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:8519,Availability,error,error,8519,"Name () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:8816,Availability,error,error,8816,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:12900,Availability,error,error,12900,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:8281,Integrability,message,message,8281,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:8822,Integrability,message,message,8822,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:9812,Integrability,message,message,9812,"ssue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class shou",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:12906,Integrability,message,message,12906,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:13279,Integrability,message,message,13279," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t DistancetoLine (Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2);  Compute distance from point px,py to a line. ;  ; virtual Color_t GetLineColor () const;  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Ch",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:842,Modifiability,inherit,inherited,842,". ROOT: ROOT::v5::TF1Data Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Public Attributes |; List of all members ; ROOT::v5::TF1Data Struct Reference. . Definition at line 37 of file TF1Data.h. Public Member Functions;  TF1Data ();  F1 default constructor. ;  ;  ~TF1Data () override;  TF1 default destructor. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void Streamer (TBuffer &b, Int_t version, UInt_t start, UInt_t count, const TClass *onfile_class=nullptr);  specialized streamer function being able to read old TF1 versions as TF1Data in memory ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from ROOT::v5::TFormula;  TFormula ();  Formula default constructor. ;  ;  TFormula (const char *name, const char *formula);  Normal Formula constructor. ;  ;  TFormula (const TFormula &formula);  Default constructor. ;  ;  ~TFormula () override;  Formula default destructor. ;  ; virtual void Analyze (const char *schain, Int_t &err, Int_t offset=0);  Analyze a sub-expression in one formula. ;  ; virtual Bool_t AnalyzeFunction (TString &chaine, Int_t &err, Int_t offset=0);  Check if the chain as function call. ;  ; void Clear (Option_t *option="""") override;  Resets the objects. ;  ; virtual Int_t Compile (const char *expression="""");  Compile expression already stored in fTitle. ;  ; void Copy (TObject &formula) const override;  Copy this formula. ;  ; virtual char * DefinedString (Int_t code);  Return address of string corresponding to special code. ;  ; virtual Double_t DefinedValue (Int_t code);  Return value corresponding to special code. ;  ; virtual Int_t DefinedVariable (TString &variable, Int_t &action);  Check if expression is in the list of defined variables. ;  ; virtual Double_t Eval (Double_t x, Double_t y=0, Double_t z=",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:1852,Modifiability,variab,variable,1852,"rmula;  TFormula ();  Formula default constructor. ;  ;  TFormula (const char *name, const char *formula);  Normal Formula constructor. ;  ;  TFormula (const TFormula &formula);  Default constructor. ;  ;  ~TFormula () override;  Formula default destructor. ;  ; virtual void Analyze (const char *schain, Int_t &err, Int_t offset=0);  Analyze a sub-expression in one formula. ;  ; virtual Bool_t AnalyzeFunction (TString &chaine, Int_t &err, Int_t offset=0);  Check if the chain as function call. ;  ; void Clear (Option_t *option="""") override;  Resets the objects. ;  ; virtual Int_t Compile (const char *expression="""");  Compile expression already stored in fTitle. ;  ; void Copy (TObject &formula) const override;  Copy this formula. ;  ; virtual char * DefinedString (Int_t code);  Return address of string corresponding to special code. ;  ; virtual Double_t DefinedValue (Int_t code);  Return value corresponding to special code. ;  ; virtual Int_t DefinedVariable (TString &variable, Int_t &action);  Check if expression is in the list of defined variables. ;  ; virtual Double_t Eval (Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) const;  Evaluate this formula. ;  ; virtual Double_t EvalPar (const Double_t *x, const Double_t *params=nullptr);  ; virtual Double_t EvalParOld (const Double_t *x, const Double_t *params=nullptr);  Evaluate this formula. ;  ; virtual TString GetExpFormula (Option_t *option="""") const;  Reconstruct the formula expression from the internal TFormula member variables. ;  ; virtual const TObject * GetLinearPart (Int_t i);  Return linear part. ;  ; virtual Int_t GetNdim () const;  ; virtual Int_t GetNpar () const;  ; virtual Int_t GetNumber () const;  ; Double_t GetParameter (const char *name) const;  Return value of parameter named parName. ;  ; Double_t GetParameter (Int_t ipar) const;  Return value of parameter number ipar. ;  ; virtual Double_t * GetParameters () const;  ; virtual void GetParameters (Double_t *params);  ; virtual const char * ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:1925,Modifiability,variab,variables,1925,"rmula;  TFormula ();  Formula default constructor. ;  ;  TFormula (const char *name, const char *formula);  Normal Formula constructor. ;  ;  TFormula (const TFormula &formula);  Default constructor. ;  ;  ~TFormula () override;  Formula default destructor. ;  ; virtual void Analyze (const char *schain, Int_t &err, Int_t offset=0);  Analyze a sub-expression in one formula. ;  ; virtual Bool_t AnalyzeFunction (TString &chaine, Int_t &err, Int_t offset=0);  Check if the chain as function call. ;  ; void Clear (Option_t *option="""") override;  Resets the objects. ;  ; virtual Int_t Compile (const char *expression="""");  Compile expression already stored in fTitle. ;  ; void Copy (TObject &formula) const override;  Copy this formula. ;  ; virtual char * DefinedString (Int_t code);  Return address of string corresponding to special code. ;  ; virtual Double_t DefinedValue (Int_t code);  Return value corresponding to special code. ;  ; virtual Int_t DefinedVariable (TString &variable, Int_t &action);  Check if expression is in the list of defined variables. ;  ; virtual Double_t Eval (Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) const;  Evaluate this formula. ;  ; virtual Double_t EvalPar (const Double_t *x, const Double_t *params=nullptr);  ; virtual Double_t EvalParOld (const Double_t *x, const Double_t *params=nullptr);  Evaluate this formula. ;  ; virtual TString GetExpFormula (Option_t *option="""") const;  Reconstruct the formula expression from the internal TFormula member variables. ;  ; virtual const TObject * GetLinearPart (Int_t i);  Return linear part. ;  ; virtual Int_t GetNdim () const;  ; virtual Int_t GetNpar () const;  ; virtual Int_t GetNumber () const;  ; Double_t GetParameter (const char *name) const;  Return value of parameter named parName. ;  ; Double_t GetParameter (Int_t ipar) const;  Return value of parameter number ipar. ;  ; virtual Double_t * GetParameters () const;  ; virtual void GetParameters (Double_t *params);  ; virtual const char * ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:2374,Modifiability,variab,variables,2374," Int_t offset=0);  Check if the chain as function call. ;  ; void Clear (Option_t *option="""") override;  Resets the objects. ;  ; virtual Int_t Compile (const char *expression="""");  Compile expression already stored in fTitle. ;  ; void Copy (TObject &formula) const override;  Copy this formula. ;  ; virtual char * DefinedString (Int_t code);  Return address of string corresponding to special code. ;  ; virtual Double_t DefinedValue (Int_t code);  Return value corresponding to special code. ;  ; virtual Int_t DefinedVariable (TString &variable, Int_t &action);  Check if expression is in the list of defined variables. ;  ; virtual Double_t Eval (Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) const;  Evaluate this formula. ;  ; virtual Double_t EvalPar (const Double_t *x, const Double_t *params=nullptr);  ; virtual Double_t EvalParOld (const Double_t *x, const Double_t *params=nullptr);  Evaluate this formula. ;  ; virtual TString GetExpFormula (Option_t *option="""") const;  Reconstruct the formula expression from the internal TFormula member variables. ;  ; virtual const TObject * GetLinearPart (Int_t i);  Return linear part. ;  ; virtual Int_t GetNdim () const;  ; virtual Int_t GetNpar () const;  ; virtual Int_t GetNumber () const;  ; Double_t GetParameter (const char *name) const;  Return value of parameter named parName. ;  ; Double_t GetParameter (Int_t ipar) const;  Return value of parameter number ipar. ;  ; virtual Double_t * GetParameters () const;  ; virtual void GetParameters (Double_t *params);  ; virtual const char * GetParName (Int_t ipar) const;  Return name of one parameter. ;  ; virtual Int_t GetParNumber (const char *name) const;  Return parameter number by name. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsLinear () const;  ; virtual Bool_t IsNormalized () const;  ; TFormula & operator= (const TFormula &rhs);  Operator =. ;  ; void Optimize ();  MI include. ;  ; void Print (Option_t *option="""") const override;  Dump this formula wit",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:5078,Modifiability,inherit,inherited,5078," p8=0, Double_t p9=0, Double_t p10=0);  Initialize up to 11 parameters All arguments except THE FIRST TWO are optional In case of a function with only one parameter, call this function with p1=0. ;  ; virtual void SetParName (Int_t ipar, const char *name);  Set name of parameter number ipar. ;  ; virtual void SetParNames (const char *name0=""p0"", const char *name1=""p1"", const char *name2=""p2"", const char *name3=""p3"", const char *name4=""p4"", const char *name5=""p5"", const char *name6=""p6"", const char *name7=""p7"", const char *name8=""p8"", const char *name9=""p9"", const char *name10=""p10"");  Set up to 11 parameter names. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void Streamer (TBuffer &b, const TClass *onfile_class);  Stream a class object. ;  ; void Streamer (TBuffer &b, Int_t version, UInt_t start, UInt_t count, const TClass *onfile_class=nullptr);  specialized streamer function being able to read old TF1 versions as TF1Old in memory ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:6818,Modifiability,inherit,inherited,6818,"ide;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:7911,Modifiability,inherit,inheritance,7911,"  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:9910,Modifiability,inherit,inherits,9910,"e) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:10027,Modifiability,inherit,inherits,10027,"t be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; virtual Bool_t Notify ();  This method must be overridden to handle object notification (the base ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:13586,Modifiability,inherit,inherited,13586,"tDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t DistancetoLine (Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2);  Compute distance from point px,py to a line. ;  ; virtual Color_t GetLineColor () const;  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (Option_t *option="""");  Reset this line attributes to default values. ;  ; virtual void SaveLineAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1);  Save line attributes as C++ statement(s) on output stream out. ; ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:15091,Modifiability,inherit,inherited,15091,";  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (Option_t *option="""");  Reset this line attributes to default values. ;  ; virtual void SaveLineAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1);  Save line attributes as C++ statement(s) on output stream out. ;  ; virtual void SetLineAttributes ();  Invoke the DialogCanvas Line attributes. ;  ; virtual void SetLineColor (Color_t lcolor);  Set the line color. ;  ; virtual void SetLineColorAlpha (Color_t lcolor, Float_t lalpha);  Set a transparent line color. ;  ; virtual void SetLineStyle (Style_t lstyle);  Set the line style. ;  ; virtual void SetLineWidth (Width_t lwidth);  Set the line width. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttFill;  TAttFill ();  AttFill default constructor. ;  ;  TAttFill (Color_t fcolor, Style_t fstyle);  AttFill normal constructor. ;  ; virtual ~TAttFill ();  AttFill destructor. ;  ; void Copy (TAttFill &attfill) const;  Copy this fill attributes to a new TAttFill. ;  ; virtual Color_t GetFillColor () const;  Return the fill area color. ;  ; virtual Style_t GetFillStyle () const;  Return the fill area style. ;  ; virtual Bool_t IsTransparent () const;  ; virtual void Modify ();  Change current fill area attributes if necessary. ;  ; virtual void ResetAttFill (Option_t *option="""");  Reset this fill attributes to default values. ;  ; virtual void SaveFillAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001);  Save fill attributes as C++ statement(s) on output stream out. ;  ; virtual void SetFillAttributes ();  Invoke the DialogCanvas Fill attributes. ;  ; virtual void SetFillColor (Color_t fcolor);  Set the fill area color. ; ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:16346,Modifiability,inherit,inherited,16346,"his fill attributes to a new TAttFill. ;  ; virtual Color_t GetFillColor () const;  Return the fill area color. ;  ; virtual Style_t GetFillStyle () const;  Return the fill area style. ;  ; virtual Bool_t IsTransparent () const;  ; virtual void Modify ();  Change current fill area attributes if necessary. ;  ; virtual void ResetAttFill (Option_t *option="""");  Reset this fill attributes to default values. ;  ; virtual void SaveFillAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001);  Save fill attributes as C++ statement(s) on output stream out. ;  ; virtual void SetFillAttributes ();  Invoke the DialogCanvas Fill attributes. ;  ; virtual void SetFillColor (Color_t fcolor);  Set the fill area color. ;  ; virtual void SetFillColorAlpha (Color_t fcolor, Float_t falpha);  Set a transparent fill color. ;  ; virtual void SetFillStyle (Style_t fstyle);  Set the fill area style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttMarker;  TAttMarker ();  TAttMarker default constructor. ;  ;  TAttMarker (Color_t color, Style_t style, Size_t msize);  TAttMarker normal constructor. ;  ; virtual ~TAttMarker ();  TAttMarker destructor. ;  ; void Copy (TAttMarker &attmarker) const;  Copy this marker attributes to a new TAttMarker. ;  ; virtual Color_t GetMarkerColor () const;  Return the marker color. ;  ; virtual Size_t GetMarkerSize () const;  Return the marker size. ;  ; virtual Style_t GetMarkerStyle () const;  Return the marker style. ;  ; virtual void Modify ();  Change current marker attributes if necessary. ;  ; virtual void ResetAttMarker (Option_t *toption="""");  Reset this marker attributes to the default values. ;  ; virtual void SaveMarkerAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t sizdef=1);  Save line attributes as C++ statement(s) on output stream out. ;  ; virtual void SetMarkerAttributes ();  Invoke the DialogCanvas Marker attrib",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:17960,Modifiability,inherit,inherited,17960,"mcolor=1);  Set the marker color. ;  ; virtual void SetMarkerColorAlpha (Color_t mcolor, Float_t malpha);  Set a transparent marker color. ;  ; virtual void SetMarkerSize (Size_t msize=1);  Set the marker size. ;  ; virtual void SetMarkerStyle (Style_t mstyle=1);  Set the marker style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from ROOT::v5::TFormula; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void GetMaxima (Int_t &maxop, Int_t &maxpar, Int_t &maxconst);  static function to get the maximum value of 3 parameters -maxop : maximum number of operations -maxpar : maximum number of parameters -maxconst : maximum number of constants ;  ; static void SetMaxima (Int_t maxop=1000, Int_t maxpar=1000, Int_t maxconst=1000);  static function to set the maximum value of 3 parameters ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:18577,Modifiability,inherit,inherited,18577,"mcolor=1);  Set the marker color. ;  ; virtual void SetMarkerColorAlpha (Color_t mcolor, Float_t malpha);  Set a transparent marker color. ;  ; virtual void SetMarkerSize (Size_t msize=1);  Set the marker size. ;  ; virtual void SetMarkerStyle (Style_t mstyle=1);  Set the marker style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from ROOT::v5::TFormula; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void GetMaxima (Int_t &maxop, Int_t &maxpar, Int_t &maxconst);  static function to get the maximum value of 3 parameters -maxop : maximum number of operations -maxpar : maximum number of parameters -maxconst : maximum number of constants ;  ; static void SetMaxima (Int_t maxop=1000, Int_t maxpar=1000, Int_t maxconst=1000);  static function to set the maximum value of 3 parameters ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:18787,Modifiability,inherit,inherited,18787,"mcolor=1);  Set the marker color. ;  ; virtual void SetMarkerColorAlpha (Color_t mcolor, Float_t malpha);  Set a transparent marker color. ;  ; virtual void SetMarkerSize (Size_t msize=1);  Set the marker size. ;  ; virtual void SetMarkerStyle (Style_t mstyle=1);  Set the marker style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from ROOT::v5::TFormula; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void GetMaxima (Int_t &maxop, Int_t &maxpar, Int_t &maxconst);  static function to get the maximum value of 3 parameters -maxop : maximum number of operations -maxpar : maximum number of parameters -maxconst : maximum number of constants ;  ; static void SetMaxima (Int_t maxop=1000, Int_t maxpar=1000, Int_t maxconst=1000);  static function to set the maximum value of 3 parameters ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:19305,Modifiability,inherit,inherited,19305,"e ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Public Attributes; Double_t fChisquare;  ; Double_t fMaximum;  ; Double_t fMinimum;  ; Int_t fNDF;  ; Int_t fNpfits;  ; Int_t fNpx;  ; Int_t fNsave;  ; Double_t * fParErrors;  ; Double_t * fParMax;  ; Double_t * fParMin;  ; Double_t * fSave;  ; Int_t fType;  ; Double_t fXmax;  ; Double_t fXmin;  . Additional Inherited Members;  Public Types inherited from ROOT::v5::TFormula; enum  { kNotGlobal = (1ULL << ( 10 )); , kNormalized = (1ULL << ( 14 )); , kLinear = (1ULL << ( 16 )); };  ;  Public Types inherited from",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:19517,Modifiability,inherit,inherited,19517,"e ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Public Attributes; Double_t fChisquare;  ; Double_t fMaximum;  ; Double_t fMinimum;  ; Int_t fNDF;  ; Int_t fNpfits;  ; Int_t fNpx;  ; Int_t fNsave;  ; Double_t * fParErrors;  ; Double_t * fParMax;  ; Double_t * fParMin;  ; Double_t * fSave;  ; Int_t fType;  ; Double_t fXmax;  ; Double_t fXmin;  . Additional Inherited Members;  Public Types inherited from ROOT::v5::TFormula; enum  { kNotGlobal = (1ULL << ( 10 )); , kNormalized = (1ULL << ( 14 )); , kLinear = (1ULL << ( 16 )); };  ;  Public Types inherited from",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:19729,Modifiability,inherit,inherited,19729,"e ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Public Attributes; Double_t fChisquare;  ; Double_t fMaximum;  ; Double_t fMinimum;  ; Int_t fNDF;  ; Int_t fNpfits;  ; Int_t fNpx;  ; Int_t fNsave;  ; Double_t * fParErrors;  ; Double_t * fParMax;  ; Double_t * fParMin;  ; Double_t * fSave;  ; Int_t fType;  ; Double_t fXmax;  ; Double_t fXmin;  . Additional Inherited Members;  Public Types inherited from ROOT::v5::TFormula; enum  { kNotGlobal = (1ULL << ( 10 )); , kNormalized = (1ULL << ( 14 )); , kLinear = (1ULL << ( 16 )); };  ;  Public Types inherited from",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:20575,Modifiability,inherit,inherited,20575,"er Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Public Attributes; Double_t fChisquare;  ; Double_t fMaximum;  ; Double_t fMinimum;  ; Int_t fNDF;  ; Int_t fNpfits;  ; Int_t fNpx;  ; Int_t fNsave;  ; Double_t * fParErrors;  ; Double_t * fParMax;  ; Double_t * fParMin;  ; Double_t * fSave;  ; Int_t fType;  ; Double_t fXmax;  ; Double_t fXmin;  . Additional Inherited Members;  Public Types inherited from ROOT::v5::TFormula; enum  { kNotGlobal = (1ULL << ( 10 )); , kNormalized = (1ULL << ( 14 )); , kLinear = (1ULL << ( 16 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from ROOT::v5::TFormula; enum  { ;   kEnd = 0; , kAdd = 1; , kSubstract = 2; , kMultiply = 3; , ;   kDivide = 4; , kModulo = 5; , kcos = 10; , ksin = 11; , ;   ktan = 12; , kacos = 13; , kasin = 14; , katan = 15; , ;   katan2 = 16; , kfmod = 17; , kpow = 20; , ksq = 21; , ;   ksqrt = 22; , kstrstr = 23; , kmin = 24; , kmax = 25; , ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:20733,Modifiability,inherit,inherited,20733,"er Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Public Attributes; Double_t fChisquare;  ; Double_t fMaximum;  ; Double_t fMinimum;  ; Int_t fNDF;  ; Int_t fNpfits;  ; Int_t fNpx;  ; Int_t fNsave;  ; Double_t * fParErrors;  ; Double_t * fParMax;  ; Double_t * fParMin;  ; Double_t * fSave;  ; Int_t fType;  ; Double_t fXmax;  ; Double_t fXmin;  . Additional Inherited Members;  Public Types inherited from ROOT::v5::TFormula; enum  { kNotGlobal = (1ULL << ( 10 )); , kNormalized = (1ULL << ( 14 )); , kLinear = (1ULL << ( 16 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from ROOT::v5::TFormula; enum  { ;   kEnd = 0; , kAdd = 1; , kSubstract = 2; , kMultiply = 3; , ;   kDivide = 4; , kModulo = 5; , kcos = 10; , ksin = 11; , ;   ktan = 12; , kacos = 13; , kasin = 14; , katan = 15; , ;   katan2 = 16; , kfmod = 17; , kpow = 20; , ksq = 21; , ;   ksqrt = 22; , kstrstr = 23; , kmin = 24; , kmax = 25; , ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:21374,Modifiability,inherit,inherited,21374,"1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from ROOT::v5::TFormula; enum  { ;   kEnd = 0; , kAdd = 1; , kSubstract = 2; , kMultiply = 3; , ;   kDivide = 4; , kModulo = 5; , kcos = 10; , ksin = 11; , ;   ktan = 12; , kacos = 13; , kasin = 14; , katan = 15; , ;   katan2 = 16; , kfmod = 17; , kpow = 20; , ksq = 21; , ;   ksqrt = 22; , kstrstr = 23; , kmin = 24; , kmax = 25; , ;   klog = 30; , kexp = 31; , klog10 = 32; , kpi = 40; , ;   kabs = 41; , ksign = 42; , kint = 43; , kSignInv = 44; , ;   krndm = 50; , kAnd = 60; , kOr = 61; , kEqual = 62; , ;   kNotEqual = 63; , kLess = 64; , kGreater = 65; , kLessThan = 66; , ;   kGreaterThan = 67; , kNot = 68; , kcosh = 70; , ksinh = 71; , ;   ktanh = 72; , kacosh = 73; , kasinh = 74; , katanh = 75; , ;   kStringEqual = 76; , kStringNotEqual = 77; , kBitAnd = 78; , kBitOr = 79; , ;   kLeftShift = 80; , kRightShift = 81; , kJumpIf = 82; , kJump = 83; , ;   kexpo = 100; , kxexpo = 100; , kyexpo = 101; , kzexpo = 102; , ;   kxyexpo = 105; , kgaus = 110; , kxgaus = 110; , kygaus = 111; , ;   kzgaus = 112; , kxygaus = 115; , klandau = 120; , kxlandau = 120; , ;   kylandau = 121; , kzlandau = 122; , kxylandau = 125; , kpol = 130; , ;   kxpol = 130; , kypol = 131; , kzpol = 132; , kParameter = 140; , ;   kConstant = 141; , kBoolOptimize = 142; , kStringConst = 143; , kVariable = 144; , ;   kFunctionCall = 145; , kData = 146; , kUnary = 147; , kBinary = 148; , ;   kThree = 149; , kDefinedVariable = 150; , kDefinedString = 151; , kPlusD = 152; , ;   kPlusDD = 153; , kMultD = 154; , kMultDD = 155; , kBoolOptimizeOr = 156; , ;   kBoolOptimizeAnd = 157; , kBoolSet = 158; , kFDM = 159; , kFD0 = 160; , ;   kFD1 = 161; , kFD2 = 162; , kFD3 = 163. };  ; typedef Double_t(TObject::* TFuncG) (const Double_t *, const Double_t *) const;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:23148,Modifiability,inherit,inherited,23148,"po = 100; , kxexpo = 100; , kyexpo = 101; , kzexpo = 102; , ;   kxyexpo = 105; , kgaus = 110; , kxgaus = 110; , kygaus = 111; , ;   kzgaus = 112; , kxygaus = 115; , klandau = 120; , kxlandau = 120; , ;   kylandau = 121; , kzlandau = 122; , kxylandau = 125; , kpol = 130; , ;   kxpol = 130; , kypol = 131; , kzpol = 132; , kParameter = 140; , ;   kConstant = 141; , kBoolOptimize = 142; , kStringConst = 143; , kVariable = 144; , ;   kFunctionCall = 145; , kData = 146; , kUnary = 147; , kBinary = 148; , ;   kThree = 149; , kDefinedVariable = 150; , kDefinedString = 151; , kPlusD = 152; , ;   kPlusDD = 153; , kMultD = 154; , kMultDD = 155; , kBoolOptimizeOr = 156; , ;   kBoolOptimizeAnd = 157; , kBoolSet = 158; , kFDM = 159; , kFD0 = 160; , ;   kFD1 = 161; , kFD2 = 162; , kFD3 = 163. };  ; typedef Double_t(TObject::* TFuncG) (const Double_t *, const Double_t *) const;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from ROOT::v5::TFormula; virtual Bool_t CheckOperands (Int_t leftoperand, Int_t rightoperartion, Int_t &err);  Check whether the operands at 'leftoper' and 'oper-1' are compatible with the operation at 'oper'. ;  ; virtual Bool_t CheckOperands (Int_t operation, Int_t &err);  Check whether the operand at 'oper-1' is compatible with the operation at 'oper'. ;  ; void ClearFormula (Option_t *option="""");  Resets the objects. ;  ; virtual void Convert (UInt_t fromVersion);  ; Double_t EvalParFast (const Double_t *x, const Double_t *params);  Evaluate this formula. ;  ; Double_t EvalPrimitive (const Double_t *x, const Double_t *params);  Evaluate primitive formula. ;  ; Double_t EvalPrimitive0 (const Double_t *x, const Double_t *params);  Evaluate primitive formula. ;  ; Double_t EvalPrimitive1 (const Double_t *x, const Double_t *params);  Evaluate primitive formula. ;  ; Double_t EvalPrimitive2 (const Double_t *x, const Double_t *params);  Evaluate primitive formula. ;  ; Double_t EvalPr",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:23247,Modifiability,inherit,inherited,23247,"po = 100; , kxexpo = 100; , kyexpo = 101; , kzexpo = 102; , ;   kxyexpo = 105; , kgaus = 110; , kxgaus = 110; , kygaus = 111; , ;   kzgaus = 112; , kxygaus = 115; , klandau = 120; , kxlandau = 120; , ;   kylandau = 121; , kzlandau = 122; , kxylandau = 125; , kpol = 130; , ;   kxpol = 130; , kypol = 131; , kzpol = 132; , kParameter = 140; , ;   kConstant = 141; , kBoolOptimize = 142; , kStringConst = 143; , kVariable = 144; , ;   kFunctionCall = 145; , kData = 146; , kUnary = 147; , kBinary = 148; , ;   kThree = 149; , kDefinedVariable = 150; , kDefinedString = 151; , kPlusD = 152; , ;   kPlusDD = 153; , kMultD = 154; , kMultDD = 155; , kBoolOptimizeOr = 156; , ;   kBoolOptimizeAnd = 157; , kBoolSet = 158; , kFDM = 159; , kFD0 = 160; , ;   kFD1 = 161; , kFD2 = 162; , kFD3 = 163. };  ; typedef Double_t(TObject::* TFuncG) (const Double_t *, const Double_t *) const;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from ROOT::v5::TFormula; virtual Bool_t CheckOperands (Int_t leftoperand, Int_t rightoperartion, Int_t &err);  Check whether the operands at 'leftoper' and 'oper-1' are compatible with the operation at 'oper'. ;  ; virtual Bool_t CheckOperands (Int_t operation, Int_t &err);  Check whether the operand at 'oper-1' is compatible with the operation at 'oper'. ;  ; void ClearFormula (Option_t *option="""");  Resets the objects. ;  ; virtual void Convert (UInt_t fromVersion);  ; Double_t EvalParFast (const Double_t *x, const Double_t *params);  Evaluate this formula. ;  ; Double_t EvalPrimitive (const Double_t *x, const Double_t *params);  Evaluate primitive formula. ;  ; Double_t EvalPrimitive0 (const Double_t *x, const Double_t *params);  Evaluate primitive formula. ;  ; Double_t EvalPrimitive1 (const Double_t *x, const Double_t *params);  Evaluate primitive formula. ;  ; Double_t EvalPrimitive2 (const Double_t *x, const Double_t *params);  Evaluate primitive formula. ;  ; Double_t EvalPr",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:25263,Modifiability,inherit,inherited,25263,"tive formula. ;  ; Double_t EvalPrimitive4 (const Double_t *x, const Double_t *params);  Evaluate primitive formula. ;  ; Short_t GetAction (Int_t code) const;  ; Short_t GetActionOptimized (Int_t code) const;  ; Int_t GetActionParam (Int_t code) const;  ; Int_t GetActionParamOptimized (Int_t code) const;  ; Int_t * GetOper () const;  ; Int_t * GetOperOptimized () const;  ; virtual Bool_t IsString (Int_t oper) const;  Return true if the expression at the index 'oper' has to be treated as a string. ;  ; void MakePrimitive (const char *expr, Int_t pos);  MakePrimitive find TFormulaPrimitive replacement for some operands. ;  ; Int_t PreCompile ();  pointer to optimal function ;  ; void SetAction (Int_t code, Int_t value, Int_t param=0);  ; void SetActionOptimized (Int_t code, Int_t value, Int_t param=0);  ; virtual Bool_t StringToNumber (Int_t code);  Try to 'demote' a string into an array bytes. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from ROOT::v5::TFormula; TBits fAlreadyFound;  ; Double_t * fConst;  ; TString * fExpr;  ; TString * fExprOptimized;  Number of operators after optimization. ;  ; TObjArray fFunctions;  ; TObjArray fLinearParts;  ; TString * fNames;  ; Int_t fNconst;  ; Int_t fNdim;  ; Int_t fNoper;  ; Int_t fNOperOptimized;  cache for information ;  ; Int_t fNpar;  ; Int_t fNstring;  ; Int_t fNumber;  ; Int_t fNval;  ; TOperOffset * fOperOffset;  [fNOperOptimized] List of operators. (See documentation for changes made at version 7) ;  ; Int_t * fOperOptimized;  [fNOperOptimized] List of expressions ;  ; TFuncG fOptimal;  [fNPar] predefined function ;  ; Double_t * fParams;  ; TFormulaPrimitive ** fPredefined;  [fNOperOptimized] Offsets of operrands ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attr",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:25468,Modifiability,inherit,inherited,25468,"const;  ; Int_t GetActionParam (Int_t code) const;  ; Int_t GetActionParamOptimized (Int_t code) const;  ; Int_t * GetOper () const;  ; Int_t * GetOperOptimized () const;  ; virtual Bool_t IsString (Int_t oper) const;  Return true if the expression at the index 'oper' has to be treated as a string. ;  ; void MakePrimitive (const char *expr, Int_t pos);  MakePrimitive find TFormulaPrimitive replacement for some operands. ;  ; Int_t PreCompile ();  pointer to optimal function ;  ; void SetAction (Int_t code, Int_t value, Int_t param=0);  ; void SetActionOptimized (Int_t code, Int_t value, Int_t param=0);  ; virtual Bool_t StringToNumber (Int_t code);  Try to 'demote' a string into an array bytes. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from ROOT::v5::TFormula; TBits fAlreadyFound;  ; Double_t * fConst;  ; TString * fExpr;  ; TString * fExprOptimized;  Number of operators after optimization. ;  ; TObjArray fFunctions;  ; TObjArray fLinearParts;  ; TString * fNames;  ; Int_t fNconst;  ; Int_t fNdim;  ; Int_t fNoper;  ; Int_t fNOperOptimized;  cache for information ;  ; Int_t fNpar;  ; Int_t fNstring;  ; Int_t fNumber;  ; Int_t fNval;  ; TOperOffset * fOperOffset;  [fNOperOptimized] List of operators. (See documentation for changes made at version 7) ;  ; Int_t * fOperOptimized;  [fNOperOptimized] List of expressions ;  ; TFuncG fOptimal;  [fNPar] predefined function ;  ; Double_t * fParams;  ; TFormulaPrimitive ** fPredefined;  [fNOperOptimized] Offsets of operrands ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fF",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:26248,Modifiability,inherit,inherited,26248," (Int_t code);  Try to 'demote' a string into an array bytes. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from ROOT::v5::TFormula; TBits fAlreadyFound;  ; Double_t * fConst;  ; TString * fExpr;  ; TString * fExprOptimized;  Number of operators after optimization. ;  ; TObjArray fFunctions;  ; TObjArray fLinearParts;  ; TString * fNames;  ; Int_t fNconst;  ; Int_t fNdim;  ; Int_t fNoper;  ; Int_t fNOperOptimized;  cache for information ;  ; Int_t fNpar;  ; Int_t fNstring;  ; Int_t fNumber;  ; Int_t fNval;  ; TOperOffset * fOperOffset;  [fNOperOptimized] List of operators. (See documentation for changes made at version 7) ;  ; Int_t * fOperOptimized;  [fNOperOptimized] List of expressions ;  ; TFuncG fOptimal;  [fNPar] predefined function ;  ; Double_t * fParams;  ; TFormulaPrimitive ** fPredefined;  [fNOperOptimized] Offsets of operrands ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Style_t fFillStyle;  Fill area style. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  . #include <v5/TF1Data.h>. Inheritance diagram for ROOT::v5::TF1Data:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TF1Data(). ROOT::v5::TF1Data::TF1Data ; (; ). F1 default constructor. ; Definition at line 26 of file TF1Data_v5.cxx. ◆ ~TF1Data(). ROOT::v5::TF1Data::~TF1Data ; (; ). override . TF1 defa",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:26330,Modifiability,inherit,inherited,26330," (Int_t code);  Try to 'demote' a string into an array bytes. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from ROOT::v5::TFormula; TBits fAlreadyFound;  ; Double_t * fConst;  ; TString * fExpr;  ; TString * fExprOptimized;  Number of operators after optimization. ;  ; TObjArray fFunctions;  ; TObjArray fLinearParts;  ; TString * fNames;  ; Int_t fNconst;  ; Int_t fNdim;  ; Int_t fNoper;  ; Int_t fNOperOptimized;  cache for information ;  ; Int_t fNpar;  ; Int_t fNstring;  ; Int_t fNumber;  ; Int_t fNval;  ; TOperOffset * fOperOffset;  [fNOperOptimized] List of operators. (See documentation for changes made at version 7) ;  ; Int_t * fOperOptimized;  [fNOperOptimized] List of expressions ;  ; TFuncG fOptimal;  [fNPar] predefined function ;  ; Double_t * fParams;  ; TFormulaPrimitive ** fPredefined;  [fNOperOptimized] Offsets of operrands ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Style_t fFillStyle;  Fill area style. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  . #include <v5/TF1Data.h>. Inheritance diagram for ROOT::v5::TF1Data:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TF1Data(). ROOT::v5::TF1Data::TF1Data ; (; ). F1 default constructor. ; Definition at line 26 of file TF1Data_v5.cxx. ◆ ~TF1Data(). ROOT::v5::TF1Data::~TF1Data ; (; ). override . TF1 defa",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:26491,Modifiability,inherit,inherited,26491," fAlreadyFound;  ; Double_t * fConst;  ; TString * fExpr;  ; TString * fExprOptimized;  Number of operators after optimization. ;  ; TObjArray fFunctions;  ; TObjArray fLinearParts;  ; TString * fNames;  ; Int_t fNconst;  ; Int_t fNdim;  ; Int_t fNoper;  ; Int_t fNOperOptimized;  cache for information ;  ; Int_t fNpar;  ; Int_t fNstring;  ; Int_t fNumber;  ; Int_t fNval;  ; TOperOffset * fOperOffset;  [fNOperOptimized] List of operators. (See documentation for changes made at version 7) ;  ; Int_t * fOperOptimized;  [fNOperOptimized] List of expressions ;  ; TFuncG fOptimal;  [fNPar] predefined function ;  ; Double_t * fParams;  ; TFormulaPrimitive ** fPredefined;  [fNOperOptimized] Offsets of operrands ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Style_t fFillStyle;  Fill area style. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  . #include <v5/TF1Data.h>. Inheritance diagram for ROOT::v5::TF1Data:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TF1Data(). ROOT::v5::TF1Data::TF1Data ; (; ). F1 default constructor. ; Definition at line 26 of file TF1Data_v5.cxx. ◆ ~TF1Data(). ROOT::v5::TF1Data::~TF1Data ; (; ). override . TF1 default destructor. ; Definition at line 48 of file TF1Data_v5.cxx. Member Function Documentation. ◆ Class(). static TClass * ROOT::v5::TF1Data::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * ROOT::v5::TF1Data::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static c",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:26624,Modifiability,inherit,inherited,26624,"TObjArray fFunctions;  ; TObjArray fLinearParts;  ; TString * fNames;  ; Int_t fNconst;  ; Int_t fNdim;  ; Int_t fNoper;  ; Int_t fNOperOptimized;  cache for information ;  ; Int_t fNpar;  ; Int_t fNstring;  ; Int_t fNumber;  ; Int_t fNval;  ; TOperOffset * fOperOffset;  [fNOperOptimized] List of operators. (See documentation for changes made at version 7) ;  ; Int_t * fOperOptimized;  [fNOperOptimized] List of expressions ;  ; TFuncG fOptimal;  [fNPar] predefined function ;  ; Double_t * fParams;  ; TFormulaPrimitive ** fPredefined;  [fNOperOptimized] Offsets of operrands ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Style_t fFillStyle;  Fill area style. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  . #include <v5/TF1Data.h>. Inheritance diagram for ROOT::v5::TF1Data:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TF1Data(). ROOT::v5::TF1Data::TF1Data ; (; ). F1 default constructor. ; Definition at line 26 of file TF1Data_v5.cxx. ◆ ~TF1Data(). ROOT::v5::TF1Data::~TF1Data ; (; ). override . TF1 default destructor. ; Definition at line 48 of file TF1Data_v5.cxx. Member Function Documentation. ◆ Class(). static TClass * ROOT::v5::TF1Data::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * ROOT::v5::TF1Data::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t ROOT::v5::TF1Data::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:25622,Performance,optimiz,optimization,25622,"const;  ; Int_t GetActionParam (Int_t code) const;  ; Int_t GetActionParamOptimized (Int_t code) const;  ; Int_t * GetOper () const;  ; Int_t * GetOperOptimized () const;  ; virtual Bool_t IsString (Int_t oper) const;  Return true if the expression at the index 'oper' has to be treated as a string. ;  ; void MakePrimitive (const char *expr, Int_t pos);  MakePrimitive find TFormulaPrimitive replacement for some operands. ;  ; Int_t PreCompile ();  pointer to optimal function ;  ; void SetAction (Int_t code, Int_t value, Int_t param=0);  ; void SetActionOptimized (Int_t code, Int_t value, Int_t param=0);  ; virtual Bool_t StringToNumber (Int_t code);  Try to 'demote' a string into an array bytes. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from ROOT::v5::TFormula; TBits fAlreadyFound;  ; Double_t * fConst;  ; TString * fExpr;  ; TString * fExprOptimized;  Number of operators after optimization. ;  ; TObjArray fFunctions;  ; TObjArray fLinearParts;  ; TString * fNames;  ; Int_t fNconst;  ; Int_t fNdim;  ; Int_t fNoper;  ; Int_t fNOperOptimized;  cache for information ;  ; Int_t fNpar;  ; Int_t fNstring;  ; Int_t fNumber;  ; Int_t fNval;  ; TOperOffset * fOperOffset;  [fNOperOptimized] List of operators. (See documentation for changes made at version 7) ;  ; Int_t * fOperOptimized;  [fNOperOptimized] List of expressions ;  ; TFuncG fOptimal;  [fNPar] predefined function ;  ; Double_t * fParams;  ; TFormulaPrimitive ** fPredefined;  [fNOperOptimized] Offsets of operrands ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fF",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:25789,Performance,cache,cache,25789,"r' has to be treated as a string. ;  ; void MakePrimitive (const char *expr, Int_t pos);  MakePrimitive find TFormulaPrimitive replacement for some operands. ;  ; Int_t PreCompile ();  pointer to optimal function ;  ; void SetAction (Int_t code, Int_t value, Int_t param=0);  ; void SetActionOptimized (Int_t code, Int_t value, Int_t param=0);  ; virtual Bool_t StringToNumber (Int_t code);  Try to 'demote' a string into an array bytes. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from ROOT::v5::TFormula; TBits fAlreadyFound;  ; Double_t * fConst;  ; TString * fExpr;  ; TString * fExprOptimized;  Number of operators after optimization. ;  ; TObjArray fFunctions;  ; TObjArray fLinearParts;  ; TString * fNames;  ; Int_t fNconst;  ; Int_t fNdim;  ; Int_t fNoper;  ; Int_t fNOperOptimized;  cache for information ;  ; Int_t fNpar;  ; Int_t fNstring;  ; Int_t fNumber;  ; Int_t fNval;  ; TOperOffset * fOperOffset;  [fNOperOptimized] List of operators. (See documentation for changes made at version 7) ;  ; Int_t * fOperOptimized;  [fNOperOptimized] List of expressions ;  ; TFuncG fOptimal;  [fNPar] predefined function ;  ; Double_t * fParams;  ; TFormulaPrimitive ** fPredefined;  [fNOperOptimized] Offsets of operrands ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Style_t fFillStyle;  Fill area style. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  . #include <v5/TF1Da",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:5946,Security,hash,hash,5946,"as TF1Old in memory ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
https://root.cern/doc/master/structSetWindowAttributes__t.html:1150,Availability,mask,mask,1150,". ROOT: SetWindowAttributes_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; SetWindowAttributes_t Struct Reference. ; Attributes that can be used when creating or changing a window. ; Definition at line 93 of file GuiTypes.h. Public Attributes; ULong_t fBackgroundPixel;  background pixel ;  ; Pixmap_t fBackgroundPixmap;  background or kNone or kParentRelative ;  ; ULong_t fBackingPixel;  value to use in restoring planes ;  ; ULong_t fBackingPlanes;  planes to be preserved if possible ;  ; Int_t fBackingStore;  kNotUseful, kWhenMapped, kAlways ;  ; Int_t fBitGravity;  one of bit gravity values ;  ; ULong_t fBorderPixel;  border pixel value ;  ; Pixmap_t fBorderPixmap;  border of the window ;  ; UInt_t fBorderWidth;  border width in pixels ;  ; Colormap_t fColormap;  color map to be associated with window ;  ; Cursor_t fCursor;  cursor to be displayed (or kNone) ;  ; Long_t fDoNotPropagateMask;  set of events that should not propagate ;  ; Long_t fEventMask;  set of events that should be saved ;  ; Mask_t fMask;  bit mask specifying which fields are valid ;  ; Bool_t fOverrideRedirect;  boolean value for override-redirect ;  ; Bool_t fSaveUnder;  should bits under be saved (popups)? ;  ; Int_t fWinGravity;  one of the window gravity values ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fBackgroundPixel. ULong_t SetWindowAttributes_t::fBackgroundPixel. background pixel ; Definition at line 95 of file GuiTypes.h. ◆ fBackgroundPixmap. Pixmap_t SetWindowAttributes_t::fBackgroundPixmap. background or kNone or kParentRelative ; Definition at line 94 of file GuiTypes.h. ◆ fBackingPixel. ULong_t SetWindowAttributes_t::fBackingPixel. value to use in restoring planes ; Definition at line 103 of file GuiTypes.h. ◆ fBackingPlanes. ULong_t SetWindowAttributes_t::fBackingPlanes. planes to be preserved if possible ; Definition at line 102 of file GuiTypes.h",MatchSource.WIKI,doc/master/structSetWindowAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structSetWindowAttributes__t.html
https://root.cern/doc/master/structSetWindowAttributes__t.html:3267,Availability,mask,mask,3267,"tGravity. Int_t SetWindowAttributes_t::fBitGravity. one of bit gravity values ; Definition at line 99 of file GuiTypes.h. ◆ fBorderPixel. ULong_t SetWindowAttributes_t::fBorderPixel. border pixel value ; Definition at line 97 of file GuiTypes.h. ◆ fBorderPixmap. Pixmap_t SetWindowAttributes_t::fBorderPixmap. border of the window ; Definition at line 96 of file GuiTypes.h. ◆ fBorderWidth. UInt_t SetWindowAttributes_t::fBorderWidth. border width in pixels ; Definition at line 98 of file GuiTypes.h. ◆ fColormap. Colormap_t SetWindowAttributes_t::fColormap. color map to be associated with window ; Definition at line 108 of file GuiTypes.h. ◆ fCursor. Cursor_t SetWindowAttributes_t::fCursor. cursor to be displayed (or kNone) ; Definition at line 109 of file GuiTypes.h. ◆ fDoNotPropagateMask. Long_t SetWindowAttributes_t::fDoNotPropagateMask. set of events that should not propagate ; Definition at line 106 of file GuiTypes.h. ◆ fEventMask. Long_t SetWindowAttributes_t::fEventMask. set of events that should be saved ; Definition at line 105 of file GuiTypes.h. ◆ fMask. Mask_t SetWindowAttributes_t::fMask. bit mask specifying which fields are valid ; Definition at line 110 of file GuiTypes.h. ◆ fOverrideRedirect. Bool_t SetWindowAttributes_t::fOverrideRedirect. boolean value for override-redirect ; Definition at line 107 of file GuiTypes.h. ◆ fSaveUnder. Bool_t SetWindowAttributes_t::fSaveUnder. should bits under be saved (popups)? ; Definition at line 104 of file GuiTypes.h. ◆ fWinGravity. Int_t SetWindowAttributes_t::fWinGravity. one of the window gravity values ; Definition at line 100 of file GuiTypes.h. Collaboration diagram for SetWindowAttributes_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. SetWindowAttributes_t. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structSetWindowAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structSetWindowAttributes__t.html
https://root.cern/doc/master/structTF1_1_1TF1FunctorPointerImpl.html:707,Modifiability,inherit,inherited,707,". ROOT: TF1::TF1FunctorPointerImpl< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; TF1::TF1FunctorPointerImpl< T > Struct Template Reference. ; template<class T>; struct TF1::TF1FunctorPointerImpl< T >; Definition at line 313 of file TF1.h. Public Member Functions;  TF1FunctorPointerImpl (const ROOT::Math::ParamFunctorTempl< T > &func);  ;  TF1FunctorPointerImpl (const std::function< T(const T *f, const Double_t *param)> &func);  ;  ~TF1FunctorPointerImpl () override;  ; TF1FunctorPointer * Clone () const override;  ;  Public Member Functions inherited from TF1::TF1FunctorPointer; virtual ~TF1FunctorPointer ();  . Public Attributes; ROOT::Math::ParamFunctorTempl< T > fImpl;  . #include <TF1.h>. Inheritance diagram for TF1::TF1FunctorPointerImpl< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TF1FunctorPointerImpl() [1/2]. template<class T > . TF1::TF1FunctorPointerImpl< T >::TF1FunctorPointerImpl ; (; const ROOT::Math::ParamFunctorTempl< T > & ; func). inline . Definition at line 314 of file TF1.h. ◆ TF1FunctorPointerImpl() [2/2]. template<class T > . TF1::TF1FunctorPointerImpl< T >::TF1FunctorPointerImpl ; (; const std::function< T(const T *f, const Double_t *param)> & ; func). inline . Definition at line 315 of file TF1.h. ◆ ~TF1FunctorPointerImpl(). template<class T > . TF1::TF1FunctorPointerImpl< T >::~TF1FunctorPointerImpl ; (; ). inlineoverride . Definition at line 316 of file TF1.h. Member Function Documentation. ◆ Clone(). template<class T > . TF1FunctorPointer * TF1::TF1FunctorPointerImpl< T >::Clone ; (; ); const. inlineoverridevirtual . Implements TF1::TF1FunctorPointer.; Definition at line 317 of file TF1.h. Member Data Documentation. ◆ fImpl. template<class T > . ROOT::Math::ParamFunctorTempl<T> TF1::TF1",MatchSource.WIKI,doc/master/structTF1_1_1TF1FunctorPointerImpl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTF1_1_1TF1FunctorPointerImpl.html
https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html:805,Performance,cache,cache,805,". ROOT: TGenCollectionProxy::Value Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; TGenCollectionProxy::Value Class Reference. ; Small helper to describe the Value_type or the key_type of an STL container. ; AuthorM.Frank ; Version1.0 ; Date10/10/2004 ; Definition at line 60 of file TGenCollectionProxy.h. Public Member Functions;  Value (const std::string &info, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0);  Constructor. ;  ; void DeleteItem (void *ptr);  ; Bool_t IsValid ();  Return true if the Value has been properly initialized. ;  . Public Attributes; UInt_t fCase;  type of data of Value_type ;  ; ROOT::NewFunc_t fCtor;  Method cache for containee constructor. ;  ; ROOT::DelFunc_t fDelete;  Method cache for containee delete. ;  ; ROOT::DesFunc_t fDtor;  Method cache for containee destructor. ;  ; EDataType fKind;  kind of ROOT-fundamental type ;  ; UInt_t fProperties;  Additional properties of the value type (kNeedDelete) ;  ; size_t fSize;  fSize of the contained object ;  ; TClassRef fType;  TClass reference of Value_type in collection. ;  . #include <TGenCollectionProxy.h>; Constructor & Destructor Documentation. ◆ Value(). TGenCollectionProxy::Value::Value ; (; const std::string & ; info, . Bool_t ; silent, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). Constructor. ; Definition at line 316 of file TGenCollectionProxy.cxx. Member Function Documentation. ◆ DeleteItem(). void TGenCollectionProxy::Value::DeleteItem ; (; void * ; ptr). Definition at line 518 of file TGenCollectionProxy.cxx. ◆ IsValid(). Bool_t TGenCollectionProxy::Value::IsValid ; (; ). Return true if the Value has been properly initialized. ; Definition at line 511 of file TGenCollectionProxy.cxx. Member Data Documentation. ◆ fCase. UInt_t TGenCollectionProxy::Value::fCase. type of data of Value_type ; Definition",MatchSource.WIKI,doc/master/structTGenCollectionProxy_1_1Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html
https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html:876,Performance,cache,cache,876,". ROOT: TGenCollectionProxy::Value Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; TGenCollectionProxy::Value Class Reference. ; Small helper to describe the Value_type or the key_type of an STL container. ; AuthorM.Frank ; Version1.0 ; Date10/10/2004 ; Definition at line 60 of file TGenCollectionProxy.h. Public Member Functions;  Value (const std::string &info, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0);  Constructor. ;  ; void DeleteItem (void *ptr);  ; Bool_t IsValid ();  Return true if the Value has been properly initialized. ;  . Public Attributes; UInt_t fCase;  type of data of Value_type ;  ; ROOT::NewFunc_t fCtor;  Method cache for containee constructor. ;  ; ROOT::DelFunc_t fDelete;  Method cache for containee delete. ;  ; ROOT::DesFunc_t fDtor;  Method cache for containee destructor. ;  ; EDataType fKind;  kind of ROOT-fundamental type ;  ; UInt_t fProperties;  Additional properties of the value type (kNeedDelete) ;  ; size_t fSize;  fSize of the contained object ;  ; TClassRef fType;  TClass reference of Value_type in collection. ;  . #include <TGenCollectionProxy.h>; Constructor & Destructor Documentation. ◆ Value(). TGenCollectionProxy::Value::Value ; (; const std::string & ; info, . Bool_t ; silent, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). Constructor. ; Definition at line 316 of file TGenCollectionProxy.cxx. Member Function Documentation. ◆ DeleteItem(). void TGenCollectionProxy::Value::DeleteItem ; (; void * ; ptr). Definition at line 518 of file TGenCollectionProxy.cxx. ◆ IsValid(). Bool_t TGenCollectionProxy::Value::IsValid ; (; ). Return true if the Value has been properly initialized. ; Definition at line 511 of file TGenCollectionProxy.cxx. Member Data Documentation. ◆ fCase. UInt_t TGenCollectionProxy::Value::fCase. type of data of Value_type ; Definition",MatchSource.WIKI,doc/master/structTGenCollectionProxy_1_1Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html
https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html:940,Performance,cache,cache,940,". ROOT: TGenCollectionProxy::Value Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; TGenCollectionProxy::Value Class Reference. ; Small helper to describe the Value_type or the key_type of an STL container. ; AuthorM.Frank ; Version1.0 ; Date10/10/2004 ; Definition at line 60 of file TGenCollectionProxy.h. Public Member Functions;  Value (const std::string &info, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0);  Constructor. ;  ; void DeleteItem (void *ptr);  ; Bool_t IsValid ();  Return true if the Value has been properly initialized. ;  . Public Attributes; UInt_t fCase;  type of data of Value_type ;  ; ROOT::NewFunc_t fCtor;  Method cache for containee constructor. ;  ; ROOT::DelFunc_t fDelete;  Method cache for containee delete. ;  ; ROOT::DesFunc_t fDtor;  Method cache for containee destructor. ;  ; EDataType fKind;  kind of ROOT-fundamental type ;  ; UInt_t fProperties;  Additional properties of the value type (kNeedDelete) ;  ; size_t fSize;  fSize of the contained object ;  ; TClassRef fType;  TClass reference of Value_type in collection. ;  . #include <TGenCollectionProxy.h>; Constructor & Destructor Documentation. ◆ Value(). TGenCollectionProxy::Value::Value ; (; const std::string & ; info, . Bool_t ; silent, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). Constructor. ; Definition at line 316 of file TGenCollectionProxy.cxx. Member Function Documentation. ◆ DeleteItem(). void TGenCollectionProxy::Value::DeleteItem ; (; void * ; ptr). Definition at line 518 of file TGenCollectionProxy.cxx. ◆ IsValid(). Bool_t TGenCollectionProxy::Value::IsValid ; (; ). Return true if the Value has been properly initialized. ; Definition at line 511 of file TGenCollectionProxy.cxx. Member Data Documentation. ◆ fCase. UInt_t TGenCollectionProxy::Value::fCase. type of data of Value_type ; Definition",MatchSource.WIKI,doc/master/structTGenCollectionProxy_1_1Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html
https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html:2111,Performance,cache,cache,2111,"  fSize of the contained object ;  ; TClassRef fType;  TClass reference of Value_type in collection. ;  . #include <TGenCollectionProxy.h>; Constructor & Destructor Documentation. ◆ Value(). TGenCollectionProxy::Value::Value ; (; const std::string & ; info, . Bool_t ; silent, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). Constructor. ; Definition at line 316 of file TGenCollectionProxy.cxx. Member Function Documentation. ◆ DeleteItem(). void TGenCollectionProxy::Value::DeleteItem ; (; void * ; ptr). Definition at line 518 of file TGenCollectionProxy.cxx. ◆ IsValid(). Bool_t TGenCollectionProxy::Value::IsValid ; (; ). Return true if the Value has been properly initialized. ; Definition at line 511 of file TGenCollectionProxy.cxx. Member Data Documentation. ◆ fCase. UInt_t TGenCollectionProxy::Value::fCase. type of data of Value_type ; Definition at line 64 of file TGenCollectionProxy.h. ◆ fCtor. ROOT::NewFunc_t TGenCollectionProxy::Value::fCtor. Method cache for containee constructor. ; Definition at line 61 of file TGenCollectionProxy.h. ◆ fDelete. ROOT::DelFunc_t TGenCollectionProxy::Value::fDelete. Method cache for containee delete. ; Definition at line 63 of file TGenCollectionProxy.h. ◆ fDtor. ROOT::DesFunc_t TGenCollectionProxy::Value::fDtor. Method cache for containee destructor. ; Definition at line 62 of file TGenCollectionProxy.h. ◆ fKind. EDataType TGenCollectionProxy::Value::fKind. kind of ROOT-fundamental type ; Definition at line 67 of file TGenCollectionProxy.h. ◆ fProperties. UInt_t TGenCollectionProxy::Value::fProperties. Additional properties of the value type (kNeedDelete) ; Definition at line 65 of file TGenCollectionProxy.h. ◆ fSize. size_t TGenCollectionProxy::Value::fSize. fSize of the contained object ; Definition at line 68 of file TGenCollectionProxy.h. ◆ fType. TClassRef TGenCollectionProxy::Value::fType. TClass reference of Value_type in collection. ; Definition at line 66 of file TGenCollectionProxy.h. Collaboration ",MatchSource.WIKI,doc/master/structTGenCollectionProxy_1_1Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html
https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html:2270,Performance,cache,cache,2270,"structor Documentation. ◆ Value(). TGenCollectionProxy::Value::Value ; (; const std::string & ; info, . Bool_t ; silent, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). Constructor. ; Definition at line 316 of file TGenCollectionProxy.cxx. Member Function Documentation. ◆ DeleteItem(). void TGenCollectionProxy::Value::DeleteItem ; (; void * ; ptr). Definition at line 518 of file TGenCollectionProxy.cxx. ◆ IsValid(). Bool_t TGenCollectionProxy::Value::IsValid ; (; ). Return true if the Value has been properly initialized. ; Definition at line 511 of file TGenCollectionProxy.cxx. Member Data Documentation. ◆ fCase. UInt_t TGenCollectionProxy::Value::fCase. type of data of Value_type ; Definition at line 64 of file TGenCollectionProxy.h. ◆ fCtor. ROOT::NewFunc_t TGenCollectionProxy::Value::fCtor. Method cache for containee constructor. ; Definition at line 61 of file TGenCollectionProxy.h. ◆ fDelete. ROOT::DelFunc_t TGenCollectionProxy::Value::fDelete. Method cache for containee delete. ; Definition at line 63 of file TGenCollectionProxy.h. ◆ fDtor. ROOT::DesFunc_t TGenCollectionProxy::Value::fDtor. Method cache for containee destructor. ; Definition at line 62 of file TGenCollectionProxy.h. ◆ fKind. EDataType TGenCollectionProxy::Value::fKind. kind of ROOT-fundamental type ; Definition at line 67 of file TGenCollectionProxy.h. ◆ fProperties. UInt_t TGenCollectionProxy::Value::fProperties. Additional properties of the value type (kNeedDelete) ; Definition at line 65 of file TGenCollectionProxy.h. ◆ fSize. size_t TGenCollectionProxy::Value::fSize. fSize of the contained object ; Definition at line 68 of file TGenCollectionProxy.h. ◆ fType. TClassRef TGenCollectionProxy::Value::fType. TClass reference of Value_type in collection. ; Definition at line 66 of file TGenCollectionProxy.h. Collaboration diagram for TGenCollectionProxy::Value:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation fo",MatchSource.WIKI,doc/master/structTGenCollectionProxy_1_1Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html
https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html:2420,Performance,cache,cache,2420,", . size_t ; hint_pair_size = 0 . ). Constructor. ; Definition at line 316 of file TGenCollectionProxy.cxx. Member Function Documentation. ◆ DeleteItem(). void TGenCollectionProxy::Value::DeleteItem ; (; void * ; ptr). Definition at line 518 of file TGenCollectionProxy.cxx. ◆ IsValid(). Bool_t TGenCollectionProxy::Value::IsValid ; (; ). Return true if the Value has been properly initialized. ; Definition at line 511 of file TGenCollectionProxy.cxx. Member Data Documentation. ◆ fCase. UInt_t TGenCollectionProxy::Value::fCase. type of data of Value_type ; Definition at line 64 of file TGenCollectionProxy.h. ◆ fCtor. ROOT::NewFunc_t TGenCollectionProxy::Value::fCtor. Method cache for containee constructor. ; Definition at line 61 of file TGenCollectionProxy.h. ◆ fDelete. ROOT::DelFunc_t TGenCollectionProxy::Value::fDelete. Method cache for containee delete. ; Definition at line 63 of file TGenCollectionProxy.h. ◆ fDtor. ROOT::DesFunc_t TGenCollectionProxy::Value::fDtor. Method cache for containee destructor. ; Definition at line 62 of file TGenCollectionProxy.h. ◆ fKind. EDataType TGenCollectionProxy::Value::fKind. kind of ROOT-fundamental type ; Definition at line 67 of file TGenCollectionProxy.h. ◆ fProperties. UInt_t TGenCollectionProxy::Value::fProperties. Additional properties of the value type (kNeedDelete) ; Definition at line 65 of file TGenCollectionProxy.h. ◆ fSize. size_t TGenCollectionProxy::Value::fSize. fSize of the contained object ; Definition at line 68 of file TGenCollectionProxy.h. ◆ fType. TClassRef TGenCollectionProxy::Value::fType. TClass reference of Value_type in collection. ; Definition at line 66 of file TGenCollectionProxy.h. Collaboration diagram for TGenCollectionProxy::Value:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this class was generated from the following files:; io/io/inc/TGenCollectionProxy.h; io/io/src/TGenCollectionProxy.cxx. TGenCollectionProxyValue. ROOT",MatchSource.WIKI,doc/master/structTGenCollectionProxy_1_1Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html
https://root.cern/doc/master/structTMVA_1_1DNN_1_1TDNNGenDescriptors.html:630,Modifiability,inherit,inherited,630,". ROOT: TMVA::DNN::TDNNGenDescriptors< Layer_t > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Attributes |; List of all members ; TMVA::DNN::TDNNGenDescriptors< Layer_t > Struct Template Reference. ; template<typename Layer_t>; struct TMVA::DNN::TDNNGenDescriptors< Layer_t >; Definition at line 37 of file ContextHandles.h. Public Types; using HelperDescriptor_t = typename Layer_t::HelperDescriptor_t;  . Public Attributes; HelperDescriptor_t HelperDescriptor;  . Additional Inherited Members;  Public Member Functions inherited from TMVA::DNN::TDescriptors; virtual ~TDescriptors ();  . #include <TMVA/DNN/CNN/ContextHandles.h>. Inheritance diagram for TMVA::DNN::TDNNGenDescriptors< Layer_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ HelperDescriptor_t. template<typename Layer_t > . using TMVA::DNN::TDNNGenDescriptors< Layer_t >::HelperDescriptor_t = typename Layer_t::HelperDescriptor_t. Definition at line 38 of file ContextHandles.h. Member Data Documentation. ◆ HelperDescriptor. template<typename Layer_t > . HelperDescriptor_t TMVA::DNN::TDNNGenDescriptors< Layer_t >::HelperDescriptor. Definition at line 40 of file ContextHandles.h. Collaboration diagram for TMVA::DNN::TDNNGenDescriptors< Layer_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/DNN/CNN/ContextHandles.h. TMVADNNTDNNGenDescriptors. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:46 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structTMVA_1_1DNN_1_1TDNNGenDescriptors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1DNN_1_1TDNNGenDescriptors.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:576,Performance,optimiz,optimizer,576,". ROOT: TMVA::TTrainingSettings Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; TMVA::TTrainingSettings Struct Reference. ; All of the options that can be specified in the training string. ; Definition at line 72 of file MethodDL.h. Public Attributes; size_t batchSize;  ; size_t convergenceSteps;  ; std::vector< Double_t > dropoutProbabilities;  ; Double_t learningRate;  ; size_t maxEpochs;  ; Double_t momentum;  ; bool multithreading;  ; DNN::EOptimizer optimizer;  ; TString optimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:598,Performance,optimiz,optimizerName,598,". ROOT: TMVA::TTrainingSettings Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; TMVA::TTrainingSettings Struct Reference. ; All of the options that can be specified in the training string. ; Definition at line 72 of file MethodDL.h. Public Attributes; size_t batchSize;  ; size_t convergenceSteps;  ; std::vector< Double_t > dropoutProbabilities;  ; Double_t learningRate;  ; size_t maxEpochs;  ; Double_t momentum;  ; bool multithreading;  ; DNN::EOptimizer optimizer;  ; TString optimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:644,Performance,optimiz,optimizerParams,644,". ROOT: TMVA::TTrainingSettings Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; TMVA::TTrainingSettings Struct Reference. ; All of the options that can be specified in the training string. ; Definition at line 72 of file MethodDL.h. Public Attributes; size_t batchSize;  ; size_t convergenceSteps;  ; std::vector< Double_t > dropoutProbabilities;  ; Double_t learningRate;  ; size_t maxEpochs;  ; Double_t momentum;  ; bool multithreading;  ; DNN::EOptimizer optimizer;  ; TString optimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:1563,Performance,optimiz,optimizer,1563,"Optimizer optimizer;  ; TString optimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::TTrainingSettings::weightDecay. Definition at line 82 of file MethodDL.h. Collaboration diagram for TMVA::TTrainingSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/MethodDL.h. TMVATTrainingSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 ",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:1615,Performance,optimiz,optimizer,1615,"ptimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::TTrainingSettings::weightDecay. Definition at line 82 of file MethodDL.h. Collaboration diagram for TMVA::TTrainingSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/MethodDL.h. TMVATTrainingSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:44 (GVA Time) using Doxyge",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:1670,Performance,optimiz,optimizerName,1670," ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::TTrainingSettings::weightDecay. Definition at line 82 of file MethodDL.h. Collaboration diagram for TMVA::TTrainingSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/MethodDL.h. TMVATTrainingSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:44 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:1718,Performance,optimiz,optimizerName,1718," ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::TTrainingSettings::weightDecay. Definition at line 82 of file MethodDL.h. Collaboration diagram for TMVA::TTrainingSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/MethodDL.h. TMVATTrainingSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:44 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:1777,Performance,optimiz,optimizerParams,1777," ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::TTrainingSettings::weightDecay. Definition at line 82 of file MethodDL.h. Collaboration diagram for TMVA::TTrainingSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/MethodDL.h. TMVATTrainingSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:44 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:1844,Performance,optimiz,optimizerParams,1844," ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::TTrainingSettings::weightDecay. Definition at line 82 of file MethodDL.h. Collaboration diagram for TMVA::TTrainingSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/MethodDL.h. TMVATTrainingSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:44 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:711,Testability,test,testInterval,711,". ROOT: TMVA::TTrainingSettings Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; TMVA::TTrainingSettings Struct Reference. ; All of the options that can be specified in the training string. ; Definition at line 72 of file MethodDL.h. Public Attributes; size_t batchSize;  ; size_t convergenceSteps;  ; std::vector< Double_t > dropoutProbabilities;  ; Double_t learningRate;  ; size_t maxEpochs;  ; Double_t momentum;  ; bool multithreading;  ; DNN::EOptimizer optimizer;  ; TString optimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:2027,Testability,test,testInterval,2027," ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::TTrainingSettings::weightDecay. Definition at line 82 of file MethodDL.h. Collaboration diagram for TMVA::TTrainingSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/MethodDL.h. TMVATTrainingSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:44 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:2073,Testability,test,testInterval,2073," ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::TTrainingSettings::weightDecay. Definition at line 82 of file MethodDL.h. Collaboration diagram for TMVA::TTrainingSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/MethodDL.h. TMVATTrainingSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:44 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:476,Usability,learn,learningRate,476,". ROOT: TMVA::TTrainingSettings Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; TMVA::TTrainingSettings Struct Reference. ; All of the options that can be specified in the training string. ; Definition at line 72 of file MethodDL.h. Public Attributes; size_t batchSize;  ; size_t convergenceSteps;  ; std::vector< Double_t > dropoutProbabilities;  ; Double_t learningRate;  ; size_t maxEpochs;  ; Double_t momentum;  ; bool multithreading;  ; DNN::EOptimizer optimizer;  ; TString optimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:1155,Usability,learn,learningRate,1155," Attributes |; List of all members ; TMVA::TTrainingSettings Struct Reference. ; All of the options that can be specified in the training string. ; Definition at line 72 of file MethodDL.h. Public Attributes; size_t batchSize;  ; size_t convergenceSteps;  ; std::vector< Double_t > dropoutProbabilities;  ; Double_t learningRate;  ; size_t maxEpochs;  ; Double_t momentum;  ; bool multithreading;  ; DNN::EOptimizer optimizer;  ; TString optimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::T",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:1203,Usability,learn,learningRate,1203,"rs ; TMVA::TTrainingSettings Struct Reference. ; All of the options that can be specified in the training string. ; Definition at line 72 of file MethodDL.h. Public Attributes; size_t batchSize;  ; size_t convergenceSteps;  ; std::vector< Double_t > dropoutProbabilities;  ; Double_t learningRate;  ; size_t maxEpochs;  ; Double_t momentum;  ; bool multithreading;  ; DNN::EOptimizer optimizer;  ; TString optimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::TTrainingSettings::weightDecay. D",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
https://root.cern/doc/master/structTTreePerfStats_1_1BasketInfo.html:483,Performance,cache,cache,483,". ROOT: TTreePerfStats::BasketInfo Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; TTreePerfStats::BasketInfo Struct Reference. . Definition at line 41 of file TTreePerfStats.h. Public Attributes; UInt_t fLoaded = {0};  Number of times the basket was put in the primary TTreeCache. ;  ; UInt_t fLoadedMiss = {0};  Number of times the basket was put in the secondary cache. ;  ; UInt_t fMissed = {0};  Number of times the basket was read directly from the file. ;  ; UInt_t fUsed = {0};  Number of times the basket was requested from the disk. ;  . #include <TTreePerfStats.h>; Member Data Documentation. ◆ fLoaded. UInt_t TTreePerfStats::BasketInfo::fLoaded = {0}. Number of times the basket was put in the primary TTreeCache. ; Definition at line 43 of file TTreePerfStats.h. ◆ fLoadedMiss. UInt_t TTreePerfStats::BasketInfo::fLoadedMiss = {0}. Number of times the basket was put in the secondary cache. ; Definition at line 44 of file TTreePerfStats.h. ◆ fMissed. UInt_t TTreePerfStats::BasketInfo::fMissed = {0}. Number of times the basket was read directly from the file. ; Definition at line 45 of file TTreePerfStats.h. ◆ fUsed. UInt_t TTreePerfStats::BasketInfo::fUsed = {0}. Number of times the basket was requested from the disk. ; Definition at line 42 of file TTreePerfStats.h. Collaboration diagram for TTreePerfStats::BasketInfo:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tree/treeplayer/inc/TTreePerfStats.h. TTreePerfStatsBasketInfo. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structTTreePerfStats_1_1BasketInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTTreePerfStats_1_1BasketInfo.html
https://root.cern/doc/master/structTTreePerfStats_1_1BasketInfo.html:1015,Performance,cache,cache,1015,". ROOT: TTreePerfStats::BasketInfo Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; TTreePerfStats::BasketInfo Struct Reference. . Definition at line 41 of file TTreePerfStats.h. Public Attributes; UInt_t fLoaded = {0};  Number of times the basket was put in the primary TTreeCache. ;  ; UInt_t fLoadedMiss = {0};  Number of times the basket was put in the secondary cache. ;  ; UInt_t fMissed = {0};  Number of times the basket was read directly from the file. ;  ; UInt_t fUsed = {0};  Number of times the basket was requested from the disk. ;  . #include <TTreePerfStats.h>; Member Data Documentation. ◆ fLoaded. UInt_t TTreePerfStats::BasketInfo::fLoaded = {0}. Number of times the basket was put in the primary TTreeCache. ; Definition at line 43 of file TTreePerfStats.h. ◆ fLoadedMiss. UInt_t TTreePerfStats::BasketInfo::fLoadedMiss = {0}. Number of times the basket was put in the secondary cache. ; Definition at line 44 of file TTreePerfStats.h. ◆ fMissed. UInt_t TTreePerfStats::BasketInfo::fMissed = {0}. Number of times the basket was read directly from the file. ; Definition at line 45 of file TTreePerfStats.h. ◆ fUsed. UInt_t TTreePerfStats::BasketInfo::fUsed = {0}. Number of times the basket was requested from the disk. ; Definition at line 42 of file TTreePerfStats.h. Collaboration diagram for TTreePerfStats::BasketInfo:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tree/treeplayer/inc/TTreePerfStats.h. TTreePerfStatsBasketInfo. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structTTreePerfStats_1_1BasketInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTTreePerfStats_1_1BasketInfo.html
https://root.cern/doc/master/structWindowAttributes__t.html:1550,Availability,mask,mask,1550,". ROOT: WindowAttributes_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; WindowAttributes_t Struct Reference. ; Window attributes that can be inquired. ; Definition at line 114 of file GuiTypes.h. Public Attributes; Long_t fAllEventMasks;  set of events all people have interest in ;  ; ULong_t fBackingPixel;  value to be used when restoring planes ;  ; ULong_t fBackingPlanes;  planes to be preserved if possible ;  ; Int_t fBackingStore;  kNotUseful, kWhenMapped, kAlways ;  ; Int_t fBitGravity;  one of bit gravity values ;  ; Int_t fBorderWidth;  border width of window ;  ; Int_t fClass;  kInputOutput, kInputOnly ;  ; Colormap_t fColormap;  color map to be associated with window ;  ; Int_t fDepth;  depth of window ;  ; Long_t fDoNotPropagateMask;  set of events that should not propagate ;  ; Int_t fHeight;  width and height of window ;  ; Bool_t fMapInstalled;  boolean, is color map currently installed ;  ; Int_t fMapState;  kIsUnmapped, kIsUnviewable, kIsViewable ;  ; Bool_t fOverrideRedirect;  boolean value for override-redirect ;  ; Window_t fRoot;  root of screen containing window ;  ; Bool_t fSaveUnder;  boolean, should bits under be saved? ;  ; void * fScreen;  back pointer to correct screen ;  ; void * fVisual;  the associated visual structure ;  ; Int_t fWidth;  ; Int_t fWinGravity;  one of the window gravity values ;  ; Int_t fX;  ; Int_t fY;  location of window ;  ; Long_t fYourEventMask;  my event mask ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fAllEventMasks. Long_t WindowAttributes_t::fAllEventMasks. set of events all people have interest in ; Definition at line 131 of file GuiTypes.h. ◆ fBackingPixel. ULong_t WindowAttributes_t::fBackingPixel. value to be used when restoring planes ; Definition at line 126 of file GuiTypes.h. ◆ fBackingPlanes. ULong_t WindowAttributes_t::fBackingPlanes. planes to be preserved if possible ; ",MatchSource.WIKI,doc/master/structWindowAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structWindowAttributes__t.html
https://root.cern/doc/master/structWindowAttributes__t.html:4461,Availability,mask,mask,4461,"should not propagate ; Definition at line 133 of file GuiTypes.h. ◆ fHeight. Int_t WindowAttributes_t::fHeight. width and height of window ; Definition at line 116 of file GuiTypes.h. ◆ fMapInstalled. Bool_t WindowAttributes_t::fMapInstalled. boolean, is color map currently installed ; Definition at line 129 of file GuiTypes.h. ◆ fMapState. Int_t WindowAttributes_t::fMapState. kIsUnmapped, kIsUnviewable, kIsViewable ; Definition at line 130 of file GuiTypes.h. ◆ fOverrideRedirect. Bool_t WindowAttributes_t::fOverrideRedirect. boolean value for override-redirect ; Definition at line 134 of file GuiTypes.h. ◆ fRoot. Window_t WindowAttributes_t::fRoot. root of screen containing window ; Definition at line 120 of file GuiTypes.h. ◆ fSaveUnder. Bool_t WindowAttributes_t::fSaveUnder. boolean, should bits under be saved? ; Definition at line 127 of file GuiTypes.h. ◆ fScreen. void* WindowAttributes_t::fScreen. back pointer to correct screen ; Definition at line 135 of file GuiTypes.h. ◆ fVisual. void* WindowAttributes_t::fVisual. the associated visual structure ; Definition at line 119 of file GuiTypes.h. ◆ fWidth. Int_t WindowAttributes_t::fWidth. Definition at line 116 of file GuiTypes.h. ◆ fWinGravity. Int_t WindowAttributes_t::fWinGravity. one of the window gravity values ; Definition at line 123 of file GuiTypes.h. ◆ fX. Int_t WindowAttributes_t::fX. Definition at line 115 of file GuiTypes.h. ◆ fY. Int_t WindowAttributes_t::fY. location of window ; Definition at line 115 of file GuiTypes.h. ◆ fYourEventMask. Long_t WindowAttributes_t::fYourEventMask. my event mask ; Definition at line 132 of file GuiTypes.h. Collaboration diagram for WindowAttributes_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. WindowAttributes_t. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:49 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structWindowAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structWindowAttributes__t.html
https://root.cern/doc/master/structWindowAttributes__t.html:1024,Deployability,install,installed,1024,". ROOT: WindowAttributes_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; WindowAttributes_t Struct Reference. ; Window attributes that can be inquired. ; Definition at line 114 of file GuiTypes.h. Public Attributes; Long_t fAllEventMasks;  set of events all people have interest in ;  ; ULong_t fBackingPixel;  value to be used when restoring planes ;  ; ULong_t fBackingPlanes;  planes to be preserved if possible ;  ; Int_t fBackingStore;  kNotUseful, kWhenMapped, kAlways ;  ; Int_t fBitGravity;  one of bit gravity values ;  ; Int_t fBorderWidth;  border width of window ;  ; Int_t fClass;  kInputOutput, kInputOnly ;  ; Colormap_t fColormap;  color map to be associated with window ;  ; Int_t fDepth;  depth of window ;  ; Long_t fDoNotPropagateMask;  set of events that should not propagate ;  ; Int_t fHeight;  width and height of window ;  ; Bool_t fMapInstalled;  boolean, is color map currently installed ;  ; Int_t fMapState;  kIsUnmapped, kIsUnviewable, kIsViewable ;  ; Bool_t fOverrideRedirect;  boolean value for override-redirect ;  ; Window_t fRoot;  root of screen containing window ;  ; Bool_t fSaveUnder;  boolean, should bits under be saved? ;  ; void * fScreen;  back pointer to correct screen ;  ; void * fVisual;  the associated visual structure ;  ; Int_t fWidth;  ; Int_t fWinGravity;  one of the window gravity values ;  ; Int_t fX;  ; Int_t fY;  location of window ;  ; Long_t fYourEventMask;  my event mask ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fAllEventMasks. Long_t WindowAttributes_t::fAllEventMasks. set of events all people have interest in ; Definition at line 131 of file GuiTypes.h. ◆ fBackingPixel. ULong_t WindowAttributes_t::fBackingPixel. value to be used when restoring planes ; Definition at line 126 of file GuiTypes.h. ◆ fBackingPlanes. ULong_t WindowAttributes_t::fBackingPlanes. planes to be preserved if possible ; ",MatchSource.WIKI,doc/master/structWindowAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structWindowAttributes__t.html
https://root.cern/doc/master/structWindowAttributes__t.html:3152,Deployability,install,installed,3152,"f file GuiTypes.h. ◆ fBitGravity. Int_t WindowAttributes_t::fBitGravity. one of bit gravity values ; Definition at line 122 of file GuiTypes.h. ◆ fBorderWidth. Int_t WindowAttributes_t::fBorderWidth. border width of window ; Definition at line 117 of file GuiTypes.h. ◆ fClass. Int_t WindowAttributes_t::fClass. kInputOutput, kInputOnly ; Definition at line 121 of file GuiTypes.h. ◆ fColormap. Colormap_t WindowAttributes_t::fColormap. color map to be associated with window ; Definition at line 128 of file GuiTypes.h. ◆ fDepth. Int_t WindowAttributes_t::fDepth. depth of window ; Definition at line 118 of file GuiTypes.h. ◆ fDoNotPropagateMask. Long_t WindowAttributes_t::fDoNotPropagateMask. set of events that should not propagate ; Definition at line 133 of file GuiTypes.h. ◆ fHeight. Int_t WindowAttributes_t::fHeight. width and height of window ; Definition at line 116 of file GuiTypes.h. ◆ fMapInstalled. Bool_t WindowAttributes_t::fMapInstalled. boolean, is color map currently installed ; Definition at line 129 of file GuiTypes.h. ◆ fMapState. Int_t WindowAttributes_t::fMapState. kIsUnmapped, kIsUnviewable, kIsViewable ; Definition at line 130 of file GuiTypes.h. ◆ fOverrideRedirect. Bool_t WindowAttributes_t::fOverrideRedirect. boolean value for override-redirect ; Definition at line 134 of file GuiTypes.h. ◆ fRoot. Window_t WindowAttributes_t::fRoot. root of screen containing window ; Definition at line 120 of file GuiTypes.h. ◆ fSaveUnder. Bool_t WindowAttributes_t::fSaveUnder. boolean, should bits under be saved? ; Definition at line 127 of file GuiTypes.h. ◆ fScreen. void* WindowAttributes_t::fScreen. back pointer to correct screen ; Definition at line 135 of file GuiTypes.h. ◆ fVisual. void* WindowAttributes_t::fVisual. the associated visual structure ; Definition at line 119 of file GuiTypes.h. ◆ fWidth. Int_t WindowAttributes_t::fWidth. Definition at line 116 of file GuiTypes.h. ◆ fWinGravity. Int_t WindowAttributes_t::fWinGravity. one of the window gravity va",MatchSource.WIKI,doc/master/structWindowAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structWindowAttributes__t.html
https://root.cern/doc/master/SVector_8icc_source.html:1133,Availability,error,error,1133,". ROOT: math/smatrix/inc/Math/SVector.icc Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. SVector.icc. Go to the documentation of this file. 1// @(#)root/smatrix:$Id$; 2// Authors: T. Glebe, L. Moneta 2005; 3 ; 4#ifndef ROOT_Math_SVector_icc; 5#define ROOT_Math_SVector_icc; 6// ********************************************************************; 7//; 8// source:; 9//; 10// type: source code; 11//; 12// created: 21. Mar 2001; 13//; 14// author: Thorsten Glebe; 15// HERA-B Collaboration; 16// Max-Planck-Institut fuer Kernphysik; 17// Saupfercheckweg 1; 18// 69117 Heidelberg; 19// Germany; 20// E-mail: T.Glebe@mpi-hd.mpg.de; 21//; 22// Description: A fixed size Vector class; 23//; 24// changes:; 25// 21 Mar 2001 (TG) creation; 26// 26 Mar 2001 (TG) added place_at(); 27// 06 Apr 2001 (TG) CTORS added; 28// 07 Apr 2001 (TG) CTORS added; 29// 22 Aug 2001 (TG) CTOR(T*,len) added; 30// 14 Jan 2002 (TG) added operator==(), operator!=(), operator>(), operator<(); 31//; 32// ********************************************************************; 33 ; 34#ifndef ROOT_Math_SVector; 35#error ""Do not use SVector.icc directly. #include \""Math/SVector.h\"" instead.""; 36#endif // ROOT_Math_SVector; 37 ; 38#include <iostream>; 39#include <assert.h>; 40#include <algorithm>; 41 ; 42#include ""Math/StaticCheck.h""; 43 ; 44namespace ROOT {; 45 ; 46namespace Math {; 47 ; 48 ; 49//==============================================================================; 50// Constructors; 51//==============================================================================; 52template <class T, unsigned int D>; 53SVector<T,D>::SVector() {; 54 for(unsigned int i=0; i<D; ++i); 55 fArray[i] = 0;; 56}; 57 ; 58template <class T, unsigned int D>; 59template <class A>; 60SVector<T,D>::SVector(const VecExpr<A,T,D>& rhs) {; 61 operator=(rhs);; 62}; 63 ; 64template <class T, unsigned int D>; 65SVector<T,D>::SVector(const SVector<T,D>& rhs) {; 66 for(unsigned int i=0; i<D; ++",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:2171,Integrability,interface,interfaces,2171,,MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:17516,Integrability,interface,interface,17516,,MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:22524,Integrability,interface,interface,22524,"GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; operator=Binding & operator=(OUT(*fun)(void))Definition TRInterface_Binding.h:15; ROOT::Math::SVectorSVector: a generic fixed size Vector class.Definition SVector.h:75; ROOT::Math::SVector::const_iteratorconst T * const_iteratorSTL const_iterator interface.Definition SVector.h:85; ROOT::Math::SVector::operator=SVector< T, D > & operator=(const T &a1)assignment from a scalar (only for size 1 vector)Definition SVector.icc:191; ROOT::Math::SVector::operator>bool operator>(const T &rhs) constelement wise comparisonDefinition SVector.icc:280; ROOT::Math::SVector::Place_atSVector< T, D > & Place_at(const SVector< T, D2 > &rhs, unsigned int row)place a sub-vector starting from the given positionDefinition SVector.icc:490; ROOT::Math::SVector::beginiterator begin()STL iterator interface.Definition SVector.icc:550; ROOT::Math::SVector::operator*=SVector< T, D > & operator*=(const T &rhs)self multiplication with a scalarDefinition SVector.icc:428; ROOT::Math::SVector::UnitSVector< T, D > & Unit()transform vector into a vector of length 1Definition SVector.icc:477; ROOT::Math::SVector::SubSubVector Sub(unsigned int row) constreturn a subvector of size N starting at the value row where N is the size of ",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:23057,Integrability,interface,interface,23057,"t_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; operator=Binding & operator=(OUT(*fun)(void))Definition TRInterface_Binding.h:15; ROOT::Math::SVectorSVector: a generic fixed size Vector class.Definition SVector.h:75; ROOT::Math::SVector::const_iteratorconst T * const_iteratorSTL const_iterator interface.Definition SVector.h:85; ROOT::Math::SVector::operator=SVector< T, D > & operator=(const T &a1)assignment from a scalar (only for size 1 vector)Definition SVector.icc:191; ROOT::Math::SVector::operator>bool operator>(const T &rhs) constelement wise comparisonDefinition SVector.icc:280; ROOT::Math::SVector::Place_atSVector< T, D > & Place_at(const SVector< T, D2 > &rhs, unsigned int row)place a sub-vector starting from the given positionDefinition SVector.icc:490; ROOT::Math::SVector::beginiterator begin()STL iterator interface.Definition SVector.icc:550; ROOT::Math::SVector::operator*=SVector< T, D > & operator*=(const T &rhs)self multiplication with a scalarDefinition SVector.icc:428; ROOT::Math::SVector::UnitSVector< T, D > & Unit()transform vector into a vector of length 1Definition SVector.icc:477; ROOT::Math::SVector::SubSubVector Sub(unsigned int row) constreturn a subvector of size N starting at the value row where N is the size of the returned vector (Su...Definition SVector.icc:612; ROOT::Math::SVector::Arrayconst T * Array() constreturn read-only pointer to internal arrayDefinition SVector.icc:540; ROOT::Math::SVector::applyT apply(unsigned int i) constaccess the parse tree. Index starts from zeroDefinition SVector.icc:537; ROOT::Math::SVector::Atconst T & At(unsigned int i) constread-only access of vector elements with check on index. Index starts from 0.Definition SVector.icc:596; ROOT::Math::SVector::operator!=bool operator!=(const T &rhs) constelement wise c",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:25554,Integrability,interface,interface,25554,"tFunction to check if a vector is sharing same memory location of the passed pointer This function is ...Definition SVector.icc:628; ROOT::Math::SVector::operator<bool operator<(const T &rhs) constelement wise comparisonDefinition SVector.icc:311; ROOT::Math::SVector::operator[]const T & operator[](unsigned int i) constread-only access of vector elements. Index starts from 0.Definition SVector.icc:582; ROOT::Math::SVector::operator+=SVector< T, D > & operator+=(const T &rhs)self addition with a scalarDefinition SVector.icc:371; ROOT::Math::SVector::operator==bool operator==(const T &rhs) constelement wise comparisonDefinition SVector.icc:230; ROOT::Math::SVector::operator/=SVector< T, D > & operator/=(const T &rhs)self division with a scalarDefinition SVector.icc:465; ROOT::Math::SVector::fArrayT fArray[D]SVector data.Definition SVector.h:333; ROOT::Math::SVector::Printstd::ostream & Print(std::ostream &os) constused by operator<<()Definition SVector.icc:521; ROOT::Math::SVector::enditerator end()STL iterator interface.Definition SVector.icc:556; ROOT::Math::SVector::SetElementsvoid SetElements(InputIterator begin, InputIterator end)set vector elements copying the values iterator size must match vector sizeDefinition SVector.icc:563; ROOT::Math::VecExprExpression wrapper class for Vector objects.Definition Expression.h:64; ROOT::Math::VecExpr::applyT apply(unsigned int i) constDefinition Expression.h:77; ROOT::Math::VecExpr::IsInUsebool IsInUse(const T *p) constfunction to determine if any use operand is being used (has same memory address)Definition Expression.h:104; ROOT::Math::MagT Mag(const SVector< T, D > &rhs)Vector magnitude (Euclidean norm) Compute : .Definition Functions.h:253; MathNamespace for new Math classes and functions.; ROOT::Internal::operator==bool operator==(const RConcurrentHashColl::HashValue &lhs, const RConcurrentHashColl::HashValue &rhs)Definition RConcurrentHashColl.hxx:69; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, whi",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:25813,Integrability,wrap,wrapper,25813,"omparisonDefinition SVector.icc:311; ROOT::Math::SVector::operator[]const T & operator[](unsigned int i) constread-only access of vector elements. Index starts from 0.Definition SVector.icc:582; ROOT::Math::SVector::operator+=SVector< T, D > & operator+=(const T &rhs)self addition with a scalarDefinition SVector.icc:371; ROOT::Math::SVector::operator==bool operator==(const T &rhs) constelement wise comparisonDefinition SVector.icc:230; ROOT::Math::SVector::operator/=SVector< T, D > & operator/=(const T &rhs)self division with a scalarDefinition SVector.icc:465; ROOT::Math::SVector::fArrayT fArray[D]SVector data.Definition SVector.h:333; ROOT::Math::SVector::Printstd::ostream & Print(std::ostream &os) constused by operator<<()Definition SVector.icc:521; ROOT::Math::SVector::enditerator end()STL iterator interface.Definition SVector.icc:556; ROOT::Math::SVector::SetElementsvoid SetElements(InputIterator begin, InputIterator end)set vector elements copying the values iterator size must match vector sizeDefinition SVector.icc:563; ROOT::Math::VecExprExpression wrapper class for Vector objects.Definition Expression.h:64; ROOT::Math::VecExpr::applyT apply(unsigned int i) constDefinition Expression.h:77; ROOT::Math::VecExpr::IsInUsebool IsInUse(const T *p) constfunction to determine if any use operand is being used (has same memory address)Definition Expression.h:104; ROOT::Math::MagT Mag(const SVector< T, D > &rhs)Vector magnitude (Euclidean norm) Compute : .Definition Functions.h:253; MathNamespace for new Math classes and functions.; ROOT::Internal::operator==bool operator==(const RConcurrentHashColl::HashValue &lhs, const RConcurrentHashColl::HashValue &rhs)Definition RConcurrentHashColl.hxx:69; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. mathsmatrixincMathSVector.icc. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:45 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:19390,Security,access,access,19390,"Iterator>; 571void SVector<T,D>::SetElements(InputIterator ibegin, unsigned int size) {; 572 // size <= vector size; 573 assert( size <= D);; 574 std::copy(ibegin, ibegin+size, fArray);; 575}; 576 ; 577 ; 578//==============================================================================; 579// Operators; 580//==============================================================================; 581template <class T, unsigned int D>; 582inline const T& SVector<T,D>::operator[](unsigned int i) const { return fArray[i]; }; 583 ; 584template <class T, unsigned int D>; 585inline const T& SVector<T,D>::operator()(unsigned int i) const { return fArray[i]; }; 586 ; 587template <class T, unsigned int D>; 588inline T& SVector<T,D>::operator[](unsigned int i) { return fArray[i]; }; 589 ; 590template <class T, unsigned int D>; 591inline T& SVector<T,D>::operator()(unsigned int i) { return fArray[i]; }; 592//==============================================================================; 593// Element access with At(); 594//==============================================================================; 595template <class T, unsigned int D>; 596inline const T& SVector<T,D>::At(unsigned int i) const {; 597 assert(i < D);; 598 return fArray[i];; 599}; 600 ; 601template <class T, unsigned int D>; 602inline T& SVector<T,D>::At(unsigned int i) {; 603 assert(i < D);; 604 return fArray[i];; 605}; 606 ; 607//==============================================================================; 608// SubVector; 609//==============================================================================; 610template <class T, unsigned int D>; 611template <class SubVector>; 612SubVector SVector<T,D>::Sub(unsigned int row) const {; 613 ; 614 STATIC_CHECK( SubVector::kSize <= D,SVector_dimension_too_small);; 615 ; 616 assert(row + SubVector::kSize <= D);; 617 ; 618 SubVector tmp;; 619 // need to use std::copy ??; 620 for(unsigned int i=0; i < SubVector::kSize; ++i) {; 621 tmp[i] = fArray[i+row];; 622 }; 623 return t",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:23855,Security,access,access,23855,"::Place_atSVector< T, D > & Place_at(const SVector< T, D2 > &rhs, unsigned int row)place a sub-vector starting from the given positionDefinition SVector.icc:490; ROOT::Math::SVector::beginiterator begin()STL iterator interface.Definition SVector.icc:550; ROOT::Math::SVector::operator*=SVector< T, D > & operator*=(const T &rhs)self multiplication with a scalarDefinition SVector.icc:428; ROOT::Math::SVector::UnitSVector< T, D > & Unit()transform vector into a vector of length 1Definition SVector.icc:477; ROOT::Math::SVector::SubSubVector Sub(unsigned int row) constreturn a subvector of size N starting at the value row where N is the size of the returned vector (Su...Definition SVector.icc:612; ROOT::Math::SVector::Arrayconst T * Array() constreturn read-only pointer to internal arrayDefinition SVector.icc:540; ROOT::Math::SVector::applyT apply(unsigned int i) constaccess the parse tree. Index starts from zeroDefinition SVector.icc:537; ROOT::Math::SVector::Atconst T & At(unsigned int i) constread-only access of vector elements with check on index. Index starts from 0.Definition SVector.icc:596; ROOT::Math::SVector::operator!=bool operator!=(const T &rhs) constelement wise comparisonDefinition SVector.icc:261; ROOT::Math::SVector::SVectorSVector()Default constructor: vector filled with zero values.Definition SVector.icc:53; ROOT::Math::SVector::operator()const T & operator()(unsigned int i) constread-only access of vector elements. Index starts from 0.Definition SVector.icc:585; ROOT::Math::SVector::operator-=SVector< T, D > & operator-=(const T &rhs)self subtraction with a scalarDefinition SVector.icc:400; ROOT::Math::SVector::IsInUsebool IsInUse(const T *p) constFunction to check if a vector is sharing same memory location of the passed pointer This function is ...Definition SVector.icc:628; ROOT::Math::SVector::operator<bool operator<(const T &rhs) constelement wise comparisonDefinition SVector.icc:311; ROOT::Math::SVector::operator[]const T & operator[](unsigned in",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:24266,Security,access,access,24266,"::Math::SVector::UnitSVector< T, D > & Unit()transform vector into a vector of length 1Definition SVector.icc:477; ROOT::Math::SVector::SubSubVector Sub(unsigned int row) constreturn a subvector of size N starting at the value row where N is the size of the returned vector (Su...Definition SVector.icc:612; ROOT::Math::SVector::Arrayconst T * Array() constreturn read-only pointer to internal arrayDefinition SVector.icc:540; ROOT::Math::SVector::applyT apply(unsigned int i) constaccess the parse tree. Index starts from zeroDefinition SVector.icc:537; ROOT::Math::SVector::Atconst T & At(unsigned int i) constread-only access of vector elements with check on index. Index starts from 0.Definition SVector.icc:596; ROOT::Math::SVector::operator!=bool operator!=(const T &rhs) constelement wise comparisonDefinition SVector.icc:261; ROOT::Math::SVector::SVectorSVector()Default constructor: vector filled with zero values.Definition SVector.icc:53; ROOT::Math::SVector::operator()const T & operator()(unsigned int i) constread-only access of vector elements. Index starts from 0.Definition SVector.icc:585; ROOT::Math::SVector::operator-=SVector< T, D > & operator-=(const T &rhs)self subtraction with a scalarDefinition SVector.icc:400; ROOT::Math::SVector::IsInUsebool IsInUse(const T *p) constFunction to check if a vector is sharing same memory location of the passed pointer This function is ...Definition SVector.icc:628; ROOT::Math::SVector::operator<bool operator<(const T &rhs) constelement wise comparisonDefinition SVector.icc:311; ROOT::Math::SVector::operator[]const T & operator[](unsigned int i) constread-only access of vector elements. Index starts from 0.Definition SVector.icc:582; ROOT::Math::SVector::operator+=SVector< T, D > & operator+=(const T &rhs)self addition with a scalarDefinition SVector.icc:371; ROOT::Math::SVector::operator==bool operator==(const T &rhs) constelement wise comparisonDefinition SVector.icc:230; ROOT::Math::SVector::operator/=SVector< T, D > & opera",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:24860,Security,access,access,24860,"igned int i) constread-only access of vector elements with check on index. Index starts from 0.Definition SVector.icc:596; ROOT::Math::SVector::operator!=bool operator!=(const T &rhs) constelement wise comparisonDefinition SVector.icc:261; ROOT::Math::SVector::SVectorSVector()Default constructor: vector filled with zero values.Definition SVector.icc:53; ROOT::Math::SVector::operator()const T & operator()(unsigned int i) constread-only access of vector elements. Index starts from 0.Definition SVector.icc:585; ROOT::Math::SVector::operator-=SVector< T, D > & operator-=(const T &rhs)self subtraction with a scalarDefinition SVector.icc:400; ROOT::Math::SVector::IsInUsebool IsInUse(const T *p) constFunction to check if a vector is sharing same memory location of the passed pointer This function is ...Definition SVector.icc:628; ROOT::Math::SVector::operator<bool operator<(const T &rhs) constelement wise comparisonDefinition SVector.icc:311; ROOT::Math::SVector::operator[]const T & operator[](unsigned int i) constread-only access of vector elements. Index starts from 0.Definition SVector.icc:582; ROOT::Math::SVector::operator+=SVector< T, D > & operator+=(const T &rhs)self addition with a scalarDefinition SVector.icc:371; ROOT::Math::SVector::operator==bool operator==(const T &rhs) constelement wise comparisonDefinition SVector.icc:230; ROOT::Math::SVector::operator/=SVector< T, D > & operator/=(const T &rhs)self division with a scalarDefinition SVector.icc:465; ROOT::Math::SVector::fArrayT fArray[D]SVector data.Definition SVector.h:333; ROOT::Math::SVector::Printstd::ostream & Print(std::ostream &os) constused by operator<<()Definition SVector.icc:521; ROOT::Math::SVector::enditerator end()STL iterator interface.Definition SVector.icc:556; ROOT::Math::SVector::SetElementsvoid SetElements(InputIterator begin, InputIterator end)set vector elements copying the values iterator size must match vector sizeDefinition SVector.icc:563; ROOT::Math::VecExprExpression wrapper class ",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:1283,Testability,assert,assert,1283,"05; 3 ; 4#ifndef ROOT_Math_SVector_icc; 5#define ROOT_Math_SVector_icc; 6// ********************************************************************; 7//; 8// source:; 9//; 10// type: source code; 11//; 12// created: 21. Mar 2001; 13//; 14// author: Thorsten Glebe; 15// HERA-B Collaboration; 16// Max-Planck-Institut fuer Kernphysik; 17// Saupfercheckweg 1; 18// 69117 Heidelberg; 19// Germany; 20// E-mail: T.Glebe@mpi-hd.mpg.de; 21//; 22// Description: A fixed size Vector class; 23//; 24// changes:; 25// 21 Mar 2001 (TG) creation; 26// 26 Mar 2001 (TG) added place_at(); 27// 06 Apr 2001 (TG) CTORS added; 28// 07 Apr 2001 (TG) CTORS added; 29// 22 Aug 2001 (TG) CTOR(T*,len) added; 30// 14 Jan 2002 (TG) added operator==(), operator!=(), operator>(), operator<(); 31//; 32// ********************************************************************; 33 ; 34#ifndef ROOT_Math_SVector; 35#error ""Do not use SVector.icc directly. #include \""Math/SVector.h\"" instead.""; 36#endif // ROOT_Math_SVector; 37 ; 38#include <iostream>; 39#include <assert.h>; 40#include <algorithm>; 41 ; 42#include ""Math/StaticCheck.h""; 43 ; 44namespace ROOT {; 45 ; 46namespace Math {; 47 ; 48 ; 49//==============================================================================; 50// Constructors; 51//==============================================================================; 52template <class T, unsigned int D>; 53SVector<T,D>::SVector() {; 54 for(unsigned int i=0; i<D; ++i); 55 fArray[i] = 0;; 56}; 57 ; 58template <class T, unsigned int D>; 59template <class A>; 60SVector<T,D>::SVector(const VecExpr<A,T,D>& rhs) {; 61 operator=(rhs);; 62}; 63 ; 64template <class T, unsigned int D>; 65SVector<T,D>::SVector(const SVector<T,D>& rhs) {; 66 for(unsigned int i=0; i<D; ++i); 67 fArray[i] = rhs.fArray[i];; 68}; 69 ; 70 ; 71 ; 72//==============================================================================; 73// New Constructors from STL interfaces; 74//===============================================================",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:2430,Testability,assert,assert,2430,,MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:2644,Testability,assert,assert,2644,,MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:2844,Testability,assert,assert,2844,,MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:3047,Testability,assert,assert,3047," 71 ; 72//==============================================================================; 73// New Constructors from STL interfaces; 74//==============================================================================; 75 ; 76#ifdef LATER; 77template <class T, unsigned int D>; 78template <class InputIterator>; 79SVector<T,D>::SVector(InputIterator begin, InputIterator end) {; 80 assert(begin + D == end);; 81 std::copy(begin, end, fArray);; 82}; 83 ; 84template <class T, unsigned int D>; 85template <class InputIterator>; 86SVector<T,D>::SVector(InputIterator begin, unsigned int size) {; 87 assert( size <= D);; 88 std::copy(begin, begin+size, fArray);; 89}; 90 ; 91#else; 92 ; 93template <class T, unsigned int D>; 94SVector<T,D>::SVector(const T* a, unsigned int len) {; 95 (void)len;; 96 assert(len == D);; 97 for(unsigned int i=0; i<D; ++i); 98 fArray[i] = a[i];; 99}; 100 ; 101template <class T, unsigned int D>; 102SVector<T,D>::SVector(const_iterator ibegin, const_iterator iend) {; 103 assert(ibegin + D == iend);; 104 std::copy(ibegin, iend, fArray);; 105}; 106 ; 107 ; 108#endif; 109 ; 110 ; 111template <class T, unsigned int D>; 112SVector<T,D>::SVector(const T& a1) {; 113 STATIC_CHECK( D == 1,SVector_dimension_not_right);; 114 fArray[0] = a1;; 115}; 116 ; 117template <class T, unsigned int D>; 118SVector<T,D>::SVector(const T& a1, const T& a2) {; 119 STATIC_CHECK( D == 2,SVector_dimension_not_right);; 120 fArray[0] = a1; fArray[1] = a2;; 121}; 122 ; 123template <class T, unsigned int D>; 124SVector<T,D>::SVector(const T& a1, const T& a2, const T& a3) {; 125 STATIC_CHECK( D == 3,SVector_dimension_not_right);; 126 fArray[0] = a1; fArray[1] = a2; fArray[2] = a3;; 127}; 128 ; 129template <class T, unsigned int D>; 130SVector<T,D>::SVector(const T& a1, const T& a2, const T& a3, const T& a4) {; 131 STATIC_CHECK( D == 4,SVector_dimension_not_right);; 132 fArray[0] = a1; fArray[1] = a2; fArray[2] = a3; fArray[3] = a4;; 133}; 134 ; 135template <class T, unsigned int D>; 136SVec",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:15579,Testability,assert,assert,15579,"======================; 447template <class T, unsigned int D>; 448SVector<T,D>& SVector<T,D>::operator/=(const SVector<T,D>& rhs) {; 449 for(unsigned int i=0; i<D; ++i) {; 450 fArray[i] /= rhs.apply(i);; 451 }; 452 return *this;; 453}; 454 ; 455template <class T, unsigned int D>; 456template <class A>; 457SVector<T,D>& SVector<T,D>::operator/=(const VecExpr<A,T,D>& rhs) {; 458 for(unsigned int i=0; i<D; ++i) {; 459 fArray[i] /= rhs.apply(i);; 460 }; 461 return *this;; 462}; 463#endif; 464template <class T, unsigned int D>; 465SVector<T,D>& SVector<T,D>::operator/=(const T& rhs) {; 466 for(unsigned int i=0; i<D; ++i) {; 467 fArray[i] /= rhs;; 468 }; 469 return *this;; 470}; 471 ; 472 ; 473//==============================================================================; 474// unit; 475//==============================================================================; 476template <class T, unsigned int D>; 477SVector<T,D>& SVector<T,D>::Unit() {; 478 const T len = Mag(*this);; 479 for(unsigned int i=0; i<D; ++i) {; 480 fArray[i] /= len;; 481 }; 482 return *this;; 483}; 484 ; 485//==============================================================================; 486// place_at; 487//==============================================================================; 488template <class T, unsigned int D>; 489template <unsigned int D2>; 490SVector<T,D>& SVector<T,D>::Place_at(const SVector<T,D2>& rhs, unsigned int row) {; 491 ; 492 assert(row+D2 <= D);; 493 // Sassert(end <= D);; 494 ; 495 for(unsigned int i=row, j=0; j<D2; ++i,++j); 496 fArray[i] = rhs.apply(j);; 497 ; 498 return *this;; 499}; 500 ; 501 ; 502//==============================================================================; 503// place_at; 504//==============================================================================; 505template <class T, unsigned int D>; 506template <class A, unsigned int D2>; 507SVector<T,D>& SVector<T,D>::Place_at(const VecExpr<A,T,D2>& rhs, unsigned int row) {; 508 ; 509 assert(row+D2 <= D",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:16121,Testability,assert,assert,16121,"=====================================================; 476template <class T, unsigned int D>; 477SVector<T,D>& SVector<T,D>::Unit() {; 478 const T len = Mag(*this);; 479 for(unsigned int i=0; i<D; ++i) {; 480 fArray[i] /= len;; 481 }; 482 return *this;; 483}; 484 ; 485//==============================================================================; 486// place_at; 487//==============================================================================; 488template <class T, unsigned int D>; 489template <unsigned int D2>; 490SVector<T,D>& SVector<T,D>::Place_at(const SVector<T,D2>& rhs, unsigned int row) {; 491 ; 492 assert(row+D2 <= D);; 493 // Sassert(end <= D);; 494 ; 495 for(unsigned int i=row, j=0; j<D2; ++i,++j); 496 fArray[i] = rhs.apply(j);; 497 ; 498 return *this;; 499}; 500 ; 501 ; 502//==============================================================================; 503// place_at; 504//==============================================================================; 505template <class T, unsigned int D>; 506template <class A, unsigned int D2>; 507SVector<T,D>& SVector<T,D>::Place_at(const VecExpr<A,T,D2>& rhs, unsigned int row) {; 508 ; 509 assert(row+D2 <= D);; 510 ; 511 for(unsigned int i=row, j=0; j<D2; ++i,++j); 512 fArray[i] = rhs.apply(j);; 513 ; 514 return *this;; 515}; 516 ; 517//==============================================================================; 518// print; 519//==============================================================================; 520template <class T, unsigned int D>; 521std::ostream& SVector<T,D>::Print(std::ostream& os) const {; 522 const std::ios_base::fmtflags prevFmt = os.setf(std::ios::right,std::ios::adjustfield);; 523 // os.setf(ios::fixed);; 524 ; 525 for (unsigned int i = 0; i < D; ++i ) {; 526 os << fArray[i];; 527 if (i != D-1) os << "", "";; 528 }; 529 if (prevFmt != os.flags() ) os.setf(prevFmt, std::ios::adjustfield);; 530 return os;; 531}; 532 ; 533//=====================================================================",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:18250,Testability,assert,assert,18250,"onst T* SVector<T,D>::Array() const { return fArray; }; 541 ; 542template <class T, unsigned int D>; 543inline T* SVector<T,D>::Array() { return fArray; }; 544 ; 545 ; 546//==============================================================================; 547// STL interface; 548//==============================================================================; 549template <class T, unsigned int D>; 550inline T* SVector<T,D>::begin() { return fArray; }; 551 ; 552template <class T, unsigned int D>; 553inline const T* SVector<T,D>::begin() const { return fArray; }; 554 ; 555template <class T, unsigned int D>; 556inline T* SVector<T,D>::end() { return fArray + Dim(); }; 557 ; 558template <class T, unsigned int D>; 559inline const T* SVector<T,D>::end() const { return fArray + Dim(); }; 560 ; 561template <class T, unsigned int D>; 562template <class InputIterator>; 563void SVector<T,D>::SetElements(InputIterator ibegin, InputIterator iend) {; 564 // iterator size must match vector size; 565 assert( ibegin + D == iend);; 566 std::copy(ibegin, iend, fArray);; 567}; 568 ; 569template <class T, unsigned int D>; 570template <class InputIterator>; 571void SVector<T,D>::SetElements(InputIterator ibegin, unsigned int size) {; 572 // size <= vector size; 573 assert( size <= D);; 574 std::copy(ibegin, ibegin+size, fArray);; 575}; 576 ; 577 ; 578//==============================================================================; 579// Operators; 580//==============================================================================; 581template <class T, unsigned int D>; 582inline const T& SVector<T,D>::operator[](unsigned int i) const { return fArray[i]; }; 583 ; 584template <class T, unsigned int D>; 585inline const T& SVector<T,D>::operator()(unsigned int i) const { return fArray[i]; }; 586 ; 587template <class T, unsigned int D>; 588inline T& SVector<T,D>::operator[](unsigned int i) { return fArray[i]; }; 589 ; 590template <class T, unsigned int D>; 591inline T& SVector<T,D>::operator()(un",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:18514,Testability,assert,assert,18514,"nterface; 548//==============================================================================; 549template <class T, unsigned int D>; 550inline T* SVector<T,D>::begin() { return fArray; }; 551 ; 552template <class T, unsigned int D>; 553inline const T* SVector<T,D>::begin() const { return fArray; }; 554 ; 555template <class T, unsigned int D>; 556inline T* SVector<T,D>::end() { return fArray + Dim(); }; 557 ; 558template <class T, unsigned int D>; 559inline const T* SVector<T,D>::end() const { return fArray + Dim(); }; 560 ; 561template <class T, unsigned int D>; 562template <class InputIterator>; 563void SVector<T,D>::SetElements(InputIterator ibegin, InputIterator iend) {; 564 // iterator size must match vector size; 565 assert( ibegin + D == iend);; 566 std::copy(ibegin, iend, fArray);; 567}; 568 ; 569template <class T, unsigned int D>; 570template <class InputIterator>; 571void SVector<T,D>::SetElements(InputIterator ibegin, unsigned int size) {; 572 // size <= vector size; 573 assert( size <= D);; 574 std::copy(ibegin, ibegin+size, fArray);; 575}; 576 ; 577 ; 578//==============================================================================; 579// Operators; 580//==============================================================================; 581template <class T, unsigned int D>; 582inline const T& SVector<T,D>::operator[](unsigned int i) const { return fArray[i]; }; 583 ; 584template <class T, unsigned int D>; 585inline const T& SVector<T,D>::operator()(unsigned int i) const { return fArray[i]; }; 586 ; 587template <class T, unsigned int D>; 588inline T& SVector<T,D>::operator[](unsigned int i) { return fArray[i]; }; 589 ; 590template <class T, unsigned int D>; 591inline T& SVector<T,D>::operator()(unsigned int i) { return fArray[i]; }; 592//==============================================================================; 593// Element access with At(); 594//==============================================================================; 595template <class T, uns",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:19597,Testability,assert,assert,19597,"8//==============================================================================; 579// Operators; 580//==============================================================================; 581template <class T, unsigned int D>; 582inline const T& SVector<T,D>::operator[](unsigned int i) const { return fArray[i]; }; 583 ; 584template <class T, unsigned int D>; 585inline const T& SVector<T,D>::operator()(unsigned int i) const { return fArray[i]; }; 586 ; 587template <class T, unsigned int D>; 588inline T& SVector<T,D>::operator[](unsigned int i) { return fArray[i]; }; 589 ; 590template <class T, unsigned int D>; 591inline T& SVector<T,D>::operator()(unsigned int i) { return fArray[i]; }; 592//==============================================================================; 593// Element access with At(); 594//==============================================================================; 595template <class T, unsigned int D>; 596inline const T& SVector<T,D>::At(unsigned int i) const {; 597 assert(i < D);; 598 return fArray[i];; 599}; 600 ; 601template <class T, unsigned int D>; 602inline T& SVector<T,D>::At(unsigned int i) {; 603 assert(i < D);; 604 return fArray[i];; 605}; 606 ; 607//==============================================================================; 608// SubVector; 609//==============================================================================; 610template <class T, unsigned int D>; 611template <class SubVector>; 612SubVector SVector<T,D>::Sub(unsigned int row) const {; 613 ; 614 STATIC_CHECK( SubVector::kSize <= D,SVector_dimension_too_small);; 615 ; 616 assert(row + SubVector::kSize <= D);; 617 ; 618 SubVector tmp;; 619 // need to use std::copy ??; 620 for(unsigned int i=0; i < SubVector::kSize; ++i) {; 621 tmp[i] = fArray[i+row];; 622 }; 623 return tmp;; 624}; 625 ; 626// check if the given passed pointer is the same contained in the vector; 627template <class T, unsigned int D>; 628bool SVector<T,D>::IsInUse( const T * p) const {; 629 return p == fArra",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:19740,Testability,assert,assert,19740,"========================================; 581template <class T, unsigned int D>; 582inline const T& SVector<T,D>::operator[](unsigned int i) const { return fArray[i]; }; 583 ; 584template <class T, unsigned int D>; 585inline const T& SVector<T,D>::operator()(unsigned int i) const { return fArray[i]; }; 586 ; 587template <class T, unsigned int D>; 588inline T& SVector<T,D>::operator[](unsigned int i) { return fArray[i]; }; 589 ; 590template <class T, unsigned int D>; 591inline T& SVector<T,D>::operator()(unsigned int i) { return fArray[i]; }; 592//==============================================================================; 593// Element access with At(); 594//==============================================================================; 595template <class T, unsigned int D>; 596inline const T& SVector<T,D>::At(unsigned int i) const {; 597 assert(i < D);; 598 return fArray[i];; 599}; 600 ; 601template <class T, unsigned int D>; 602inline T& SVector<T,D>::At(unsigned int i) {; 603 assert(i < D);; 604 return fArray[i];; 605}; 606 ; 607//==============================================================================; 608// SubVector; 609//==============================================================================; 610template <class T, unsigned int D>; 611template <class SubVector>; 612SubVector SVector<T,D>::Sub(unsigned int row) const {; 613 ; 614 STATIC_CHECK( SubVector::kSize <= D,SVector_dimension_too_small);; 615 ; 616 assert(row + SubVector::kSize <= D);; 617 ; 618 SubVector tmp;; 619 // need to use std::copy ??; 620 for(unsigned int i=0; i < SubVector::kSize; ++i) {; 621 tmp[i] = fArray[i+row];; 622 }; 623 return tmp;; 624}; 625 ; 626// check if the given passed pointer is the same contained in the vector; 627template <class T, unsigned int D>; 628bool SVector<T,D>::IsInUse( const T * p) const {; 629 return p == fArray;; 630}; 631 ; 632 ; 633//==============================================================================; 634// operator<<; 635//=============",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/SVector_8icc_source.html:20193,Testability,assert,assert,20193,"gned int D>; 585inline const T& SVector<T,D>::operator()(unsigned int i) const { return fArray[i]; }; 586 ; 587template <class T, unsigned int D>; 588inline T& SVector<T,D>::operator[](unsigned int i) { return fArray[i]; }; 589 ; 590template <class T, unsigned int D>; 591inline T& SVector<T,D>::operator()(unsigned int i) { return fArray[i]; }; 592//==============================================================================; 593// Element access with At(); 594//==============================================================================; 595template <class T, unsigned int D>; 596inline const T& SVector<T,D>::At(unsigned int i) const {; 597 assert(i < D);; 598 return fArray[i];; 599}; 600 ; 601template <class T, unsigned int D>; 602inline T& SVector<T,D>::At(unsigned int i) {; 603 assert(i < D);; 604 return fArray[i];; 605}; 606 ; 607//==============================================================================; 608// SubVector; 609//==============================================================================; 610template <class T, unsigned int D>; 611template <class SubVector>; 612SubVector SVector<T,D>::Sub(unsigned int row) const {; 613 ; 614 STATIC_CHECK( SubVector::kSize <= D,SVector_dimension_too_small);; 615 ; 616 assert(row + SubVector::kSize <= D);; 617 ; 618 SubVector tmp;; 619 // need to use std::copy ??; 620 for(unsigned int i=0; i < SubVector::kSize; ++i) {; 621 tmp[i] = fArray[i+row];; 622 }; 623 return tmp;; 624}; 625 ; 626// check if the given passed pointer is the same contained in the vector; 627template <class T, unsigned int D>; 628bool SVector<T,D>::IsInUse( const T * p) const {; 629 return p == fArray;; 630}; 631 ; 632 ; 633//==============================================================================; 634// operator<<; 635//==============================================================================; 636template <class T, unsigned int D>; 637inline std::ostream& operator<<(std::ostream& os, const SVector<T,D>& rhs) {; 638 return rhs.",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:1966,Availability,avail,available,1966,"clude ""TApplication.h""; 24#include ""TException.h""; 25#include ""TGuiFactory.h""; 26#include ""TVirtualX.h""; 27#include ""TROOT.h""; 28#include ""TSystem.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TObjArray.h""; 32#include ""TObjString.h""; 33#include ""TTimer.h""; 34#include ""TInterpreter.h""; 35#include ""TStyle.h""; 36#include ""TVirtualPad.h""; 37#include ""TEnv.h""; 38#include ""TColor.h""; 39#include ""TPluginManager.h""; 40#include ""TClassTable.h""; 41#include ""TBrowser.h""; 42#include ""TUrl.h""; 43#include ""TVirtualMutex.h""; 44#include ""TClassEdit.h""; 45#include ""TMethod.h""; 46#include ""TDataMember.h""; 47#include ""TApplicationCommandLineOptionsHelp.h""; 48#include ""TPRegexp.h""; 49#include <cstdlib>; 50#include <iostream>; 51#include <fstream>; 52 ; 53TApplication *gApplication = nullptr;; 54Bool_t TApplication::fgGraphNeeded = kFALSE;; 55Bool_t TApplication::fgGraphInit = kFALSE;; 56TList *TApplication::fgApplications = nullptr; // List of available applications; 57 ; 58////////////////////////////////////////////////////////////////////////////////; 59 ; 60class TIdleTimer : public TTimer {; 61public:; 62 TIdleTimer(Long_t ms) : TTimer(ms, kTRUE) {}; 63 Bool_t Notify() override;; 64};; 65 ; 66////////////////////////////////////////////////////////////////////////////////; 67/// Notify handler.; 68 ; 69Bool_t TIdleTimer::Notify(); 70{; 71 gApplication->HandleIdleTimer();; 72 Reset();; 73 return kFALSE;; 74}; 75 ; 76 ; 77ClassImp(TApplication);; 78 ; 79static void CallEndOfProcessCleanups(); 80{; 81 // Insure that the files, canvases and sockets are closed.; 82 ; 83 // If we get here, the tear down has started. We have no way to know what; 84 // has or has not yet been done. In particular on Ubuntu, this was called; 85 // after the function static in TSystem.cxx has been destructed. So we; 86 // set gROOT in its end-of-life mode which prevents executing code, like; 87 // autoloading libraries (!) that is pointless ...; 88 if (gROOT) {; 89 gROOT->SetBit(kInvalidObjec",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:2633,Availability,down,down,2633," 47#include ""TApplicationCommandLineOptionsHelp.h""; 48#include ""TPRegexp.h""; 49#include <cstdlib>; 50#include <iostream>; 51#include <fstream>; 52 ; 53TApplication *gApplication = nullptr;; 54Bool_t TApplication::fgGraphNeeded = kFALSE;; 55Bool_t TApplication::fgGraphInit = kFALSE;; 56TList *TApplication::fgApplications = nullptr; // List of available applications; 57 ; 58////////////////////////////////////////////////////////////////////////////////; 59 ; 60class TIdleTimer : public TTimer {; 61public:; 62 TIdleTimer(Long_t ms) : TTimer(ms, kTRUE) {}; 63 Bool_t Notify() override;; 64};; 65 ; 66////////////////////////////////////////////////////////////////////////////////; 67/// Notify handler.; 68 ; 69Bool_t TIdleTimer::Notify(); 70{; 71 gApplication->HandleIdleTimer();; 72 Reset();; 73 return kFALSE;; 74}; 75 ; 76 ; 77ClassImp(TApplication);; 78 ; 79static void CallEndOfProcessCleanups(); 80{; 81 // Insure that the files, canvases and sockets are closed.; 82 ; 83 // If we get here, the tear down has started. We have no way to know what; 84 // has or has not yet been done. In particular on Ubuntu, this was called; 85 // after the function static in TSystem.cxx has been destructed. So we; 86 // set gROOT in its end-of-life mode which prevents executing code, like; 87 // autoloading libraries (!) that is pointless ...; 88 if (gROOT) {; 89 gROOT->SetBit(kInvalidObject);; 90 gROOT->EndOfProcessCleanups();; 91 }; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////////; 95/// Default ctor. Can be used by classes deriving from TApplication.; 96 ; 97TApplication::TApplication() :; 98 fArgc(0), fArgv(nullptr), fAppImp(nullptr), fIsRunning(kFALSE), fReturnFromRun(kFALSE),; 99 fNoLog(kFALSE), fNoLogo(kFALSE), fQuit(kFALSE),; 100 fFiles(nullptr), fIdleTimer(nullptr), fSigHandler(nullptr), fExitOnException(kDontExit),; 101 fAppRemote(nullptr); 102{; 103 ResetBit(kProcessRemotely);; 104}; 105 ; 106///////////////////////////////////////////",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:4502,Availability,avail,available,4502,"ppRemote(nullptr); 102{; 103 ResetBit(kProcessRemotely);; 104}; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// Create an application environment. The application environment; 108/// provides an interface to the graphics system and eventloop; 109/// (be it X, Windows, macOS or BeOS). After creating the application; 110/// object start the eventloop by calling its Run() method. The command; 111/// line options recognized by TApplication are described in the GetOptions(); 112/// method. The recognized options are removed from the argument array.; 113/// The original list of argument options can be retrieved via the Argc(); 114/// and Argv() methods. The appClassName ""proofserv"" is reserved for the; 115/// PROOF system. The ""options"" and ""numOptions"" arguments are not used,; 116/// except if you want to by-pass the argv processing by GetOptions(); 117/// in which case you should specify numOptions<0. All options will; 118/// still be available via the Argv() method for later use.; 119 ; 120TApplication::TApplication(const char *appClassName, Int_t *argc, char **argv,; 121 void * /*options*/, Int_t numOptions) :; 122 fArgc(0), fArgv(nullptr), fAppImp(nullptr), fIsRunning(kFALSE), fReturnFromRun(kFALSE),; 123 fNoLog(kFALSE), fNoLogo(kFALSE), fQuit(kFALSE),; 124 fFiles(nullptr), fIdleTimer(nullptr), fSigHandler(nullptr), fExitOnException(kDontExit),; 125 fAppRemote(nullptr); 126{; 127 R__LOCKGUARD(gInterpreterMutex);; 128 ; 129 // Create the list of applications the first time; 130 if (!fgApplications); 131 fgApplications = new TList;; 132 ; 133 // Add the new TApplication early, so that the destructor of the; 134 // default TApplication (if it is called in the block of code below); 135 // will not destroy the files, socket or TColor that have already been; 136 // created.; 137 fgApplications->Add(this);; 138 ; 139 if (gApplication && gApplication->TestBit(kDefaultApplication)) {; 140 // allow default TApplication to be rep",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:14200,Availability,down,down,14200,"config"")) {; 376 fprintf(stderr, ""ROOT ./configure options:\n%s\n"", gROOT->GetConfigOptions());; 377 Terminate(0);; 378 } else if (!strcmp(argv[i], ""-a"")) {; 379 fprintf(stderr, ""ROOT splash screen is not visible with root.exe, use root instead.\n"");; 380 Terminate(0);; 381 } else if (!strcmp(argv[i], ""-b"")) {; 382 MakeBatch();; 383 argv[i] = null;; 384 } else if (!strcmp(argv[i], ""-n"")) {; 385 fNoLog = kTRUE;; 386 argv[i] = null;; 387 } else if (!strcmp(argv[i], ""-t"")) {; 388 ROOT::EnableImplicitMT();; 389 // EnableImplicitMT() only enables thread safety if IMT was configured;; 390 // enable thread safety even with IMT off:; 391 ROOT::EnableThreadSafety();; 392 argv[i] = null;; 393 } else if (!strcmp(argv[i], ""-q"")) {; 394 fQuit = kTRUE;; 395 argv[i] = null;; 396 } else if (!strcmp(argv[i], ""-l"")) {; 397 // used by front-end program to not display splash screen; 398 fNoLogo = kTRUE;; 399 argv[i] = null;; 400 } else if (!strcmp(argv[i], ""-x"")) {; 401 fExitOnException = kExit;; 402 argv[i] = null;; 403 } else if (!strcmp(argv[i], ""-splash"")) {; 404 // used when started by front-end program to signal that; 405 // splash screen can be popped down (TRint::PrintLogo()); 406 argv[i] = null;; 407 } else if (strncmp(argv[i], ""--web"", 5) == 0) {; 408 // the web mode is requested; 409 const char *opt = argv[i] + 5;; 410 argv[i] = null;; 411 gROOT->SetWebDisplay((*opt == '=') ? opt + 1 : """");; 412 } else if (!strcmp(argv[i], ""-e"")) {; 413 argv[i] = null;; 414 ++i;; 415 ; 416 if ( i < *argc ) {; 417 if (!fFiles) fFiles = new TObjArray;; 418 TObjString *expr = new TObjString(argv[i]);; 419 expr->SetBit(kExpression);; 420 fFiles->Add(expr);; 421 argv[i] = null;; 422 } else {; 423 Warning(""GetOptions"", ""-e must be followed by an expression."");; 424 }; 425 } else if (!strcmp(argv[i], ""--"")) {; 426 TObjString* macro = nullptr;; 427 bool warnShown = false;; 428 ; 429 if (fFiles) {; 430 for (auto f: *fFiles) {; 431 TObjString *file = dynamic_cast<TObjString *>(f);; 432 if (!file) {; 4",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:39752,Availability,down,download,39752,"opic?title=topic%20title&body=topic%20body&category=category/subcategory&tags=email,planned\"""");; 1017 TString report_template =; 1018R""(___; 1019_Please read [tips for efficient and successful posting](https://root-forum.cern.ch/t/tips-for-efficient-and-successful-posting/28292) and [posting code](https://root-forum.cern.ch/t/posting-code-read-this-first/28293)_; 1020 ; 1021### Describe the bug; 1022<!--; 1023A clear and concise description of what the wrong behavior is.; 1024-->; 1025### Expected behavior; 1026<!--; 1027A clear and concise description of what you expected to happen.; 1028-->; 1029 ; 1030### To Reproduce; 1031<!--; 1032Steps to reproduce the behavior:; 10331. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 10342. Don't forget to attach the required input files!; 10353. How to run your code and / or build it, e.g. `root myMacro.C`, ...; 1036-->; 1037 ; 1038### Setup; 1039)""+GetSetup()+; 1040R""(; 1041<!--; 1042Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; 1043-->; 1044 ; 1045### Additional context; 1046<!--; 1047Add any other context about the problem here.; 1048-->)"";; 1049 report_template = FormatHttpUrl(report_template);; 1050 ; 1051 OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?category=ROOT&tags=bug&body=""+report_template+""&\"""");; 1052 } else {; 1053 Warning(""OpenForumTopic"", ""cannot find \""%s\"" as type for a Forum topic\n""; 1054 ""Available types are 'bug'."", type.Data());; 1055 }; 1056}; 1057 ; 1058////////////////////////////////////////////////////////////////////////////////; 1059/// It opens a GitHub issue in a web browser with prefilled ROOT version; 1060///; 1061/// \param[in] type the issue type (bug, feature or improvement); 1062 ; 1063void TApplication::OpenGitHubIssue(const TString &type); 1064{; 1065 // https://docs.github.com/en/issues/tracking-your-work-with-issues/creating-an-issue#creating-an-issue-from-a-url-query; ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:41847,Availability,error,error,41847,"=bug_report.yml&root-version="" +; 1070 FormatHttpUrl(GetSetup()) + ""\"""");; 1071 } else if (type == ""improvement"") {; 1072 OpenInBrowser(""\""https://github.com/root-project/root/issues/""; 1073 ""new?labels=improvement&template=improvement_report.yml&root-version="" +; 1074 FormatHttpUrl(GetSetup()) + ""\"""");; 1075 } else if (type == ""feature"") {; 1076 OpenInBrowser(; 1077 ""\""https://github.com/root-project/root/issues/new?labels=new+feature&template=feature_request.yml\"""");; 1078 } else {; 1079 Warning(""OpenGitHubIssue"",; 1080 ""Cannot find GitHub issue type \""%s\"".\n""; 1081 ""Available types are 'bug', 'feature' and 'improvement'."",; 1082 type.Data());; 1083 }; 1084}; 1085 ; 1086////////////////////////////////////////////////////////////////////////////////; 1087/// It opens the online reference guide, generated with Doxygen, for the; 1088/// chosen scope (class/namespace/struct) or member (method/function/; 1089/// data member/enumeration/enumerator. If the user types incorrect value,; 1090/// it will return an error or warning.; 1091///; 1092/// \param[in] strippedClass the scope or scope::member; 1093 ; 1094void TApplication::OpenReferenceGuideFor(const TString &strippedClass); 1095{; 1096 // We check if the user is searching for a scope and if the scope exists.; 1097 if (TClass *clas = TClass::GetClass(strippedClass)) {; 1098 // We check what scope he is searching for (class/namespace/struct).; 1099 // Enumerators will switch between the possible cases.; 1100 EUrl scopeType;; 1101 if (clas->Property() & kIsNamespace) {; 1102 scopeType = kURLforNameSpace;; 1103 } else if (clas->Property() & kIsStruct) {; 1104 scopeType = kURLforStruct;; 1105 } else {; 1106 scopeType = kURLforClass;; 1107 }; 1108 // If the user search directly for a scope we open the URL for him with OpenInBrowser.; 1109 OpenInBrowser(UrlGenerator(strippedClass, scopeType));; 1110 return;; 1111 }; 1112 // Else we subtract the name of the method and remove it from the command.; 1113 TString memberName =",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:43716,Availability,avail,available,43716,"eturn;; 1111 }; 1112 // Else we subtract the name of the method and remove it from the command.; 1113 TString memberName = TClassEdit::GetUnqualifiedName(strippedClass);; 1114 // Error out if ""strippedClass"" is un-scoped (and it's not a class, see `TClass::GetClass(strippedClass)` above).; 1115 // TODO: Global functions.; 1116 if (strippedClass == memberName) {; 1117 Error(""OpenReferenceGuideFor"", ""Unknown entity \""%s\"" - global variables / functions not supported yet!"",; 1118 strippedClass.Data());; 1119 return;; 1120 }; 1121 // Else we remove the member name to be left with the scope.; 1122 TString scopeName = strippedClass(0, strippedClass.Length() - memberName.Length() - 2);; 1123 // We check if the scope exists in ROOT.; 1124 TClass *cl = TClass::GetClass(scopeName);; 1125 if (!cl) {; 1126 // That's a member of something ROOT doesn't know.; 1127 Warning(""OpenReferenceGuideFor"", ""\""%s\"" does not exist in ROOT!"", scopeName.Data());; 1128 return;; 1129 }; 1130 // We have enumerators for the three available cases - class, namespace and struct.; 1131 EUrl scopeType;; 1132 if (cl->Property() & kIsNamespace) {; 1133 scopeType = kURLforNameSpace;; 1134 } else if (cl->Property() & kIsStruct) {; 1135 scopeType = kURLforStruct;; 1136 } else {; 1137 scopeType = kURLforClass;; 1138 }; 1139 // If the user wants to search for a method, we take its name (memberName) and; 1140 // modify it - we delete everything starting at the first ""("" so the user won't have to; 1141 // do it by hand when they use Tab.; 1142 int bracket = memberName.First(""("");; 1143 if (bracket > 0) {; 1144 memberName.Remove(bracket);; 1145 }; 1146 // We check if ""memberName"" is a member function of ""cl"" or any of its base classes.; 1147 if (TFunction *func = cl->GetMethodAllAny(memberName)) {; 1148 // If so we find the name of the class that it belongs to.; 1149 TString baseClName = ((TMethod *)func)->GetClass()->GetName();; 1150 // We define an enumerator to distinguish between structor and method.; 1151 E",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:54223,Availability,down,downwards,54223,"f("" Fn+Arrow_Right : move cursor to end of line [Ctrl+E]"");; 1310 #else; 1311 Printf("" End : move cursor to end of line [Ctrl+E]"");; 1312 #endif; 1313 Printf("" Ctrl+Arrow_Left : jump to previous word [Esc,B] [Alt,B]"" FOOTNOTE);; 1314 Printf("" Ctrl+Arrow_Right : jump to next word [Esc,F] [Alt,F]"" FOOTNOTE);; 1315 ; 1316 Printf("" Backspace : delete previous character [Ctrl+H]"");; 1317 Printf("" Del : delete next character [Ctrl+D]"");; 1318 Printf("" Esc,Backspace : delete previous word [Ctrl+W] [Esc,Ctrl+H] [Alt+Backspace] [Esc,Del] [Esc,Ctrl+Del]"" FOOTNOTE);// Del is 0x7F on macOS; 1319 Printf("" Ctrl+Del : delete next word [Esc,D] [Alt,D]"" FOOTNOTE);; 1320 Printf("" Ctrl+U : cut all characters between cursor and start of line"");; 1321 Printf("" Ctrl+K : cut all characters between cursor and end of line"");; 1322 ; 1323 Printf("" Ctrl+T : transpose characters"");; 1324 Printf("" Esc,C : character to upper and jump to next word"");; 1325 Printf("" Esc,L : word to lower case and jump to its end"");; 1326 Printf("" Esc,U : word to upper case and jump to its end"");; 1327 Printf("" Ctrl+Shift+C : copy clipboard content"");; 1328 Printf("" Ctrl+Shift+V : paste clipboard content [Ctrl+Y] [Alt+Y]"");; 1329 #ifdef R__MACOSX; 1330 Printf("" Fn+Enter : toggle overwrite mode"");; 1331 #else; 1332 Printf("" Ins : toggle overwrite mode"");; 1333 #endif; 1334 ; 1335 Printf("" Ctrl+_ : undo last keypress action"");; 1336 Printf("" Tab : autocomplete command or print suggestions [Ctrl+I] [Esc,Tab]"");; 1337 Printf("" Enter : execute command [Ctrl+J] [Ctrl+M]"");; 1338 Printf("" Ctrl+L : clear prompt screen"");; 1339 Printf("" Ctrl+D : quit ROOT (if empty line)"");; 1340 Printf("" Ctrl+C : send kSigInt interrupt signal"");; 1341 Printf("" Ctrl+Z : send kSigStop pause job signal"");; 1342 ; 1343 Printf("" Arrow_Down : navigate downwards in command history [Ctrl+N]"");; 1344 Printf("" Arrow_Up : navigate upwards in command history [Ctrl+P]"");; 1345 Printf("" Ctrl+R ; Ctrl+S : search command in your history by typing a string.",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:60964,Availability,down,down,60964,", 2) ||; 1519 !strncmp(line, ""--help"", 6)) {; 1520 Info(""ProcessRemote"", ""remote session help:"");; 1521 Printf("".R [user@]host[:dir] [-l user] [-d dbg] [[<]script] | [host] -close"");; 1522 Printf(""Create a ROOT session on the specified remote host."");; 1523 Printf(""The variable \""dir\"" is the remote directory to be used as working dir."");; 1524 Printf(""The username can be specified in two ways, \""-l\"" having the priority"");; 1525 Printf(""(as in ssh). A \""dbg\"" value > 0 gives increasing verbosity."");; 1526 Printf(""The last argument \""script\"" allows to specify an alternative script to"");; 1527 Printf(""be executed remotely to startup the session, \""roots\"" being"");; 1528 Printf(""the default. If the script is preceded by a \""<\"" the script will be"");; 1529 Printf(""sourced, after which \""roots\"" is executed. The sourced script can be "");; 1530 Printf(""used to change the PATH and other variables, allowing an alternative"");; 1531 Printf(""\""roots\"" script to be found."");; 1532 Printf(""To close down a session do \"".R host -close\""."");; 1533 Printf(""To switch between sessions do \"".R host\"", to switch to the local"");; 1534 Printf(""session do \"".R\""."");; 1535 Printf(""To list all open sessions do \""gApplication->GetApplications()->Print()\""."");; 1536 return 0;; 1537 }; 1538 ; 1539 TString hostdir, user, script;; 1540 Int_t dbg = 0;; 1541 Int_t rc = ParseRemoteLine(line, hostdir, user, dbg, script);; 1542 if (hostdir.Length() <= 0) {; 1543 // Close the remote application if required; 1544 if (rc == 1) {; 1545 TApplication::Close(fAppRemote);; 1546 delete fAppRemote;; 1547 }; 1548 // Return to local run; 1549 fAppRemote = nullptr;; 1550 // Done; 1551 return 1;; 1552 } else if (rc == 1) {; 1553 // close an existing remote application; 1554 TApplication *ap = TApplication::Open(hostdir, 0, nullptr);; 1555 if (ap) {; 1556 TApplication::Close(ap);; 1557 delete ap;; 1558 }; 1559 }; 1560 // Attach or start a remote application; 1561 if (user.Length() > 0); 1562 hostdir.Insert(0, TStr",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:67947,Availability,error,error,67947," in Cling because too many side effects; 1723 Printf(""*** .reset not allowed, please use gROOT->Reset() ***"");; 1724 return 0;; 1725 ; 1726#if 0; 1727 // delete the ROOT dictionary since CINT will destroy all objects; 1728 // referenced by the dictionary classes (TClass et. al.); 1729 gROOT->GetListOfClasses()->Delete();; 1730 // fall through; 1731#endif; 1732 }; 1733 ; 1734 if (!strcmp(line, "".libraries"")) {; 1735 // List the loaded libraries; 1736 gSystem->ListLibraries();; 1737 return 0;; 1738 }; 1739 ; 1740 if (sync); 1741 return gInterpreter->ProcessLineSynch(line, (TInterpreter::EErrorCode*)err);; 1742 else; 1743 return gInterpreter->ProcessLine(line, (TInterpreter::EErrorCode*)err);; 1744}; 1745 ; 1746////////////////////////////////////////////////////////////////////////////////; 1747/// Process a file containing a C++ macro.; 1748 ; 1749Longptr_t TApplication::ProcessFile(const char *file, Int_t *error, Bool_t keep); 1750{; 1751 return ExecuteFile(file, error, keep);; 1752}; 1753 ; 1754////////////////////////////////////////////////////////////////////////////////; 1755/// Execute a file containing a C++ macro (static method). Can be used; 1756/// while TApplication is not yet created.; 1757 ; 1758Longptr_t TApplication::ExecuteFile(const char *file, Int_t *error, Bool_t keep); 1759{; 1760 static const Int_t kBufSize = 1024;; 1761 ; 1762 if (!file || !*file) return 0;; 1763 ; 1764 TString aclicMode;; 1765 TString arguments;; 1766 TString io;; 1767 TString fname = gSystem->SplitAclicMode(file, aclicMode, arguments, io);; 1768 ; 1769 char *exnam = gSystem->Which(TROOT::GetMacroPath(), fname, kReadPermission);; 1770 if (!exnam) {; 1771 ::Error(""TApplication::ExecuteFile"", ""macro %s not found in path %s"", fname.Data(),; 1772 TROOT::GetMacroPath());; 1773 delete [] exnam;; 1774 if (error); 1775 *error = (Int_t)TInterpreter::kRecoverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TA",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:68005,Availability,error,error,68005," in Cling because too many side effects; 1723 Printf(""*** .reset not allowed, please use gROOT->Reset() ***"");; 1724 return 0;; 1725 ; 1726#if 0; 1727 // delete the ROOT dictionary since CINT will destroy all objects; 1728 // referenced by the dictionary classes (TClass et. al.); 1729 gROOT->GetListOfClasses()->Delete();; 1730 // fall through; 1731#endif; 1732 }; 1733 ; 1734 if (!strcmp(line, "".libraries"")) {; 1735 // List the loaded libraries; 1736 gSystem->ListLibraries();; 1737 return 0;; 1738 }; 1739 ; 1740 if (sync); 1741 return gInterpreter->ProcessLineSynch(line, (TInterpreter::EErrorCode*)err);; 1742 else; 1743 return gInterpreter->ProcessLine(line, (TInterpreter::EErrorCode*)err);; 1744}; 1745 ; 1746////////////////////////////////////////////////////////////////////////////////; 1747/// Process a file containing a C++ macro.; 1748 ; 1749Longptr_t TApplication::ProcessFile(const char *file, Int_t *error, Bool_t keep); 1750{; 1751 return ExecuteFile(file, error, keep);; 1752}; 1753 ; 1754////////////////////////////////////////////////////////////////////////////////; 1755/// Execute a file containing a C++ macro (static method). Can be used; 1756/// while TApplication is not yet created.; 1757 ; 1758Longptr_t TApplication::ExecuteFile(const char *file, Int_t *error, Bool_t keep); 1759{; 1760 static const Int_t kBufSize = 1024;; 1761 ; 1762 if (!file || !*file) return 0;; 1763 ; 1764 TString aclicMode;; 1765 TString arguments;; 1766 TString io;; 1767 TString fname = gSystem->SplitAclicMode(file, aclicMode, arguments, io);; 1768 ; 1769 char *exnam = gSystem->Which(TROOT::GetMacroPath(), fname, kReadPermission);; 1770 if (!exnam) {; 1771 ::Error(""TApplication::ExecuteFile"", ""macro %s not found in path %s"", fname.Data(),; 1772 TROOT::GetMacroPath());; 1773 delete [] exnam;; 1774 if (error); 1775 *error = (Int_t)TInterpreter::kRecoverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TA",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:68316,Availability,error,error,68316,"1737 return 0;; 1738 }; 1739 ; 1740 if (sync); 1741 return gInterpreter->ProcessLineSynch(line, (TInterpreter::EErrorCode*)err);; 1742 else; 1743 return gInterpreter->ProcessLine(line, (TInterpreter::EErrorCode*)err);; 1744}; 1745 ; 1746////////////////////////////////////////////////////////////////////////////////; 1747/// Process a file containing a C++ macro.; 1748 ; 1749Longptr_t TApplication::ProcessFile(const char *file, Int_t *error, Bool_t keep); 1750{; 1751 return ExecuteFile(file, error, keep);; 1752}; 1753 ; 1754////////////////////////////////////////////////////////////////////////////////; 1755/// Execute a file containing a C++ macro (static method). Can be used; 1756/// while TApplication is not yet created.; 1757 ; 1758Longptr_t TApplication::ExecuteFile(const char *file, Int_t *error, Bool_t keep); 1759{; 1760 static const Int_t kBufSize = 1024;; 1761 ; 1762 if (!file || !*file) return 0;; 1763 ; 1764 TString aclicMode;; 1765 TString arguments;; 1766 TString io;; 1767 TString fname = gSystem->SplitAclicMode(file, aclicMode, arguments, io);; 1768 ; 1769 char *exnam = gSystem->Which(TROOT::GetMacroPath(), fname, kReadPermission);; 1770 if (!exnam) {; 1771 ::Error(""TApplication::ExecuteFile"", ""macro %s not found in path %s"", fname.Data(),; 1772 TROOT::GetMacroPath());; 1773 delete [] exnam;; 1774 if (error); 1775 *error = (Int_t)TInterpreter::kRecoverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TApplication::ExecuteFile"", ""%s no such file"", exnam);; 1782 if (error); 1783 *error = (Int_t)TInterpreter::kRecoverable;; 1784 delete [] exnam;; 1785 return 0;; 1786 }; 1787 ; 1788 char currentline[kBufSize];; 1789 char dummyline[kBufSize];; 1790 int tempfile = 0;; 1791 int comment = 0;; 1792 int ifndefc = 0;; 1793 int ifdef = 0;; 1794 char *s = nullptr;; 1795 Bool_t execute = kFALSE;; 1796 Longptr_t retval = 0;; 1797 ; 1798 while (1) {; 1799 bool res = (bool)macro.getline(curr",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:68846,Availability,error,error,68846,"ngptr_t TApplication::ProcessFile(const char *file, Int_t *error, Bool_t keep); 1750{; 1751 return ExecuteFile(file, error, keep);; 1752}; 1753 ; 1754////////////////////////////////////////////////////////////////////////////////; 1755/// Execute a file containing a C++ macro (static method). Can be used; 1756/// while TApplication is not yet created.; 1757 ; 1758Longptr_t TApplication::ExecuteFile(const char *file, Int_t *error, Bool_t keep); 1759{; 1760 static const Int_t kBufSize = 1024;; 1761 ; 1762 if (!file || !*file) return 0;; 1763 ; 1764 TString aclicMode;; 1765 TString arguments;; 1766 TString io;; 1767 TString fname = gSystem->SplitAclicMode(file, aclicMode, arguments, io);; 1768 ; 1769 char *exnam = gSystem->Which(TROOT::GetMacroPath(), fname, kReadPermission);; 1770 if (!exnam) {; 1771 ::Error(""TApplication::ExecuteFile"", ""macro %s not found in path %s"", fname.Data(),; 1772 TROOT::GetMacroPath());; 1773 delete [] exnam;; 1774 if (error); 1775 *error = (Int_t)TInterpreter::kRecoverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TApplication::ExecuteFile"", ""%s no such file"", exnam);; 1782 if (error); 1783 *error = (Int_t)TInterpreter::kRecoverable;; 1784 delete [] exnam;; 1785 return 0;; 1786 }; 1787 ; 1788 char currentline[kBufSize];; 1789 char dummyline[kBufSize];; 1790 int tempfile = 0;; 1791 int comment = 0;; 1792 int ifndefc = 0;; 1793 int ifdef = 0;; 1794 char *s = nullptr;; 1795 Bool_t execute = kFALSE;; 1796 Longptr_t retval = 0;; 1797 ; 1798 while (1) {; 1799 bool res = (bool)macro.getline(currentline, kBufSize);; 1800 if (macro.eof()) break;; 1801 if (!res) {; 1802 // Probably only read kBufSize, let's ignore the remainder of; 1803 // the line.; 1804 macro.clear();; 1805 while (!macro.getline(dummyline, kBufSize) && !macro.eof()) {; 1806 macro.clear();; 1807 }; 1808 }; 1809 s = currentline;; 1810 while (s && (*s == ' ' || *s == '\t')) s++; // strip-off leading blan",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:68860,Availability,error,error,68860,"ngptr_t TApplication::ProcessFile(const char *file, Int_t *error, Bool_t keep); 1750{; 1751 return ExecuteFile(file, error, keep);; 1752}; 1753 ; 1754////////////////////////////////////////////////////////////////////////////////; 1755/// Execute a file containing a C++ macro (static method). Can be used; 1756/// while TApplication is not yet created.; 1757 ; 1758Longptr_t TApplication::ExecuteFile(const char *file, Int_t *error, Bool_t keep); 1759{; 1760 static const Int_t kBufSize = 1024;; 1761 ; 1762 if (!file || !*file) return 0;; 1763 ; 1764 TString aclicMode;; 1765 TString arguments;; 1766 TString io;; 1767 TString fname = gSystem->SplitAclicMode(file, aclicMode, arguments, io);; 1768 ; 1769 char *exnam = gSystem->Which(TROOT::GetMacroPath(), fname, kReadPermission);; 1770 if (!exnam) {; 1771 ::Error(""TApplication::ExecuteFile"", ""macro %s not found in path %s"", fname.Data(),; 1772 TROOT::GetMacroPath());; 1773 delete [] exnam;; 1774 if (error); 1775 *error = (Int_t)TInterpreter::kRecoverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TApplication::ExecuteFile"", ""%s no such file"", exnam);; 1782 if (error); 1783 *error = (Int_t)TInterpreter::kRecoverable;; 1784 delete [] exnam;; 1785 return 0;; 1786 }; 1787 ; 1788 char currentline[kBufSize];; 1789 char dummyline[kBufSize];; 1790 int tempfile = 0;; 1791 int comment = 0;; 1792 int ifndefc = 0;; 1793 int ifdef = 0;; 1794 char *s = nullptr;; 1795 Bool_t execute = kFALSE;; 1796 Longptr_t retval = 0;; 1797 ; 1798 while (1) {; 1799 bool res = (bool)macro.getline(currentline, kBufSize);; 1800 if (macro.eof()) break;; 1801 if (!res) {; 1802 // Probably only read kBufSize, let's ignore the remainder of; 1803 // the line.; 1804 macro.clear();; 1805 while (!macro.getline(dummyline, kBufSize) && !macro.eof()) {; 1806 macro.clear();; 1807 }; 1808 }; 1809 s = currentline;; 1810 while (s && (*s == ' ' || *s == '\t')) s++; // strip-off leading blan",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:69091,Availability,error,error,69091,"; 1758Longptr_t TApplication::ExecuteFile(const char *file, Int_t *error, Bool_t keep); 1759{; 1760 static const Int_t kBufSize = 1024;; 1761 ; 1762 if (!file || !*file) return 0;; 1763 ; 1764 TString aclicMode;; 1765 TString arguments;; 1766 TString io;; 1767 TString fname = gSystem->SplitAclicMode(file, aclicMode, arguments, io);; 1768 ; 1769 char *exnam = gSystem->Which(TROOT::GetMacroPath(), fname, kReadPermission);; 1770 if (!exnam) {; 1771 ::Error(""TApplication::ExecuteFile"", ""macro %s not found in path %s"", fname.Data(),; 1772 TROOT::GetMacroPath());; 1773 delete [] exnam;; 1774 if (error); 1775 *error = (Int_t)TInterpreter::kRecoverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TApplication::ExecuteFile"", ""%s no such file"", exnam);; 1782 if (error); 1783 *error = (Int_t)TInterpreter::kRecoverable;; 1784 delete [] exnam;; 1785 return 0;; 1786 }; 1787 ; 1788 char currentline[kBufSize];; 1789 char dummyline[kBufSize];; 1790 int tempfile = 0;; 1791 int comment = 0;; 1792 int ifndefc = 0;; 1793 int ifdef = 0;; 1794 char *s = nullptr;; 1795 Bool_t execute = kFALSE;; 1796 Longptr_t retval = 0;; 1797 ; 1798 while (1) {; 1799 bool res = (bool)macro.getline(currentline, kBufSize);; 1800 if (macro.eof()) break;; 1801 if (!res) {; 1802 // Probably only read kBufSize, let's ignore the remainder of; 1803 // the line.; 1804 macro.clear();; 1805 while (!macro.getline(dummyline, kBufSize) && !macro.eof()) {; 1806 macro.clear();; 1807 }; 1808 }; 1809 s = currentline;; 1810 while (s && (*s == ' ' || *s == '\t')) s++; // strip-off leading blanks; 1811 ; 1812 // very simple minded pre-processor parsing, only works in case macro file; 1813 // starts with ""#ifndef __CINT__"". In that case everything till next; 1814 // ""#else"" or ""#endif"" will be skipped.; 1815 if (*s == '#') {; 1816 char *cs = Compress(currentline);; 1817 if (strstr(cs, ""#ifndef__CINT__"") ||; 1818 strstr(cs, ""#if!defined(__CINT__)""));",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:69105,Availability,error,error,69105,"; 1758Longptr_t TApplication::ExecuteFile(const char *file, Int_t *error, Bool_t keep); 1759{; 1760 static const Int_t kBufSize = 1024;; 1761 ; 1762 if (!file || !*file) return 0;; 1763 ; 1764 TString aclicMode;; 1765 TString arguments;; 1766 TString io;; 1767 TString fname = gSystem->SplitAclicMode(file, aclicMode, arguments, io);; 1768 ; 1769 char *exnam = gSystem->Which(TROOT::GetMacroPath(), fname, kReadPermission);; 1770 if (!exnam) {; 1771 ::Error(""TApplication::ExecuteFile"", ""macro %s not found in path %s"", fname.Data(),; 1772 TROOT::GetMacroPath());; 1773 delete [] exnam;; 1774 if (error); 1775 *error = (Int_t)TInterpreter::kRecoverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TApplication::ExecuteFile"", ""%s no such file"", exnam);; 1782 if (error); 1783 *error = (Int_t)TInterpreter::kRecoverable;; 1784 delete [] exnam;; 1785 return 0;; 1786 }; 1787 ; 1788 char currentline[kBufSize];; 1789 char dummyline[kBufSize];; 1790 int tempfile = 0;; 1791 int comment = 0;; 1792 int ifndefc = 0;; 1793 int ifdef = 0;; 1794 char *s = nullptr;; 1795 Bool_t execute = kFALSE;; 1796 Longptr_t retval = 0;; 1797 ; 1798 while (1) {; 1799 bool res = (bool)macro.getline(currentline, kBufSize);; 1800 if (macro.eof()) break;; 1801 if (!res) {; 1802 // Probably only read kBufSize, let's ignore the remainder of; 1803 // the line.; 1804 macro.clear();; 1805 while (!macro.getline(dummyline, kBufSize) && !macro.eof()) {; 1806 macro.clear();; 1807 }; 1808 }; 1809 s = currentline;; 1810 while (s && (*s == ' ' || *s == '\t')) s++; // strip-off leading blanks; 1811 ; 1812 // very simple minded pre-processor parsing, only works in case macro file; 1813 // starts with ""#ifndef __CINT__"". In that case everything till next; 1814 // ""#else"" or ""#endif"" will be skipped.; 1815 if (*s == '#') {; 1816 char *cs = Compress(currentline);; 1817 if (strstr(cs, ""#ifndef__CINT__"") ||; 1818 strstr(cs, ""#if!defined(__CINT__)""));",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:71985,Availability,error,error,71985,"/"");; 1845 if (s) {; 1846 comment = 0;; 1847 s += 2;; 1848 ; 1849 while (s && (*s == ' ' || *s == '\t')) s++; // strip-off leading blanks; 1850 if (!*s) continue;; 1851 if (!strncmp(s, ""//"", 2)) continue;; 1852 if (!strncmp(s, ""/*"", 2)) {; 1853 comment = 1;; 1854 goto again;; 1855 }; 1856 }; 1857 }; 1858 if (!comment && *s == '{') tempfile = 1;; 1859 if (!comment) break;; 1860 }; 1861 macro.close();; 1862 ; 1863 if (!execute) {; 1864 TString exname = exnam;; 1865 if (!tempfile) {; 1866 // We have a script that does NOT contain an unnamed macro,; 1867 // so we can call the script compiler on it.; 1868 exname += aclicMode;; 1869 }; 1870 exname += arguments;; 1871 exname += io;; 1872 ; 1873 TString tempbuf;; 1874 if (tempfile) {; 1875 tempbuf.Form("".x %s"", exname.Data());; 1876 } else {; 1877 tempbuf.Form("".X%s %s"", keep ? ""k"" : "" "", exname.Data());; 1878 }; 1879 retval = gInterpreter->ProcessLineSynch(tempbuf,(TInterpreter::EErrorCode*)error);; 1880 }; 1881 ; 1882 delete [] exnam;; 1883 return retval;; 1884}; 1885 ; 1886////////////////////////////////////////////////////////////////////////////////; 1887/// Main application eventloop. Calls system dependent eventloop via gSystem.; 1888 ; 1889void TApplication::Run(Bool_t retrn); 1890{; 1891 SetReturnFromRun(retrn);; 1892 ; 1893 fIsRunning = kTRUE;; 1894 ; 1895 gSystem->Run();; 1896 fIsRunning = kFALSE;; 1897}; 1898 ; 1899////////////////////////////////////////////////////////////////////////////////; 1900/// Set the command to be executed after the system has been idle for; 1901/// idleTimeInSec seconds. Normally called via TROOT::Idle(...).; 1902 ; 1903void TApplication::SetIdleTimer(UInt_t idleTimeInSec, const char *command); 1904{; 1905 if (fIdleTimer) RemoveIdleTimer();; 1906 fIdleCommand = command;; 1907 fIdleTimer = new TIdleTimer(idleTimeInSec*1000);; 1908 gSystem->AddTimer(fIdleTimer);; 1909}; 1910 ; 1911////////////////////////////////////////////////////////////////////////////////; 1912/// Remove idle time",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:75549,Availability,echo,echo,75549,"963 gSystem->Exit(status);; 1964 }; 1965}; 1966 ; 1967////////////////////////////////////////////////////////////////////////////////; 1968/// Emit signal when a line has been processed.; 1969 ; 1970void TApplication::LineProcessed(const char *line); 1971{; 1972 Emit(""LineProcessed(const char*)"", line);; 1973}; 1974 ; 1975////////////////////////////////////////////////////////////////////////////////; 1976/// Emit signal when console keyboard key was pressed.; 1977 ; 1978void TApplication::KeyPressed(Int_t key); 1979{; 1980 Emit(""KeyPressed(Int_t)"", key);; 1981}; 1982 ; 1983////////////////////////////////////////////////////////////////////////////////; 1984/// Emit signal when return key was pressed.; 1985 ; 1986void TApplication::ReturnPressed(char *text ); 1987{; 1988 Emit(""ReturnPressed(char*)"", text);; 1989}; 1990 ; 1991////////////////////////////////////////////////////////////////////////////////; 1992/// Set console echo mode:; 1993///; 1994/// - mode = kTRUE - echo input symbols; 1995/// - mode = kFALSE - noecho input symbols; 1996 ; 1997void TApplication::SetEchoMode(Bool_t); 1998{; 1999}; 2000 ; 2001////////////////////////////////////////////////////////////////////////////////; 2002/// Static function used to create a default application environment.; 2003 ; 2004void TApplication::CreateApplication(); 2005{; 2006 R__LOCKGUARD(gROOTMutex);; 2007 // gApplication is set at the end of 'new TApplication.; 2008 if (!gApplication) {; 2009 char *a = StrDup(""RootApp"");; 2010 char *b = StrDup(""-b"");; 2011 char *argv[2];; 2012 Int_t argc = 2;; 2013 argv[0] = a;; 2014 argv[1] = b;; 2015 new TApplication(""RootApp"", &argc, argv, nullptr, 0);; 2016 if (gDebug > 0); 2017 Printf(""<TApplication::CreateApplication>: ""; 2018 ""created default TApplication"");; 2019 delete [] a; delete [] b;; 2020 gApplication->SetBit(kDefaultApplication);; 2021 }; 2022}; 2023 ; 2024////////////////////////////////////////////////////////////////////////////////; 2025/// Static function u",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:75595,Availability,echo,echo,75595,"963 gSystem->Exit(status);; 1964 }; 1965}; 1966 ; 1967////////////////////////////////////////////////////////////////////////////////; 1968/// Emit signal when a line has been processed.; 1969 ; 1970void TApplication::LineProcessed(const char *line); 1971{; 1972 Emit(""LineProcessed(const char*)"", line);; 1973}; 1974 ; 1975////////////////////////////////////////////////////////////////////////////////; 1976/// Emit signal when console keyboard key was pressed.; 1977 ; 1978void TApplication::KeyPressed(Int_t key); 1979{; 1980 Emit(""KeyPressed(Int_t)"", key);; 1981}; 1982 ; 1983////////////////////////////////////////////////////////////////////////////////; 1984/// Emit signal when return key was pressed.; 1985 ; 1986void TApplication::ReturnPressed(char *text ); 1987{; 1988 Emit(""ReturnPressed(char*)"", text);; 1989}; 1990 ; 1991////////////////////////////////////////////////////////////////////////////////; 1992/// Set console echo mode:; 1993///; 1994/// - mode = kTRUE - echo input symbols; 1995/// - mode = kFALSE - noecho input symbols; 1996 ; 1997void TApplication::SetEchoMode(Bool_t); 1998{; 1999}; 2000 ; 2001////////////////////////////////////////////////////////////////////////////////; 2002/// Static function used to create a default application environment.; 2003 ; 2004void TApplication::CreateApplication(); 2005{; 2006 R__LOCKGUARD(gROOTMutex);; 2007 // gApplication is set at the end of 'new TApplication.; 2008 if (!gApplication) {; 2009 char *a = StrDup(""RootApp"");; 2010 char *b = StrDup(""-b"");; 2011 char *argv[2];; 2012 Int_t argc = 2;; 2013 argv[0] = a;; 2014 argv[1] = b;; 2015 new TApplication(""RootApp"", &argc, argv, nullptr, 0);; 2016 if (gDebug > 0); 2017 Printf(""<TApplication::CreateApplication>: ""; 2018 ""created default TApplication"");; 2019 delete [] a; delete [] b;; 2020 gApplication->SetBit(kDefaultApplication);; 2021 }; 2022}; 2023 ; 2024////////////////////////////////////////////////////////////////////////////////; 2025/// Static function u",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:77564,Availability,error,error,77564,"///////////////////////////////; 2025/// Static function used to attach to an existing remote application; 2026/// or to start one.; 2027 ; 2028TApplication *TApplication::Open(const char *url,; 2029 Int_t debug, const char *script); 2030{; 2031 TApplication *ap = nullptr;; 2032 TUrl nu(url);; 2033 Int_t nnew = 0;; 2034 ; 2035 // Look among the existing ones; 2036 if (fgApplications) {; 2037 TIter nxa(fgApplications);; 2038 while ((ap = (TApplication *) nxa())) {; 2039 TString apn(ap->ApplicationName());; 2040 if (apn == url) {; 2041 // Found matching application; 2042 return ap;; 2043 } else {; 2044 // Check if same machine and user; 2045 TUrl au(apn);; 2046 if (strlen(au.GetUser()) > 0 && strlen(nu.GetUser()) > 0 &&; 2047 !strcmp(au.GetUser(), nu.GetUser())) {; 2048 if (!strncmp(au.GetHost(), nu.GetHost(), strlen(nu.GetHost()))); 2049 // New session on a known machine; 2050 nnew++;; 2051 }; 2052 }; 2053 }; 2054 } else {; 2055 ::Error(""TApplication::Open"", ""list of applications undefined - protocol error"");; 2056 return ap;; 2057 }; 2058 ; 2059 // If new session on a known machine pass the number as option; 2060 if (nnew > 0) {; 2061 nnew++;; 2062 nu.SetOptions(TString::Format(""%d"", nnew).Data());; 2063 }; 2064 ; 2065 // Instantiate the TApplication object to be run; 2066 TPluginHandler *h = nullptr;; 2067 if ((h = gROOT->GetPluginManager()->FindHandler(""TApplication"",""remote""))) {; 2068 if (h->LoadPlugin() == 0) {; 2069 ap = (TApplication *) h->ExecPlugin(3, nu.GetUrl(), debug, script);; 2070 } else {; 2071 ::Error(""TApplication::Open"", ""failed to load plugin for TApplicationRemote"");; 2072 }; 2073 } else {; 2074 ::Error(""TApplication::Open"", ""failed to find plugin for TApplicationRemote"");; 2075 }; 2076 ; 2077 // Add to the list; 2078 if (ap && !(ap->TestBit(kInvalidObject))) {; 2079 fgApplications->Add(ap);; 2080 gROOT->GetListOfBrowsables()->Add(ap, ap->ApplicationName());; 2081 TIter next(gROOT->GetListOfBrowsers());; 2082 TBrowser *b;; 2083 while ((b = (TBrow",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:79470,Availability,avail,available,79470,"lse {; 2071 ::Error(""TApplication::Open"", ""failed to load plugin for TApplicationRemote"");; 2072 }; 2073 } else {; 2074 ::Error(""TApplication::Open"", ""failed to find plugin for TApplicationRemote"");; 2075 }; 2076 ; 2077 // Add to the list; 2078 if (ap && !(ap->TestBit(kInvalidObject))) {; 2079 fgApplications->Add(ap);; 2080 gROOT->GetListOfBrowsables()->Add(ap, ap->ApplicationName());; 2081 TIter next(gROOT->GetListOfBrowsers());; 2082 TBrowser *b;; 2083 while ((b = (TBrowser*) next())); 2084 b->Add(ap, ap->ApplicationName());; 2085 gROOT->RefreshBrowsers();; 2086 } else {; 2087 SafeDelete(ap);; 2088 ::Error(""TApplication::Open"",; 2089 ""TApplicationRemote for %s could not be instantiated"", url);; 2090 }; 2091 ; 2092 // Done; 2093 return ap;; 2094}; 2095 ; 2096////////////////////////////////////////////////////////////////////////////////; 2097/// Static function used to close a remote application; 2098 ; 2099void TApplication::Close(TApplication *app); 2100{; 2101 if (app) {; 2102 app->Terminate(0);; 2103 fgApplications->Remove(app);; 2104 gROOT->GetListOfBrowsables()->RecursiveRemove(app);; 2105 TIter next(gROOT->GetListOfBrowsers());; 2106 TBrowser *b;; 2107 while ((b = (TBrowser*) next())); 2108 b->RecursiveRemove(app);; 2109 gROOT->RefreshBrowsers();; 2110 }; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Show available sessions; 2115 ; 2116void TApplication::ls(Option_t *opt) const; 2117{; 2118 if (fgApplications) {; 2119 TIter nxa(fgApplications);; 2120 TApplication *a = nullptr;; 2121 while ((a = (TApplication *) nxa())) {; 2122 a->Print(opt);; 2123 }; 2124 } else {; 2125 Print(opt);; 2126 }; 2127}; 2128 ; 2129////////////////////////////////////////////////////////////////////////////////; 2130/// Static method returning the list of available applications; 2131 ; 2132TList *TApplication::GetApplications(); 2133{; 2134 return fgApplications;; 2135}; SafeDelete#define SafeDelete(p)Definition RConfig.",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:79905,Availability,avail,available,79905,"lse {; 2071 ::Error(""TApplication::Open"", ""failed to load plugin for TApplicationRemote"");; 2072 }; 2073 } else {; 2074 ::Error(""TApplication::Open"", ""failed to find plugin for TApplicationRemote"");; 2075 }; 2076 ; 2077 // Add to the list; 2078 if (ap && !(ap->TestBit(kInvalidObject))) {; 2079 fgApplications->Add(ap);; 2080 gROOT->GetListOfBrowsables()->Add(ap, ap->ApplicationName());; 2081 TIter next(gROOT->GetListOfBrowsers());; 2082 TBrowser *b;; 2083 while ((b = (TBrowser*) next())); 2084 b->Add(ap, ap->ApplicationName());; 2085 gROOT->RefreshBrowsers();; 2086 } else {; 2087 SafeDelete(ap);; 2088 ::Error(""TApplication::Open"",; 2089 ""TApplicationRemote for %s could not be instantiated"", url);; 2090 }; 2091 ; 2092 // Done; 2093 return ap;; 2094}; 2095 ; 2096////////////////////////////////////////////////////////////////////////////////; 2097/// Static function used to close a remote application; 2098 ; 2099void TApplication::Close(TApplication *app); 2100{; 2101 if (app) {; 2102 app->Terminate(0);; 2103 fgApplications->Remove(app);; 2104 gROOT->GetListOfBrowsables()->RecursiveRemove(app);; 2105 TIter next(gROOT->GetListOfBrowsers());; 2106 TBrowser *b;; 2107 while ((b = (TBrowser*) next())); 2108 b->RecursiveRemove(app);; 2109 gROOT->RefreshBrowsers();; 2110 }; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Show available sessions; 2115 ; 2116void TApplication::ls(Option_t *opt) const; 2117{; 2118 if (fgApplications) {; 2119 TIter nxa(fgApplications);; 2120 TApplication *a = nullptr;; 2121 while ((a = (TApplication *) nxa())) {; 2122 a->Print(opt);; 2123 }; 2124 } else {; 2125 Print(opt);; 2126 }; 2127}; 2128 ; 2129////////////////////////////////////////////////////////////////////////////////; 2130/// Static method returning the list of available applications; 2131 ; 2132TList *TApplication::GetApplications(); 2133{; 2134 return fgApplications;; 2135}; SafeDelete#define SafeDelete(p)Definition RConfig.",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:81837,Availability,error,error,81837,"_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; CallEndOfProcessCleanupsstatic void CallEndOfProcessCleanups()Definition TApplication.cxx:79; FOOTNOTE#define FOOTNOTE; gApplicationTApplication * gApplicationDefinition TApplication.cxx:53; TApplication.h; gApplicationR__EXTERN TApplication * gApplicationDefinition TApplication.h:170; TBrowser.h; TClassEdit.h; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:104; TColor.h; TDataMember.h; kIsInlined@ kIsInlinedDefinition TDictionary.h:131; kIsConstexpr@ kIsConstexprDefinition TDictionary.h:93; kIsStruct@ kIsStructDefinition TDictionary.h:66; kIsVirtual@ kIsVirtualDefinition TDictionary.h:72; kIsNamespace@ kIsNamespaceDefinition TDictionary.h:95; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TException.h; gExceptionR__EXTERN ExceptionContext_t * gExceptionDefinition TException.h:69; ThrowR__EXTERN void Throw(int code)If an exception context has been set (using the TRY and RETRY macros) jump back to where it was set.Definition TException.cxx:27; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32Vir",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:86505,Availability,error,error,86505,"tyleDefinition TStyle.h:436; TSystem.h; kReadPermission@ kReadPermissionDefinition TSystem.h:45; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTimer.h; TUrl.h; TVirtualMutex.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TVirtualX.h; gVirtualX#define gVirtualXDefinition TVirtualX.h:337; gGXBatchR__EXTERN TVirtualX * gGXBatchDefinition TVirtualX.h:339; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TApplication::ExitOnExceptionEExitOnException ExitOnException(EExitOnException opt=kExit)Set the exit on exception option.Definition TApplication.cxx:614; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpT",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:86955,Availability,echo,echo,86955,"atchDefinition TVirtualX.h:339; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TApplication::ExitOnExceptionEExitOnException ExitOnException(EExitOnException opt=kExit)Set the exit on exception option.Definition TApplication.cxx:614; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@ kExitDefinition TApplication.h:53; TApplication::ExecuteFilestatic Longptr_t ExecuteFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TA",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:87829,Availability,error,error,87829,"mote application.Definition TApplication.cxx:2070; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@ kExitDefinition TApplication.h:53; TApplication::ExecuteFilestatic Longptr_t ExecuteFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::InitializeGraphicsvoid InitializeGraphics(Bool_t only_web=kFALSE)Initialize the graphics environment.Definition TApplication.cxx:244; TApplication::Openvirtual void Open()Definition TApplication.h:132; TApplication::LoadGraphicsLibsvirtual void LoadGraphicsLibs()Load shared libs necessary for graphics.Definition TApplication.cxx:1333; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::kDefaultApplication@ kDefaultApplicationDefinition TApplication.h:45; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.D",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:91504,Availability,error,error,91504,"me() constDefinition TApplication.h:128; TApplication::Forumvirtual void Forum(const char *line)The function ("".forum <type>"") submits a new post on the ROOT forum via web browser.Definition TApplication.cxx:1165; TApplication::SetReturnFromRunvoid SetReturnFromRun(Bool_t ret)Definition TApplication.h:154; TApplication::fQuitBool_t fQuitDefinition TApplication.h:65; TApplication::TabCompletionHookvirtual Int_t TabCompletionHook(char *buf, int *pLoc, std::ostream &out)What to do when tab is pressed.Definition TApplication.cxx:1917; TApplication::fExitOnExceptionEExitOnException fExitOnExceptionDefinition TApplication.h:71; TApplication::fFilesTObjArray * fFilesDefinition TApplication.h:66; TApplication::GetIdleCommandconst char * GetIdleCommand() constDefinition TApplication.h:123; TApplication::TApplicationTApplication()Default ctor. Can be used by classes deriving from TApplication.Definition TApplication.cxx:97; TApplication::ProcessFilevirtual Longptr_t ProcessFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Process a file containing a C++ macro.Definition TApplication.cxx:1720; TApplication::OpenForumTopicvoid OpenForumTopic(const TString &type)It opens a Forum topic in a web browser with prefilled ROOT version.Definition TApplication.cxx:1011; TApplication::fWorkDirTString fWorkDirDefinition TApplication.h:67; TApplication::ReturnPressedvirtual void ReturnPressed(char *text)Emit signal when return key was pressed.Definition TApplication.cxx:1957; TApplication::fgGraphInitstatic Bool_t fgGraphInitDefinition TApplication.h:74; TApplication::RemoveIdleTimervirtual void RemoveIdleTimer()Remove idle timer. Normally called via TROOT::Idle(0).Definition TApplication.cxx:1885; TApplication::kExpression@ kExpressionDefinition TApplication.h:49; TApplication::SetIdleTimervirtual void SetIdleTimer(UInt_t idleTimeInSec, const char *command)Set the command to be executed after the system has been idle for idleTimeInSec seconds.Definition TApplication.cxx:1874",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:93063,Availability,avail,available,93063,"ol_t fgGraphInitDefinition TApplication.h:74; TApplication::RemoveIdleTimervirtual void RemoveIdleTimer()Remove idle timer. Normally called via TROOT::Idle(0).Definition TApplication.cxx:1885; TApplication::kExpression@ kExpressionDefinition TApplication.h:49; TApplication::SetIdleTimervirtual void SetIdleTimer(UInt_t idleTimeInSec, const char *command)Set the command to be executed after the system has been idle for idleTimeInSec seconds.Definition TApplication.cxx:1874; TApplication::GitHubvirtual void GitHub(const char *line)The function ("".gh <type>"") submits a new issue on GitHub via web browser.Definition TApplication.cxx:1186; TApplication::CreateApplicationstatic void CreateApplication()Static function used to create a default application environment.Definition TApplication.cxx:1975; TApplication::GetOptionsvirtual void GetOptions(Int_t *argc, char **argv)Get and handle command line options.Definition TApplication.cxx:345; TApplication::GetApplicationsstatic TList * GetApplications()Static method returning the list of available applications.Definition TApplication.cxx:2103; TApplication::fIsRunningstd::atomic< bool > fIsRunningWindow system specific application implementation.Definition TApplication.h:61; TApplication::NeedGraphicsLibsstatic void NeedGraphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:93751,Availability,avail,available,93751,"Static function used to create a default application environment.Definition TApplication.cxx:1975; TApplication::GetOptionsvirtual void GetOptions(Int_t *argc, char **argv)Get and handle command line options.Definition TApplication.cxx:345; TApplication::GetApplicationsstatic TList * GetApplications()Static method returning the list of available applications.Definition TApplication.cxx:2103; TApplication::fIsRunningstd::atomic< bool > fIsRunningWindow system specific application implementation.Definition TApplication.h:61; TApplication::NeedGraphicsLibsstatic void NeedGraphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::RecursiveRemovevoid RecursiveRemove(TObject *obj) ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:94308,Availability,error,error,94308,"void NeedGraphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove obj from browser.Definition TBrowser.cxx:408; TBrowser::Addvoid Add(TObject *obj, const char *name=nullptr, Int_t check=-1)Add object with name to browser.Definition TBrowser.cxx:303; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfAllPublicDataMembersTList * GetListOfAll",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:100419,Availability,error,error,100419,"ed objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPRegexpDefinition TPRegexp.h:36; TPluginHandlerDefinition TPluginManager.h:103; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::ShutDownstatic void S",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:100555,Availability,error,error,100555,"dvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPRegexpDefinition TPRegexp.h:36; TPluginHandlerDefinition TPluginManager.h:103; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:101434,Availability,down,down,101434,"Issue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPRegexpDefinition TPRegexp.h:36; TPluginHandlerDefinition TPluginManager.h:103; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3193; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3082; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::AtoiInt_t Atoi() constReturn integer value of string.D",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:23689,Deployability,patch,patches,23689,"b should have opened in your browser."");; 658}; 659 ; 660namespace {; 661enum EUrl { kURLforClass, kURLforNameSpace, kURLforStruct };; 662////////////////////////////////////////////////////////////////////////////////; 663/// The function generates a URL address for class or namespace (scopeName).; 664/// This is the URL to the online reference guide, generated by Doxygen.; 665/// With the enumeration ""EUrl"" we pick which case we need - the one for; 666/// class (kURLforClass) or the one for namespace (kURLforNameSpace).; 667///; 668/// \param[in] scopeName the name of the class or the namespace; 669/// \param[in] scopeType the enumerator for class or namespace; 670 ; 671static TString UrlGenerator(TString scopeName, EUrl scopeType); 672{; 673 // We start the URL with a static part, the same for all scopes and members.; 674 TString url = ""https://root.cern/doc/"";; 675 // Then we check the ROOT version used.; 676 TPRegexp re4(R""(.*/(v\d)-(\d\d)-00-patches)"");; 677 const char *branchName = gROOT->GetGitBranch();; 678 TObjArray *objarr = re4.MatchS(branchName);; 679 TString version;; 680 // We extract the correct version name for the URL.; 681 if (objarr && objarr->GetEntries() == 3) {; 682 // We have a valid version of ROOT and we will extract the correct name for the URL.; 683 version = ((TObjString *)objarr->At(1))->GetString() + ((TObjString *)objarr->At(2))->GetString();; 684 } else {; 685 // If it's not a supported version, we will go to ""master"" branch.; 686 version = ""master"";; 687 }; 688 delete objarr;; 689 url.Append(version);; 690 url.Append(""/"");; 691 // We will replace all ""::"" with ""_1_1"" and all ""_"" with ""__"" in the; 692 // classes definitions, due to Doxygen syntax requirements.; 693 scopeName.ReplaceAll(""_"", ""__"");; 694 scopeName.ReplaceAll(""::"", ""_1_1"");; 695 // We build the URL for the correct scope type and name.; 696 if (scopeType == kURLforClass) {; 697 url.Append(""class"");; 698 } else if (scopeType == kURLforStruct) {; 699 url.Append(""struct"");;",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:36635,Deployability,install,installation,36635,"rDoxygen(scopeName, func)));; 938 if (scopeType == kURLforNameSpace) {; 939 // We need to append ""constexpr"" if we work with constexpr functions in namespaces.; 940 if (func->Property() & kIsConstexpr) {; 941 md5Text.Prepend(""constexpr "");; 942 }; 943 }; 944 md5Text.Append("" "");; 945 }; 946 // We append ScopeName::MethodNameMethodName.; 947 md5Text.Append(scopeName);; 948 md5Text.Append(""::"");; 949 md5Text.Append(methodName);; 950 md5Text.Append(methodName);; 951 // We use ""FormatMethodArgsForDoxygen"" to modify the arguments of Method with respect of Doxygen.; 952 md5Text.Append(FormatMethodArgsForDoxygen(scopeName, func));; 953 // We generate the URL for the class/namespace/struct.; 954 TString url = UrlGenerator(scopeName, scopeType);; 955 url.Append(""#a"");; 956 // We append the hashed text.; 957 url.Append(md5Text.MD5());; 958 return url;; 959}; 960} // namespace; 961 ; 962////////////////////////////////////////////////////////////////////////////////; 963/// It gets the ROOT installation setup as TString; 964///; 965/// \return a string with several lines; 966///; 967TString TApplication::GetSetup(); 968{; 969 std::vector<TString> lines;; 970 lines.emplace_back(""```"");; 971 lines.emplace_back(TString::Format(""ROOT v%s"",; 972 gROOT->GetVersion()));; 973 lines.emplace_back(TString::Format(""Built for %s on %s"", gSystem->GetBuildArch(), gROOT->GetGitDate()));; 974 if (!strcmp(gROOT->GetGitBranch(), gROOT->GetGitCommit())) {; 975 static const char *months[] = {""January"",""February"",""March"",""April"",""May"",; 976 ""June"",""July"",""August"",""September"",""October"",; 977 ""November"",""December""};; 978 Int_t idatqq = gROOT->GetVersionDate();; 979 Int_t iday = idatqq%100;; 980 Int_t imonth = (idatqq/100)%100;; 981 Int_t iyear = (idatqq/10000);; 982 ; 983 lines.emplace_back(TString::Format(""From tag %s, %d %s %4d"",; 984 gROOT->GetGitBranch(),; 985 iday,months[imonth-1],iyear));; 986 } else {; 987 // If branch and commit are identical - e.g. ""v5-34-18"" - then we have; 988 // a release ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:37633,Deployability,release,release,37633,"gets the ROOT installation setup as TString; 964///; 965/// \return a string with several lines; 966///; 967TString TApplication::GetSetup(); 968{; 969 std::vector<TString> lines;; 970 lines.emplace_back(""```"");; 971 lines.emplace_back(TString::Format(""ROOT v%s"",; 972 gROOT->GetVersion()));; 973 lines.emplace_back(TString::Format(""Built for %s on %s"", gSystem->GetBuildArch(), gROOT->GetGitDate()));; 974 if (!strcmp(gROOT->GetGitBranch(), gROOT->GetGitCommit())) {; 975 static const char *months[] = {""January"",""February"",""March"",""April"",""May"",; 976 ""June"",""July"",""August"",""September"",""October"",; 977 ""November"",""December""};; 978 Int_t idatqq = gROOT->GetVersionDate();; 979 Int_t iday = idatqq%100;; 980 Int_t imonth = (idatqq/100)%100;; 981 Int_t iyear = (idatqq/10000);; 982 ; 983 lines.emplace_back(TString::Format(""From tag %s, %d %s %4d"",; 984 gROOT->GetGitBranch(),; 985 iday,months[imonth-1],iyear));; 986 } else {; 987 // If branch and commit are identical - e.g. ""v5-34-18"" - then we have; 988 // a release build. Else specify the git hash this build was made from.; 989 lines.emplace_back(TString::Format(""From %s@%s"",; 990 gROOT->GetGitBranch(),; 991 gROOT->GetGitCommit()));; 992 }; 993 lines.emplace_back(TString::Format(""With %s"",; 994 gSystem->GetBuildCompilerVersionStr()));; 995 lines.emplace_back(""Binary directory: ""+ gROOT->GetBinDir());; 996 lines.emplace_back(""```"");; 997 TString setup = """";; 998 for (auto& line : lines) {; 999 setup.Append(line);; 1000 setup.Append('\n');; 1001 }; 1002 setup.Chop(); // trim final `\n`; 1003 return setup;; 1004}; 1005 ; 1006////////////////////////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (typ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:39734,Deployability,install,install,39734,"opic?title=topic%20title&body=topic%20body&category=category/subcategory&tags=email,planned\"""");; 1017 TString report_template =; 1018R""(___; 1019_Please read [tips for efficient and successful posting](https://root-forum.cern.ch/t/tips-for-efficient-and-successful-posting/28292) and [posting code](https://root-forum.cern.ch/t/posting-code-read-this-first/28293)_; 1020 ; 1021### Describe the bug; 1022<!--; 1023A clear and concise description of what the wrong behavior is.; 1024-->; 1025### Expected behavior; 1026<!--; 1027A clear and concise description of what you expected to happen.; 1028-->; 1029 ; 1030### To Reproduce; 1031<!--; 1032Steps to reproduce the behavior:; 10331. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 10342. Don't forget to attach the required input files!; 10353. How to run your code and / or build it, e.g. `root myMacro.C`, ...; 1036-->; 1037 ; 1038### Setup; 1039)""+GetSetup()+; 1040R""(; 1041<!--; 1042Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; 1043-->; 1044 ; 1045### Additional context; 1046<!--; 1047Add any other context about the problem here.; 1048-->)"";; 1049 report_template = FormatHttpUrl(report_template);; 1050 ; 1051 OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?category=ROOT&tags=bug&body=""+report_template+""&\"""");; 1052 } else {; 1053 Warning(""OpenForumTopic"", ""cannot find \""%s\"" as type for a Forum topic\n""; 1054 ""Available types are 'bug'."", type.Data());; 1055 }; 1056}; 1057 ; 1058////////////////////////////////////////////////////////////////////////////////; 1059/// It opens a GitHub issue in a web browser with prefilled ROOT version; 1060///; 1061/// \param[in] type the issue type (bug, feature or improvement); 1062 ; 1063void TApplication::OpenGitHubIssue(const TString &type); 1064{; 1065 // https://docs.github.com/en/issues/tracking-your-work-with-issues/creating-an-issue#creating-an-issue-from-a-url-query; ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:53663,Deployability,toggle,toggle,53663,"f("" Fn+Arrow_Right : move cursor to end of line [Ctrl+E]"");; 1310 #else; 1311 Printf("" End : move cursor to end of line [Ctrl+E]"");; 1312 #endif; 1313 Printf("" Ctrl+Arrow_Left : jump to previous word [Esc,B] [Alt,B]"" FOOTNOTE);; 1314 Printf("" Ctrl+Arrow_Right : jump to next word [Esc,F] [Alt,F]"" FOOTNOTE);; 1315 ; 1316 Printf("" Backspace : delete previous character [Ctrl+H]"");; 1317 Printf("" Del : delete next character [Ctrl+D]"");; 1318 Printf("" Esc,Backspace : delete previous word [Ctrl+W] [Esc,Ctrl+H] [Alt+Backspace] [Esc,Del] [Esc,Ctrl+Del]"" FOOTNOTE);// Del is 0x7F on macOS; 1319 Printf("" Ctrl+Del : delete next word [Esc,D] [Alt,D]"" FOOTNOTE);; 1320 Printf("" Ctrl+U : cut all characters between cursor and start of line"");; 1321 Printf("" Ctrl+K : cut all characters between cursor and end of line"");; 1322 ; 1323 Printf("" Ctrl+T : transpose characters"");; 1324 Printf("" Esc,C : character to upper and jump to next word"");; 1325 Printf("" Esc,L : word to lower case and jump to its end"");; 1326 Printf("" Esc,U : word to upper case and jump to its end"");; 1327 Printf("" Ctrl+Shift+C : copy clipboard content"");; 1328 Printf("" Ctrl+Shift+V : paste clipboard content [Ctrl+Y] [Alt+Y]"");; 1329 #ifdef R__MACOSX; 1330 Printf("" Fn+Enter : toggle overwrite mode"");; 1331 #else; 1332 Printf("" Ins : toggle overwrite mode"");; 1333 #endif; 1334 ; 1335 Printf("" Ctrl+_ : undo last keypress action"");; 1336 Printf("" Tab : autocomplete command or print suggestions [Ctrl+I] [Esc,Tab]"");; 1337 Printf("" Enter : execute command [Ctrl+J] [Ctrl+M]"");; 1338 Printf("" Ctrl+L : clear prompt screen"");; 1339 Printf("" Ctrl+D : quit ROOT (if empty line)"");; 1340 Printf("" Ctrl+C : send kSigInt interrupt signal"");; 1341 Printf("" Ctrl+Z : send kSigStop pause job signal"");; 1342 ; 1343 Printf("" Arrow_Down : navigate downwards in command history [Ctrl+N]"");; 1344 Printf("" Arrow_Up : navigate upwards in command history [Ctrl+P]"");; 1345 Printf("" Ctrl+R ; Ctrl+S : search command in your history by typing a string.",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:53721,Deployability,toggle,toggle,53721,"f("" Fn+Arrow_Right : move cursor to end of line [Ctrl+E]"");; 1310 #else; 1311 Printf("" End : move cursor to end of line [Ctrl+E]"");; 1312 #endif; 1313 Printf("" Ctrl+Arrow_Left : jump to previous word [Esc,B] [Alt,B]"" FOOTNOTE);; 1314 Printf("" Ctrl+Arrow_Right : jump to next word [Esc,F] [Alt,F]"" FOOTNOTE);; 1315 ; 1316 Printf("" Backspace : delete previous character [Ctrl+H]"");; 1317 Printf("" Del : delete next character [Ctrl+D]"");; 1318 Printf("" Esc,Backspace : delete previous word [Ctrl+W] [Esc,Ctrl+H] [Alt+Backspace] [Esc,Del] [Esc,Ctrl+Del]"" FOOTNOTE);// Del is 0x7F on macOS; 1319 Printf("" Ctrl+Del : delete next word [Esc,D] [Alt,D]"" FOOTNOTE);; 1320 Printf("" Ctrl+U : cut all characters between cursor and start of line"");; 1321 Printf("" Ctrl+K : cut all characters between cursor and end of line"");; 1322 ; 1323 Printf("" Ctrl+T : transpose characters"");; 1324 Printf("" Esc,C : character to upper and jump to next word"");; 1325 Printf("" Esc,L : word to lower case and jump to its end"");; 1326 Printf("" Esc,U : word to upper case and jump to its end"");; 1327 Printf("" Ctrl+Shift+C : copy clipboard content"");; 1328 Printf("" Ctrl+Shift+V : paste clipboard content [Ctrl+Y] [Alt+Y]"");; 1329 #ifdef R__MACOSX; 1330 Printf("" Fn+Enter : toggle overwrite mode"");; 1331 #else; 1332 Printf("" Ins : toggle overwrite mode"");; 1333 #endif; 1334 ; 1335 Printf("" Ctrl+_ : undo last keypress action"");; 1336 Printf("" Tab : autocomplete command or print suggestions [Ctrl+I] [Esc,Tab]"");; 1337 Printf("" Enter : execute command [Ctrl+J] [Ctrl+M]"");; 1338 Printf("" Ctrl+L : clear prompt screen"");; 1339 Printf("" Ctrl+D : quit ROOT (if empty line)"");; 1340 Printf("" Ctrl+C : send kSigInt interrupt signal"");; 1341 Printf("" Ctrl+Z : send kSigStop pause job signal"");; 1342 ; 1343 Printf("" Arrow_Down : navigate downwards in command history [Ctrl+N]"");; 1344 Printf("" Arrow_Up : navigate upwards in command history [Ctrl+P]"");; 1345 Printf("" Ctrl+R ; Ctrl+S : search command in your history by typing a string.",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:94049,Deployability,install,installation,94049,"c method returning the list of available applications.Definition TApplication.cxx:2103; TApplication::fIsRunningstd::atomic< bool > fIsRunningWindow system specific application implementation.Definition TApplication.h:61; TApplication::NeedGraphicsLibsstatic void NeedGraphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove obj from browser.Definition TBrowser.cxx:408; TBrowser::Addvoid Add(TObject *obj, const char *name=nullptr, Int_t check=-1)Add object with name to browser.Definition TBrowser.cxx:303; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:101560,Deployability,install,installation,101560,"st char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPRegexpDefinition TPRegexp.h:36; TPluginHandlerDefinition TPluginManager.h:103; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3193; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3082; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) c",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:101846,Deployability,install,installation,101846,"n TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPRegexpDefinition TPRegexp.h:36; TPluginHandlerDefinition TPluginManager.h:103; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3193; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3082; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::ReplaceTString & Replace(Ss",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:102000,Deployability,install,installation,102000,"oid Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPRegexpDefinition TPRegexp.h:36; TPluginHandlerDefinition TPluginManager.h:103; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3193; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3082; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:10554,Energy Efficiency,allocate,allocated,10554,"/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initialize TGX11TTF by hand; 269 // (normally this is done by the static library initializer); 270 ProcessLine(""TGX11TTF::Activate();"");; 271 } else {; 272 TPluginHandler *h;; 273 if ((h = gROOT->GetPluginManager()->FindHandler(""TVirtualX"", ""x11ttf""))); 274 if (h->LoadPlugin() == -1); 275 Info(""InitializeGraphics"", ""no TTF support"");; 276 }; 277 }; 278 #endif; 279 delete [] ttfont;; 280 }; 281 ; 282 if (!only_web || !fAppImp) {; 283 // Create WM dependent application environment; 284 if (fAppImp); 285 delete fAppImp;; 286 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 287 if (!fAppImp) {; 288 MakeBatch();; 289 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 290 }; 291 }; 292 ; 293 // Create the canvas colors early so they are allocated before; 294 // any color table expensive bitmaps get allocated in GUI routines (like; 295 // creation of XPM bitmaps).; 296 TColor::InitializeColors();; 297 ; 298 // Hook for further initializing the WM dependent application environment; 299 Init();; 300 ; 301 // Set default screen factor (if not disabled in rc file); 302 if (!only_web && gEnv->GetValue(""Canvas.UseScreenFactor"", 1)) {; 303 Int_t x, y;; 304 UInt_t w, h;; 305 if (gVirtualX) {; 306 gVirtualX->GetGeometry(-1, x, y, w, h);; 307 if (h > 0); 308 gStyle->SetScreenFactor(0.001 * h);; 309 }; 310 }; 311",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:10617,Energy Efficiency,allocate,allocated,10617,"/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initialize TGX11TTF by hand; 269 // (normally this is done by the static library initializer); 270 ProcessLine(""TGX11TTF::Activate();"");; 271 } else {; 272 TPluginHandler *h;; 273 if ((h = gROOT->GetPluginManager()->FindHandler(""TVirtualX"", ""x11ttf""))); 274 if (h->LoadPlugin() == -1); 275 Info(""InitializeGraphics"", ""no TTF support"");; 276 }; 277 }; 278 #endif; 279 delete [] ttfont;; 280 }; 281 ; 282 if (!only_web || !fAppImp) {; 283 // Create WM dependent application environment; 284 if (fAppImp); 285 delete fAppImp;; 286 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 287 if (!fAppImp) {; 288 MakeBatch();; 289 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 290 }; 291 }; 292 ; 293 // Create the canvas colors early so they are allocated before; 294 // any color table expensive bitmaps get allocated in GUI routines (like; 295 // creation of XPM bitmaps).; 296 TColor::InitializeColors();; 297 ; 298 // Hook for further initializing the WM dependent application environment; 299 Init();; 300 ; 301 // Set default screen factor (if not disabled in rc file); 302 if (!only_web && gEnv->GetValue(""Canvas.UseScreenFactor"", 1)) {; 303 Int_t x, y;; 304 UInt_t w, h;; 305 if (gVirtualX) {; 306 gVirtualX->GetGeometry(-1, x, y, w, h);; 307 if (h > 0); 308 gStyle->SetScreenFactor(0.001 * h);; 309 }; 310 }; 311",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:38862,Energy Efficiency,efficient,efficient,38862,"Commit()));; 992 }; 993 lines.emplace_back(TString::Format(""With %s"",; 994 gSystem->GetBuildCompilerVersionStr()));; 995 lines.emplace_back(""Binary directory: ""+ gROOT->GetBinDir());; 996 lines.emplace_back(""```"");; 997 TString setup = """";; 998 for (auto& line : lines) {; 999 setup.Append(line);; 1000 setup.Append('\n');; 1001 }; 1002 setup.Chop(); // trim final `\n`; 1003 return setup;; 1004}; 1005 ; 1006////////////////////////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (type == ""bug"") {; 1016 //OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?title=topic%20title&body=topic%20body&category=category/subcategory&tags=email,planned\"""");; 1017 TString report_template =; 1018R""(___; 1019_Please read [tips for efficient and successful posting](https://root-forum.cern.ch/t/tips-for-efficient-and-successful-posting/28292) and [posting code](https://root-forum.cern.ch/t/posting-code-read-this-first/28293)_; 1020 ; 1021### Describe the bug; 1022<!--; 1023A clear and concise description of what the wrong behavior is.; 1024-->; 1025### Expected behavior; 1026<!--; 1027A clear and concise description of what you expected to happen.; 1028-->; 1029 ; 1030### To Reproduce; 1031<!--; 1032Steps to reproduce the behavior:; 10331. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 10342. Don't forget to attach the required input files!; 10353. How to run your code and / or build it, e.g. `root myMacro.C`, ...; 1036-->; 1037 ; 1038### Setup; 1039)""+GetSetup()+; 1040R""(; 1041<!--; 1042Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; 1043-->; 1044",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:38934,Energy Efficiency,efficient,efficient-and-successful-posting,38934,"T->GetBinDir());; 996 lines.emplace_back(""```"");; 997 TString setup = """";; 998 for (auto& line : lines) {; 999 setup.Append(line);; 1000 setup.Append('\n');; 1001 }; 1002 setup.Chop(); // trim final `\n`; 1003 return setup;; 1004}; 1005 ; 1006////////////////////////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (type == ""bug"") {; 1016 //OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?title=topic%20title&body=topic%20body&category=category/subcategory&tags=email,planned\"""");; 1017 TString report_template =; 1018R""(___; 1019_Please read [tips for efficient and successful posting](https://root-forum.cern.ch/t/tips-for-efficient-and-successful-posting/28292) and [posting code](https://root-forum.cern.ch/t/posting-code-read-this-first/28293)_; 1020 ; 1021### Describe the bug; 1022<!--; 1023A clear and concise description of what the wrong behavior is.; 1024-->; 1025### Expected behavior; 1026<!--; 1027A clear and concise description of what you expected to happen.; 1028-->; 1029 ; 1030### To Reproduce; 1031<!--; 1032Steps to reproduce the behavior:; 10331. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 10342. Don't forget to attach the required input files!; 10353. How to run your code and / or build it, e.g. `root myMacro.C`, ...; 1036-->; 1037 ; 1038### Setup; 1039)""+GetSetup()+; 1040R""(; 1041<!--; 1042Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; 1043-->; 1044 ; 1045### Additional context; 1046<!--; 1047Add any other context about the problem here.; 1048-->)"";; 1049 report_template = FormatHttpUrl(report_template);; 1050 ;",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:740,Integrability,interface,interfaces,740,". ROOT: core/base/src/TApplication.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TApplication.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/12/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TApplication; 13\ingroup Base; 14 ; 15This class creates the ROOT Application Environment that interfaces; 16to the windowing system eventloop and eventhandlers.; 17This class must be instantiated exactly once in any given; 18application. Normally the specific application class inherits from; 19TApplication (see TRint).; 20*/; 21 ; 22#include ""RConfigure.h""; 23#include ""TApplication.h""; 24#include ""TException.h""; 25#include ""TGuiFactory.h""; 26#include ""TVirtualX.h""; 27#include ""TROOT.h""; 28#include ""TSystem.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TObjArray.h""; 32#include ""TObjString.h""; 33#include ""TTimer.h""; 34#include ""TInterpreter.h""; 35#include ""TStyle.h""; 36#include ""TVirtualPad.h""; 37#include ""TEnv.h""; 38#include ""TColor.h""; 39#include ""TPluginManager.h""; 40#include ""TClassTable.h""; 41#include ""TBrowser.h""; 42#include ""TUrl.h""; 43#include ""TVirtualMutex.h""; 44#include ""TClassEdit.h""; 45#include ""TMethod.h""; 46#include ""TDataMember.h""; 47#include ""TApplicationCommandLineOptionsHelp.h""; 48#include ""TPRegexp.h""; 49#include <cstdlib>; 50#include <iostream>; 51#include <fstream>; 52 ; 53TApplication *gApplication = nullptr;; 54Bool_t TApplication::fgGraphNeeded = kFALSE;; 55Bool_t TApplication::fgGraphInit = kFALSE;; 56TList *TApplication::fgApplications = nullptr; // List of available applications; 57 ; 58////",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:3752,Integrability,interface,interface,3752,"e function static in TSystem.cxx has been destructed. So we; 86 // set gROOT in its end-of-life mode which prevents executing code, like; 87 // autoloading libraries (!) that is pointless ...; 88 if (gROOT) {; 89 gROOT->SetBit(kInvalidObject);; 90 gROOT->EndOfProcessCleanups();; 91 }; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////////; 95/// Default ctor. Can be used by classes deriving from TApplication.; 96 ; 97TApplication::TApplication() :; 98 fArgc(0), fArgv(nullptr), fAppImp(nullptr), fIsRunning(kFALSE), fReturnFromRun(kFALSE),; 99 fNoLog(kFALSE), fNoLogo(kFALSE), fQuit(kFALSE),; 100 fFiles(nullptr), fIdleTimer(nullptr), fSigHandler(nullptr), fExitOnException(kDontExit),; 101 fAppRemote(nullptr); 102{; 103 ResetBit(kProcessRemotely);; 104}; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// Create an application environment. The application environment; 108/// provides an interface to the graphics system and eventloop; 109/// (be it X, Windows, macOS or BeOS). After creating the application; 110/// object start the eventloop by calling its Run() method. The command; 111/// line options recognized by TApplication are described in the GetOptions(); 112/// method. The recognized options are removed from the argument array.; 113/// The original list of argument options can be retrieved via the Argc(); 114/// and Argv() methods. The appClassName ""proofserv"" is reserved for the; 115/// PROOF system. The ""options"" and ""numOptions"" arguments are not used,; 116/// except if you want to by-pass the argv processing by GetOptions(); 117/// in which case you should specify numOptions<0. All options will; 118/// still be available via the Argv() method for later use.; 119 ; 120TApplication::TApplication(const char *appClassName, Int_t *argc, char **argv,; 121 void * /*options*/, Int_t numOptions) :; 122 fArgc(0), fArgv(nullptr), fAppImp(nullptr), fIsRunning(kFALSE), fReturnFromRun(kFALS",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:10205,Integrability,depend,dependent,10205,"/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initialize TGX11TTF by hand; 269 // (normally this is done by the static library initializer); 270 ProcessLine(""TGX11TTF::Activate();"");; 271 } else {; 272 TPluginHandler *h;; 273 if ((h = gROOT->GetPluginManager()->FindHandler(""TVirtualX"", ""x11ttf""))); 274 if (h->LoadPlugin() == -1); 275 Info(""InitializeGraphics"", ""no TTF support"");; 276 }; 277 }; 278 #endif; 279 delete [] ttfont;; 280 }; 281 ; 282 if (!only_web || !fAppImp) {; 283 // Create WM dependent application environment; 284 if (fAppImp); 285 delete fAppImp;; 286 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 287 if (!fAppImp) {; 288 MakeBatch();; 289 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 290 }; 291 }; 292 ; 293 // Create the canvas colors early so they are allocated before; 294 // any color table expensive bitmaps get allocated in GUI routines (like; 295 // creation of XPM bitmaps).; 296 TColor::InitializeColors();; 297 ; 298 // Hook for further initializing the WM dependent application environment; 299 Init();; 300 ; 301 // Set default screen factor (if not disabled in rc file); 302 if (!only_web && gEnv->GetValue(""Canvas.UseScreenFactor"", 1)) {; 303 Int_t x, y;; 304 UInt_t w, h;; 305 if (gVirtualX) {; 306 gVirtualX->GetGeometry(-1, x, y, w, h);; 307 if (h > 0); 308 gStyle->SetScreenFactor(0.001 * h);; 309 }; 310 }; 311",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:10634,Integrability,rout,routines,10634,"/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initialize TGX11TTF by hand; 269 // (normally this is done by the static library initializer); 270 ProcessLine(""TGX11TTF::Activate();"");; 271 } else {; 272 TPluginHandler *h;; 273 if ((h = gROOT->GetPluginManager()->FindHandler(""TVirtualX"", ""x11ttf""))); 274 if (h->LoadPlugin() == -1); 275 Info(""InitializeGraphics"", ""no TTF support"");; 276 }; 277 }; 278 #endif; 279 delete [] ttfont;; 280 }; 281 ; 282 if (!only_web || !fAppImp) {; 283 // Create WM dependent application environment; 284 if (fAppImp); 285 delete fAppImp;; 286 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 287 if (!fAppImp) {; 288 MakeBatch();; 289 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 290 }; 291 }; 292 ; 293 // Create the canvas colors early so they are allocated before; 294 // any color table expensive bitmaps get allocated in GUI routines (like; 295 // creation of XPM bitmaps).; 296 TColor::InitializeColors();; 297 ; 298 // Hook for further initializing the WM dependent application environment; 299 Init();; 300 ; 301 // Set default screen factor (if not disabled in rc file); 302 if (!only_web && gEnv->GetValue(""Canvas.UseScreenFactor"", 1)) {; 303 Int_t x, y;; 304 UInt_t w, h;; 305 if (gVirtualX) {; 306 gVirtualX->GetGeometry(-1, x, y, w, h);; 307 if (h > 0); 308 gStyle->SetScreenFactor(0.001 * h);; 309 }; 310 }; 311",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:10767,Integrability,depend,dependent,10767," is done by the static library initializer); 270 ProcessLine(""TGX11TTF::Activate();"");; 271 } else {; 272 TPluginHandler *h;; 273 if ((h = gROOT->GetPluginManager()->FindHandler(""TVirtualX"", ""x11ttf""))); 274 if (h->LoadPlugin() == -1); 275 Info(""InitializeGraphics"", ""no TTF support"");; 276 }; 277 }; 278 #endif; 279 delete [] ttfont;; 280 }; 281 ; 282 if (!only_web || !fAppImp) {; 283 // Create WM dependent application environment; 284 if (fAppImp); 285 delete fAppImp;; 286 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 287 if (!fAppImp) {; 288 MakeBatch();; 289 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 290 }; 291 }; 292 ; 293 // Create the canvas colors early so they are allocated before; 294 // any color table expensive bitmaps get allocated in GUI routines (like; 295 // creation of XPM bitmaps).; 296 TColor::InitializeColors();; 297 ; 298 // Hook for further initializing the WM dependent application environment; 299 Init();; 300 ; 301 // Set default screen factor (if not disabled in rc file); 302 if (!only_web && gEnv->GetValue(""Canvas.UseScreenFactor"", 1)) {; 303 Int_t x, y;; 304 UInt_t w, h;; 305 if (gVirtualX) {; 306 gVirtualX->GetGeometry(-1, x, y, w, h);; 307 if (h > 0); 308 gStyle->SetScreenFactor(0.001 * h);; 309 }; 310 }; 311}; 312 ; 313////////////////////////////////////////////////////////////////////////////////; 314/// Clear list containing macro files passed as program arguments.; 315/// This method is called from TRint::Run() to ensure that the macro; 316/// files are only executed the first time Run() is called.; 317 ; 318void TApplication::ClearInputFiles(); 319{; 320 if (fFiles) {; 321 fFiles->Delete();; 322 SafeDelete(fFiles);; 323 }; 324}; 325 ; 326////////////////////////////////////////////////////////////////////////////////; 327/// Return specified argument.; 328 ; 329char *TApplication::Argv(Int_t index) const; 330{; 331 if (fArgv) {; 332 if (index >= fArgc) {; 333 Error(",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:19663,Integrability,rout,routine,19663,"} else {; 540 // if file add an invalid entry to list of files to be processed; 541 fFiles->Add(new TNamed(""NOT FOUND!"", argv[i]));; 542 // only warn if we're plain root,; 543 // other progs might have their own params; 544 if (!strcmp(gROOT->GetName(), ""Rint"")) {; 545 Error(""GetOptions"", ""macro %s not found"", fname.Data());; 546 // Return 2 as the Python interpreter does in case the macro; 547 // is not found.; 548 Terminate(2);; 549 }; 550 }; 551 }; 552 }; 553 }; 554 // ignore unknown options; 555 }; 556 ; 557 // go back to startup directory; 558 if (pwd != """"); 559 gSystem->ChangeDirectory(pwd);; 560 ; 561 // remove handled arguments from argument array; 562 j = 0;; 563 for (i = 0; i < *argc; i++) {; 564 if (strcmp(argv[i], """")) {; 565 argv[j] = argv[i];; 566 j++;; 567 }; 568 }; 569 ; 570 *argc = j;; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Handle idle timeout. When this timer expires the registered idle command; 575/// will be executed by this routine and a signal will be emitted.; 576 ; 577void TApplication::HandleIdleTimer(); 578{; 579 if (!fIdleCommand.IsNull()); 580 ProcessLine(GetIdleCommand());; 581 ; 582 Emit(""HandleIdleTimer()"");; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Handle exceptions (kSigBus, kSigSegmentationViolation,; 587/// kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; 588/// Specific TApplication implementations may want something different here.; 589 ; 590void TApplication::HandleException(Int_t sig); 591{; 592 if (TROOT::Initialized()) {; 593 if (gException) {; 594 gInterpreter->RewindDictionary();; 595 gInterpreter->ClearFileBusy();; 596 }; 597 if (fExitOnException == kExit); 598 gSystem->Exit(128 + sig);; 599 else if (fExitOnException == kAbort); 600 gSystem->Abort();; 601 else; 602 Throw(sig);; 603 }; 604 gSystem->Exit(128 + sig);; 605}; 606 ; 607//////////////////////////////////////////////",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:21555,Integrability,message,message,21555,");; 605}; 606 ; 607////////////////////////////////////////////////////////////////////////////////; 608/// Set the exit on exception option. Setting this option determines what; 609/// happens in HandleException() in case an exception (kSigBus,; 610/// kSigSegmentationViolation, kSigIllegalInstruction or kSigFloatingException); 611/// is trapped. Choices are: kDontExit (default), kExit or kAbort.; 612/// Returns the previous value.; 613 ; 614TApplication::EExitOnException TApplication::ExitOnException(TApplication::EExitOnException opt); 615{; 616 EExitOnException old = fExitOnException;; 617 fExitOnException = opt;; 618 return old;; 619}; 620 ; 621/////////////////////////////////////////////////////////////////////////////////; 622/// The function generates and executes a command that loads the Doxygen URL in; 623/// a browser. It works for Mac, Windows and Linux. In the case of Linux, the; 624/// function also checks if the DISPLAY is set. If it isn't, a warning message; 625/// and the URL will be displayed on the terminal.; 626///; 627/// \param[in] url web page to be displayed in a browser; 628 ; 629void TApplication::OpenInBrowser(const TString &url); 630{; 631 // We check what operating system the user has.; 632#ifdef R__MACOSX; 633 // Command for opening a browser on Mac.; 634 TString cMac(""open "");; 635 // We generate the full command and execute it.; 636 cMac.Append(url);; 637 gSystem->Exec(cMac);; 638#elif defined(R__WIN32); 639 // Command for opening a browser on Windows.; 640 TString cWindows(""start \""\"" "");; 641 cWindows.Append(url);; 642 gSystem->Exec(cWindows);; 643#else; 644 // Command for opening a browser in Linux.; 645 TString cLinux(""xdg-open "");; 646 // For Linux we check if the DISPLAY is set.; 647 if (gSystem->Getenv(""DISPLAY"")) {; 648 // If the DISPLAY is set it will open the browser.; 649 cLinux.Append(url);; 650 gSystem->Exec(cLinux);; 651 } else {; 652 // Else the user will have a warning and the URL in the terminal.; 653 Warning(""OpenIn",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:46107,Integrability,message,message,46107,"61 }; 1162 // We call ""GetUrlForMethod"" for the correct class and scope.; 1163 OpenInBrowser(GetUrlForMethod(baseClName, memberName, func, methodType, scopeType));; 1164 return;; 1165 }; 1166 // We check if ""memberName"" is an enumeration.; 1167 if (cl->GetListOfEnums()->FindObject(memberName)) {; 1168 // If so with OpenInBrowser we open the URL generated with GetUrlForEnumeration; 1169 // with respect to the ""scopeType"".; 1170 OpenInBrowser(GetUrlForEnumeration(scopeName, memberName, scopeType));; 1171 return;; 1172 }; 1173 ; 1174 // We check if ""memberName"" is enumerator defined in one the base classes of ""scopeName"".; 1175 if (auto enumerator = (TDataMember *)cl->GetListOfAllPublicDataMembers()->FindObject(memberName)) {; 1176 // We find the actual scope (might be in a base) and open the URL in a browser.; 1177 TString baseClName = ((TMethod *)enumerator->GetClass())->GetName();; 1178 OpenInBrowser(GetUrlForDataMember(baseClName, memberName, enumerator, scopeType));; 1179 return;; 1180 }; 1181 ; 1182 // Warning message will appear if the user types the function name incorrectly; 1183 // or the function is not a member function of ""cl"" or any of its base classes.; 1184 Warning(""OpenReferenceGuideFor"", ""cannot find \""%s\"" as member of %s or its base classes! Check %s\n"", memberName.Data(),; 1185 scopeName.Data(), UrlGenerator(scopeName, scopeType).Data());; 1186}; 1187 ; 1188////////////////////////////////////////////////////////////////////////////////; 1189/// The function ("".forum <type>"") submits a new post on the ROOT forum; 1190/// via web browser.; 1191/// \note You can use ""bug"" as <type>.; 1192/// \param[in] line command from the command line; 1193 ; 1194void TApplication::Forum(const char *line); 1195{; 1196 // We first check if the user chose a correct syntax.; 1197 TString strippedCommand = TString(line).Strip(TString::kBoth);; 1198 if (!strippedCommand.BeginsWith("".forum "")) {; 1199 Error(""Forum"", ""Unknown command! Use 'bug' after '.forum '"");; 1200 re",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:55405,Integrability,interface,interface,55405,"ws).\n""; 1347 "" Press Ctrl+R (Ctrl+S) repeateadly to navigate matches in reverse (forward) order"");; 1348 Printf("" Arrow_Right : after Ctrl+R (Ctrl+S), select current match of the history search\n""; 1349 "" [Ctrl+O] [Enter] [Ctrl+J] [Ctrl+M] [Arrow_Left] [Esc,Esc].\n""; 1350 "" Use Ctrl+F or Ctrl+G to cancel search and revert original line"");; 1351 ; 1352 return;; 1353 }; 1354 // We call the function what handles the extended "".help scopeName"" command.; 1355 OpenReferenceGuideFor(strippedCommand);; 1356 }; 1357}; 1358 ; 1359/// Load shared libs necessary for graphics. These libraries are only; 1360/// loaded when gROOT->IsBatch() is kFALSE.; 1361 ; 1362void TApplication::LoadGraphicsLibs(); 1363{; 1364 if (gROOT->IsBatch()); 1365 return;; 1366 ; 1367 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPad"")); 1368 if (h->LoadPlugin() == -1); 1369 return;; 1370 ; 1371 TString name;; 1372 TString title1 = ""ROOT interface to "";; 1373 TString nativex, title;; 1374 ; 1375#ifdef R__WIN32; 1376 nativex = ""win32gdk"";; 1377 name = ""Win32gdk"";; 1378 title = title1 + ""Win32gdk"";; 1379#elif defined(R__HAS_COCOA); 1380 nativex = ""quartz"";; 1381 name = ""quartz"";; 1382 title = title1 + ""Quartz"";; 1383#else; 1384 nativex = ""x11"";; 1385 name = ""X11"";; 1386 title = title1 + ""X11"";; 1387#endif; 1388 ; 1389 TString guiBackend = gEnv->GetValue(""Gui.Backend"", ""native"");; 1390 guiBackend.ToLower();; 1391 if (guiBackend == ""native"") {; 1392 guiBackend = nativex;; 1393 } else {; 1394 name = guiBackend;; 1395 title = title1 + guiBackend;; 1396 }; 1397 ; 1398 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualX"", guiBackend)) {; 1399 if (h->LoadPlugin() == -1) {; 1400 gROOT->SetBatch(kTRUE);; 1401 return;; 1402 }; 1403 gVirtualX = (TVirtualX *) h->ExecPlugin(2, name.Data(), title.Data());; 1404 fgGraphInit = kTRUE;; 1405 }; 1406 ; 1407 TString guiFactory = gEnv->GetValue(""Gui.Factory"", ""native"");; 1408 guiFactory.ToLower();; 1409 if (guiFactory == ""native""); 1410 guiFactory = """,MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:72202,Integrability,depend,dependent,72202,"strncmp(s, ""//"", 2)) continue;; 1852 if (!strncmp(s, ""/*"", 2)) {; 1853 comment = 1;; 1854 goto again;; 1855 }; 1856 }; 1857 }; 1858 if (!comment && *s == '{') tempfile = 1;; 1859 if (!comment) break;; 1860 }; 1861 macro.close();; 1862 ; 1863 if (!execute) {; 1864 TString exname = exnam;; 1865 if (!tempfile) {; 1866 // We have a script that does NOT contain an unnamed macro,; 1867 // so we can call the script compiler on it.; 1868 exname += aclicMode;; 1869 }; 1870 exname += arguments;; 1871 exname += io;; 1872 ; 1873 TString tempbuf;; 1874 if (tempfile) {; 1875 tempbuf.Form("".x %s"", exname.Data());; 1876 } else {; 1877 tempbuf.Form("".X%s %s"", keep ? ""k"" : "" "", exname.Data());; 1878 }; 1879 retval = gInterpreter->ProcessLineSynch(tempbuf,(TInterpreter::EErrorCode*)error);; 1880 }; 1881 ; 1882 delete [] exnam;; 1883 return retval;; 1884}; 1885 ; 1886////////////////////////////////////////////////////////////////////////////////; 1887/// Main application eventloop. Calls system dependent eventloop via gSystem.; 1888 ; 1889void TApplication::Run(Bool_t retrn); 1890{; 1891 SetReturnFromRun(retrn);; 1892 ; 1893 fIsRunning = kTRUE;; 1894 ; 1895 gSystem->Run();; 1896 fIsRunning = kFALSE;; 1897}; 1898 ; 1899////////////////////////////////////////////////////////////////////////////////; 1900/// Set the command to be executed after the system has been idle for; 1901/// idleTimeInSec seconds. Normally called via TROOT::Idle(...).; 1902 ; 1903void TApplication::SetIdleTimer(UInt_t idleTimeInSec, const char *command); 1904{; 1905 if (fIdleTimer) RemoveIdleTimer();; 1906 fIdleCommand = command;; 1907 fIdleTimer = new TIdleTimer(idleTimeInSec*1000);; 1908 gSystem->AddTimer(fIdleTimer);; 1909}; 1910 ; 1911////////////////////////////////////////////////////////////////////////////////; 1912/// Remove idle timer. Normally called via TROOT::Idle(0).; 1913 ; 1914void TApplication::RemoveIdleTimer(); 1915{; 1916 if (fIdleTimer) {; 1917 // timers are removed from the gSystem timer lis",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:77555,Integrability,protocol,protocol,77555,"///////////////////////////////; 2025/// Static function used to attach to an existing remote application; 2026/// or to start one.; 2027 ; 2028TApplication *TApplication::Open(const char *url,; 2029 Int_t debug, const char *script); 2030{; 2031 TApplication *ap = nullptr;; 2032 TUrl nu(url);; 2033 Int_t nnew = 0;; 2034 ; 2035 // Look among the existing ones; 2036 if (fgApplications) {; 2037 TIter nxa(fgApplications);; 2038 while ((ap = (TApplication *) nxa())) {; 2039 TString apn(ap->ApplicationName());; 2040 if (apn == url) {; 2041 // Found matching application; 2042 return ap;; 2043 } else {; 2044 // Check if same machine and user; 2045 TUrl au(apn);; 2046 if (strlen(au.GetUser()) > 0 && strlen(nu.GetUser()) > 0 &&; 2047 !strcmp(au.GetUser(), nu.GetUser())) {; 2048 if (!strncmp(au.GetHost(), nu.GetHost(), strlen(nu.GetHost()))); 2049 // New session on a known machine; 2050 nnew++;; 2051 }; 2052 }; 2053 }; 2054 } else {; 2055 ::Error(""TApplication::Open"", ""list of applications undefined - protocol error"");; 2056 return ap;; 2057 }; 2058 ; 2059 // If new session on a known machine pass the number as option; 2060 if (nnew > 0) {; 2061 nnew++;; 2062 nu.SetOptions(TString::Format(""%d"", nnew).Data());; 2063 }; 2064 ; 2065 // Instantiate the TApplication object to be run; 2066 TPluginHandler *h = nullptr;; 2067 if ((h = gROOT->GetPluginManager()->FindHandler(""TApplication"",""remote""))) {; 2068 if (h->LoadPlugin() == 0) {; 2069 ap = (TApplication *) h->ExecPlugin(3, nu.GetUrl(), debug, script);; 2070 } else {; 2071 ::Error(""TApplication::Open"", ""failed to load plugin for TApplicationRemote"");; 2072 }; 2073 } else {; 2074 ::Error(""TApplication::Open"", ""failed to find plugin for TApplicationRemote"");; 2075 }; 2076 ; 2077 // Add to the list; 2078 if (ap && !(ap->TestBit(kInvalidObject))) {; 2079 fgApplications->Add(ap);; 2080 gROOT->GetListOfBrowsables()->Add(ap, ap->ApplicationName());; 2081 TIter next(gROOT->GetListOfBrowsers());; 2082 TBrowser *b;; 2083 while ((b = (TBrow",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:86031,Integrability,interface,interfaces,86031,"ress(const char *str)Remove all blanks from the string str.Definition TString.cxx:2572; Stripchar * Strip(const char *str, char c=' ')Strip leading and trailing c (blanks by default) from a string.Definition TString.cxx:2521; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; StrDupchar * StrDup(const char *str)Duplicate the string str.Definition TString.cxx:2557; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TSystem.h; kReadPermission@ kReadPermissionDefinition TSystem.h:45; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTimer.h; TUrl.h; TVirtualMutex.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TVirtualX.h; gVirtualX#define gVirtualXDefinition TVirtualX.h:337; gGXBatchR__EXTERN TVirtualX * gGXBatchDefinition TVirtualX.h:339; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TApplication::ExitOnExceptionEExitOnException ExitOnException(EExitOnException opt=kExit)Set the exit on exception option.Definition TApplication.cxx:614; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::Hel",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:88798,Integrability,depend,dependent,88798,"st char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::InitializeGraphicsvoid InitializeGraphics(Bool_t only_web=kFALSE)Initialize the graphics environment.Definition TApplication.cxx:244; TApplication::Openvirtual void Open()Definition TApplication.h:132; TApplication::LoadGraphicsLibsvirtual void LoadGraphicsLibs()Load shared libs necessary for graphics.Definition TApplication.cxx:1333; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::kDefaultApplication@ kDefaultApplicationDefinition TApplication.h:45; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.Definition TApplication.cxx:1860; TApplication::~TApplicationvirtual ~TApplication()TApplication dtor.Definition TApplication.cxx:210; TApplication::OpenReferenceGuideForvoid OpenReferenceGuideFor(const TString &strippedClass)It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/st...Definition TApplication.cxx:1065; TApplication::HandleExceptionvirtual void HandleException(Int_t sig)Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingExcepti...Definition TApplication.cxx:590; TApplication::MakeBatchvirtual void MakeBatch()Switch to batch mode.Definition TApplication.cxx:1395; TApplication::OpenGitHubIssuevoid OpenGitHubIssue(const TString &type)It opens a GitHub issue in a web browser with prefilled ROOT version.Definition TApplication.cxx:1034; TApplication::fReturnFromRunBool_t fReturnFromRunDefinition TApplication.h:62; TApplication::Initvirtual void Init()Definition TAppli",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:100167,Integrability,message,message,100167," TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPRegexpDefinition TPRegexp.h:36; TPluginHandlerDefinition TPluginManager.h:103; TQObject::Emitvoid",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:100425,Integrability,message,message,100425,"ed objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPRegexpDefinition TPRegexp.h:36; TPluginHandlerDefinition TPluginManager.h:103; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::ShutDownstatic void S",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:100561,Integrability,message,message,100561,"dvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPRegexpDefinition TPRegexp.h:36; TPluginHandlerDefinition TPluginManager.h:103; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:101026,Integrability,message,message,101026,"bject from a list.Definition TObject.cxx:665; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPRegexpDefinition TPRegexp.h:36; TPluginHandlerDefinition TPluginManager.h:103; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3193; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:107909,Integrability,interface,interface,107909,"copy it in gProgName.Definition TSystem.cxx:226; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TUrl::GetUrlconst char * GetUrl(Bool_t withDeflt=kFALSE) constReturn full URL.Definition TUrl.cxx:390; TUrl::GetFileAndOptionsconst char * GetFileAndOptions() constReturn the file and its options (the string specified behind the ?).Definition TUrl.cxx:504; TUrl::GetFileconst char * GetFile() constDefinition TUrl.h:69; TUrl::GetProtocolconst char * GetProtocol() constDefinition TUrl.h:64; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; TClassEdit::GetUnqualifiedNameconst char * GetUnqualifiedName(const char *name)Return the start of the unqualified name include in 'original'.Definition TClassEdit.cxx:942. corebasesrcTApplication.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:924,Modifiability,inherit,inherits,924,". ROOT: core/base/src/TApplication.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TApplication.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/12/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TApplication; 13\ingroup Base; 14 ; 15This class creates the ROOT Application Environment that interfaces; 16to the windowing system eventloop and eventhandlers.; 17This class must be instantiated exactly once in any given; 18application. Normally the specific application class inherits from; 19TApplication (see TRint).; 20*/; 21 ; 22#include ""RConfigure.h""; 23#include ""TApplication.h""; 24#include ""TException.h""; 25#include ""TGuiFactory.h""; 26#include ""TVirtualX.h""; 27#include ""TROOT.h""; 28#include ""TSystem.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TObjArray.h""; 32#include ""TObjString.h""; 33#include ""TTimer.h""; 34#include ""TInterpreter.h""; 35#include ""TStyle.h""; 36#include ""TVirtualPad.h""; 37#include ""TEnv.h""; 38#include ""TColor.h""; 39#include ""TPluginManager.h""; 40#include ""TClassTable.h""; 41#include ""TBrowser.h""; 42#include ""TUrl.h""; 43#include ""TVirtualMutex.h""; 44#include ""TClassEdit.h""; 45#include ""TMethod.h""; 46#include ""TDataMember.h""; 47#include ""TApplicationCommandLineOptionsHelp.h""; 48#include ""TPRegexp.h""; 49#include <cstdlib>; 50#include <iostream>; 51#include <fstream>; 52 ; 53TApplication *gApplication = nullptr;; 54Bool_t TApplication::fgGraphNeeded = kFALSE;; 55Bool_t TApplication::fgGraphInit = kFALSE;; 56TList *TApplication::fgApplications = nullptr; // List of available applications; 57 ; 58////",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:13043,Modifiability,config,config,13043,"/////////////; 327/// Return specified argument.; 328 ; 329char *TApplication::Argv(Int_t index) const; 330{; 331 if (fArgv) {; 332 if (index >= fArgc) {; 333 Error(""Argv"", ""index (%d) >= number of arguments (%d)"", index, fArgc);; 334 return nullptr;; 335 }; 336 return fArgv[index];; 337 }; 338 return nullptr;; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Get and handle command line options. Arguments handled are removed; 343/// from the argument array. See CommandLineOptionsHelp.h for options.; 344 ; 345void TApplication::GetOptions(Int_t *argc, char **argv); 346{; 347 static char null[1] = { """" };; 348 ; 349 fNoLog = kFALSE;; 350 fQuit = kFALSE;; 351 fFiles = nullptr;; 352 ; 353 if (!argc); 354 return;; 355 ; 356 int i, j;; 357 TString pwd;; 358 ; 359 for (i = 1; i < *argc; i++) {; 360 if (!strcmp(argv[i], ""-?"") || !strncmp(argv[i], ""-h"", 2) ||; 361 !strncmp(argv[i], ""--help"", 6)) {; 362 fprintf(stderr, kCommandLineOptionsHelp);; 363 Terminate(0);; 364 } else if (!strncmp(argv[i], ""--version"", 9)) {; 365 fprintf(stderr, ""ROOT Version: %s\n"", gROOT->GetVersion());; 366 fprintf(stderr, ""Built for %s on %s\n"",; 367 gSystem->GetBuildArch(),; 368 gROOT->GetGitDate());; 369 ; 370 fprintf(stderr, ""From %s@%s\n"",; 371 gROOT->GetGitBranch(),; 372 gROOT->GetGitCommit());; 373 ; 374 Terminate(0);; 375 } else if (!strcmp(argv[i], ""-config"")) {; 376 fprintf(stderr, ""ROOT ./configure options:\n%s\n"", gROOT->GetConfigOptions());; 377 Terminate(0);; 378 } else if (!strcmp(argv[i], ""-a"")) {; 379 fprintf(stderr, ""ROOT splash screen is not visible with root.exe, use root instead.\n"");; 380 Terminate(0);; 381 } else if (!strcmp(argv[i], ""-b"")) {; 382 MakeBatch();; 383 argv[i] = null;; 384 } else if (!strcmp(argv[i], ""-n"")) {; 385 fNoLog = kTRUE;; 386 argv[i] = null;; 387 } else if (!strcmp(argv[i], ""-t"")) {; 388 ROOT::EnableImplicitMT();; 389 // EnableImplicitMT() only enables thread safety if IMT was configured;; 390 // enabl",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:13084,Modifiability,config,configure,13084,"tionsHelp.h for options.; 344 ; 345void TApplication::GetOptions(Int_t *argc, char **argv); 346{; 347 static char null[1] = { """" };; 348 ; 349 fNoLog = kFALSE;; 350 fQuit = kFALSE;; 351 fFiles = nullptr;; 352 ; 353 if (!argc); 354 return;; 355 ; 356 int i, j;; 357 TString pwd;; 358 ; 359 for (i = 1; i < *argc; i++) {; 360 if (!strcmp(argv[i], ""-?"") || !strncmp(argv[i], ""-h"", 2) ||; 361 !strncmp(argv[i], ""--help"", 6)) {; 362 fprintf(stderr, kCommandLineOptionsHelp);; 363 Terminate(0);; 364 } else if (!strncmp(argv[i], ""--version"", 9)) {; 365 fprintf(stderr, ""ROOT Version: %s\n"", gROOT->GetVersion());; 366 fprintf(stderr, ""Built for %s on %s\n"",; 367 gSystem->GetBuildArch(),; 368 gROOT->GetGitDate());; 369 ; 370 fprintf(stderr, ""From %s@%s\n"",; 371 gROOT->GetGitBranch(),; 372 gROOT->GetGitCommit());; 373 ; 374 Terminate(0);; 375 } else if (!strcmp(argv[i], ""-config"")) {; 376 fprintf(stderr, ""ROOT ./configure options:\n%s\n"", gROOT->GetConfigOptions());; 377 Terminate(0);; 378 } else if (!strcmp(argv[i], ""-a"")) {; 379 fprintf(stderr, ""ROOT splash screen is not visible with root.exe, use root instead.\n"");; 380 Terminate(0);; 381 } else if (!strcmp(argv[i], ""-b"")) {; 382 MakeBatch();; 383 argv[i] = null;; 384 } else if (!strcmp(argv[i], ""-n"")) {; 385 fNoLog = kTRUE;; 386 argv[i] = null;; 387 } else if (!strcmp(argv[i], ""-t"")) {; 388 ROOT::EnableImplicitMT();; 389 // EnableImplicitMT() only enables thread safety if IMT was configured;; 390 // enable thread safety even with IMT off:; 391 ROOT::EnableThreadSafety();; 392 argv[i] = null;; 393 } else if (!strcmp(argv[i], ""-q"")) {; 394 fQuit = kTRUE;; 395 argv[i] = null;; 396 } else if (!strcmp(argv[i], ""-l"")) {; 397 // used by front-end program to not display splash screen; 398 fNoLogo = kTRUE;; 399 argv[i] = null;; 400 } else if (!strcmp(argv[i], ""-x"")) {; 401 fExitOnException = kExit;; 402 argv[i] = null;; 403 } else if (!strcmp(argv[i], ""-splash"")) {; 404 // used when started by front-end program to signal that; 405 // spl",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:13616,Modifiability,config,configured,13616,"config"")) {; 376 fprintf(stderr, ""ROOT ./configure options:\n%s\n"", gROOT->GetConfigOptions());; 377 Terminate(0);; 378 } else if (!strcmp(argv[i], ""-a"")) {; 379 fprintf(stderr, ""ROOT splash screen is not visible with root.exe, use root instead.\n"");; 380 Terminate(0);; 381 } else if (!strcmp(argv[i], ""-b"")) {; 382 MakeBatch();; 383 argv[i] = null;; 384 } else if (!strcmp(argv[i], ""-n"")) {; 385 fNoLog = kTRUE;; 386 argv[i] = null;; 387 } else if (!strcmp(argv[i], ""-t"")) {; 388 ROOT::EnableImplicitMT();; 389 // EnableImplicitMT() only enables thread safety if IMT was configured;; 390 // enable thread safety even with IMT off:; 391 ROOT::EnableThreadSafety();; 392 argv[i] = null;; 393 } else if (!strcmp(argv[i], ""-q"")) {; 394 fQuit = kTRUE;; 395 argv[i] = null;; 396 } else if (!strcmp(argv[i], ""-l"")) {; 397 // used by front-end program to not display splash screen; 398 fNoLogo = kTRUE;; 399 argv[i] = null;; 400 } else if (!strcmp(argv[i], ""-x"")) {; 401 fExitOnException = kExit;; 402 argv[i] = null;; 403 } else if (!strcmp(argv[i], ""-splash"")) {; 404 // used when started by front-end program to signal that; 405 // splash screen can be popped down (TRint::PrintLogo()); 406 argv[i] = null;; 407 } else if (strncmp(argv[i], ""--web"", 5) == 0) {; 408 // the web mode is requested; 409 const char *opt = argv[i] + 5;; 410 argv[i] = null;; 411 gROOT->SetWebDisplay((*opt == '=') ? opt + 1 : """");; 412 } else if (!strcmp(argv[i], ""-e"")) {; 413 argv[i] = null;; 414 ++i;; 415 ; 416 if ( i < *argc ) {; 417 if (!fFiles) fFiles = new TObjArray;; 418 TObjString *expr = new TObjString(argv[i]);; 419 expr->SetBit(kExpression);; 420 fFiles->Add(expr);; 421 argv[i] = null;; 422 } else {; 423 Warning(""GetOptions"", ""-e must be followed by an expression."");; 424 }; 425 } else if (!strcmp(argv[i], ""--"")) {; 426 TObjString* macro = nullptr;; 427 bool warnShown = false;; 428 ; 429 if (fFiles) {; 430 for (auto f: *fFiles) {; 431 TObjString *file = dynamic_cast<TObjString *>(f);; 432 if (!file) {; 4",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:43135,Modifiability,variab,variables,43135,"if (TClass *clas = TClass::GetClass(strippedClass)) {; 1098 // We check what scope he is searching for (class/namespace/struct).; 1099 // Enumerators will switch between the possible cases.; 1100 EUrl scopeType;; 1101 if (clas->Property() & kIsNamespace) {; 1102 scopeType = kURLforNameSpace;; 1103 } else if (clas->Property() & kIsStruct) {; 1104 scopeType = kURLforStruct;; 1105 } else {; 1106 scopeType = kURLforClass;; 1107 }; 1108 // If the user search directly for a scope we open the URL for him with OpenInBrowser.; 1109 OpenInBrowser(UrlGenerator(strippedClass, scopeType));; 1110 return;; 1111 }; 1112 // Else we subtract the name of the method and remove it from the command.; 1113 TString memberName = TClassEdit::GetUnqualifiedName(strippedClass);; 1114 // Error out if ""strippedClass"" is un-scoped (and it's not a class, see `TClass::GetClass(strippedClass)` above).; 1115 // TODO: Global functions.; 1116 if (strippedClass == memberName) {; 1117 Error(""OpenReferenceGuideFor"", ""Unknown entity \""%s\"" - global variables / functions not supported yet!"",; 1118 strippedClass.Data());; 1119 return;; 1120 }; 1121 // Else we remove the member name to be left with the scope.; 1122 TString scopeName = strippedClass(0, strippedClass.Length() - memberName.Length() - 2);; 1123 // We check if the scope exists in ROOT.; 1124 TClass *cl = TClass::GetClass(scopeName);; 1125 if (!cl) {; 1126 // That's a member of something ROOT doesn't know.; 1127 Warning(""OpenReferenceGuideFor"", ""\""%s\"" does not exist in ROOT!"", scopeName.Data());; 1128 return;; 1129 }; 1130 // We have enumerators for the three available cases - class, namespace and struct.; 1131 EUrl scopeType;; 1132 if (cl->Property() & kIsNamespace) {; 1133 scopeType = kURLforNameSpace;; 1134 } else if (cl->Property() & kIsStruct) {; 1135 scopeType = kURLforStruct;; 1136 } else {; 1137 scopeType = kURLforClass;; 1138 }; 1139 // If the user wants to search for a method, we take its name (memberName) and; 1140 // modify it - we del",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:50902,Modifiability,extend,extended,50902,"t a bug report, feature or improvement suggestion"");; 1258 Printf("" .help Class::Member : open reference guide for that class member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 // the online reference guide, we first check if the command starts correctly.; 1278 if ((!strippedCommand.BeginsWith("".help "")) && (!strippedCommand.BeginsWith("".? ""))) {; 1279 Error(""Help"", ""Unknown command!"");; 1280 return;; 1281 }; 1282 // We remove the command "".help"" or "".?"" from the TString.; 1283 if (strippedCommand.BeginsWith("".? "")) {; 1284 strippedCommand.Remove(0, 3);; 1285 } else {; 1286 strippedCommand.Remove(0, 5);; 1287 }; 1288 // We strip the command line after removing "".help"" or "".?"".; 1289 strippedCommand = strippedCommand.Strip(TString::kBoth);; 1290 ; 1291 if (strippedCommand == ""edit"") {; 1292 Printf(""\n ROOT terminal keyboard shortcuts (GNU-readline style)."");; 1293 #ifdef R__MACOSX; 1294 #define FOOTNOTE "" *""; 1295 Printf(""* Some of these commands might be intercepted by macOS predefined system shortcuts."");; 1296 // https://apple.stackexchange.com/questions/180",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:54894,Modifiability,extend,extended,54894,"36 Printf("" Tab : autocomplete command or print suggestions [Ctrl+I] [Esc,Tab]"");; 1337 Printf("" Enter : execute command [Ctrl+J] [Ctrl+M]"");; 1338 Printf("" Ctrl+L : clear prompt screen"");; 1339 Printf("" Ctrl+D : quit ROOT (if empty line)"");; 1340 Printf("" Ctrl+C : send kSigInt interrupt signal"");; 1341 Printf("" Ctrl+Z : send kSigStop pause job signal"");; 1342 ; 1343 Printf("" Arrow_Down : navigate downwards in command history [Ctrl+N]"");; 1344 Printf("" Arrow_Up : navigate upwards in command history [Ctrl+P]"");; 1345 Printf("" Ctrl+R ; Ctrl+S : search command in your history by typing a string.\n""; 1346 "" Use Backspace if you mistyped (but not arrows).\n""; 1347 "" Press Ctrl+R (Ctrl+S) repeateadly to navigate matches in reverse (forward) order"");; 1348 Printf("" Arrow_Right : after Ctrl+R (Ctrl+S), select current match of the history search\n""; 1349 "" [Ctrl+O] [Enter] [Ctrl+J] [Ctrl+M] [Arrow_Left] [Esc,Esc].\n""; 1350 "" Use Ctrl+F or Ctrl+G to cancel search and revert original line"");; 1351 ; 1352 return;; 1353 }; 1354 // We call the function what handles the extended "".help scopeName"" command.; 1355 OpenReferenceGuideFor(strippedCommand);; 1356 }; 1357}; 1358 ; 1359/// Load shared libs necessary for graphics. These libraries are only; 1360/// loaded when gROOT->IsBatch() is kFALSE.; 1361 ; 1362void TApplication::LoadGraphicsLibs(); 1363{; 1364 if (gROOT->IsBatch()); 1365 return;; 1366 ; 1367 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPad"")); 1368 if (h->LoadPlugin() == -1); 1369 return;; 1370 ; 1371 TString name;; 1372 TString title1 = ""ROOT interface to "";; 1373 TString nativex, title;; 1374 ; 1375#ifdef R__WIN32; 1376 nativex = ""win32gdk"";; 1377 name = ""Win32gdk"";; 1378 title = title1 + ""Win32gdk"";; 1379#elif defined(R__HAS_COCOA); 1380 nativex = ""quartz"";; 1381 name = ""quartz"";; 1382 title = title1 + ""Quartz"";; 1383#else; 1384 nativex = ""x11"";; 1385 name = ""X11"";; 1386 title = title1 + ""X11"";; 1387#endif; 1388 ; 1389 TString guiBackend = gEnv->GetVa",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:57451,Modifiability,variab,variable,57451,"ory == ""native""); 1410 guiFactory = ""root"";; 1411 ; 1412 if (auto h = gROOT->GetPluginManager()->FindHandler(""TGuiFactory"", guiFactory)) {; 1413 if (h->LoadPlugin() == -1) {; 1414 gROOT->SetBatch(kTRUE);; 1415 return;; 1416 }; 1417 gGuiFactory = (TGuiFactory *) h->ExecPlugin(0);; 1418 }; 1419}; 1420 ; 1421////////////////////////////////////////////////////////////////////////////////; 1422/// Switch to batch mode.; 1423 ; 1424void TApplication::MakeBatch(); 1425{; 1426 gROOT->SetBatch();; 1427 if (gGuiFactory != gBatchGuiFactory) delete gGuiFactory;; 1428 gGuiFactory = gBatchGuiFactory;; 1429#ifndef R__WIN32; 1430 if (gVirtualX != gGXBatch) delete gVirtualX;; 1431#endif; 1432 gVirtualX = gGXBatch;; 1433}; 1434 ; 1435////////////////////////////////////////////////////////////////////////////////; 1436/// Parse the content of a line starting with "".R"" (already stripped-off); 1437/// The format is; 1438/// ~~~ {.cpp}; 1439/// [user@]host[:dir] [-l user] [-d dbg] [script]; 1440/// ~~~; 1441/// The variable 'dir' is the remote directory to be used as working dir.; 1442/// The username can be specified in two ways, ""-l"" having the priority; 1443/// (as in ssh).; 1444/// A 'dbg' value > 0 gives increasing verbosity.; 1445/// The last argument 'script' allows to specify an alternative script to; 1446/// be executed remotely to startup the session.; 1447 ; 1448Int_t TApplication::ParseRemoteLine(const char *ln,; 1449 TString &hostdir, TString &user,; 1450 Int_t &dbg, TString &script); 1451{; 1452 if (!ln || strlen(ln) <= 0); 1453 return 0;; 1454 ; 1455 Int_t rc = 0;; 1456 Bool_t isHostDir = kTRUE;; 1457 Bool_t isScript = kFALSE;; 1458 Bool_t isUser = kFALSE;; 1459 Bool_t isDbg = kFALSE;; 1460 ; 1461 TString line(ln);; 1462 TString tkn;; 1463 Int_t from = 0;; 1464 while (line.Tokenize(tkn, from, "" "")) {; 1465 if (tkn == ""-l"") {; 1466 // Next is a user name; 1467 isUser = kTRUE;; 1468 } else if (tkn == ""-d"") {; 1469 isDbg = kTRUE;; 1470 } else if (tkn == ""-close"") {; 1471 rc ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:59434,Modifiability,variab,variable,59434,"n == ""-close"") {; 1471 rc = 1;; 1472 } else if (tkn.BeginsWith(""-"")) {; 1473 ::Warning(""TApplication::ParseRemoteLine"",""unknown option: %s"", tkn.Data());; 1474 } else {; 1475 if (isUser) {; 1476 user = tkn;; 1477 isUser = kFALSE;; 1478 } else if (isDbg) {; 1479 dbg = tkn.Atoi();; 1480 isDbg = kFALSE;; 1481 } else if (isHostDir) {; 1482 hostdir = tkn;; 1483 hostdir.ReplaceAll("":"",""/"");; 1484 isHostDir = kFALSE;; 1485 isScript = kTRUE;; 1486 } else if (isScript) {; 1487 // Add everything left; 1488 script = tkn;; 1489 script.Insert(0, ""\"""");; 1490 script += ""\"""";; 1491 // isScript = kFALSE; // [clang-tidy] never read; 1492 break;; 1493 }; 1494 }; 1495 }; 1496 ; 1497 // Done; 1498 return rc;; 1499}; 1500 ; 1501////////////////////////////////////////////////////////////////////////////////; 1502/// Process the content of a line starting with "".R"" (already stripped-off); 1503/// The format is; 1504/// ~~~ {.cpp}; 1505/// [user@]host[:dir] [-l user] [-d dbg] [script] | [host] -close; 1506/// ~~~; 1507/// The variable 'dir' is the remote directory to be used as working dir.; 1508/// The username can be specified in two ways, ""-l"" having the priority; 1509/// (as in ssh).; 1510/// A 'dbg' value > 0 gives increasing verbosity.; 1511/// The last argument 'script' allows to specify an alternative script to; 1512/// be executed remotely to startup the session.; 1513 ; 1514Longptr_t TApplication::ProcessRemote(const char *line, Int_t *); 1515{; 1516 if (!line) return 0;; 1517 ; 1518 if (!strncmp(line, ""-?"", 2) || !strncmp(line, ""-h"", 2) ||; 1519 !strncmp(line, ""--help"", 6)) {; 1520 Info(""ProcessRemote"", ""remote session help:"");; 1521 Printf("".R [user@]host[:dir] [-l user] [-d dbg] [[<]script] | [host] -close"");; 1522 Printf(""Create a ROOT session on the specified remote host."");; 1523 Printf(""The variable \""dir\"" is the remote directory to be used as working dir."");; 1524 Printf(""The username can be specified in two ways, \""-l\"" having the priority"");; 1525 Printf(""(as in ssh). ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:60231,Modifiability,variab,variable,60231,"tarting with "".R"" (already stripped-off); 1503/// The format is; 1504/// ~~~ {.cpp}; 1505/// [user@]host[:dir] [-l user] [-d dbg] [script] | [host] -close; 1506/// ~~~; 1507/// The variable 'dir' is the remote directory to be used as working dir.; 1508/// The username can be specified in two ways, ""-l"" having the priority; 1509/// (as in ssh).; 1510/// A 'dbg' value > 0 gives increasing verbosity.; 1511/// The last argument 'script' allows to specify an alternative script to; 1512/// be executed remotely to startup the session.; 1513 ; 1514Longptr_t TApplication::ProcessRemote(const char *line, Int_t *); 1515{; 1516 if (!line) return 0;; 1517 ; 1518 if (!strncmp(line, ""-?"", 2) || !strncmp(line, ""-h"", 2) ||; 1519 !strncmp(line, ""--help"", 6)) {; 1520 Info(""ProcessRemote"", ""remote session help:"");; 1521 Printf("".R [user@]host[:dir] [-l user] [-d dbg] [[<]script] | [host] -close"");; 1522 Printf(""Create a ROOT session on the specified remote host."");; 1523 Printf(""The variable \""dir\"" is the remote directory to be used as working dir."");; 1524 Printf(""The username can be specified in two ways, \""-l\"" having the priority"");; 1525 Printf(""(as in ssh). A \""dbg\"" value > 0 gives increasing verbosity."");; 1526 Printf(""The last argument \""script\"" allows to specify an alternative script to"");; 1527 Printf(""be executed remotely to startup the session, \""roots\"" being"");; 1528 Printf(""the default. If the script is preceded by a \""<\"" the script will be"");; 1529 Printf(""sourced, after which \""roots\"" is executed. The sourced script can be "");; 1530 Printf(""used to change the PATH and other variables, allowing an alternative"");; 1531 Printf(""\""roots\"" script to be found."");; 1532 Printf(""To close down a session do \"".R host -close\""."");; 1533 Printf(""To switch between sessions do \"".R host\"", to switch to the local"");; 1534 Printf(""session do \"".R\""."");; 1535 Printf(""To list all open sessions do \""gApplication->GetApplications()->Print()\""."");; 1536 return 0;; 1537 }; 1538 ; 1539 T",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:60856,Modifiability,variab,variables,60856,"t_t *); 1515{; 1516 if (!line) return 0;; 1517 ; 1518 if (!strncmp(line, ""-?"", 2) || !strncmp(line, ""-h"", 2) ||; 1519 !strncmp(line, ""--help"", 6)) {; 1520 Info(""ProcessRemote"", ""remote session help:"");; 1521 Printf("".R [user@]host[:dir] [-l user] [-d dbg] [[<]script] | [host] -close"");; 1522 Printf(""Create a ROOT session on the specified remote host."");; 1523 Printf(""The variable \""dir\"" is the remote directory to be used as working dir."");; 1524 Printf(""The username can be specified in two ways, \""-l\"" having the priority"");; 1525 Printf(""(as in ssh). A \""dbg\"" value > 0 gives increasing verbosity."");; 1526 Printf(""The last argument \""script\"" allows to specify an alternative script to"");; 1527 Printf(""be executed remotely to startup the session, \""roots\"" being"");; 1528 Printf(""the default. If the script is preceded by a \""<\"" the script will be"");; 1529 Printf(""sourced, after which \""roots\"" is executed. The sourced script can be "");; 1530 Printf(""used to change the PATH and other variables, allowing an alternative"");; 1531 Printf(""\""roots\"" script to be found."");; 1532 Printf(""To close down a session do \"".R host -close\""."");; 1533 Printf(""To switch between sessions do \"".R host\"", to switch to the local"");; 1534 Printf(""session do \"".R\""."");; 1535 Printf(""To list all open sessions do \""gApplication->GetApplications()->Print()\""."");; 1536 return 0;; 1537 }; 1538 ; 1539 TString hostdir, user, script;; 1540 Int_t dbg = 0;; 1541 Int_t rc = ParseRemoteLine(line, hostdir, user, dbg, script);; 1542 if (hostdir.Length() <= 0) {; 1543 // Close the remote application if required; 1544 if (rc == 1) {; 1545 TApplication::Close(fAppRemote);; 1546 delete fAppRemote;; 1547 }; 1548 // Return to local run; 1549 fAppRemote = nullptr;; 1550 // Done; 1551 return 1;; 1552 } else if (rc == 1) {; 1553 // close an existing remote application; 1554 TApplication *ap = TApplication::Open(hostdir, 0, nullptr);; 1555 if (ap) {; 1556 TApplication::Close(ap);; 1557 delete ap;; 1558 }; 1559 }",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:78130,Modifiability,plugin,plugin,78130,,MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:78238,Modifiability,plugin,plugin,78238,,MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:104914,Modifiability,variab,variable,104914,"tion TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TStyle::SetScreenFactorvoid SetScreenFactor(Float_t factor=1)Definition TStyle.h:317; TSystem::NotifyApplicationCreatedvirtual void NotifyApplicationCreated()Hook to tell TSystem that the TApplication object has been created.Definition TSystem.cxx:311; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Runvirtual void Run()System event loop.Definition TSystem.cxx:343; TSystem::ExitLoopvirtual",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:8661,Performance,load,loaded,8661,"ing closed after the; 220 // end of 'main' (or more exactly before the library start being; 221 // unloaded).; 222 if (fgApplications == nullptr || fgApplications->FirstLink() == nullptr ) {; 223 TROOT::ShutDown();; 224 }; 225 ; 226 // Now that all the canvases and files have been closed we can; 227 // delete the implementation.; 228 SafeDelete(fAppImp);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Static method. This method should be called from static library; 233/// initializers if the library needs the low level graphics system.; 234 ; 235void TApplication::NeedGraphicsLibs(); 236{; 237 fgGraphNeeded = kTRUE;; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Initialize the graphics environment.; 242/// If @param only_web is specified, only web-related part of graphics is loaded; 243 ; 244void TApplication::InitializeGraphics(Bool_t only_web); 245{; 246 if (fgGraphInit || !fgGraphNeeded); 247 return;; 248 ; 249 if (!only_web) {; 250 // Load the graphics related libraries; 251 LoadGraphicsLibs();; 252 ; 253 // Try to load TrueType font renderer. Only try to load if not in batch; 254 // mode and Root.UseTTFonts is true and Root.TTFontPath exists. Abort silently; 255 // if libttf or libGX11TTF are not found in $ROOTSYS/lib or $ROOTSYS/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initi",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:8910,Performance,load,load,8910,"ing closed after the; 220 // end of 'main' (or more exactly before the library start being; 221 // unloaded).; 222 if (fgApplications == nullptr || fgApplications->FirstLink() == nullptr ) {; 223 TROOT::ShutDown();; 224 }; 225 ; 226 // Now that all the canvases and files have been closed we can; 227 // delete the implementation.; 228 SafeDelete(fAppImp);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Static method. This method should be called from static library; 233/// initializers if the library needs the low level graphics system.; 234 ; 235void TApplication::NeedGraphicsLibs(); 236{; 237 fgGraphNeeded = kTRUE;; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Initialize the graphics environment.; 242/// If @param only_web is specified, only web-related part of graphics is loaded; 243 ; 244void TApplication::InitializeGraphics(Bool_t only_web); 245{; 246 if (fgGraphInit || !fgGraphNeeded); 247 return;; 248 ; 249 if (!only_web) {; 250 // Load the graphics related libraries; 251 LoadGraphicsLibs();; 252 ; 253 // Try to load TrueType font renderer. Only try to load if not in batch; 254 // mode and Root.UseTTFonts is true and Root.TTFontPath exists. Abort silently; 255 // if libttf or libGX11TTF are not found in $ROOTSYS/lib or $ROOTSYS/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initi",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:8951,Performance,load,load,8951,"tDown();; 224 }; 225 ; 226 // Now that all the canvases and files have been closed we can; 227 // delete the implementation.; 228 SafeDelete(fAppImp);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Static method. This method should be called from static library; 233/// initializers if the library needs the low level graphics system.; 234 ; 235void TApplication::NeedGraphicsLibs(); 236{; 237 fgGraphNeeded = kTRUE;; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Initialize the graphics environment.; 242/// If @param only_web is specified, only web-related part of graphics is loaded; 243 ; 244void TApplication::InitializeGraphics(Bool_t only_web); 245{; 246 if (fgGraphInit || !fgGraphNeeded); 247 return;; 248 ; 249 if (!only_web) {; 250 // Load the graphics related libraries; 251 LoadGraphicsLibs();; 252 ; 253 // Try to load TrueType font renderer. Only try to load if not in batch; 254 // mode and Root.UseTTFonts is true and Root.TTFontPath exists. Abort silently; 255 // if libttf or libGX11TTF are not found in $ROOTSYS/lib or $ROOTSYS/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initialize TGX11TTF by hand; 269 // (normally this is done by the static library initializer); 270 ProcessLine(""TGX11TTF::Activate();"");; 271 } else {; 272 TPluginHandler *h;; 273 if ((h = gROOT->GetPluginManage",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:21373,Performance,load,loads,21373,"leException(Int_t sig); 591{; 592 if (TROOT::Initialized()) {; 593 if (gException) {; 594 gInterpreter->RewindDictionary();; 595 gInterpreter->ClearFileBusy();; 596 }; 597 if (fExitOnException == kExit); 598 gSystem->Exit(128 + sig);; 599 else if (fExitOnException == kAbort); 600 gSystem->Abort();; 601 else; 602 Throw(sig);; 603 }; 604 gSystem->Exit(128 + sig);; 605}; 606 ; 607////////////////////////////////////////////////////////////////////////////////; 608/// Set the exit on exception option. Setting this option determines what; 609/// happens in HandleException() in case an exception (kSigBus,; 610/// kSigSegmentationViolation, kSigIllegalInstruction or kSigFloatingException); 611/// is trapped. Choices are: kDontExit (default), kExit or kAbort.; 612/// Returns the previous value.; 613 ; 614TApplication::EExitOnException TApplication::ExitOnException(TApplication::EExitOnException opt); 615{; 616 EExitOnException old = fExitOnException;; 617 fExitOnException = opt;; 618 return old;; 619}; 620 ; 621/////////////////////////////////////////////////////////////////////////////////; 622/// The function generates and executes a command that loads the Doxygen URL in; 623/// a browser. It works for Mac, Windows and Linux. In the case of Linux, the; 624/// function also checks if the DISPLAY is set. If it isn't, a warning message; 625/// and the URL will be displayed on the terminal.; 626///; 627/// \param[in] url web page to be displayed in a browser; 628 ; 629void TApplication::OpenInBrowser(const TString &url); 630{; 631 // We check what operating system the user has.; 632#ifdef R__MACOSX; 633 // Command for opening a browser on Mac.; 634 TString cMac(""open "");; 635 // We generate the full command and execute it.; 636 cMac.Append(url);; 637 gSystem->Exec(cMac);; 638#elif defined(R__WIN32); 639 // Command for opening a browser on Windows.; 640 TString cWindows(""start \""\"" "");; 641 cWindows.Append(url);; 642 gSystem->Exec(cWindows);; 643#else; 644 // Command for open",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:49225,Performance,load,load,49225,"28 OpenGitHubIssue(strippedCommand);; 1229}; 1230 ; 1231////////////////////////////////////////////////////////////////////////////////; 1232/// The function lists useful commands ("".help"") or opens the online reference; 1233/// guide, generated with Doxygen ("".help scope"" or "".help scope::member"").; 1234/// \note You can use "".?"" as the short version of "".help""; 1235/// \param[in] line command from the command line; 1236 ; 1237void TApplication::Help(const char *line); 1238{; 1239 // We first check if the user wants to print the help on the interpreter.; 1240 TString strippedCommand = TString(line).Strip(TString::kBoth);; 1241 // If the user chooses "".help"" or "".?"".; 1242 if ((strippedCommand == "".help"") || (strippedCommand == "".?"")) {; 1243 gInterpreter->ProcessLine(line);; 1244 Printf(""\n ROOT special commands."");; 1245 Printf("" =============================================================================="");; 1246 Printf("" .L <filename>[flags]: load the given file with optional flags like\n""; 1247 "" + to compile or ++ to force recompile.\n""; 1248 "" Type .? TSystem::CompileMacro for a list of all flags.\n""; 1249 "" <filename> can also be a shared library; skip flags."");; 1250 Printf("" .(x|X) <filename>[flags](args) :\n""; 1251 "" same as .L <filename>[flags] and runs then a function\n""; 1252 "" with signature: ret_type filename(args)."");; 1253 Printf("" .credits : show credits"");; 1254 Printf("" .demo : launch GUI demo"");; 1255 Printf("" .forum bug : ask for help with a bug or crash at the ROOT forum."");; 1256 Printf("" .gh [bug|feature|improvement]\n""; 1257 "" : submit a bug report, feature or improvement suggestion"");; 1258 Printf("" .help Class::Member : open reference guide for that class member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"")",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:50184,Performance,load,loaded,50184," Printf("" .L <filename>[flags]: load the given file with optional flags like\n""; 1247 "" + to compile or ++ to force recompile.\n""; 1248 "" Type .? TSystem::CompileMacro for a list of all flags.\n""; 1249 "" <filename> can also be a shared library; skip flags."");; 1250 Printf("" .(x|X) <filename>[flags](args) :\n""; 1251 "" same as .L <filename>[flags] and runs then a function\n""; 1252 "" with signature: ret_type filename(args)."");; 1253 Printf("" .credits : show credits"");; 1254 Printf("" .demo : launch GUI demo"");; 1255 Printf("" .forum bug : ask for help with a bug or crash at the ROOT forum."");; 1256 Printf("" .gh [bug|feature|improvement]\n""; 1257 "" : submit a bug report, feature or improvement suggestion"");; 1258 Printf("" .help Class::Member : open reference guide for that class member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 // the online reference guide, we first check if the command starts correctly.; 1278 if ((!strippedCommand.BeginsWith("".help "")) && (!strippedCommand.BeginsWith("".? ""))) {; 1279 Error(""Help"", ""Unknown command!"");; 1280 return;; 1281 }; 1282 ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:55082,Performance,load,loaded,55082,"C : send kSigInt interrupt signal"");; 1341 Printf("" Ctrl+Z : send kSigStop pause job signal"");; 1342 ; 1343 Printf("" Arrow_Down : navigate downwards in command history [Ctrl+N]"");; 1344 Printf("" Arrow_Up : navigate upwards in command history [Ctrl+P]"");; 1345 Printf("" Ctrl+R ; Ctrl+S : search command in your history by typing a string.\n""; 1346 "" Use Backspace if you mistyped (but not arrows).\n""; 1347 "" Press Ctrl+R (Ctrl+S) repeateadly to navigate matches in reverse (forward) order"");; 1348 Printf("" Arrow_Right : after Ctrl+R (Ctrl+S), select current match of the history search\n""; 1349 "" [Ctrl+O] [Enter] [Ctrl+J] [Ctrl+M] [Arrow_Left] [Esc,Esc].\n""; 1350 "" Use Ctrl+F or Ctrl+G to cancel search and revert original line"");; 1351 ; 1352 return;; 1353 }; 1354 // We call the function what handles the extended "".help scopeName"" command.; 1355 OpenReferenceGuideFor(strippedCommand);; 1356 }; 1357}; 1358 ; 1359/// Load shared libs necessary for graphics. These libraries are only; 1360/// loaded when gROOT->IsBatch() is kFALSE.; 1361 ; 1362void TApplication::LoadGraphicsLibs(); 1363{; 1364 if (gROOT->IsBatch()); 1365 return;; 1366 ; 1367 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPad"")); 1368 if (h->LoadPlugin() == -1); 1369 return;; 1370 ; 1371 TString name;; 1372 TString title1 = ""ROOT interface to "";; 1373 TString nativex, title;; 1374 ; 1375#ifdef R__WIN32; 1376 nativex = ""win32gdk"";; 1377 name = ""Win32gdk"";; 1378 title = title1 + ""Win32gdk"";; 1379#elif defined(R__HAS_COCOA); 1380 nativex = ""quartz"";; 1381 name = ""quartz"";; 1382 title = title1 + ""Quartz"";; 1383#else; 1384 nativex = ""x11"";; 1385 name = ""X11"";; 1386 title = title1 + ""X11"";; 1387#endif; 1388 ; 1389 TString guiBackend = gEnv->GetValue(""Gui.Backend"", ""native"");; 1390 guiBackend.ToLower();; 1391 if (guiBackend == ""native"") {; 1392 guiBackend = nativex;; 1393 } else {; 1394 name = guiBackend;; 1395 title = title1 + guiBackend;; 1396 }; 1397 ; 1398 if (auto h = gROOT->GetPluginManager()->Fin",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:67458,Performance,load,loaded,67458,"->ProcessLine(tempbuf.Data(), (TInterpreter::EErrorCode *)err);; 1710 }; 1711 ; 1712 InitializeGraphics(gROOT->IsWebDisplay());; 1713 ; 1714 return retval;; 1715 }; 1716 ; 1717 if (!strncmp(line, "".X"", 2) || !strncmp(line, "".x"", 2)) {; 1718 return ProcessFile(line+3, err, line[2] == 'k');; 1719 }; 1720 ; 1721 if (!strcmp(line, "".reset"")) {; 1722 // Do nothing, .reset disabled in Cling because too many side effects; 1723 Printf(""*** .reset not allowed, please use gROOT->Reset() ***"");; 1724 return 0;; 1725 ; 1726#if 0; 1727 // delete the ROOT dictionary since CINT will destroy all objects; 1728 // referenced by the dictionary classes (TClass et. al.); 1729 gROOT->GetListOfClasses()->Delete();; 1730 // fall through; 1731#endif; 1732 }; 1733 ; 1734 if (!strcmp(line, "".libraries"")) {; 1735 // List the loaded libraries; 1736 gSystem->ListLibraries();; 1737 return 0;; 1738 }; 1739 ; 1740 if (sync); 1741 return gInterpreter->ProcessLineSynch(line, (TInterpreter::EErrorCode*)err);; 1742 else; 1743 return gInterpreter->ProcessLine(line, (TInterpreter::EErrorCode*)err);; 1744}; 1745 ; 1746////////////////////////////////////////////////////////////////////////////////; 1747/// Process a file containing a C++ macro.; 1748 ; 1749Longptr_t TApplication::ProcessFile(const char *file, Int_t *error, Bool_t keep); 1750{; 1751 return ExecuteFile(file, error, keep);; 1752}; 1753 ; 1754////////////////////////////////////////////////////////////////////////////////; 1755/// Execute a file containing a C++ macro (static method). Can be used; 1756/// while TApplication is not yet created.; 1757 ; 1758Longptr_t TApplication::ExecuteFile(const char *file, Int_t *error, Bool_t keep); 1759{; 1760 static const Int_t kBufSize = 1024;; 1761 ; 1762 if (!file || !*file) return 0;; 1763 ; 1764 TString aclicMode;; 1765 TString arguments;; 1766 TString io;; 1767 TString fname = gSystem->SplitAclicMode(file, aclicMode, arguments, io);; 1768 ; 1769 char *exnam = gSystem->Which(TROOT::GetMacroPath(), f",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:78125,Performance,load,load,78125,,MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:90365,Performance,load,loads,90365,"igIllegalInstruction and kSigFloatingExcepti...Definition TApplication.cxx:590; TApplication::MakeBatchvirtual void MakeBatch()Switch to batch mode.Definition TApplication.cxx:1395; TApplication::OpenGitHubIssuevoid OpenGitHubIssue(const TString &type)It opens a GitHub issue in a web browser with prefilled ROOT version.Definition TApplication.cxx:1034; TApplication::fReturnFromRunBool_t fReturnFromRunDefinition TApplication.h:62; TApplication::Initvirtual void Init()Definition TApplication.h:117; TApplication::fIdleCommandTString fIdleCommandDefinition TApplication.h:68; TApplication::Argvchar ** Argv() constDefinition TApplication.h:141; TApplication::fgGraphNeededstatic Bool_t fgGraphNeededDefinition TApplication.h:73; TApplication::Terminatevirtual void Terminate(Int_t status=0)Terminate the application by call TSystem::Exit() unless application has been told to return from Run...Definition TApplication.cxx:1927; TApplication::OpenInBrowservoid OpenInBrowser(const TString &url)The function generates and executes a command that loads the Doxygen URL in a browser.Definition TApplication.cxx:629; TApplication::ApplicationNamevirtual const char * ApplicationName() constDefinition TApplication.h:128; TApplication::Forumvirtual void Forum(const char *line)The function ("".forum <type>"") submits a new post on the ROOT forum via web browser.Definition TApplication.cxx:1165; TApplication::SetReturnFromRunvoid SetReturnFromRun(Bool_t ret)Definition TApplication.h:154; TApplication::fQuitBool_t fQuitDefinition TApplication.h:65; TApplication::TabCompletionHookvirtual Int_t TabCompletionHook(char *buf, int *pLoc, std::ostream &out)What to do when tab is pressed.Definition TApplication.cxx:1917; TApplication::fExitOnExceptionEExitOnException fExitOnExceptionDefinition TApplication.h:71; TApplication::fFilesTObjArray * fFilesDefinition TApplication.h:66; TApplication::GetIdleCommandconst char * GetIdleCommand() constDefinition TApplication.h:123; TApplication::TApplicationTAppli",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:95317,Performance,load,load,95317,"lptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove obj from browser.Definition TBrowser.cxx:408; TBrowser::Addvoid Add(TObject *obj, const char *name=nullptr, Int_t check=-1)Add object with name to browser.Definition TBrowser.cxx:303; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3929; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3753; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4451; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TColor::InitializeColorsstatic void InitializeColors()Initialize colors used by the TCanvas based graphics (via TColor objects).Definition TColor.cxx:1167; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.De",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:95485,Performance,load,load,95485,"ppRemoteDefinition TApplication.h:80; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove obj from browser.Definition TBrowser.cxx:408; TBrowser::Addvoid Add(TObject *obj, const char *name=nullptr, Int_t check=-1)Add object with name to browser.Definition TBrowser.cxx:303; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3929; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3753; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4451; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TColor::InitializeColorsstatic void InitializeColors()Initialize colors used by the TCanvas based graphics (via TColor objects).Definition TColor.cxx:1167; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDataMember::GetTrueTypeNameconst char * GetTrueTypeName() constGet the desugared type name of this data member, including const and volati",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:95941,Performance,load,load,95941,"ictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3929; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3753; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4451; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TColor::InitializeColorsstatic void InitializeColors()Initialize colors used by the TCanvas based graphics (via TColor objects).Definition TColor.cxx:1167; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDataMember::GetTrueTypeNameconst char * GetTrueTypeName() constGet the desugared type name of this data member, including const and volatile qualifiers.Definition TDataMember.cxx:435; TDataMember::IsEnumBool_t IsEnum() constReturn true if data member is an enum.Definition TDataMember.cxx:533; TDataMember::GetFullTypeNameconst char * GetFullTypeName() constGet the concrete type name of this data member, including const and volatile qualifiers.Definition TDataMember.cxx:423; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:105325,Performance,load,loaded,105325,"ition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TStyle::SetScreenFactorvoid SetScreenFactor(Float_t factor=1)Definition TStyle.h:317; TSystem::NotifyApplicationCreatedvirtual void NotifyApplicationCreated()Hook to tell TSystem that the TApplication object has been created.Definition TSystem.cxx:311; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Runvirtual void Run()System event loop.Definition TSystem.cxx:343; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:108264,Performance,multi-thread,multi-threading,108264,"copy it in gProgName.Definition TSystem.cxx:226; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TUrl::GetUrlconst char * GetUrl(Bool_t withDeflt=kFALSE) constReturn full URL.Definition TUrl.cxx:390; TUrl::GetFileAndOptionsconst char * GetFileAndOptions() constReturn the file and its options (the string specified behind the ?).Definition TUrl.cxx:504; TUrl::GetFileconst char * GetFile() constDefinition TUrl.h:69; TUrl::GetProtocolconst char * GetProtocol() constDefinition TUrl.h:64; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; TClassEdit::GetUnqualifiedNameconst char * GetUnqualifiedName(const char *name)Return the start of the unqualified name include in 'original'.Definition TClassEdit.cxx:942. corebasesrcTApplication.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:108439,Performance,multi-thread,multi-threading,108439,"copy it in gProgName.Definition TSystem.cxx:226; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TUrl::GetUrlconst char * GetUrl(Bool_t withDeflt=kFALSE) constReturn full URL.Definition TUrl.cxx:390; TUrl::GetFileAndOptionsconst char * GetFileAndOptions() constReturn the file and its options (the string specified behind the ?).Definition TUrl.cxx:504; TUrl::GetFileconst char * GetFile() constDefinition TUrl.h:69; TUrl::GetProtocolconst char * GetProtocol() constDefinition TUrl.h:64; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; TClassEdit::GetUnqualifiedNameconst char * GetUnqualifiedName(const char *name)Return the start of the unqualified name include in 'original'.Definition TClassEdit.cxx:942. corebasesrcTApplication.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:7729,Safety,risk,risk,7729,"Application has been created; 183 gSystem->NotifyApplicationCreated();; 184 ; 185 fAppImp = gGuiFactory->CreateApplicationImp(appClassName, argc, argv);; 186 ResetBit(kProcessRemotely);; 187 ; 188 // Initialize the graphics environment; 189 if (gClassTable->GetDict(""TPad"")) {; 190 fgGraphNeeded = kTRUE;; 191 InitializeGraphics(gROOT->IsWebDisplay());; 192 }; 193 ; 194 // Save current interpreter context; 195 gInterpreter->SaveContext();; 196 gInterpreter->SaveGlobalsContext();; 197 ; 198 // to allow user to interact with TCanvas's under WIN32; 199 gROOT->SetLineHasBeenProcessed();; 200 ; 201 //Needs to be done last; 202 gApplication = this;; 203 gROOT->SetApplication(this);; 204 ; 205}; 206 ; 207////////////////////////////////////////////////////////////////////////////////; 208/// TApplication dtor.; 209 ; 210TApplication::~TApplication(); 211{; 212 for (int i = 0; i < fArgc; i++); 213 if (fArgv[i]) delete [] fArgv[i];; 214 delete [] fArgv;; 215 ; 216 if (fgApplications); 217 fgApplications->Remove(this);; 218 ; 219 // Reduce the risk of the files or sockets being closed after the; 220 // end of 'main' (or more exactly before the library start being; 221 // unloaded).; 222 if (fgApplications == nullptr || fgApplications->FirstLink() == nullptr ) {; 223 TROOT::ShutDown();; 224 }; 225 ; 226 // Now that all the canvases and files have been closed we can; 227 // delete the implementation.; 228 SafeDelete(fAppImp);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Static method. This method should be called from static library; 233/// initializers if the library needs the low level graphics system.; 234 ; 235void TApplication::NeedGraphicsLibs(); 236{; 237 fgGraphNeeded = kTRUE;; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Initialize the graphics environment.; 242/// If @param only_web is specified, only web-related part of graphics is loaded; 243 ; 244voi",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:13598,Safety,safe,safety,13598,"config"")) {; 376 fprintf(stderr, ""ROOT ./configure options:\n%s\n"", gROOT->GetConfigOptions());; 377 Terminate(0);; 378 } else if (!strcmp(argv[i], ""-a"")) {; 379 fprintf(stderr, ""ROOT splash screen is not visible with root.exe, use root instead.\n"");; 380 Terminate(0);; 381 } else if (!strcmp(argv[i], ""-b"")) {; 382 MakeBatch();; 383 argv[i] = null;; 384 } else if (!strcmp(argv[i], ""-n"")) {; 385 fNoLog = kTRUE;; 386 argv[i] = null;; 387 } else if (!strcmp(argv[i], ""-t"")) {; 388 ROOT::EnableImplicitMT();; 389 // EnableImplicitMT() only enables thread safety if IMT was configured;; 390 // enable thread safety even with IMT off:; 391 ROOT::EnableThreadSafety();; 392 argv[i] = null;; 393 } else if (!strcmp(argv[i], ""-q"")) {; 394 fQuit = kTRUE;; 395 argv[i] = null;; 396 } else if (!strcmp(argv[i], ""-l"")) {; 397 // used by front-end program to not display splash screen; 398 fNoLogo = kTRUE;; 399 argv[i] = null;; 400 } else if (!strcmp(argv[i], ""-x"")) {; 401 fExitOnException = kExit;; 402 argv[i] = null;; 403 } else if (!strcmp(argv[i], ""-splash"")) {; 404 // used when started by front-end program to signal that; 405 // splash screen can be popped down (TRint::PrintLogo()); 406 argv[i] = null;; 407 } else if (strncmp(argv[i], ""--web"", 5) == 0) {; 408 // the web mode is requested; 409 const char *opt = argv[i] + 5;; 410 argv[i] = null;; 411 gROOT->SetWebDisplay((*opt == '=') ? opt + 1 : """");; 412 } else if (!strcmp(argv[i], ""-e"")) {; 413 argv[i] = null;; 414 ++i;; 415 ; 416 if ( i < *argc ) {; 417 if (!fFiles) fFiles = new TObjArray;; 418 TObjString *expr = new TObjString(argv[i]);; 419 expr->SetBit(kExpression);; 420 fFiles->Add(expr);; 421 argv[i] = null;; 422 } else {; 423 Warning(""GetOptions"", ""-e must be followed by an expression."");; 424 }; 425 } else if (!strcmp(argv[i], ""--"")) {; 426 TObjString* macro = nullptr;; 427 bool warnShown = false;; 428 ; 429 if (fFiles) {; 430 for (auto f: *fFiles) {; 431 TObjString *file = dynamic_cast<TObjString *>(f);; 432 if (!file) {; 4",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:13650,Safety,safe,safety,13650,"config"")) {; 376 fprintf(stderr, ""ROOT ./configure options:\n%s\n"", gROOT->GetConfigOptions());; 377 Terminate(0);; 378 } else if (!strcmp(argv[i], ""-a"")) {; 379 fprintf(stderr, ""ROOT splash screen is not visible with root.exe, use root instead.\n"");; 380 Terminate(0);; 381 } else if (!strcmp(argv[i], ""-b"")) {; 382 MakeBatch();; 383 argv[i] = null;; 384 } else if (!strcmp(argv[i], ""-n"")) {; 385 fNoLog = kTRUE;; 386 argv[i] = null;; 387 } else if (!strcmp(argv[i], ""-t"")) {; 388 ROOT::EnableImplicitMT();; 389 // EnableImplicitMT() only enables thread safety if IMT was configured;; 390 // enable thread safety even with IMT off:; 391 ROOT::EnableThreadSafety();; 392 argv[i] = null;; 393 } else if (!strcmp(argv[i], ""-q"")) {; 394 fQuit = kTRUE;; 395 argv[i] = null;; 396 } else if (!strcmp(argv[i], ""-l"")) {; 397 // used by front-end program to not display splash screen; 398 fNoLogo = kTRUE;; 399 argv[i] = null;; 400 } else if (!strcmp(argv[i], ""-x"")) {; 401 fExitOnException = kExit;; 402 argv[i] = null;; 403 } else if (!strcmp(argv[i], ""-splash"")) {; 404 // used when started by front-end program to signal that; 405 // splash screen can be popped down (TRint::PrintLogo()); 406 argv[i] = null;; 407 } else if (strncmp(argv[i], ""--web"", 5) == 0) {; 408 // the web mode is requested; 409 const char *opt = argv[i] + 5;; 410 argv[i] = null;; 411 gROOT->SetWebDisplay((*opt == '=') ? opt + 1 : """");; 412 } else if (!strcmp(argv[i], ""-e"")) {; 413 argv[i] = null;; 414 ++i;; 415 ; 416 if ( i < *argc ) {; 417 if (!fFiles) fFiles = new TObjArray;; 418 TObjString *expr = new TObjString(argv[i]);; 419 expr->SetBit(kExpression);; 420 fFiles->Add(expr);; 421 argv[i] = null;; 422 } else {; 423 Warning(""GetOptions"", ""-e must be followed by an expression."");; 424 }; 425 } else if (!strcmp(argv[i], ""--"")) {; 426 TObjString* macro = nullptr;; 427 bool warnShown = false;; 428 ; 429 if (fFiles) {; 430 for (auto f: *fFiles) {; 431 TObjString *file = dynamic_cast<TObjString *>(f);; 432 if (!file) {; 4",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:19569,Safety,timeout,timeout,19569,"clicMode(expandedDir,mode,fargs,io);; 531 char *mac;; 532 if (!fFiles) fFiles = new TObjArray;; 533 if ((mac = gSystem->Which(TROOT::GetMacroPath(), fname,; 534 kReadPermission))) {; 535 // if file add to list of files to be processed; 536 fFiles->Add(new TObjString(argv[i]));; 537 argv[i] = null;; 538 delete [] mac;; 539 } else {; 540 // if file add an invalid entry to list of files to be processed; 541 fFiles->Add(new TNamed(""NOT FOUND!"", argv[i]));; 542 // only warn if we're plain root,; 543 // other progs might have their own params; 544 if (!strcmp(gROOT->GetName(), ""Rint"")) {; 545 Error(""GetOptions"", ""macro %s not found"", fname.Data());; 546 // Return 2 as the Python interpreter does in case the macro; 547 // is not found.; 548 Terminate(2);; 549 }; 550 }; 551 }; 552 }; 553 }; 554 // ignore unknown options; 555 }; 556 ; 557 // go back to startup directory; 558 if (pwd != """"); 559 gSystem->ChangeDirectory(pwd);; 560 ; 561 // remove handled arguments from argument array; 562 j = 0;; 563 for (i = 0; i < *argc; i++) {; 564 if (strcmp(argv[i], """")) {; 565 argv[j] = argv[i];; 566 j++;; 567 }; 568 }; 569 ; 570 *argc = j;; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Handle idle timeout. When this timer expires the registered idle command; 575/// will be executed by this routine and a signal will be emitted.; 576 ; 577void TApplication::HandleIdleTimer(); 578{; 579 if (!fIdleCommand.IsNull()); 580 ProcessLine(GetIdleCommand());; 581 ; 582 Emit(""HandleIdleTimer()"");; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Handle exceptions (kSigBus, kSigSegmentationViolation,; 587/// kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; 588/// Specific TApplication implementations may want something different here.; 589 ; 590void TApplication::HandleException(Int_t sig); 591{; 592 if (TROOT::Initialized()) {; 593 if (gException) {; 594 gInterpreter",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:25316,Safety,avoid,avoid,25316,"with ""_1_1"" and all ""_"" with ""__"" in the; 692 // classes definitions, due to Doxygen syntax requirements.; 693 scopeName.ReplaceAll(""_"", ""__"");; 694 scopeName.ReplaceAll(""::"", ""_1_1"");; 695 // We build the URL for the correct scope type and name.; 696 if (scopeType == kURLforClass) {; 697 url.Append(""class"");; 698 } else if (scopeType == kURLforStruct) {; 699 url.Append(""struct"");; 700 } else {; 701 url.Append(""namespace"");; 702 }; 703 url.Append(scopeName);; 704 url.Append("".html"");; 705 return url;; 706}; 707} // namespace; 708 ; 709namespace {; 710////////////////////////////////////////////////////////////////////////////////; 711/// The function returns a TString with the arguments of a method from the; 712/// scope (scopeName), but modified with respect to Doxygen syntax - spacing; 713/// around special symbols and adding the missing scopes (""std::"").; 714/// ""FormatMethodArgsForDoxygen"" works for functions defined inside namespaces; 715/// as well. We avoid looking up twice for the TFunction by passing ""func"".; 716///; 717/// \param[in] scopeName the name of the class/namespace/struct; 718/// \param[in] func pointer to the method; 719 ; 720static TString FormatMethodArgsForDoxygen(const TString &scopeName, TFunction *func); 721{; 722 // With ""GetSignature"" we get the arguments of the method and put them in a TString.; 723 TString methodArguments = func->GetSignature();; 724 // ""methodArguments"" is modified with respect of Doxygen requirements.; 725 methodArguments.ReplaceAll("" = "", ""="");; 726 methodArguments.ReplaceAll(""* "", "" *"");; 727 methodArguments.ReplaceAll(""*="", "" *="");; 728 methodArguments.ReplaceAll(""*)"", "" *)"");; 729 methodArguments.ReplaceAll(""*,"", "" *,"");; 730 methodArguments.ReplaceAll(""*& "", "" *&"");; 731 methodArguments.ReplaceAll(""& "", "" &"");; 732 // TODO: prepend ""std::"" to all stdlib classes!; 733 methodArguments.ReplaceAll(""ostream"", ""std::ostream"");; 734 methodArguments.ReplaceAll(""istream"", ""std::istream"");; 735 methodArguments.ReplaceAll(""",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:50630,Safety,abort,abort,50630,"its : show credits"");; 1254 Printf("" .demo : launch GUI demo"");; 1255 Printf("" .forum bug : ask for help with a bug or crash at the ROOT forum."");; 1256 Printf("" .gh [bug|feature|improvement]\n""; 1257 "" : submit a bug report, feature or improvement suggestion"");; 1258 Printf("" .help Class::Member : open reference guide for that class member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 // the online reference guide, we first check if the command starts correctly.; 1278 if ((!strippedCommand.BeginsWith("".help "")) && (!strippedCommand.BeginsWith("".? ""))) {; 1279 Error(""Help"", ""Unknown command!"");; 1280 return;; 1281 }; 1282 // We remove the command "".help"" or "".?"" from the TString.; 1283 if (strippedCommand.BeginsWith("".? "")) {; 1284 strippedCommand.Remove(0, 3);; 1285 } else {; 1286 strippedCommand.Remove(0, 5);; 1287 }; 1288 // We strip the command line after removing "".help"" or "".?"".; 1289 strippedCommand = strippedCommand.Strip(TString::kBoth);; 1290 ; 1291 if (strippedCommand == ""edit"") {; 1292 Printf(""\n ROOT terminal keyboard shortcuts (GNU-readline style).",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:94183,Safety,timeout,timeout,94183,"::atomic< bool > fIsRunningWindow system specific application implementation.Definition TApplication.h:61; TApplication::NeedGraphicsLibsstatic void NeedGraphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove obj from browser.Definition TBrowser.cxx:408; TBrowser::Addvoid Add(TObject *obj, const char *name=nullptr, Int_t check=-1)Add object with name to browser.Definition TBrowser.cxx:303; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances re",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:6325,Security,access,accessed,6325,,MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:30746,Security,hash,hashed,30746," for ""dataMemberName"" defined in ""scopeName"".; 818/// It returns a TString with the URL used in the online reference guide,; 819/// generated with Doxygen. For data members the URL consist of 2 parts -; 820/// URL for ""scopeName"" and a part for ""dataMemberName"".; 821/// For enumerator, the URL could be separated into 3 parts - URL for; 822/// ""scopeName"", part for the enumeration and a part for the enumerator.; 823///; 824/// \param[in] scopeName the name of the class/namespace/struct; 825/// \param[in] dataMemberName the name of the data member/enumerator; 826/// \param[in] dataMember pointer to the data member/enumerator; 827/// \param[in] scopeType enumerator to the scope type; 828 ; 829static TString; 830GetUrlForDataMember(const TString &scopeName, const TString &dataMemberName, TDataMember *dataMember, EUrl scopeType); 831{; 832 // We first check if the data member is not enumerator.; 833 if (!dataMember->IsEnum()) {; 834 // If we work with data members, we have to append a hashed with MD5 text, consisting of:; 835 // ""Type ClassName::DataMemberNameDataMemberName(arguments)"".; 836 // We first get the type of the data member.; 837 TString md5DataMember(dataMember->GetFullTypeName());; 838 md5DataMember.Append("" "");; 839 // We append the scopeName and ""::"".; 840 md5DataMember.Append(scopeName);; 841 md5DataMember.Append(""::"");; 842 // We append the dataMemberName twice.; 843 md5DataMember.Append(dataMemberName);; 844 md5DataMember.Append(dataMemberName);; 845 // We call UrlGenerator for the scopeName.; 846 TString urlForDataMember = UrlGenerator(scopeName, scopeType);; 847 // Then we append ""#a"" and the hashed text.; 848 urlForDataMember.Append(""#a"");; 849 urlForDataMember.Append(md5DataMember.MD5());; 850 return urlForDataMember;; 851 }; 852 // If the data member is enumerator, then we first have to check if the enumeration is anonymous.; 853 // Doxygen requires different syntax for anonymous enumeration (""scopeName::@1@1"").; 854 // We create a TString with the",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:31386,Security,hash,hashed,31386,"mber pointer to the data member/enumerator; 827/// \param[in] scopeType enumerator to the scope type; 828 ; 829static TString; 830GetUrlForDataMember(const TString &scopeName, const TString &dataMemberName, TDataMember *dataMember, EUrl scopeType); 831{; 832 // We first check if the data member is not enumerator.; 833 if (!dataMember->IsEnum()) {; 834 // If we work with data members, we have to append a hashed with MD5 text, consisting of:; 835 // ""Type ClassName::DataMemberNameDataMemberName(arguments)"".; 836 // We first get the type of the data member.; 837 TString md5DataMember(dataMember->GetFullTypeName());; 838 md5DataMember.Append("" "");; 839 // We append the scopeName and ""::"".; 840 md5DataMember.Append(scopeName);; 841 md5DataMember.Append(""::"");; 842 // We append the dataMemberName twice.; 843 md5DataMember.Append(dataMemberName);; 844 md5DataMember.Append(dataMemberName);; 845 // We call UrlGenerator for the scopeName.; 846 TString urlForDataMember = UrlGenerator(scopeName, scopeType);; 847 // Then we append ""#a"" and the hashed text.; 848 urlForDataMember.Append(""#a"");; 849 urlForDataMember.Append(md5DataMember.MD5());; 850 return urlForDataMember;; 851 }; 852 // If the data member is enumerator, then we first have to check if the enumeration is anonymous.; 853 // Doxygen requires different syntax for anonymous enumeration (""scopeName::@1@1"").; 854 // We create a TString with the name of the scope and the enumeration from which the enumerator is.; 855 TString scopeEnumeration = dataMember->GetTrueTypeName();; 856 TString md5EnumClass;; 857 if (scopeEnumeration.Contains(""(unnamed)"")) {; 858 // FIXME: need to investigate the numbering scheme.; 859 md5EnumClass.Append(scopeName);; 860 md5EnumClass.Append(""::@1@1"");; 861 } else {; 862 // If the enumeration is not anonymous we put ""scopeName::Enumeration"" in a TString,; 863 // which will be hashed with MD5 later.; 864 md5EnumClass.Append(scopeEnumeration);; 865 // We extract the part after ""::"" (this is the enum",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:32217,Security,hash,hashed,32217,"DataMember.Append(dataMemberName);; 844 md5DataMember.Append(dataMemberName);; 845 // We call UrlGenerator for the scopeName.; 846 TString urlForDataMember = UrlGenerator(scopeName, scopeType);; 847 // Then we append ""#a"" and the hashed text.; 848 urlForDataMember.Append(""#a"");; 849 urlForDataMember.Append(md5DataMember.MD5());; 850 return urlForDataMember;; 851 }; 852 // If the data member is enumerator, then we first have to check if the enumeration is anonymous.; 853 // Doxygen requires different syntax for anonymous enumeration (""scopeName::@1@1"").; 854 // We create a TString with the name of the scope and the enumeration from which the enumerator is.; 855 TString scopeEnumeration = dataMember->GetTrueTypeName();; 856 TString md5EnumClass;; 857 if (scopeEnumeration.Contains(""(unnamed)"")) {; 858 // FIXME: need to investigate the numbering scheme.; 859 md5EnumClass.Append(scopeName);; 860 md5EnumClass.Append(""::@1@1"");; 861 } else {; 862 // If the enumeration is not anonymous we put ""scopeName::Enumeration"" in a TString,; 863 // which will be hashed with MD5 later.; 864 md5EnumClass.Append(scopeEnumeration);; 865 // We extract the part after ""::"" (this is the enumerator name).; 866 TString enumOnlyName = TClassEdit::GetUnqualifiedName(scopeEnumeration);; 867 // The syntax is ""Class::EnumeratorEnumerator; 868 md5EnumClass.Append(enumOnlyName);; 869 }; 870 // The next part of the URL is hashed ""@ scopeName::EnumeratorEnumerator"".; 871 TString md5Enumerator(""@ "");; 872 md5Enumerator.Append(scopeName);; 873 md5Enumerator.Append(""::"");; 874 md5Enumerator.Append(dataMemberName);; 875 md5Enumerator.Append(dataMemberName);; 876 // We make the URL for the ""scopeName"".; 877 TString url = UrlGenerator(scopeName, scopeType);; 878 // Then we have to append the hashed text for the enumerator.; 879 url.Append(""#a"");; 880 url.Append(md5EnumClass.MD5());; 881 // We append ""a"" and then the next hashed text.; 882 url.Append(""a"");; 883 url.Append(md5Enumerator.MD5());; 884 return url",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:32566,Security,hash,hashed,32566,"umerator, then we first have to check if the enumeration is anonymous.; 853 // Doxygen requires different syntax for anonymous enumeration (""scopeName::@1@1"").; 854 // We create a TString with the name of the scope and the enumeration from which the enumerator is.; 855 TString scopeEnumeration = dataMember->GetTrueTypeName();; 856 TString md5EnumClass;; 857 if (scopeEnumeration.Contains(""(unnamed)"")) {; 858 // FIXME: need to investigate the numbering scheme.; 859 md5EnumClass.Append(scopeName);; 860 md5EnumClass.Append(""::@1@1"");; 861 } else {; 862 // If the enumeration is not anonymous we put ""scopeName::Enumeration"" in a TString,; 863 // which will be hashed with MD5 later.; 864 md5EnumClass.Append(scopeEnumeration);; 865 // We extract the part after ""::"" (this is the enumerator name).; 866 TString enumOnlyName = TClassEdit::GetUnqualifiedName(scopeEnumeration);; 867 // The syntax is ""Class::EnumeratorEnumerator; 868 md5EnumClass.Append(enumOnlyName);; 869 }; 870 // The next part of the URL is hashed ""@ scopeName::EnumeratorEnumerator"".; 871 TString md5Enumerator(""@ "");; 872 md5Enumerator.Append(scopeName);; 873 md5Enumerator.Append(""::"");; 874 md5Enumerator.Append(dataMemberName);; 875 md5Enumerator.Append(dataMemberName);; 876 // We make the URL for the ""scopeName"".; 877 TString url = UrlGenerator(scopeName, scopeType);; 878 // Then we have to append the hashed text for the enumerator.; 879 url.Append(""#a"");; 880 url.Append(md5EnumClass.MD5());; 881 // We append ""a"" and then the next hashed text.; 882 url.Append(""a"");; 883 url.Append(md5Enumerator.MD5());; 884 return url;; 885}; 886} // namespace; 887 ; 888namespace {; 889////////////////////////////////////////////////////////////////////////////////; 890/// The function generates URL for enumeration. The hashed text consist of:; 891/// ""Class::EnumerationEnumeration"".; 892///; 893/// \param[in] scopeName the name of the class/namespace/struct; 894/// \param[in] enumeration the name of the enumeration; 895/// \",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:32936,Security,hash,hashed,32936,"ss;; 857 if (scopeEnumeration.Contains(""(unnamed)"")) {; 858 // FIXME: need to investigate the numbering scheme.; 859 md5EnumClass.Append(scopeName);; 860 md5EnumClass.Append(""::@1@1"");; 861 } else {; 862 // If the enumeration is not anonymous we put ""scopeName::Enumeration"" in a TString,; 863 // which will be hashed with MD5 later.; 864 md5EnumClass.Append(scopeEnumeration);; 865 // We extract the part after ""::"" (this is the enumerator name).; 866 TString enumOnlyName = TClassEdit::GetUnqualifiedName(scopeEnumeration);; 867 // The syntax is ""Class::EnumeratorEnumerator; 868 md5EnumClass.Append(enumOnlyName);; 869 }; 870 // The next part of the URL is hashed ""@ scopeName::EnumeratorEnumerator"".; 871 TString md5Enumerator(""@ "");; 872 md5Enumerator.Append(scopeName);; 873 md5Enumerator.Append(""::"");; 874 md5Enumerator.Append(dataMemberName);; 875 md5Enumerator.Append(dataMemberName);; 876 // We make the URL for the ""scopeName"".; 877 TString url = UrlGenerator(scopeName, scopeType);; 878 // Then we have to append the hashed text for the enumerator.; 879 url.Append(""#a"");; 880 url.Append(md5EnumClass.MD5());; 881 // We append ""a"" and then the next hashed text.; 882 url.Append(""a"");; 883 url.Append(md5Enumerator.MD5());; 884 return url;; 885}; 886} // namespace; 887 ; 888namespace {; 889////////////////////////////////////////////////////////////////////////////////; 890/// The function generates URL for enumeration. The hashed text consist of:; 891/// ""Class::EnumerationEnumeration"".; 892///; 893/// \param[in] scopeName the name of the class/namespace/struct; 894/// \param[in] enumeration the name of the enumeration; 895/// \param[in] scopeType enumerator for class/namespace/struct; 896 ; 897static TString GetUrlForEnumeration(TString scopeName, const TString &enumeration, EUrl scopeType); 898{; 899 // The URL consists of URL for the ""scopeName"", ""#a"" and hashed as MD5 text.; 900 // The text is ""Class::EnumerationEnumeration.; 901 TString md5Enumeration(scopeName);; 902",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:33068,Security,hash,hashed,33068,"me);; 860 md5EnumClass.Append(""::@1@1"");; 861 } else {; 862 // If the enumeration is not anonymous we put ""scopeName::Enumeration"" in a TString,; 863 // which will be hashed with MD5 later.; 864 md5EnumClass.Append(scopeEnumeration);; 865 // We extract the part after ""::"" (this is the enumerator name).; 866 TString enumOnlyName = TClassEdit::GetUnqualifiedName(scopeEnumeration);; 867 // The syntax is ""Class::EnumeratorEnumerator; 868 md5EnumClass.Append(enumOnlyName);; 869 }; 870 // The next part of the URL is hashed ""@ scopeName::EnumeratorEnumerator"".; 871 TString md5Enumerator(""@ "");; 872 md5Enumerator.Append(scopeName);; 873 md5Enumerator.Append(""::"");; 874 md5Enumerator.Append(dataMemberName);; 875 md5Enumerator.Append(dataMemberName);; 876 // We make the URL for the ""scopeName"".; 877 TString url = UrlGenerator(scopeName, scopeType);; 878 // Then we have to append the hashed text for the enumerator.; 879 url.Append(""#a"");; 880 url.Append(md5EnumClass.MD5());; 881 // We append ""a"" and then the next hashed text.; 882 url.Append(""a"");; 883 url.Append(md5Enumerator.MD5());; 884 return url;; 885}; 886} // namespace; 887 ; 888namespace {; 889////////////////////////////////////////////////////////////////////////////////; 890/// The function generates URL for enumeration. The hashed text consist of:; 891/// ""Class::EnumerationEnumeration"".; 892///; 893/// \param[in] scopeName the name of the class/namespace/struct; 894/// \param[in] enumeration the name of the enumeration; 895/// \param[in] scopeType enumerator for class/namespace/struct; 896 ; 897static TString GetUrlForEnumeration(TString scopeName, const TString &enumeration, EUrl scopeType); 898{; 899 // The URL consists of URL for the ""scopeName"", ""#a"" and hashed as MD5 text.; 900 // The text is ""Class::EnumerationEnumeration.; 901 TString md5Enumeration(scopeName);; 902 md5Enumeration.Append(""::"");; 903 md5Enumeration.Append(enumeration);; 904 md5Enumeration.Append(enumeration);; 905 // We make the URL for the ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:33346,Security,hash,hashed,33346,"Name = TClassEdit::GetUnqualifiedName(scopeEnumeration);; 867 // The syntax is ""Class::EnumeratorEnumerator; 868 md5EnumClass.Append(enumOnlyName);; 869 }; 870 // The next part of the URL is hashed ""@ scopeName::EnumeratorEnumerator"".; 871 TString md5Enumerator(""@ "");; 872 md5Enumerator.Append(scopeName);; 873 md5Enumerator.Append(""::"");; 874 md5Enumerator.Append(dataMemberName);; 875 md5Enumerator.Append(dataMemberName);; 876 // We make the URL for the ""scopeName"".; 877 TString url = UrlGenerator(scopeName, scopeType);; 878 // Then we have to append the hashed text for the enumerator.; 879 url.Append(""#a"");; 880 url.Append(md5EnumClass.MD5());; 881 // We append ""a"" and then the next hashed text.; 882 url.Append(""a"");; 883 url.Append(md5Enumerator.MD5());; 884 return url;; 885}; 886} // namespace; 887 ; 888namespace {; 889////////////////////////////////////////////////////////////////////////////////; 890/// The function generates URL for enumeration. The hashed text consist of:; 891/// ""Class::EnumerationEnumeration"".; 892///; 893/// \param[in] scopeName the name of the class/namespace/struct; 894/// \param[in] enumeration the name of the enumeration; 895/// \param[in] scopeType enumerator for class/namespace/struct; 896 ; 897static TString GetUrlForEnumeration(TString scopeName, const TString &enumeration, EUrl scopeType); 898{; 899 // The URL consists of URL for the ""scopeName"", ""#a"" and hashed as MD5 text.; 900 // The text is ""Class::EnumerationEnumeration.; 901 TString md5Enumeration(scopeName);; 902 md5Enumeration.Append(""::"");; 903 md5Enumeration.Append(enumeration);; 904 md5Enumeration.Append(enumeration);; 905 // We make the URL for the scope ""scopeName"".; 906 TString url(UrlGenerator(scopeName, scopeType));; 907 // Then we have to append ""#a"" and the hashed text.; 908 url.Append(""#a"");; 909 url.Append(md5Enumeration.MD5());; 910 return url;; 911}; 912} // namespace; 913 ; 914namespace {; 915enum EMethodKind { kURLforMethod, kURLforStructor };; 916/////////",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:33790,Security,hash,hashed,33790,"; 871 TString md5Enumerator(""@ "");; 872 md5Enumerator.Append(scopeName);; 873 md5Enumerator.Append(""::"");; 874 md5Enumerator.Append(dataMemberName);; 875 md5Enumerator.Append(dataMemberName);; 876 // We make the URL for the ""scopeName"".; 877 TString url = UrlGenerator(scopeName, scopeType);; 878 // Then we have to append the hashed text for the enumerator.; 879 url.Append(""#a"");; 880 url.Append(md5EnumClass.MD5());; 881 // We append ""a"" and then the next hashed text.; 882 url.Append(""a"");; 883 url.Append(md5Enumerator.MD5());; 884 return url;; 885}; 886} // namespace; 887 ; 888namespace {; 889////////////////////////////////////////////////////////////////////////////////; 890/// The function generates URL for enumeration. The hashed text consist of:; 891/// ""Class::EnumerationEnumeration"".; 892///; 893/// \param[in] scopeName the name of the class/namespace/struct; 894/// \param[in] enumeration the name of the enumeration; 895/// \param[in] scopeType enumerator for class/namespace/struct; 896 ; 897static TString GetUrlForEnumeration(TString scopeName, const TString &enumeration, EUrl scopeType); 898{; 899 // The URL consists of URL for the ""scopeName"", ""#a"" and hashed as MD5 text.; 900 // The text is ""Class::EnumerationEnumeration.; 901 TString md5Enumeration(scopeName);; 902 md5Enumeration.Append(""::"");; 903 md5Enumeration.Append(enumeration);; 904 md5Enumeration.Append(enumeration);; 905 // We make the URL for the scope ""scopeName"".; 906 TString url(UrlGenerator(scopeName, scopeType));; 907 // Then we have to append ""#a"" and the hashed text.; 908 url.Append(""#a"");; 909 url.Append(md5Enumeration.MD5());; 910 return url;; 911}; 912} // namespace; 913 ; 914namespace {; 915enum EMethodKind { kURLforMethod, kURLforStructor };; 916////////////////////////////////////////////////////////////////////////////////; 917/// The function generates URL for any member function (including Constructor/; 918/// Destructor) of ""scopeName"". Doxygen first generates the URL for the sco",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:34167,Security,hash,hashed,34167,"numerator.MD5());; 884 return url;; 885}; 886} // namespace; 887 ; 888namespace {; 889////////////////////////////////////////////////////////////////////////////////; 890/// The function generates URL for enumeration. The hashed text consist of:; 891/// ""Class::EnumerationEnumeration"".; 892///; 893/// \param[in] scopeName the name of the class/namespace/struct; 894/// \param[in] enumeration the name of the enumeration; 895/// \param[in] scopeType enumerator for class/namespace/struct; 896 ; 897static TString GetUrlForEnumeration(TString scopeName, const TString &enumeration, EUrl scopeType); 898{; 899 // The URL consists of URL for the ""scopeName"", ""#a"" and hashed as MD5 text.; 900 // The text is ""Class::EnumerationEnumeration.; 901 TString md5Enumeration(scopeName);; 902 md5Enumeration.Append(""::"");; 903 md5Enumeration.Append(enumeration);; 904 md5Enumeration.Append(enumeration);; 905 // We make the URL for the scope ""scopeName"".; 906 TString url(UrlGenerator(scopeName, scopeType));; 907 // Then we have to append ""#a"" and the hashed text.; 908 url.Append(""#a"");; 909 url.Append(md5Enumeration.MD5());; 910 return url;; 911}; 912} // namespace; 913 ; 914namespace {; 915enum EMethodKind { kURLforMethod, kURLforStructor };; 916////////////////////////////////////////////////////////////////////////////////; 917/// The function generates URL for any member function (including Constructor/; 918/// Destructor) of ""scopeName"". Doxygen first generates the URL for the scope.; 919/// We do that with the help of ""UrlGenerator"". Then we append ""#a"" and a; 920/// hashed with MD5 text. It consists of:; 921/// ""ReturnType ScopeName::MethodNameMethodName(Method arguments)"".; 922/// For constructor/destructor of a class, the return type is not appended.; 923///; 924/// \param[in] scopeName the name of the class/namespace/struct; 925/// \param[in] methodName the name of the method from the scope; 926/// \param[in] func pointer to the method; 927/// \param[in] methodType enumerator for",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:34700,Security,hash,hashed,34700,"enumeration, EUrl scopeType); 898{; 899 // The URL consists of URL for the ""scopeName"", ""#a"" and hashed as MD5 text.; 900 // The text is ""Class::EnumerationEnumeration.; 901 TString md5Enumeration(scopeName);; 902 md5Enumeration.Append(""::"");; 903 md5Enumeration.Append(enumeration);; 904 md5Enumeration.Append(enumeration);; 905 // We make the URL for the scope ""scopeName"".; 906 TString url(UrlGenerator(scopeName, scopeType));; 907 // Then we have to append ""#a"" and the hashed text.; 908 url.Append(""#a"");; 909 url.Append(md5Enumeration.MD5());; 910 return url;; 911}; 912} // namespace; 913 ; 914namespace {; 915enum EMethodKind { kURLforMethod, kURLforStructor };; 916////////////////////////////////////////////////////////////////////////////////; 917/// The function generates URL for any member function (including Constructor/; 918/// Destructor) of ""scopeName"". Doxygen first generates the URL for the scope.; 919/// We do that with the help of ""UrlGenerator"". Then we append ""#a"" and a; 920/// hashed with MD5 text. It consists of:; 921/// ""ReturnType ScopeName::MethodNameMethodName(Method arguments)"".; 922/// For constructor/destructor of a class, the return type is not appended.; 923///; 924/// \param[in] scopeName the name of the class/namespace/struct; 925/// \param[in] methodName the name of the method from the scope; 926/// \param[in] func pointer to the method; 927/// \param[in] methodType enumerator for method or constructor; 928/// \param[in] scopeType enumerator for class/namespace/struct; 929 ; 930static TString GetUrlForMethod(const TString &scopeName, const TString &methodName, TFunction *func,; 931 EMethodKind methodType, EUrl scopeType); 932{; 933 TString md5Text;; 934 if (methodType == kURLforMethod) {; 935 // In the case of method, we append the return type too.; 936 // ""FormatReturnTypeForDoxygen"" modifies the return type with respect to Doxygen's requirement.; 937 md5Text.Append((FormatReturnTypeForDoxygen(scopeName, func)));; 938 if (scopeType == kU",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:36432,Security,hash,hashed,36432," kURLforMethod) {; 935 // In the case of method, we append the return type too.; 936 // ""FormatReturnTypeForDoxygen"" modifies the return type with respect to Doxygen's requirement.; 937 md5Text.Append((FormatReturnTypeForDoxygen(scopeName, func)));; 938 if (scopeType == kURLforNameSpace) {; 939 // We need to append ""constexpr"" if we work with constexpr functions in namespaces.; 940 if (func->Property() & kIsConstexpr) {; 941 md5Text.Prepend(""constexpr "");; 942 }; 943 }; 944 md5Text.Append("" "");; 945 }; 946 // We append ScopeName::MethodNameMethodName.; 947 md5Text.Append(scopeName);; 948 md5Text.Append(""::"");; 949 md5Text.Append(methodName);; 950 md5Text.Append(methodName);; 951 // We use ""FormatMethodArgsForDoxygen"" to modify the arguments of Method with respect of Doxygen.; 952 md5Text.Append(FormatMethodArgsForDoxygen(scopeName, func));; 953 // We generate the URL for the class/namespace/struct.; 954 TString url = UrlGenerator(scopeName, scopeType);; 955 url.Append(""#a"");; 956 // We append the hashed text.; 957 url.Append(md5Text.MD5());; 958 return url;; 959}; 960} // namespace; 961 ; 962////////////////////////////////////////////////////////////////////////////////; 963/// It gets the ROOT installation setup as TString; 964///; 965/// \return a string with several lines; 966///; 967TString TApplication::GetSetup(); 968{; 969 std::vector<TString> lines;; 970 lines.emplace_back(""```"");; 971 lines.emplace_back(TString::Format(""ROOT v%s"",; 972 gROOT->GetVersion()));; 973 lines.emplace_back(TString::Format(""Built for %s on %s"", gSystem->GetBuildArch(), gROOT->GetGitDate()));; 974 if (!strcmp(gROOT->GetGitBranch(), gROOT->GetGitCommit())) {; 975 static const char *months[] = {""January"",""February"",""March"",""April"",""May"",; 976 ""June"",""July"",""August"",""September"",""October"",; 977 ""November"",""December""};; 978 Int_t idatqq = gROOT->GetVersionDate();; 979 Int_t iday = idatqq%100;; 980 Int_t imonth = (idatqq/100)%100;; 981 Int_t iyear = (idatqq/10000);; 982 ; 983 lines.emplac",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:37669,Security,hash,hash,37669," 965/// \return a string with several lines; 966///; 967TString TApplication::GetSetup(); 968{; 969 std::vector<TString> lines;; 970 lines.emplace_back(""```"");; 971 lines.emplace_back(TString::Format(""ROOT v%s"",; 972 gROOT->GetVersion()));; 973 lines.emplace_back(TString::Format(""Built for %s on %s"", gSystem->GetBuildArch(), gROOT->GetGitDate()));; 974 if (!strcmp(gROOT->GetGitBranch(), gROOT->GetGitCommit())) {; 975 static const char *months[] = {""January"",""February"",""March"",""April"",""May"",; 976 ""June"",""July"",""August"",""September"",""October"",; 977 ""November"",""December""};; 978 Int_t idatqq = gROOT->GetVersionDate();; 979 Int_t iday = idatqq%100;; 980 Int_t imonth = (idatqq/100)%100;; 981 Int_t iyear = (idatqq/10000);; 982 ; 983 lines.emplace_back(TString::Format(""From tag %s, %d %s %4d"",; 984 gROOT->GetGitBranch(),; 985 iday,months[imonth-1],iyear));; 986 } else {; 987 // If branch and commit are identical - e.g. ""v5-34-18"" - then we have; 988 // a release build. Else specify the git hash this build was made from.; 989 lines.emplace_back(TString::Format(""From %s@%s"",; 990 gROOT->GetGitBranch(),; 991 gROOT->GetGitCommit()));; 992 }; 993 lines.emplace_back(TString::Format(""With %s"",; 994 gSystem->GetBuildCompilerVersionStr()));; 995 lines.emplace_back(""Binary directory: ""+ gROOT->GetBinDir());; 996 lines.emplace_back(""```"");; 997 TString setup = """";; 998 for (auto& line : lines) {; 999 setup.Append(line);; 1000 setup.Append('\n');; 1001 }; 1002 setup.Chop(); // trim final `\n`; 1003 return setup;; 1004}; 1005 ; 1006////////////////////////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (type == ""bug"") {; 1016 //OpenInBrowser(""\""https://root",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:50940,Security,access,access,50940,"lass member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 // the online reference guide, we first check if the command starts correctly.; 1278 if ((!strippedCommand.BeginsWith("".help "")) && (!strippedCommand.BeginsWith("".? ""))) {; 1279 Error(""Help"", ""Unknown command!"");; 1280 return;; 1281 }; 1282 // We remove the command "".help"" or "".?"" from the TString.; 1283 if (strippedCommand.BeginsWith("".? "")) {; 1284 strippedCommand.Remove(0, 3);; 1285 } else {; 1286 strippedCommand.Remove(0, 5);; 1287 }; 1288 // We strip the command line after removing "".help"" or "".?"".; 1289 strippedCommand = strippedCommand.Strip(TString::kBoth);; 1290 ; 1291 if (strippedCommand == ""edit"") {; 1292 Printf(""\n ROOT terminal keyboard shortcuts (GNU-readline style)."");; 1293 #ifdef R__MACOSX; 1294 #define FOOTNOTE "" *""; 1295 Printf(""* Some of these commands might be intercepted by macOS predefined system shortcuts."");; 1296 // https://apple.stackexchange.com/questions/18043/how-can-i-make-ctrlright-left-arrow-stop-changing-desktops-in-lion; 1297 #else; 1298 #define FOOTNOTE """"; 1299 #endif",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:95076,Security,hash,hash,95076,"SetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove obj from browser.Definition TBrowser.cxx:408; TBrowser::Addvoid Add(TObject *obj, const char *name=nullptr, Int_t check=-1)Add object with name to browser.Definition TBrowser.cxx:303; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3929; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3753; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4451; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:105701,Security,access,access,105701,"tion TSystem.cxx:311; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Runvirtual void Run()System event loop.Definition TSystem.cxx:343; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::Exitvirtual void Exit(int code, Bool_t mode=kTRUE)Exit the application.Definition TSystem.cxx:716; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=k",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:105735,Security,access,access,105735,"tion TSystem.cxx:311; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Runvirtual void Run()System event loop.Definition TSystem.cxx:343; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::Exitvirtual void Exit(int code, Bool_t mode=kTRUE)Exit the application.Definition TSystem.cxx:716; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=k",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:23075,Usability,guid,guide,23075,"browser on Windows.; 640 TString cWindows(""start \""\"" "");; 641 cWindows.Append(url);; 642 gSystem->Exec(cWindows);; 643#else; 644 // Command for opening a browser in Linux.; 645 TString cLinux(""xdg-open "");; 646 // For Linux we check if the DISPLAY is set.; 647 if (gSystem->Getenv(""DISPLAY"")) {; 648 // If the DISPLAY is set it will open the browser.; 649 cLinux.Append(url);; 650 gSystem->Exec(cLinux);; 651 } else {; 652 // Else the user will have a warning and the URL in the terminal.; 653 Warning(""OpenInBrowser"", ""The $DISPLAY is not set! Please open (e.g. Ctrl-click) %s\n"", url.Data());; 654 return;; 655 }; 656#endif; 657 Info(""OpenInBrowser"", ""A new tab should have opened in your browser."");; 658}; 659 ; 660namespace {; 661enum EUrl { kURLforClass, kURLforNameSpace, kURLforStruct };; 662////////////////////////////////////////////////////////////////////////////////; 663/// The function generates a URL address for class or namespace (scopeName).; 664/// This is the URL to the online reference guide, generated by Doxygen.; 665/// With the enumeration ""EUrl"" we pick which case we need - the one for; 666/// class (kURLforClass) or the one for namespace (kURLforNameSpace).; 667///; 668/// \param[in] scopeName the name of the class or the namespace; 669/// \param[in] scopeType the enumerator for class or namespace; 670 ; 671static TString UrlGenerator(TString scopeName, EUrl scopeType); 672{; 673 // We start the URL with a static part, the same for all scopes and members.; 674 TString url = ""https://root.cern/doc/"";; 675 // Then we check the ROOT version used.; 676 TPRegexp re4(R""(.*/(v\d)-(\d\d)-00-patches)"");; 677 const char *branchName = gROOT->GetGitBranch();; 678 TObjArray *objarr = re4.MatchS(branchName);; 679 TString version;; 680 // We extract the correct version name for the URL.; 681 if (objarr && objarr->GetEntries() == 3) {; 682 // We have a valid version of ROOT and we will extract the correct name for the URL.; 683 version = ((TObjString *)objarr->At(1))-",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:29868,Usability,guid,guide,29868,"unction is virtual, we append ""virtual"" before the return type.; 796 returnType.Prepend(""virtual "");; 797 }; 798 returnType.ReplaceAll("" *"", ""*"");; 799 } else {; 800 // If the function is not inline we only change the spacing in ""returnType""; 801 returnType.ReplaceAll(""*"", "" *"");; 802 }; 803 // In any case (with no respect to virtual/inline check) we need to change; 804 // the return type as following.; 805 // TODO: prepend ""std::"" to all stdlib classes!; 806 returnType.ReplaceAll(""istream"", ""std::istream"");; 807 returnType.ReplaceAll(""ostream"", ""std::ostream"");; 808 returnType.ReplaceAll(""map"", ""std::map"");; 809 returnType.ReplaceAll(""vector"", ""std::vector"");; 810 returnType.ReplaceAll(""&"", "" &"");; 811 return returnType;; 812}; 813} // namespace; 814 ; 815namespace {; 816////////////////////////////////////////////////////////////////////////////////; 817/// The function generates a URL for ""dataMemberName"" defined in ""scopeName"".; 818/// It returns a TString with the URL used in the online reference guide,; 819/// generated with Doxygen. For data members the URL consist of 2 parts -; 820/// URL for ""scopeName"" and a part for ""dataMemberName"".; 821/// For enumerator, the URL could be separated into 3 parts - URL for; 822/// ""scopeName"", part for the enumeration and a part for the enumerator.; 823///; 824/// \param[in] scopeName the name of the class/namespace/struct; 825/// \param[in] dataMemberName the name of the data member/enumerator; 826/// \param[in] dataMember pointer to the data member/enumerator; 827/// \param[in] scopeType enumerator to the scope type; 828 ; 829static TString; 830GetUrlForDataMember(const TString &scopeName, const TString &dataMemberName, TDataMember *dataMember, EUrl scopeType); 831{; 832 // We first check if the data member is not enumerator.; 833 if (!dataMember->IsEnum()) {; 834 // If we work with data members, we have to append a hashed with MD5 text, consisting of:; 835 // ""Type ClassName::DataMemberNameDataMemberName(arguments)"".; ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:39109,Usability,clear,clear,39109,"e);; 1000 setup.Append('\n');; 1001 }; 1002 setup.Chop(); // trim final `\n`; 1003 return setup;; 1004}; 1005 ; 1006////////////////////////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (type == ""bug"") {; 1016 //OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?title=topic%20title&body=topic%20body&category=category/subcategory&tags=email,planned\"""");; 1017 TString report_template =; 1018R""(___; 1019_Please read [tips for efficient and successful posting](https://root-forum.cern.ch/t/tips-for-efficient-and-successful-posting/28292) and [posting code](https://root-forum.cern.ch/t/posting-code-read-this-first/28293)_; 1020 ; 1021### Describe the bug; 1022<!--; 1023A clear and concise description of what the wrong behavior is.; 1024-->; 1025### Expected behavior; 1026<!--; 1027A clear and concise description of what you expected to happen.; 1028-->; 1029 ; 1030### To Reproduce; 1031<!--; 1032Steps to reproduce the behavior:; 10331. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 10342. Don't forget to attach the required input files!; 10353. How to run your code and / or build it, e.g. `root myMacro.C`, ...; 1036-->; 1037 ; 1038### Setup; 1039)""+GetSetup()+; 1040R""(; 1041<!--; 1042Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; 1043-->; 1044 ; 1045### Additional context; 1046<!--; 1047Add any other context about the problem here.; 1048-->)"";; 1049 report_template = FormatHttpUrl(report_template);; 1050 ; 1051 OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?category=ROOT&tags=bug&body=""+report_template+""&\"""");; 1052 } else ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:39223,Usability,clear,clear,39223,"///////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (type == ""bug"") {; 1016 //OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?title=topic%20title&body=topic%20body&category=category/subcategory&tags=email,planned\"""");; 1017 TString report_template =; 1018R""(___; 1019_Please read [tips for efficient and successful posting](https://root-forum.cern.ch/t/tips-for-efficient-and-successful-posting/28292) and [posting code](https://root-forum.cern.ch/t/posting-code-read-this-first/28293)_; 1020 ; 1021### Describe the bug; 1022<!--; 1023A clear and concise description of what the wrong behavior is.; 1024-->; 1025### Expected behavior; 1026<!--; 1027A clear and concise description of what you expected to happen.; 1028-->; 1029 ; 1030### To Reproduce; 1031<!--; 1032Steps to reproduce the behavior:; 10331. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 10342. Don't forget to attach the required input files!; 10353. How to run your code and / or build it, e.g. `root myMacro.C`, ...; 1036-->; 1037 ; 1038### Setup; 1039)""+GetSetup()+; 1040R""(; 1041<!--; 1042Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; 1043-->; 1044 ; 1045### Additional context; 1046<!--; 1047Add any other context about the problem here.; 1048-->)"";; 1049 report_template = FormatHttpUrl(report_template);; 1050 ; 1051 OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?category=ROOT&tags=bug&body=""+report_template+""&\"""");; 1052 } else {; 1053 Warning(""OpenForumTopic"", ""cannot find \""%s\"" as type for a Forum topic\n""; 1054 ""Available types are 'bug'."", type.Data());; ",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:41626,Usability,guid,guide,41626,"-with-issues/creating-an-issue#creating-an-issue-from-a-url-query; 1066 ; 1067 if (type == ""bug"") {; 1068 OpenInBrowser(; 1069 ""\""https://github.com/root-project/root/issues/new?labels=bug&template=bug_report.yml&root-version="" +; 1070 FormatHttpUrl(GetSetup()) + ""\"""");; 1071 } else if (type == ""improvement"") {; 1072 OpenInBrowser(""\""https://github.com/root-project/root/issues/""; 1073 ""new?labels=improvement&template=improvement_report.yml&root-version="" +; 1074 FormatHttpUrl(GetSetup()) + ""\"""");; 1075 } else if (type == ""feature"") {; 1076 OpenInBrowser(; 1077 ""\""https://github.com/root-project/root/issues/new?labels=new+feature&template=feature_request.yml\"""");; 1078 } else {; 1079 Warning(""OpenGitHubIssue"",; 1080 ""Cannot find GitHub issue type \""%s\"".\n""; 1081 ""Available types are 'bug', 'feature' and 'improvement'."",; 1082 type.Data());; 1083 }; 1084}; 1085 ; 1086////////////////////////////////////////////////////////////////////////////////; 1087/// It opens the online reference guide, generated with Doxygen, for the; 1088/// chosen scope (class/namespace/struct) or member (method/function/; 1089/// data member/enumeration/enumerator. If the user types incorrect value,; 1090/// it will return an error or warning.; 1091///; 1092/// \param[in] strippedClass the scope or scope::member; 1093 ; 1094void TApplication::OpenReferenceGuideFor(const TString &strippedClass); 1095{; 1096 // We check if the user is searching for a scope and if the scope exists.; 1097 if (TClass *clas = TClass::GetClass(strippedClass)) {; 1098 // We check what scope he is searching for (class/namespace/struct).; 1099 // Enumerators will switch between the possible cases.; 1100 EUrl scopeType;; 1101 if (clas->Property() & kIsNamespace) {; 1102 scopeType = kURLforNameSpace;; 1103 } else if (clas->Property() & kIsStruct) {; 1104 scopeType = kURLforStruct;; 1105 } else {; 1106 scopeType = kURLforClass;; 1107 }; 1108 // If the user search directly for a scope we open the URL for him with OpenInBr",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:48491,Usability,guid,guide,48491,"("".gh <type>"") submits a new issue on GitHub via web browser.; 1212/// \note You can use ""bug"", ""feature"" or ""improvement"" as <type>.; 1213/// \param[in] line command from the command line; 1214 ; 1215void TApplication::GitHub(const char *line); 1216{; 1217 // We first check if the user chose a correct syntax.; 1218 TString strippedCommand = TString(line).Strip(TString::kBoth);; 1219 if (!strippedCommand.BeginsWith("".gh "")) {; 1220 Error(""GitHub"", ""Unknown command! Use 'bug', 'feature' or 'improvement' after '.gh '"");; 1221 return;; 1222 }; 1223 // We remove the command "".gh"" from the TString.; 1224 strippedCommand.Remove(0, 4);; 1225 // We strip the command line after removing "".help"" or "".?"".; 1226 strippedCommand = strippedCommand.Strip(TString::kBoth);; 1227 ; 1228 OpenGitHubIssue(strippedCommand);; 1229}; 1230 ; 1231////////////////////////////////////////////////////////////////////////////////; 1232/// The function lists useful commands ("".help"") or opens the online reference; 1233/// guide, generated with Doxygen ("".help scope"" or "".help scope::member"").; 1234/// \note You can use "".?"" as the short version of "".help""; 1235/// \param[in] line command from the command line; 1236 ; 1237void TApplication::Help(const char *line); 1238{; 1239 // We first check if the user wants to print the help on the interpreter.; 1240 TString strippedCommand = TString(line).Strip(TString::kBoth);; 1241 // If the user chooses "".help"" or "".?"".; 1242 if ((strippedCommand == "".help"") || (strippedCommand == "".?"")) {; 1243 gInterpreter->ProcessLine(line);; 1244 Printf(""\n ROOT special commands."");; 1245 Printf("" =============================================================================="");; 1246 Printf("" .L <filename>[flags]: load the given file with optional flags like\n""; 1247 "" + to compile or ++ to force recompile.\n""; 1248 "" Type .? TSystem::CompileMacro for a list of all flags.\n""; 1249 "" <filename> can also be a shared library; skip flags."");; 1250 Printf("" .(x|X) <filename>",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:49956,Usability,guid,guide,49956,"pedCommand == "".help"") || (strippedCommand == "".?"")) {; 1243 gInterpreter->ProcessLine(line);; 1244 Printf(""\n ROOT special commands."");; 1245 Printf("" =============================================================================="");; 1246 Printf("" .L <filename>[flags]: load the given file with optional flags like\n""; 1247 "" + to compile or ++ to force recompile.\n""; 1248 "" Type .? TSystem::CompileMacro for a list of all flags.\n""; 1249 "" <filename> can also be a shared library; skip flags."");; 1250 Printf("" .(x|X) <filename>[flags](args) :\n""; 1251 "" same as .L <filename>[flags] and runs then a function\n""; 1252 "" with signature: ret_type filename(args)."");; 1253 Printf("" .credits : show credits"");; 1254 Printf("" .demo : launch GUI demo"");; 1255 Printf("" .forum bug : ask for help with a bug or crash at the ROOT forum."");; 1256 Printf("" .gh [bug|feature|improvement]\n""; 1257 "" : submit a bug report, feature or improvement suggestion"");; 1258 Printf("" .help Class::Member : open reference guide for that class member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 //",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:50977,Usability,guid,guide,50977,"lass member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 // the online reference guide, we first check if the command starts correctly.; 1278 if ((!strippedCommand.BeginsWith("".help "")) && (!strippedCommand.BeginsWith("".? ""))) {; 1279 Error(""Help"", ""Unknown command!"");; 1280 return;; 1281 }; 1282 // We remove the command "".help"" or "".?"" from the TString.; 1283 if (strippedCommand.BeginsWith("".? "")) {; 1284 strippedCommand.Remove(0, 3);; 1285 } else {; 1286 strippedCommand.Remove(0, 5);; 1287 }; 1288 // We strip the command line after removing "".help"" or "".?"".; 1289 strippedCommand = strippedCommand.Strip(TString::kBoth);; 1290 ; 1291 if (strippedCommand == ""edit"") {; 1292 Printf(""\n ROOT terminal keyboard shortcuts (GNU-readline style)."");; 1293 #ifdef R__MACOSX; 1294 #define FOOTNOTE "" *""; 1295 Printf(""* Some of these commands might be intercepted by macOS predefined system shortcuts."");; 1296 // https://apple.stackexchange.com/questions/18043/how-can-i-make-ctrlright-left-arrow-stop-changing-desktops-in-lion; 1297 #else; 1298 #define FOOTNOTE """"; 1299 #endif",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:53790,Usability,undo,undo,53790,"f("" Fn+Arrow_Right : move cursor to end of line [Ctrl+E]"");; 1310 #else; 1311 Printf("" End : move cursor to end of line [Ctrl+E]"");; 1312 #endif; 1313 Printf("" Ctrl+Arrow_Left : jump to previous word [Esc,B] [Alt,B]"" FOOTNOTE);; 1314 Printf("" Ctrl+Arrow_Right : jump to next word [Esc,F] [Alt,F]"" FOOTNOTE);; 1315 ; 1316 Printf("" Backspace : delete previous character [Ctrl+H]"");; 1317 Printf("" Del : delete next character [Ctrl+D]"");; 1318 Printf("" Esc,Backspace : delete previous word [Ctrl+W] [Esc,Ctrl+H] [Alt+Backspace] [Esc,Del] [Esc,Ctrl+Del]"" FOOTNOTE);// Del is 0x7F on macOS; 1319 Printf("" Ctrl+Del : delete next word [Esc,D] [Alt,D]"" FOOTNOTE);; 1320 Printf("" Ctrl+U : cut all characters between cursor and start of line"");; 1321 Printf("" Ctrl+K : cut all characters between cursor and end of line"");; 1322 ; 1323 Printf("" Ctrl+T : transpose characters"");; 1324 Printf("" Esc,C : character to upper and jump to next word"");; 1325 Printf("" Esc,L : word to lower case and jump to its end"");; 1326 Printf("" Esc,U : word to upper case and jump to its end"");; 1327 Printf("" Ctrl+Shift+C : copy clipboard content"");; 1328 Printf("" Ctrl+Shift+V : paste clipboard content [Ctrl+Y] [Alt+Y]"");; 1329 #ifdef R__MACOSX; 1330 Printf("" Fn+Enter : toggle overwrite mode"");; 1331 #else; 1332 Printf("" Ins : toggle overwrite mode"");; 1333 #endif; 1334 ; 1335 Printf("" Ctrl+_ : undo last keypress action"");; 1336 Printf("" Tab : autocomplete command or print suggestions [Ctrl+I] [Esc,Tab]"");; 1337 Printf("" Enter : execute command [Ctrl+J] [Ctrl+M]"");; 1338 Printf("" Ctrl+L : clear prompt screen"");; 1339 Printf("" Ctrl+D : quit ROOT (if empty line)"");; 1340 Printf("" Ctrl+C : send kSigInt interrupt signal"");; 1341 Printf("" Ctrl+Z : send kSigStop pause job signal"");; 1342 ; 1343 Printf("" Arrow_Down : navigate downwards in command history [Ctrl+N]"");; 1344 Printf("" Arrow_Up : navigate upwards in command history [Ctrl+P]"");; 1345 Printf("" Ctrl+R ; Ctrl+S : search command in your history by typing a string.",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:53988,Usability,clear,clear,53988,"f("" Fn+Arrow_Right : move cursor to end of line [Ctrl+E]"");; 1310 #else; 1311 Printf("" End : move cursor to end of line [Ctrl+E]"");; 1312 #endif; 1313 Printf("" Ctrl+Arrow_Left : jump to previous word [Esc,B] [Alt,B]"" FOOTNOTE);; 1314 Printf("" Ctrl+Arrow_Right : jump to next word [Esc,F] [Alt,F]"" FOOTNOTE);; 1315 ; 1316 Printf("" Backspace : delete previous character [Ctrl+H]"");; 1317 Printf("" Del : delete next character [Ctrl+D]"");; 1318 Printf("" Esc,Backspace : delete previous word [Ctrl+W] [Esc,Ctrl+H] [Alt+Backspace] [Esc,Del] [Esc,Ctrl+Del]"" FOOTNOTE);// Del is 0x7F on macOS; 1319 Printf("" Ctrl+Del : delete next word [Esc,D] [Alt,D]"" FOOTNOTE);; 1320 Printf("" Ctrl+U : cut all characters between cursor and start of line"");; 1321 Printf("" Ctrl+K : cut all characters between cursor and end of line"");; 1322 ; 1323 Printf("" Ctrl+T : transpose characters"");; 1324 Printf("" Esc,C : character to upper and jump to next word"");; 1325 Printf("" Esc,L : word to lower case and jump to its end"");; 1326 Printf("" Esc,U : word to upper case and jump to its end"");; 1327 Printf("" Ctrl+Shift+C : copy clipboard content"");; 1328 Printf("" Ctrl+Shift+V : paste clipboard content [Ctrl+Y] [Alt+Y]"");; 1329 #ifdef R__MACOSX; 1330 Printf("" Fn+Enter : toggle overwrite mode"");; 1331 #else; 1332 Printf("" Ins : toggle overwrite mode"");; 1333 #endif; 1334 ; 1335 Printf("" Ctrl+_ : undo last keypress action"");; 1336 Printf("" Tab : autocomplete command or print suggestions [Ctrl+I] [Esc,Tab]"");; 1337 Printf("" Enter : execute command [Ctrl+J] [Ctrl+M]"");; 1338 Printf("" Ctrl+L : clear prompt screen"");; 1339 Printf("" Ctrl+D : quit ROOT (if empty line)"");; 1340 Printf("" Ctrl+C : send kSigInt interrupt signal"");; 1341 Printf("" Ctrl+Z : send kSigStop pause job signal"");; 1342 ; 1343 Printf("" Arrow_Down : navigate downwards in command history [Ctrl+N]"");; 1344 Printf("" Arrow_Up : navigate upwards in command history [Ctrl+P]"");; 1345 Printf("" Ctrl+R ; Ctrl+S : search command in your history by typing a string.",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:54159,Usability,pause,pause,54159,"f("" Fn+Arrow_Right : move cursor to end of line [Ctrl+E]"");; 1310 #else; 1311 Printf("" End : move cursor to end of line [Ctrl+E]"");; 1312 #endif; 1313 Printf("" Ctrl+Arrow_Left : jump to previous word [Esc,B] [Alt,B]"" FOOTNOTE);; 1314 Printf("" Ctrl+Arrow_Right : jump to next word [Esc,F] [Alt,F]"" FOOTNOTE);; 1315 ; 1316 Printf("" Backspace : delete previous character [Ctrl+H]"");; 1317 Printf("" Del : delete next character [Ctrl+D]"");; 1318 Printf("" Esc,Backspace : delete previous word [Ctrl+W] [Esc,Ctrl+H] [Alt+Backspace] [Esc,Del] [Esc,Ctrl+Del]"" FOOTNOTE);// Del is 0x7F on macOS; 1319 Printf("" Ctrl+Del : delete next word [Esc,D] [Alt,D]"" FOOTNOTE);; 1320 Printf("" Ctrl+U : cut all characters between cursor and start of line"");; 1321 Printf("" Ctrl+K : cut all characters between cursor and end of line"");; 1322 ; 1323 Printf("" Ctrl+T : transpose characters"");; 1324 Printf("" Esc,C : character to upper and jump to next word"");; 1325 Printf("" Esc,L : word to lower case and jump to its end"");; 1326 Printf("" Esc,U : word to upper case and jump to its end"");; 1327 Printf("" Ctrl+Shift+C : copy clipboard content"");; 1328 Printf("" Ctrl+Shift+V : paste clipboard content [Ctrl+Y] [Alt+Y]"");; 1329 #ifdef R__MACOSX; 1330 Printf("" Fn+Enter : toggle overwrite mode"");; 1331 #else; 1332 Printf("" Ins : toggle overwrite mode"");; 1333 #endif; 1334 ; 1335 Printf("" Ctrl+_ : undo last keypress action"");; 1336 Printf("" Tab : autocomplete command or print suggestions [Ctrl+I] [Esc,Tab]"");; 1337 Printf("" Enter : execute command [Ctrl+J] [Ctrl+M]"");; 1338 Printf("" Ctrl+L : clear prompt screen"");; 1339 Printf("" Ctrl+D : quit ROOT (if empty line)"");; 1340 Printf("" Ctrl+C : send kSigInt interrupt signal"");; 1341 Printf("" Ctrl+Z : send kSigStop pause job signal"");; 1342 ; 1343 Printf("" Arrow_Down : navigate downwards in command history [Ctrl+N]"");; 1344 Printf("" Arrow_Up : navigate upwards in command history [Ctrl+P]"");; 1345 Printf("" Ctrl+R ; Ctrl+S : search command in your history by typing a string.",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:69676,Usability,clear,clear,69676," {; 1771 ::Error(""TApplication::ExecuteFile"", ""macro %s not found in path %s"", fname.Data(),; 1772 TROOT::GetMacroPath());; 1773 delete [] exnam;; 1774 if (error); 1775 *error = (Int_t)TInterpreter::kRecoverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TApplication::ExecuteFile"", ""%s no such file"", exnam);; 1782 if (error); 1783 *error = (Int_t)TInterpreter::kRecoverable;; 1784 delete [] exnam;; 1785 return 0;; 1786 }; 1787 ; 1788 char currentline[kBufSize];; 1789 char dummyline[kBufSize];; 1790 int tempfile = 0;; 1791 int comment = 0;; 1792 int ifndefc = 0;; 1793 int ifdef = 0;; 1794 char *s = nullptr;; 1795 Bool_t execute = kFALSE;; 1796 Longptr_t retval = 0;; 1797 ; 1798 while (1) {; 1799 bool res = (bool)macro.getline(currentline, kBufSize);; 1800 if (macro.eof()) break;; 1801 if (!res) {; 1802 // Probably only read kBufSize, let's ignore the remainder of; 1803 // the line.; 1804 macro.clear();; 1805 while (!macro.getline(dummyline, kBufSize) && !macro.eof()) {; 1806 macro.clear();; 1807 }; 1808 }; 1809 s = currentline;; 1810 while (s && (*s == ' ' || *s == '\t')) s++; // strip-off leading blanks; 1811 ; 1812 // very simple minded pre-processor parsing, only works in case macro file; 1813 // starts with ""#ifndef __CINT__"". In that case everything till next; 1814 // ""#else"" or ""#endif"" will be skipped.; 1815 if (*s == '#') {; 1816 char *cs = Compress(currentline);; 1817 if (strstr(cs, ""#ifndef__CINT__"") ||; 1818 strstr(cs, ""#if!defined(__CINT__)"")); 1819 ifndefc = 1;; 1820 else if (ifndefc && (strstr(cs, ""#ifdef"") || strstr(cs, ""#ifndef"") ||; 1821 strstr(cs, ""#ifdefined"") || strstr(cs, ""#if!defined""))); 1822 ifdef++;; 1823 else if (ifndefc && strstr(cs, ""#endif"")) {; 1824 if (ifdef); 1825 ifdef--;; 1826 else; 1827 ifndefc = 0;; 1828 } else if (ifndefc && !ifdef && strstr(cs, ""#else"")); 1829 ifndefc = 0;; 1830 delete [] cs;; 1831 }; 1832 if (!*s || *s == '#' || ifndefc || !strncmp(s,",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:69765,Usability,clear,clear,69765,"coverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TApplication::ExecuteFile"", ""%s no such file"", exnam);; 1782 if (error); 1783 *error = (Int_t)TInterpreter::kRecoverable;; 1784 delete [] exnam;; 1785 return 0;; 1786 }; 1787 ; 1788 char currentline[kBufSize];; 1789 char dummyline[kBufSize];; 1790 int tempfile = 0;; 1791 int comment = 0;; 1792 int ifndefc = 0;; 1793 int ifdef = 0;; 1794 char *s = nullptr;; 1795 Bool_t execute = kFALSE;; 1796 Longptr_t retval = 0;; 1797 ; 1798 while (1) {; 1799 bool res = (bool)macro.getline(currentline, kBufSize);; 1800 if (macro.eof()) break;; 1801 if (!res) {; 1802 // Probably only read kBufSize, let's ignore the remainder of; 1803 // the line.; 1804 macro.clear();; 1805 while (!macro.getline(dummyline, kBufSize) && !macro.eof()) {; 1806 macro.clear();; 1807 }; 1808 }; 1809 s = currentline;; 1810 while (s && (*s == ' ' || *s == '\t')) s++; // strip-off leading blanks; 1811 ; 1812 // very simple minded pre-processor parsing, only works in case macro file; 1813 // starts with ""#ifndef __CINT__"". In that case everything till next; 1814 // ""#else"" or ""#endif"" will be skipped.; 1815 if (*s == '#') {; 1816 char *cs = Compress(currentline);; 1817 if (strstr(cs, ""#ifndef__CINT__"") ||; 1818 strstr(cs, ""#if!defined(__CINT__)"")); 1819 ifndefc = 1;; 1820 else if (ifndefc && (strstr(cs, ""#ifdef"") || strstr(cs, ""#ifndef"") ||; 1821 strstr(cs, ""#ifdefined"") || strstr(cs, ""#if!defined""))); 1822 ifdef++;; 1823 else if (ifndefc && strstr(cs, ""#endif"")) {; 1824 if (ifdef); 1825 ifdef--;; 1826 else; 1827 ifndefc = 0;; 1828 } else if (ifndefc && !ifdef && strstr(cs, ""#else"")); 1829 ifndefc = 0;; 1830 delete [] cs;; 1831 }; 1832 if (!*s || *s == '#' || ifndefc || !strncmp(s, ""//"", 2)) continue;; 1833 ; 1834 if (!comment && (!strncmp(s, "".X"", 2) || !strncmp(s, "".x"", 2))) {; 1835 retval = ExecuteFile(s+3);; 1836 execute = kTRUE;; 1837 continue;; 1838 }; 1839 ; 1840 if (!str",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:69912,Usability,simpl,simple,69912,"coverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TApplication::ExecuteFile"", ""%s no such file"", exnam);; 1782 if (error); 1783 *error = (Int_t)TInterpreter::kRecoverable;; 1784 delete [] exnam;; 1785 return 0;; 1786 }; 1787 ; 1788 char currentline[kBufSize];; 1789 char dummyline[kBufSize];; 1790 int tempfile = 0;; 1791 int comment = 0;; 1792 int ifndefc = 0;; 1793 int ifdef = 0;; 1794 char *s = nullptr;; 1795 Bool_t execute = kFALSE;; 1796 Longptr_t retval = 0;; 1797 ; 1798 while (1) {; 1799 bool res = (bool)macro.getline(currentline, kBufSize);; 1800 if (macro.eof()) break;; 1801 if (!res) {; 1802 // Probably only read kBufSize, let's ignore the remainder of; 1803 // the line.; 1804 macro.clear();; 1805 while (!macro.getline(dummyline, kBufSize) && !macro.eof()) {; 1806 macro.clear();; 1807 }; 1808 }; 1809 s = currentline;; 1810 while (s && (*s == ' ' || *s == '\t')) s++; // strip-off leading blanks; 1811 ; 1812 // very simple minded pre-processor parsing, only works in case macro file; 1813 // starts with ""#ifndef __CINT__"". In that case everything till next; 1814 // ""#else"" or ""#endif"" will be skipped.; 1815 if (*s == '#') {; 1816 char *cs = Compress(currentline);; 1817 if (strstr(cs, ""#ifndef__CINT__"") ||; 1818 strstr(cs, ""#if!defined(__CINT__)"")); 1819 ifndefc = 1;; 1820 else if (ifndefc && (strstr(cs, ""#ifdef"") || strstr(cs, ""#ifndef"") ||; 1821 strstr(cs, ""#ifdefined"") || strstr(cs, ""#if!defined""))); 1822 ifdef++;; 1823 else if (ifndefc && strstr(cs, ""#endif"")) {; 1824 if (ifdef); 1825 ifdef--;; 1826 else; 1827 ifndefc = 0;; 1828 } else if (ifndefc && !ifdef && strstr(cs, ""#else"")); 1829 ifndefc = 0;; 1830 delete [] cs;; 1831 }; 1832 if (!*s || *s == '#' || ifndefc || !strncmp(s, ""//"", 2)) continue;; 1833 ; 1834 if (!comment && (!strncmp(s, "".X"", 2) || !strncmp(s, "".x"", 2))) {; 1835 retval = ExecuteFile(s+3);; 1836 execute = kTRUE;; 1837 continue;; 1838 }; 1839 ; 1840 if (!str",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:87127,Usability,guid,guide,87127,"ExitOnExceptionEExitOnException ExitOnException(EExitOnException opt=kExit)Set the exit on exception option.Definition TApplication.cxx:614; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@ kExitDefinition TApplication.h:53; TApplication::ExecuteFilestatic Longptr_t ExecuteFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::InitializeGraphicsvoid InitializeGraphics(Bool_t only_web=kFALSE)Initialize the graphics environment.Definition TApplication.cxx:244; TApplication::Openvirtu",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8cxx_source.html:89086,Usability,guid,guide,89086,"ironment.Definition TApplication.cxx:244; TApplication::Openvirtual void Open()Definition TApplication.h:132; TApplication::LoadGraphicsLibsvirtual void LoadGraphicsLibs()Load shared libs necessary for graphics.Definition TApplication.cxx:1333; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::kDefaultApplication@ kDefaultApplicationDefinition TApplication.h:45; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.Definition TApplication.cxx:1860; TApplication::~TApplicationvirtual ~TApplication()TApplication dtor.Definition TApplication.cxx:210; TApplication::OpenReferenceGuideForvoid OpenReferenceGuideFor(const TString &strippedClass)It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/st...Definition TApplication.cxx:1065; TApplication::HandleExceptionvirtual void HandleException(Int_t sig)Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingExcepti...Definition TApplication.cxx:590; TApplication::MakeBatchvirtual void MakeBatch()Switch to batch mode.Definition TApplication.cxx:1395; TApplication::OpenGitHubIssuevoid OpenGitHubIssue(const TString &type)It opens a GitHub issue in a web browser with prefilled ROOT version.Definition TApplication.cxx:1034; TApplication::fReturnFromRunBool_t fReturnFromRunDefinition TApplication.h:62; TApplication::Initvirtual void Init()Definition TApplication.h:117; TApplication::fIdleCommandTString fIdleCommandDefinition TApplication.h:68; TApplication::Argvchar ** Argv() constDefinition TApplication.h:141; TApplication::fgGraphNeededstatic Bool_t fgGraphNeededDefinition TApplication.h:73; TApplic",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
https://root.cern/doc/master/TApplication_8h_source.html:3233,Availability,avail,available,3233,"rn from Run(); 63 Bool_t fNoLog; //Do not process logon and logoff macros; 64 Bool_t fNoLogo; //Do not show splash screen and welcome message; 65 Bool_t fQuit; //Exit after having processed input files; 66 TObjArray *fFiles; //Array of input files or C++ expression (TObjString's) specified via argv; 67 TString fWorkDir; //Working directory specified via argv; 68 TString fIdleCommand; //Command to execute while application is idle; 69 TTimer *fIdleTimer; //Idle timer; 70 TSignalHandler *fSigHandler; //Interrupt handler; 71 EExitOnException fExitOnException; //Exit on exception option; 72 ; 73 static Bool_t fgGraphNeeded; // True if graphics libs need to be initialized; 74 static Bool_t fgGraphInit; // True if graphics libs initialized; 75 ; 76 TApplication(const TApplication&) = delete;; 77 TApplication& operator=(const TApplication&) = delete;; 78 ; 79protected:; 80 TApplication *fAppRemote; //Current remote application, if defined; 81 ; 82 static TList *fgApplications; //List of available applications; 83 ; 84 TApplication();; 85 ; 86 virtual Longptr_t ProcessRemote(const char *line, Int_t *error = nullptr);; 87 virtual void Forum(const char *line);; 88 virtual void GitHub(const char *line);; 89 virtual void Help(const char *line);; 90 virtual void LoadGraphicsLibs();; 91 virtual void MakeBatch();; 92 void SetSignalHandler(TSignalHandler *sh) { fSigHandler = sh; }; 93 ; 94 static Int_t ParseRemoteLine(const char *ln,; 95 TString &hostdir, TString &user,; 96 Int_t &dbg, TString &script);; 97 static TApplication *Open(const char *url, Int_t debug, const char *script);; 98 static void Close(TApplication *app);; 99 ; 100public:; 101 TApplication(const char *appClassName, Int_t *argc, char **argv,; 102 void *options = nullptr, Int_t numOptions = 0);; 103 virtual ~TApplication();; 104 ; 105 void InitializeGraphics(Bool_t only_web = kFALSE);; 106 virtual void GetOptions(Int_t *argc, char **argv);; 107 TSignalHandler *GetSignalHandler() const { return fSigHandler; }; 108 v",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:3347,Availability,error,error,3347,"sh screen and welcome message; 65 Bool_t fQuit; //Exit after having processed input files; 66 TObjArray *fFiles; //Array of input files or C++ expression (TObjString's) specified via argv; 67 TString fWorkDir; //Working directory specified via argv; 68 TString fIdleCommand; //Command to execute while application is idle; 69 TTimer *fIdleTimer; //Idle timer; 70 TSignalHandler *fSigHandler; //Interrupt handler; 71 EExitOnException fExitOnException; //Exit on exception option; 72 ; 73 static Bool_t fgGraphNeeded; // True if graphics libs need to be initialized; 74 static Bool_t fgGraphInit; // True if graphics libs initialized; 75 ; 76 TApplication(const TApplication&) = delete;; 77 TApplication& operator=(const TApplication&) = delete;; 78 ; 79protected:; 80 TApplication *fAppRemote; //Current remote application, if defined; 81 ; 82 static TList *fgApplications; //List of available applications; 83 ; 84 TApplication();; 85 ; 86 virtual Longptr_t ProcessRemote(const char *line, Int_t *error = nullptr);; 87 virtual void Forum(const char *line);; 88 virtual void GitHub(const char *line);; 89 virtual void Help(const char *line);; 90 virtual void LoadGraphicsLibs();; 91 virtual void MakeBatch();; 92 void SetSignalHandler(TSignalHandler *sh) { fSigHandler = sh; }; 93 ; 94 static Int_t ParseRemoteLine(const char *ln,; 95 TString &hostdir, TString &user,; 96 Int_t &dbg, TString &script);; 97 static TApplication *Open(const char *url, Int_t debug, const char *script);; 98 static void Close(TApplication *app);; 99 ; 100public:; 101 TApplication(const char *appClassName, Int_t *argc, char **argv,; 102 void *options = nullptr, Int_t numOptions = 0);; 103 virtual ~TApplication();; 104 ; 105 void InitializeGraphics(Bool_t only_web = kFALSE);; 106 virtual void GetOptions(Int_t *argc, char **argv);; 107 TSignalHandler *GetSignalHandler() const { return fSigHandler; }; 108 virtual void SetEchoMode(Bool_t mode);; 109 TString GetSetup();; 110 void OpenForumTopic(const TString & type);; ",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:4787,Availability,error,error,4787,"r *url, Int_t debug, const char *script);; 98 static void Close(TApplication *app);; 99 ; 100public:; 101 TApplication(const char *appClassName, Int_t *argc, char **argv,; 102 void *options = nullptr, Int_t numOptions = 0);; 103 virtual ~TApplication();; 104 ; 105 void InitializeGraphics(Bool_t only_web = kFALSE);; 106 virtual void GetOptions(Int_t *argc, char **argv);; 107 TSignalHandler *GetSignalHandler() const { return fSigHandler; }; 108 virtual void SetEchoMode(Bool_t mode);; 109 TString GetSetup();; 110 void OpenForumTopic(const TString & type);; 111 void OpenGitHubIssue(const TString & type);; 112 void OpenInBrowser(const TString & url);; 113 void OpenReferenceGuideFor(const TString & strippedClass);; 114 virtual void HandleException(Int_t sig);; 115 virtual void HandleIdleTimer(); //*SIGNAL*; 116 virtual Bool_t HandleTermInput() { return kFALSE; }; 117 virtual void Init() { fAppImp->Init(); }; 118 virtual Longptr_t ProcessLine(const char *line, Bool_t sync = kFALSE, Int_t *error = nullptr);; 119 virtual Longptr_t ProcessFile(const char *file, Int_t *error = nullptr, Bool_t keep = kFALSE);; 120 virtual void Run(Bool_t retrn = kFALSE);; 121 virtual void SetIdleTimer(UInt_t idleTimeInSec, const char *command);; 122 virtual void RemoveIdleTimer();; 123 const char *GetIdleCommand() const { return fIdleCommand; }; 124 virtual void StartIdleing();; 125 virtual void StopIdleing();; 126 EExitOnException ExitOnException(EExitOnException opt = kExit);; 127 ; 128 virtual const char *ApplicationName() const { return fAppImp->ApplicationName(); }; 129 virtual void Show() { fAppImp->Show(); }; 130 virtual void Hide() { fAppImp->Hide(); }; 131 virtual void Iconify() { fAppImp->Iconify(); }; 132 virtual void Open() { fAppImp->Open(); }; 133 virtual void Raise() { fAppImp->Raise(); }; 134 virtual void Lower() { fAppImp->Lower(); }; 135 virtual Bool_t IsCmdThread() { return fAppImp ? fAppImp->IsCmdThread() : kTRUE; }; 136 virtual TApplicationImp *GetApplicationImp() { return ",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:4865,Availability,error,error,4865,"app);; 99 ; 100public:; 101 TApplication(const char *appClassName, Int_t *argc, char **argv,; 102 void *options = nullptr, Int_t numOptions = 0);; 103 virtual ~TApplication();; 104 ; 105 void InitializeGraphics(Bool_t only_web = kFALSE);; 106 virtual void GetOptions(Int_t *argc, char **argv);; 107 TSignalHandler *GetSignalHandler() const { return fSigHandler; }; 108 virtual void SetEchoMode(Bool_t mode);; 109 TString GetSetup();; 110 void OpenForumTopic(const TString & type);; 111 void OpenGitHubIssue(const TString & type);; 112 void OpenInBrowser(const TString & url);; 113 void OpenReferenceGuideFor(const TString & strippedClass);; 114 virtual void HandleException(Int_t sig);; 115 virtual void HandleIdleTimer(); //*SIGNAL*; 116 virtual Bool_t HandleTermInput() { return kFALSE; }; 117 virtual void Init() { fAppImp->Init(); }; 118 virtual Longptr_t ProcessLine(const char *line, Bool_t sync = kFALSE, Int_t *error = nullptr);; 119 virtual Longptr_t ProcessFile(const char *file, Int_t *error = nullptr, Bool_t keep = kFALSE);; 120 virtual void Run(Bool_t retrn = kFALSE);; 121 virtual void SetIdleTimer(UInt_t idleTimeInSec, const char *command);; 122 virtual void RemoveIdleTimer();; 123 const char *GetIdleCommand() const { return fIdleCommand; }; 124 virtual void StartIdleing();; 125 virtual void StopIdleing();; 126 EExitOnException ExitOnException(EExitOnException opt = kExit);; 127 ; 128 virtual const char *ApplicationName() const { return fAppImp->ApplicationName(); }; 129 virtual void Show() { fAppImp->Show(); }; 130 virtual void Hide() { fAppImp->Hide(); }; 131 virtual void Iconify() { fAppImp->Iconify(); }; 132 virtual void Open() { fAppImp->Open(); }; 133 virtual void Raise() { fAppImp->Raise(); }; 134 virtual void Lower() { fAppImp->Lower(); }; 135 virtual Bool_t IsCmdThread() { return fAppImp ? fAppImp->IsCmdThread() : kTRUE; }; 136 virtual TApplicationImp *GetApplicationImp() { return fAppImp;}; 137 ; 138 void ls(Option_t *option="""") const override;; 139 ; 140 I",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:6906,Availability,error,error,6906,"opt = kExit);; 127 ; 128 virtual const char *ApplicationName() const { return fAppImp->ApplicationName(); }; 129 virtual void Show() { fAppImp->Show(); }; 130 virtual void Hide() { fAppImp->Hide(); }; 131 virtual void Iconify() { fAppImp->Iconify(); }; 132 virtual void Open() { fAppImp->Open(); }; 133 virtual void Raise() { fAppImp->Raise(); }; 134 virtual void Lower() { fAppImp->Lower(); }; 135 virtual Bool_t IsCmdThread() { return fAppImp ? fAppImp->IsCmdThread() : kTRUE; }; 136 virtual TApplicationImp *GetApplicationImp() { return fAppImp;}; 137 ; 138 void ls(Option_t *option="""") const override;; 139 ; 140 Int_t Argc() const { return fArgc; }; 141 char **Argv() const { return fArgv; }; 142 char *Argv(Int_t index) const;; 143 Bool_t NoLogOpt() const { return fNoLog; }; 144 Bool_t NoLogoOpt() const { return fNoLogo; }; 145 Bool_t QuitOpt() const { return fQuit; }; 146 TObjArray *InputFiles() const { return fFiles; }; 147 const char *WorkingDirectory() const { return fWorkDir; }; 148 void ClearInputFiles();; 149 ; 150 TApplication *GetAppRemote() const { return fAppRemote; }; 151 ; 152 Bool_t IsRunning() const { return fIsRunning; }; 153 Bool_t ReturnFromRun() const { return fReturnFromRun; }; 154 void SetReturnFromRun(Bool_t ret) { fReturnFromRun = ret; }; 155 ; 156 virtual void LineProcessed(const char *line); //*SIGNAL*; 157 virtual void Terminate(Int_t status = 0); //*SIGNAL*; 158 virtual void KeyPressed(Int_t key); //*SIGNAL*; 159 virtual void ReturnPressed(char *text ); //*SIGNAL*; 160 virtual Int_t TabCompletionHook(char *buf, int *pLoc, std::ostream& out);; 161 ; 162 static Longptr_t ExecuteFile(const char *file, Int_t *error = nullptr, Bool_t keep = kFALSE);; 163 static TList *GetApplications();; 164 static void CreateApplication();; 165 static void NeedGraphicsLibs();; 166 ; 167 ClassDefOverride(TApplication,0) //GUI application singleton; 168};; 169 ; 170R__EXTERN TApplication *gApplication;; 171 ; 172#endif; R__EXTERN#define R__EXTERNDefinition DllImport.",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:10564,Availability,error,error,10564,"cationImp::Hidevirtual void Hide()Definition TApplicationImp.h:41; TApplicationImp::Initvirtual void Init()Definition TApplicationImp.h:44; TApplicationImp::Iconifyvirtual void Iconify()Definition TApplicationImp.h:42; TApplicationImp::Lowervirtual void Lower()Definition TApplicationImp.h:47; TApplicationImp::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplicationImp.h:43; TApplicationImp::Openvirtual void Open()Definition TApplicationImp.h:45; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TApplication::ExitOnExceptionEExitOnException ExitOnException(EExitOnException opt=kExit)Set the exit on exception option.Definition TApplication.cxx:614; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::HandleTermInputvirtual Bool_t HandleTermInput()Definition TApplication.h:116; TApplication::IsRunningBool_t IsRunning() constDefinition TApplication.h:152; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::InputFilesTObjArray * InputFiles() constDefinition TApplication.h:146; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const c",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:11184,Availability,echo,echo,11184,".h:39; TApplication::ExitOnExceptionEExitOnException ExitOnException(EExitOnException opt=kExit)Set the exit on exception option.Definition TApplication.cxx:614; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::HandleTermInputvirtual Bool_t HandleTermInput()Definition TApplication.h:116; TApplication::IsRunningBool_t IsRunning() constDefinition TApplication.h:152; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::InputFilesTObjArray * InputFiles() constDefinition TApplication.h:146; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::TApplicationTApplication(const TApplication &)=delete; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kDontExit@ kDontExitDefinition TApplication.h:52; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:12276,Availability,error,error,12276,"constDefinition TApplication.h:146; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::TApplicationTApplication(const TApplication &)=delete; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kDontExit@ kDontExitDefinition TApplication.h:52; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@ kExitDefinition TApplication.h:53; TApplication::ExecuteFilestatic Longptr_t ExecuteFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::GetSignalHandlerTSignalHandler * GetSignalHandler() constDefinition TApplication.h:107; TApplication::InitializeGraphicsvoid InitializeGraphics(Bool_t only_web=kFALSE)Initialize the graphics environment.Definition TApplication.cxx:244; TApplication::Openvirtual void Open()Definition TApplication.h:132; TApplication::LoadGraphicsLibsvirtual void LoadGraphicsLibs()Load shared libs necessary for graphics.Definition TApplication.cxx:1333; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::EStatusBitsEStatusBitsDefinition TApplication.h:43; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::kDefaultApplication@ kDefaultApplicationDefinition TApplication.h:45; TApplication::Iconifyvirtual void Iconify()Definition TApplication.h:131; TApplic",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:16616,Availability,error,error,16616,"n ("".forum <type>"") submits a new post on the ROOT forum via web browser.Definition TApplication.cxx:1165; TApplication::SetReturnFromRunvoid SetReturnFromRun(Bool_t ret)Definition TApplication.h:154; TApplication::fQuitBool_t fQuitDefinition TApplication.h:65; TApplication::TabCompletionHookvirtual Int_t TabCompletionHook(char *buf, int *pLoc, std::ostream &out)What to do when tab is pressed.Definition TApplication.cxx:1917; TApplication::fExitOnExceptionEExitOnException fExitOnExceptionDefinition TApplication.h:71; TApplication::GetApplicationImpvirtual TApplicationImp * GetApplicationImp()Definition TApplication.h:136; TApplication::fFilesTObjArray * fFilesDefinition TApplication.h:66; TApplication::GetIdleCommandconst char * GetIdleCommand() constDefinition TApplication.h:123; TApplication::TApplicationTApplication()Default ctor. Can be used by classes deriving from TApplication.Definition TApplication.cxx:97; TApplication::ProcessFilevirtual Longptr_t ProcessFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Process a file containing a C++ macro.Definition TApplication.cxx:1720; TApplication::OpenForumTopicvoid OpenForumTopic(const TString &type)It opens a Forum topic in a web browser with prefilled ROOT version.Definition TApplication.cxx:1011; TApplication::fWorkDirTString fWorkDirDefinition TApplication.h:67; TApplication::ReturnPressedvirtual void ReturnPressed(char *text)Emit signal when return key was pressed.Definition TApplication.cxx:1957; TApplication::fgGraphInitstatic Bool_t fgGraphInitDefinition TApplication.h:74; TApplication::RemoveIdleTimervirtual void RemoveIdleTimer()Remove idle timer. Normally called via TROOT::Idle(0).Definition TApplication.cxx:1885; TApplication::EFileBitsEFileBitsDefinition TApplication.h:48; TApplication::kExpression@ kExpressionDefinition TApplication.h:49; TApplication::NoLogOptBool_t NoLogOpt() constDefinition TApplication.h:143; TApplication::SetIdleTimervirtual void SetIdleTimer(UInt_t idleTimeInSec, co",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:18391,Availability,avail,available,18391,"FileBitsDefinition TApplication.h:48; TApplication::kExpression@ kExpressionDefinition TApplication.h:49; TApplication::NoLogOptBool_t NoLogOpt() constDefinition TApplication.h:143; TApplication::SetIdleTimervirtual void SetIdleTimer(UInt_t idleTimeInSec, const char *command)Set the command to be executed after the system has been idle for idleTimeInSec seconds.Definition TApplication.cxx:1874; TApplication::GitHubvirtual void GitHub(const char *line)The function ("".gh <type>"") submits a new issue on GitHub via web browser.Definition TApplication.cxx:1186; TApplication::CreateApplicationstatic void CreateApplication()Static function used to create a default application environment.Definition TApplication.cxx:1975; TApplication::GetOptionsvirtual void GetOptions(Int_t *argc, char **argv)Get and handle command line options.Definition TApplication.cxx:345; TApplication::NoLogoOptBool_t NoLogoOpt() constDefinition TApplication.h:144; TApplication::GetApplicationsstatic TList * GetApplications()Static method returning the list of available applications.Definition TApplication.cxx:2103; TApplication::fIsRunningstd::atomic< bool > fIsRunningWindow system specific application implementation.Definition TApplication.h:61; TApplication::operator=TApplication & operator=(const TApplication &)=delete; TApplication::NeedGraphicsLibsstatic void NeedGraphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplication.h:135; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::Raisevirtual void Raise()Definition TApplic",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:19241,Availability,avail,available,19241," TApplication::NoLogoOptBool_t NoLogoOpt() constDefinition TApplication.h:144; TApplication::GetApplicationsstatic TList * GetApplications()Static method returning the list of available applications.Definition TApplication.cxx:2103; TApplication::fIsRunningstd::atomic< bool > fIsRunningWindow system specific application implementation.Definition TApplication.h:61; TApplication::operator=TApplication & operator=(const TApplication &)=delete; TApplication::NeedGraphicsLibsstatic void NeedGraphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplication.h:135; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::Raisevirtual void Raise()Definition TApplication.h:133; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::WorkingDirectoryconst char * WorkingDirectory() constDefinition TApplication.h:147; TApplication::QuitOptBool_t QuitOpt() constDefinition TApplication.h:145; TApplication::fSigHandlerTSignalHandler * fSigHandlerDefinition TApplication.h:70; TApplication::ArgcInt_t Argc() constDefinition TApplication.h:140; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:20190,Availability,error,error,20190,"5; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::Raisevirtual void Raise()Definition TApplication.h:133; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::WorkingDirectoryconst char * WorkingDirectory() constDefinition TApplication.h:147; TApplication::QuitOptBool_t QuitOpt() constDefinition TApplication.h:145; TApplication::fSigHandlerTSignalHandler * fSigHandlerDefinition TApplication.h:70; TApplication::ArgcInt_t Argc() constDefinition TApplication.h:140; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::Showvirtual void Show()Definition TApplication.h:129; TApplication::SetSignalHandlervoid SetSignalHandler(TSignalHandler *sh)Definition TApplication.h:92; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TListA doubly linked list.Definition TList.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TQObjectThis is the ROOT implementation of the Qt object communication mechanism (see also http://www....Definition TQObject.h:48; TSignalHandlerDefinition TSysEvtHandler.h:127; TStringBasic string class.Definition TString.h:139; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:23",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:19609,Deployability,install,installation,19609,"on::operator=TApplication & operator=(const TApplication &)=delete; TApplication::NeedGraphicsLibsstatic void NeedGraphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplication.h:135; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::Raisevirtual void Raise()Definition TApplication.h:133; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::WorkingDirectoryconst char * WorkingDirectory() constDefinition TApplication.h:147; TApplication::QuitOptBool_t QuitOpt() constDefinition TApplication.h:145; TApplication::fSigHandlerTSignalHandler * fSigHandlerDefinition TApplication.h:70; TApplication::ArgcInt_t Argc() constDefinition TApplication.h:140; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::Showvirtual void Show()Definition TApplication.h:129; TApplication::SetSignalHandlervoid SetSignalHandler(TSignalHandler *sh)Definition TApplication.h:92; TApplication::fArgvch",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:876,Integrability,interface,interfaces,876,". ROOT: core/base/inc/TApplication.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TApplication.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/12/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TApplication; 13#define ROOT_TApplication; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TApplication //; 19// //; 20// This class creates the ROOT Application Environment that interfaces //; 21// to the windowing system eventloop and eventhandlers. //; 22// This class must be instantiated exactly once in any given //; 23// application. Normally the specific application class inherits from //; 24// TApplication (see TRint). //; 25// //; 26//////////////////////////////////////////////////////////////////////////; 27 ; 28#include ""TObject.h""; 29 ; 30#include ""TQObject.h""; 31 ; 32#include ""TApplicationImp.h""; 33 ; 34class TObjArray;; 35class TTimer;; 36class TSignalHandler;; 37 ; 38 ; 39class TApplication : public TObject, public TQObject {; 40 ; 41public:; 42 // TApplication specific bits; 43 enum EStatusBits {; 44 kProcessRemotely = BIT(15), // TRUE if this line has to be processed remotely; 45 kDefaultApplication = BIT(16) // TRUE if created via CreateApplication(); 46 };; 47 // TApplication specific bits for fFiles; 48 enum EFileBits {; 49 kExpression = BIT(14) // If the arguments is an expression rather than a file.; 50 };; 51 enum EExitOnException {; 52 kDontExit,; 53 kExit,; 54 kAbort; 55 };; 56 ; 57private:; 58 Int_t fArgc; //Number of com mand line arguments; 59 char **fArgv",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:2372,Integrability,message,message,2372,"; 50 };; 51 enum EExitOnException {; 52 kDontExit,; 53 kExit,; 54 kAbort; 55 };; 56 ; 57private:; 58 Int_t fArgc; //Number of com mand line arguments; 59 char **fArgv",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:9260,Integrability,protocol,protocol,9260,alXProxy.cxx:68; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; TObject.h; TQObject.h; TApplicationImpABC describing GUI independent application implementation protocol.Definition TApplicationImp.h:29; TApplicationImp::Showvirtual void Show()Definition TApplicationImp.h:40; TApplicationImp::ApplicationNamevirtual const char * ApplicationName() constDefinition TApplicationImp.h:39; TApplicationImp::Raisevirtual void Raise()Definition TApplicationImp.h:46; TApplicationImp::Hidevirtual void Hide()Definition TApplicationImp.h:41; TApplicationImp::Initvirtual void Init()Definition TApplicationImp.h:44; TApplicationImp::Iconifyvirtual void Iconify()Definition TApplicationImp.h:42; TApplicationImp::Lowervirtual void Lower()Definition TApplicationImp.h:47; TApplicationImp::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplicationImp.h:43; TApplicationImp::Openvirtual void Open()Definition TApplicationImp.h:45; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TApplication::ExitOnExceptionEExitOnException ExitOnExceptio,MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:10090,Integrability,interface,interfaces,10090,"xtOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; TObject.h; TQObject.h; TApplicationImpABC describing GUI independent application implementation protocol.Definition TApplicationImp.h:29; TApplicationImp::Showvirtual void Show()Definition TApplicationImp.h:40; TApplicationImp::ApplicationNamevirtual const char * ApplicationName() constDefinition TApplicationImp.h:39; TApplicationImp::Raisevirtual void Raise()Definition TApplicationImp.h:46; TApplicationImp::Hidevirtual void Hide()Definition TApplicationImp.h:41; TApplicationImp::Initvirtual void Init()Definition TApplicationImp.h:44; TApplicationImp::Iconifyvirtual void Iconify()Definition TApplicationImp.h:42; TApplicationImp::Lowervirtual void Lower()Definition TApplicationImp.h:47; TApplicationImp::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplicationImp.h:43; TApplicationImp::Openvirtual void Open()Definition TApplicationImp.h:45; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TApplication::ExitOnExceptionEExitOnException ExitOnException(EExitOnException opt=kExit)Set the exit on exception option.Definition TApplication.cxx:614; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::HandleTermInputvirtual Bool_t HandleTermInput()Definition TApplication.h:116; TApplication::IsRunningBool_t IsRunning() c",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:13573,Integrability,depend,dependent,13573,"tialize the graphics environment.Definition TApplication.cxx:244; TApplication::Openvirtual void Open()Definition TApplication.h:132; TApplication::LoadGraphicsLibsvirtual void LoadGraphicsLibs()Load shared libs necessary for graphics.Definition TApplication.cxx:1333; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::EStatusBitsEStatusBitsDefinition TApplication.h:43; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::kDefaultApplication@ kDefaultApplicationDefinition TApplication.h:45; TApplication::Iconifyvirtual void Iconify()Definition TApplication.h:131; TApplication::ReturnFromRunBool_t ReturnFromRun() constDefinition TApplication.h:153; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.Definition TApplication.cxx:1860; TApplication::~TApplicationvirtual ~TApplication()TApplication dtor.Definition TApplication.cxx:210; TApplication::Lowervirtual void Lower()Definition TApplication.h:134; TApplication::OpenReferenceGuideForvoid OpenReferenceGuideFor(const TString &strippedClass)It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/st...Definition TApplication.cxx:1065; TApplication::HandleExceptionvirtual void HandleException(Int_t sig)Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingExcepti...Definition TApplication.cxx:590; TApplication::MakeBatchvirtual void MakeBatch()Switch to batch mode.Definition TApplication.cxx:1395; TApplication::OpenGitHubIssuevoid OpenGitHubIssue(const TString &type)It opens a GitHub issue in a web browser with prefilled ROOT version.Definition TApplication.cxx:1034; TApplication::Hidevirtual void Hide()Definition TApplication.h:",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:1078,Modifiability,inherit,inherits,1078,"uide ; .  . Loading...; Searching...; No Matches. TApplication.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/12/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TApplication; 13#define ROOT_TApplication; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TApplication //; 19// //; 20// This class creates the ROOT Application Environment that interfaces //; 21// to the windowing system eventloop and eventhandlers. //; 22// This class must be instantiated exactly once in any given //; 23// application. Normally the specific application class inherits from //; 24// TApplication (see TRint). //; 25// //; 26//////////////////////////////////////////////////////////////////////////; 27 ; 28#include ""TObject.h""; 29 ; 30#include ""TQObject.h""; 31 ; 32#include ""TApplicationImp.h""; 33 ; 34class TObjArray;; 35class TTimer;; 36class TSignalHandler;; 37 ; 38 ; 39class TApplication : public TObject, public TQObject {; 40 ; 41public:; 42 // TApplication specific bits; 43 enum EStatusBits {; 44 kProcessRemotely = BIT(15), // TRUE if this line has to be processed remotely; 45 kDefaultApplication = BIT(16) // TRUE if created via CreateApplication(); 46 };; 47 // TApplication specific bits for fFiles; 48 enum EFileBits {; 49 kExpression = BIT(14) // If the arguments is an expression rather than a file.; 50 };; 51 enum EExitOnException {; 52 kDontExit,; 53 kExit,; 54 kAbort; 55 };; 56 ; 57private:; 58 Int_t fArgc; //Number of com mand line arguments; 59 char **fArgv; //Command line arguments; 60 TApplicationImp *fAppImp; //!Window system specifi",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:15370,Performance,load,loads,15370,"plication.cxx:1395; TApplication::OpenGitHubIssuevoid OpenGitHubIssue(const TString &type)It opens a GitHub issue in a web browser with prefilled ROOT version.Definition TApplication.cxx:1034; TApplication::Hidevirtual void Hide()Definition TApplication.h:130; TApplication::fReturnFromRunBool_t fReturnFromRunDefinition TApplication.h:62; TApplication::Initvirtual void Init()Definition TApplication.h:117; TApplication::fIdleCommandTString fIdleCommandDefinition TApplication.h:68; TApplication::Argvchar ** Argv() constDefinition TApplication.h:141; TApplication::fgGraphNeededstatic Bool_t fgGraphNeededDefinition TApplication.h:73; TApplication::Terminatevirtual void Terminate(Int_t status=0)Terminate the application by call TSystem::Exit() unless application has been told to return from Run...Definition TApplication.cxx:1927; TApplication::GetAppRemoteTApplication * GetAppRemote() constDefinition TApplication.h:150; TApplication::OpenInBrowservoid OpenInBrowser(const TString &url)The function generates and executes a command that loads the Doxygen URL in a browser.Definition TApplication.cxx:629; TApplication::ApplicationNamevirtual const char * ApplicationName() constDefinition TApplication.h:128; TApplication::Forumvirtual void Forum(const char *line)The function ("".forum <type>"") submits a new post on the ROOT forum via web browser.Definition TApplication.cxx:1165; TApplication::SetReturnFromRunvoid SetReturnFromRun(Bool_t ret)Definition TApplication.h:154; TApplication::fQuitBool_t fQuitDefinition TApplication.h:65; TApplication::TabCompletionHookvirtual Int_t TabCompletionHook(char *buf, int *pLoc, std::ostream &out)What to do when tab is pressed.Definition TApplication.cxx:1917; TApplication::fExitOnExceptionEExitOnException fExitOnExceptionDefinition TApplication.h:71; TApplication::GetApplicationImpvirtual TApplicationImp * GetApplicationImp()Definition TApplication.h:136; TApplication::fFilesTObjArray * fFilesDefinition TApplication.h:66; TApplication::GetIdl",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:19743,Safety,timeout,timeout,19743,"raphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplication.h:135; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::Raisevirtual void Raise()Definition TApplication.h:133; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::WorkingDirectoryconst char * WorkingDirectory() constDefinition TApplication.h:147; TApplication::QuitOptBool_t QuitOpt() constDefinition TApplication.h:145; TApplication::fSigHandlerTSignalHandler * fSigHandlerDefinition TApplication.h:70; TApplication::ArgcInt_t Argc() constDefinition TApplication.h:140; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::Showvirtual void Show()Definition TApplication.h:129; TApplication::SetSignalHandlervoid SetSignalHandler(TSignalHandler *sh)Definition TApplication.h:92; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TListA doubly linked list.Definition TList.h:38; TObjArrayAn array of TOb",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:2288,Testability,log,logon,2288,"; 50 };; 51 enum EExitOnException {; 52 kDontExit,; 53 kExit,; 54 kAbort; 55 };; 56 ; 57private:; 58 Int_t fArgc; //Number of com mand line arguments; 59 char **fArgv",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:2298,Testability,log,logoff,2298,"; 50 };; 51 enum EExitOnException {; 52 kDontExit,; 53 kExit,; 54 kAbort; 55 };; 56 ; 57private:; 58 Int_t fArgc; //Number of com mand line arguments; 59 char **fArgv",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:11441,Usability,guid,guide,11441,"tion TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::HandleTermInputvirtual Bool_t HandleTermInput()Definition TApplication.h:116; TApplication::IsRunningBool_t IsRunning() constDefinition TApplication.h:152; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::InputFilesTObjArray * InputFiles() constDefinition TApplication.h:146; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::TApplicationTApplication(const TApplication &)=delete; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kDontExit@ kDontExitDefinition TApplication.h:52; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@ kExitDefinition TApplication.h:53; TApplication::ExecuteFilestatic Longptr_t ExecuteFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::GetSignalHandlerTSignalH",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TApplication_8h_source.html:13931,Usability,guid,guide,13931,"alled when system stops idleing.Definition TApplication.cxx:1907; TApplication::EStatusBitsEStatusBitsDefinition TApplication.h:43; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::kDefaultApplication@ kDefaultApplicationDefinition TApplication.h:45; TApplication::Iconifyvirtual void Iconify()Definition TApplication.h:131; TApplication::ReturnFromRunBool_t ReturnFromRun() constDefinition TApplication.h:153; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.Definition TApplication.cxx:1860; TApplication::~TApplicationvirtual ~TApplication()TApplication dtor.Definition TApplication.cxx:210; TApplication::Lowervirtual void Lower()Definition TApplication.h:134; TApplication::OpenReferenceGuideForvoid OpenReferenceGuideFor(const TString &strippedClass)It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/st...Definition TApplication.cxx:1065; TApplication::HandleExceptionvirtual void HandleException(Int_t sig)Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingExcepti...Definition TApplication.cxx:590; TApplication::MakeBatchvirtual void MakeBatch()Switch to batch mode.Definition TApplication.cxx:1395; TApplication::OpenGitHubIssuevoid OpenGitHubIssue(const TString &type)It opens a GitHub issue in a web browser with prefilled ROOT version.Definition TApplication.cxx:1034; TApplication::Hidevirtual void Hide()Definition TApplication.h:130; TApplication::fReturnFromRunBool_t fReturnFromRunDefinition TApplication.h:62; TApplication::Initvirtual void Init()Definition TApplication.h:117; TApplication::fIdleCommandTString fIdleCommandDefinition TApplication.h:68; TApplication::Argvchar ** Argv() constDefinition TApplication.h:141; TApplication::fgGraphNee",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
https://root.cern/doc/master/TArrow_8cxx_source.html:20033,Usability,simpl,simple,20033,"nge current fill area attributes if necessary.Definition TAttFill.cxx:216; TAttFill::SaveFillAttributesvirtual void SaveFillAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001)Save fill attributes as C++ statement(s) on output stream out.Definition TAttFill.cxx:239; TAttLine::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::Modifyvirtual void Modify()Change current line attributes if necessary.Definition TAttLine.cxx:247; TAttLine::Copyvoid Copy(TAttLine &attline) constCopy this line attributes to a new TAttLine.Definition TAttLine.cxx:177; TAttLine::SaveLineAttributesvirtual void SaveLineAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1)Save line attributes as C++ statement(s) on output stream out.Definition TAttLine.cxx:275; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::kLineNDC@ kLineNDCUse NDC coordinates.Definition TLine.h:33; TLine::Copyvoid Copy(TObject &line) const overrideCopy this line to line.Definition TLine.cxx:76; TLine::fX2Double_t fX2X of 2nd point.Definition TLine.h:27; TLine::fY2Double_t fY2Y of 2nd point.Definition TLine.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObj",MatchSource.WIKI,doc/master/TArrow_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TArrow_8cxx_source.html
https://root.cern/doc/master/TArrow_8h_source.html:6743,Usability,simpl,simple,6743,"ault constructor.Definition TArrow.cxx:47; TArrow::fAngleFloat_t fAngleArrow opening angle (degrees)Definition TArrow.h:31; TArrow::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TArrow.cxx:365; TArrow::SetOptionvirtual void SetOption(Option_t *option="">"")Definition TArrow.h:62; TArrow::fgDefaultOptionstatic TString fgDefaultOptionDefault Arrow shapes.Definition TArrow.h:37; TArrow::fOptionTString fOptionArrow shapes.Definition TArrow.h:33; TArrow::PaintArrowNDCvirtual void PaintArrowNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2, Float_t arrowsize=0.05, Option_t *option="">"")Draw this arrow with new coordinates in NDC.Definition TArrow.cxx:352; TArrow::PaintArrowvirtual void PaintArrow(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Float_t arrowsize=0.05, Option_t *option="">"")Draw this arrow with new coordinates.Definition TArrow.cxx:175; TArrow::~TArrow~TArrow() overrideArrow default destructor.Definition TArrow.cxx:91; TArrow::GetArrowSizeFloat_t GetArrowSize() constDefinition TArrow.h:52; TArrow::SetAnglevirtual void SetAngle(Float_t angle=60)Definition TArrow.h:60; TArrow::GetDefaultArrowSizestatic Float_t GetDefaultArrowSize()Get default arrow size.Definition TArrow.cxx:431; TArrow::Copyvoid Copy(TObject &arrow) const overrideCopy this arrow to arrow.Definition TArrow.cxx:108; TAttFillFill Area Attributes class.Definition TAttFill.h:19; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; double; arrowDefinition RArrowDS.hxx:17; v2@ v2Definition rootcling_impl.cxx:3702; v1@ v1Definition rootcling_impl.cxx:3701; Drawth1 Draw(). graf2dgrafincTArrow.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TArrow_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TArrow_8h_source.html
https://root.cern/doc/master/TAttAxis_8cxx_source.html:7444,Performance,optimiz,optimized,7444,"//////////////////////////////////////////////////////////////////////; 187/// Set distance between the axis and the labels.; 188/// The distance is expressed in per cent of the pad width.; 189/// A negative value allow to draw the label on the other side of the axis.; 190 ; 191void TAttAxis::SetLabelOffset(Float_t offset); 192{; 193 fLabelOffset = offset;; 194 if (gPad) gPad->Modified();; 195}; 196 ; 197 ; 198////////////////////////////////////////////////////////////////////////////////; 199/// Set size of axis labels.; 200/// The size is expressed in per cent of the pad size, unless the font precision; 201/// is 3 and in that case the size is expressed in pixels.; 202 ; 203void TAttAxis::SetLabelSize(Float_t size); 204{; 205 fLabelSize = size;; 206 if (gPad) gPad->Modified();; 207}; 208 ; 209////////////////////////////////////////////////////////////////////////////////; 210/// Set the number of divisions for this axis.; 211///; 212/// - if optim = kTRUE (default), the number of divisions will be; 213/// optimized around the specified value.; 214/// - if optim = kFALSE, or n < 0, the axis will be forced to use; 215/// exactly n divisions.; 216///~~~ {.cpp}; 217/// n = n1 + 100*n2 + 10000*n3; 218///~~~; 219/// Where n1 is the number of primary divisions,; 220/// n2 is the number of second order divisions and; 221/// n3 is the number of third order divisions.; 222///; 223/// If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; 224/// maximum values.; 225///; 226/// Examples:; 227///; 228/// - ndiv = 0: no tick marks.; 229/// - ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; 230/// - ndiv = 510: 10 primary divisions, 5 secondary divisions.; 231/// - ndiv = -10: exactly 10 primary divisions.; 232 ; 233void TAttAxis::SetNdivisions(Int_t n, Bool_t optim); 234{; 235 Int_t ndiv = (n%1000000);; 236 Bool_t isOptimized = optim && (ndiv>0);; 237 Int_t current_maxDigits = abs(fNdivisions)/1000000;; 238 fNdivisions = abs(ndiv) + current_maxD",MatchSource.WIKI,doc/master/TAttAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttAxis_8cxx_source.html
https://root.cern/doc/master/TAttAxis_8cxx_source.html:7851,Performance,optimiz,optimized,7851,"////////////////////////////////////////////////////////; 199/// Set size of axis labels.; 200/// The size is expressed in per cent of the pad size, unless the font precision; 201/// is 3 and in that case the size is expressed in pixels.; 202 ; 203void TAttAxis::SetLabelSize(Float_t size); 204{; 205 fLabelSize = size;; 206 if (gPad) gPad->Modified();; 207}; 208 ; 209////////////////////////////////////////////////////////////////////////////////; 210/// Set the number of divisions for this axis.; 211///; 212/// - if optim = kTRUE (default), the number of divisions will be; 213/// optimized around the specified value.; 214/// - if optim = kFALSE, or n < 0, the axis will be forced to use; 215/// exactly n divisions.; 216///~~~ {.cpp}; 217/// n = n1 + 100*n2 + 10000*n3; 218///~~~; 219/// Where n1 is the number of primary divisions,; 220/// n2 is the number of second order divisions and; 221/// n3 is the number of third order divisions.; 222///; 223/// If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; 224/// maximum values.; 225///; 226/// Examples:; 227///; 228/// - ndiv = 0: no tick marks.; 229/// - ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; 230/// - ndiv = 510: 10 primary divisions, 5 secondary divisions.; 231/// - ndiv = -10: exactly 10 primary divisions.; 232 ; 233void TAttAxis::SetNdivisions(Int_t n, Bool_t optim); 234{; 235 Int_t ndiv = (n%1000000);; 236 Bool_t isOptimized = optim && (ndiv>0);; 237 Int_t current_maxDigits = abs(fNdivisions)/1000000;; 238 fNdivisions = abs(ndiv) + current_maxDigits*1000000;; 239 if (!isOptimized) fNdivisions = -fNdivisions;; 240 ; 241 if (gPad) gPad->Modified();; 242}; 243 ; 244////////////////////////////////////////////////////////////////////////////////; 245/// Set the number of divisions for this axis using one `int` per division level.; 246 ; 247void TAttAxis::SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim); 248{; 249 SetNdivisions(n1+100*n2+10000*n3, optim);; 250}; 251 ; 25",MatchSource.WIKI,doc/master/TAttAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttAxis_8cxx_source.html
https://root.cern/doc/master/TAttFill_8cxx_source.html:2130,Availability,avail,available,2130,"ributes are:; 34 ; 35 - [Fill Area color](\ref ATTFILL1); 36 - [Fill Area style](\ref ATTFILL2); 37 ; 38\anchor ATTFILL1; 39## Fill Area color; 40The fill area color is a color index (integer) pointing in the ROOT; 41color table.; 42The fill area color of any class inheriting from `TAttFill` can; 43be changed using the method `SetFillColor` and retrieved using the; 44method `GetFillColor`.; 45The following table shows the first 50 default colors.; 46 ; 47Begin_Macro; 48{; 49 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 50 c->DrawColorTable();; 51 return c;; 52}; 53End_Macro; 54 ; 55### Color transparency; 56`SetFillColorAlpha()`, allows to set a transparent color.; 57In the following example the fill color of the histogram `histo`; 58is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 59(The color `kBlue` itself is internally stored as fully opaque.); 60 ; 61~~~ {.cpp}; 62histo->SetFillColorAlpha(kBlue, 0.35);; 63~~~; 64 ; 65The transparency is available on all platforms when the flag; 66`OpenGL.CanvasPreferGL` is set to `1` in `$ROOTSYS/etc/system.rootrc`, or on Mac; 67with the Cocoa backend.; 68On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX... but not PostScript.; 69 ; 70Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 71Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 72 ; 73### The ROOT Color Wheel.; 74The wheel contains the recommended 216 colors to be used in web applications.; 75The colors in the Color Wheel are created by TColor::CreateColorWheel.; 76 ; 77Using this color set for your text, background or graphics will give your; 78application a consistent appearance across different platforms and browsers.; 79 ; 80Colors are grouped by hue, the aspect most important in human perception; 81Touching color chips have the same hue, but with different brightness and vividness.; 82 ; 83Colors of slightly different hues _clash_. ",MatchSource.WIKI,doc/master/TAttFill_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttFill_8cxx_source.html
https://root.cern/doc/master/TAttFill_8cxx_source.html:984,Modifiability,inherit,inheritance,984,". ROOT: core/base/src/TAttFill.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TAttFill.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 12/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""TAttFill.h""; 14#include ""TVirtualPad.h""; 15#include ""TStyle.h""; 16#include ""TVirtualX.h""; 17#include ""TVirtualPadEditor.h""; 18#include ""TColor.h""; 19 ; 20ClassImp(TAttFill);; 21 ; 22/** \class TAttFill; 23\ingroup Base; 24\ingroup GraphicsAtt; 25 ; 26Fill Area Attributes class.; 27 ; 28This class is used (in general by secondary inheritance); 29by many other classes (graphics, histograms). It holds all the fill area; 30attributes.; 31 ; 32## Fill Area attributes; 33Fill Area attributes are:; 34 ; 35 - [Fill Area color](\ref ATTFILL1); 36 - [Fill Area style](\ref ATTFILL2); 37 ; 38\anchor ATTFILL1; 39## Fill Area color; 40The fill area color is a color index (integer) pointing in the ROOT; 41color table.; 42The fill area color of any class inheriting from `TAttFill` can; 43be changed using the method `SetFillColor` and retrieved using the; 44method `GetFillColor`.; 45The following table shows the first 50 default colors.; 46 ; 47Begin_Macro; 48{; 49 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 50 c->DrawColorTable();; 51 return c;; 52}; 53End_Macro; 54 ; 55### Color transparency; 56`SetFillColorAlpha()`, allows to set a transparent color.; 57In the following example the fill color of the histogram `histo`; 58is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 59(The color `kBlue` itself is int",MatchSource.WIKI,doc/master/TAttFill_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttFill_8cxx_source.html
https://root.cern/doc/master/TAttFill_8cxx_source.html:1402,Modifiability,inherit,inheriting,1402,"e $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""TAttFill.h""; 14#include ""TVirtualPad.h""; 15#include ""TStyle.h""; 16#include ""TVirtualX.h""; 17#include ""TVirtualPadEditor.h""; 18#include ""TColor.h""; 19 ; 20ClassImp(TAttFill);; 21 ; 22/** \class TAttFill; 23\ingroup Base; 24\ingroup GraphicsAtt; 25 ; 26Fill Area Attributes class.; 27 ; 28This class is used (in general by secondary inheritance); 29by many other classes (graphics, histograms). It holds all the fill area; 30attributes.; 31 ; 32## Fill Area attributes; 33Fill Area attributes are:; 34 ; 35 - [Fill Area color](\ref ATTFILL1); 36 - [Fill Area style](\ref ATTFILL2); 37 ; 38\anchor ATTFILL1; 39## Fill Area color; 40The fill area color is a color index (integer) pointing in the ROOT; 41color table.; 42The fill area color of any class inheriting from `TAttFill` can; 43be changed using the method `SetFillColor` and retrieved using the; 44method `GetFillColor`.; 45The following table shows the first 50 default colors.; 46 ; 47Begin_Macro; 48{; 49 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 50 c->DrawColorTable();; 51 return c;; 52}; 53End_Macro; 54 ; 55### Color transparency; 56`SetFillColorAlpha()`, allows to set a transparent color.; 57In the following example the fill color of the histogram `histo`; 58is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 59(The color `kBlue` itself is internally stored as fully opaque.); 60 ; 61~~~ {.cpp}; 62histo->SetFillColorAlpha(kBlue, 0.35);; 63~~~; 64 ; 65The transparency is available on all platforms when the flag; 66`OpenGL.CanvasPreferGL` is set to `1` in `$ROOTSYS/etc/system.rootrc`, or on Mac; 67with the Cocoa backend.; 68On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX... but not PostScript.; 69 ; 70Alternatively, you can call at the top of your script `gSytle->",MatchSource.WIKI,doc/master/TAttFill_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttFill_8cxx_source.html
https://root.cern/doc/master/TAttFill_8cxx_source.html:4267,Modifiability,inherit,inheriting,4267,"mber.; 87The keywords, kRed, kBlue, kYellow, kPink, etc are defined in the header file __Rtypes.h__; 88that is included in all ROOT other header files. We strongly recommend to use these keywords; 89in your code instead of hardcoded color numbers, eg:; 90~~~ {.cpp}; 91 myObject.SetFillColor(kRed);; 92 myObject.SetFillColor(kYellow-10);; 93 myLine.SetLineColor(kMagenta+2);; 94~~~; 95 ; 96Begin_Macro; 97{; 98 TColorWheel *w = new TColorWheel();; 99 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 100 w->SetCanvas(cw);; 101 w->Draw();; 102}; 103End_Macro; 104 ; 105### Special case forcing black&white output.; 106If the current style fill area color is set to 0, then ROOT will force; 107a black&white output for all objects with a fill area defined and independently; 108of the object fill style.; 109 ; 110\anchor ATTFILL2; 111## Fill Area style; 112The fill area style defines the pattern used to fill a polygon.; 113The fill area style of any class inheriting from `TAttFill` can; 114be changed using the method `SetFillStyle` and retrieved using the; 115method `GetFillStyle`.; 116### Conventions for fill styles:; 117 ; 118 - 0 : hollow; 119 - 1001 : Solid; 120 - 3000+pattern_number (see below); 121 - For TPad only:; 122 ; 123 - 4000 :the window is transparent.; 124 - 4000 to 4100 the window is 100% transparent to 100% opaque.; 125 ; 126 The pad transparency is visible in binary outputs files like gif, jpg, png etc ..; 127 but not in vector graphics output files like PS, PDF and SVG. This convention; 128 (fill style > 4000) is kept for backward compatibility. It is better to use; 129 the color transparency instead.; 130 ; 131pattern_number can have any value from 1 to 25 (see table), or any; 132value from 100 to 999. For the latest the numbering convention is the following:; 133~~~ {.cpp}; 134 pattern_number = ijk (FillStyle = 3ijk); 135 ; 136 i (1-9) : specify the space between each hatch; 137 1 = 1/2mm 9 = 6mm; 138 ; 139 j (0-9) : specify angle between 0 and 90 degrees; 140",MatchSource.WIKI,doc/master/TAttFill_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttFill_8cxx_source.html
https://root.cern/doc/master/TAttLine_8cxx_source.html:2156,Availability,avail,available,2156," are:; 35 ; 36 - [Line Color](\ref ATTLINE1); 37 - [Line Width](\ref ATTLINE2); 38 - [Line Style](\ref ATTLINE3); 39 ; 40\anchor ATTLINE1; 41## Line Color; 42The line color is a color index (integer) pointing in the ROOT; 43color table.; 44The line color of any class inheriting from `TAttLine` can; 45be changed using the method `SetLineColor` and retrieved using the; 46method `GetLineColor`.; 47The following table shows the first 50 default colors.; 48 ; 49Begin_Macro; 50{; 51 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 52 c->DrawColorTable();; 53 return c;; 54}; 55End_Macro; 56 ; 57### Color transparency; 58`SetLineColorAlpha()`, allows to set a transparent color.; 59In the following example the line color of the histogram `histo`; 60is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 61(The color `kBlue` itself is internally stored as fully opaque.); 62 ; 63~~~ {.cpp}; 64histo->SetLineColorAlpha(kBlue, 0.35);; 65~~~; 66 ; 67The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 68in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 69it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 70 ; 71Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 72Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 73 ; 74\anchor ATTLINE2; 75## Line Width; 76The line width is expressed in pixel units.; 77The line width of any class inheriting from `TAttLine` can; 78be changed using the method `SetLineWidth` and retrieved using the; 79method `GetLineWidth`.; 80The following picture shows the line widths from 1 to 10 pixels.; 81 ; 82Begin_Macro; 83{; 84 TCanvas *Lw = new TCanvas(""Lw"",""test"",500,200);; 85 TText t;; 86 t.SetTextAlign(32);; 87 t.SetTextSize(0.08);; 88 Int_t i=1;; 89 for (float s=0.1; s<1.0 ; s+=0.092) {; 90 TLine *lh = new TLine(0.15,s,.85,s);; 91 lh->SetLineWidth",MatchSource.WIKI,doc/master/TAttLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html
https://root.cern/doc/master/TAttLine_8cxx_source.html:1019,Modifiability,inherit,inheritance,1019,"AttLine.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TAttLine.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 28/11/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TAttLine.h""; 13#include ""TVirtualPad.h""; 14#include ""TStyle.h""; 15#include ""TVirtualX.h""; 16#include ""TVirtualPadEditor.h""; 17#include ""TColor.h""; 18#include <cmath>; 19#include <iostream>; 20 ; 21ClassImp(TAttLine);; 22using std::sqrt;; 23 ; 24/** \class TAttLine; 25\ingroup Base; 26\ingroup GraphicsAtt; 27 ; 28Line Attributes class.; 29 ; 30This class is used (in general by secondary inheritance); 31by many other classes (graphics, histograms). It holds all the line attributes.; 32 ; 33## Line attributes; 34Line attributes are:; 35 ; 36 - [Line Color](\ref ATTLINE1); 37 - [Line Width](\ref ATTLINE2); 38 - [Line Style](\ref ATTLINE3); 39 ; 40\anchor ATTLINE1; 41## Line Color; 42The line color is a color index (integer) pointing in the ROOT; 43color table.; 44The line color of any class inheriting from `TAttLine` can; 45be changed using the method `SetLineColor` and retrieved using the; 46method `GetLineColor`.; 47The following table shows the first 50 default colors.; 48 ; 49Begin_Macro; 50{; 51 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 52 c->DrawColorTable();; 53 return c;; 54}; 55End_Macro; 56 ; 57### Color transparency; 58`SetLineColorAlpha()`, allows to set a transparent color.; 59In the following example the line color of the histogram `histo`; 60is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 61(The color `kBlue` itself is",MatchSource.WIKI,doc/master/TAttLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html
https://root.cern/doc/master/TAttLine_8cxx_source.html:1428,Modifiability,inherit,inheriting,1428,"r the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TAttLine.h""; 13#include ""TVirtualPad.h""; 14#include ""TStyle.h""; 15#include ""TVirtualX.h""; 16#include ""TVirtualPadEditor.h""; 17#include ""TColor.h""; 18#include <cmath>; 19#include <iostream>; 20 ; 21ClassImp(TAttLine);; 22using std::sqrt;; 23 ; 24/** \class TAttLine; 25\ingroup Base; 26\ingroup GraphicsAtt; 27 ; 28Line Attributes class.; 29 ; 30This class is used (in general by secondary inheritance); 31by many other classes (graphics, histograms). It holds all the line attributes.; 32 ; 33## Line attributes; 34Line attributes are:; 35 ; 36 - [Line Color](\ref ATTLINE1); 37 - [Line Width](\ref ATTLINE2); 38 - [Line Style](\ref ATTLINE3); 39 ; 40\anchor ATTLINE1; 41## Line Color; 42The line color is a color index (integer) pointing in the ROOT; 43color table.; 44The line color of any class inheriting from `TAttLine` can; 45be changed using the method `SetLineColor` and retrieved using the; 46method `GetLineColor`.; 47The following table shows the first 50 default colors.; 48 ; 49Begin_Macro; 50{; 51 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 52 c->DrawColorTable();; 53 return c;; 54}; 55End_Macro; 56 ; 57### Color transparency; 58`SetLineColorAlpha()`, allows to set a transparent color.; 59In the following example the line color of the histogram `histo`; 60is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 61(The color `kBlue` itself is internally stored as fully opaque.); 62 ; 63~~~ {.cpp}; 64histo->SetLineColorAlpha(kBlue, 0.35);; 65~~~; 66 ; 67The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 68in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 69it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 70 ; 71Alternatively, you can call at the top of your script `gSytle->SetC",MatchSource.WIKI,doc/master/TAttLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html
https://root.cern/doc/master/TAttLine_8cxx_source.html:2709,Modifiability,inherit,inheriting,2709,"acro; 56 ; 57### Color transparency; 58`SetLineColorAlpha()`, allows to set a transparent color.; 59In the following example the line color of the histogram `histo`; 60is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 61(The color `kBlue` itself is internally stored as fully opaque.); 62 ; 63~~~ {.cpp}; 64histo->SetLineColorAlpha(kBlue, 0.35);; 65~~~; 66 ; 67The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 68in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 69it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 70 ; 71Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 72Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 73 ; 74\anchor ATTLINE2; 75## Line Width; 76The line width is expressed in pixel units.; 77The line width of any class inheriting from `TAttLine` can; 78be changed using the method `SetLineWidth` and retrieved using the; 79method `GetLineWidth`.; 80The following picture shows the line widths from 1 to 10 pixels.; 81 ; 82Begin_Macro; 83{; 84 TCanvas *Lw = new TCanvas(""Lw"",""test"",500,200);; 85 TText t;; 86 t.SetTextAlign(32);; 87 t.SetTextSize(0.08);; 88 Int_t i=1;; 89 for (float s=0.1; s<1.0 ; s+=0.092) {; 90 TLine *lh = new TLine(0.15,s,.85,s);; 91 lh->SetLineWidth(i);; 92 t.DrawText(0.1,s,Form(""%d"",i++));; 93 lh->Draw();; 94 }; 95}; 96End_Macro; 97 ; 98\anchor ATTLINE3; 99## Line Style; 100Line styles are identified via integer numbers. The line style of any class; 101inheriting from `TAttLine` can be changed using the method; 102`SetLineStyle` and retrieved using the method `GetLineStyle`.; 103 ; 104The first 10 line styles are predefined as shown on the following picture:; 105 ; 106Begin_Macro; 107{; 108 TCanvas *Ls = new TCanvas(""Ls"",""test"",500,200);; 109 TText t;; 110 t.SetTextAlign(32);; 111 t.SetTextSize(0.08);; 112 Int_t i=1;; 113 for (floa",MatchSource.WIKI,doc/master/TAttLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html
https://root.cern/doc/master/TAttLine_8cxx_source.html:3996,Security,access,accessed,3996,"500,200);; 85 TText t;; 86 t.SetTextAlign(32);; 87 t.SetTextSize(0.08);; 88 Int_t i=1;; 89 for (float s=0.1; s<1.0 ; s+=0.092) {; 90 TLine *lh = new TLine(0.15,s,.85,s);; 91 lh->SetLineWidth(i);; 92 t.DrawText(0.1,s,Form(""%d"",i++));; 93 lh->Draw();; 94 }; 95}; 96End_Macro; 97 ; 98\anchor ATTLINE3; 99## Line Style; 100Line styles are identified via integer numbers. The line style of any class; 101inheriting from `TAttLine` can be changed using the method; 102`SetLineStyle` and retrieved using the method `GetLineStyle`.; 103 ; 104The first 10 line styles are predefined as shown on the following picture:; 105 ; 106Begin_Macro; 107{; 108 TCanvas *Ls = new TCanvas(""Ls"",""test"",500,200);; 109 TText t;; 110 t.SetTextAlign(32);; 111 t.SetTextSize(0.08);; 112 Int_t i=1;; 113 for (float s=0.1; s<1.0 ; s+=0.092) {; 114 TLine *lh = new TLine(0.15,s,.85,s);; 115 lh->SetLineStyle(i);; 116 lh->SetLineWidth(3);; 117 t.DrawText(0.1,s,Form(""%d"",i++));; 118 lh->Draw();; 119 }; 120}; 121End_Macro; 122 ; 123Some line styles can be accessed via the following enum:; 124 ; 125~~~ {.cpp}; 126 kSolid = 1; 127 kDashed = 2; 128 kDotted = 3; 129 kDashDotted = 4; 130~~~; 131 ; 132Additional line styles can be defined using `TStyle::SetLineStyleString`.; 133For example the line style number 11 can be defined as follow:; 134~~~ {.cpp}; 135 gStyle->SetLineStyleString(11,""400 200"");; 136~~~; 137Existing line styles (1 to 10) can be redefined using the same method.; 138 */; 139 ; 140////////////////////////////////////////////////////////////////////////////////; 141/// AttLine default constructor.; 142 ; 143TAttLine::TAttLine(); 144{; 145 if (!gStyle) {fLineColor=1; fLineWidth=1; fLineStyle=1; return;}; 146 fLineColor = gStyle->GetLineColor();; 147 fLineWidth = gStyle->GetLineWidth();; 148 fLineStyle = gStyle->GetLineStyle();; 149}; 150 ; 151////////////////////////////////////////////////////////////////////////////////; 152/// AttLine normal constructor.; 153/// Line attributes are taking from the ",MatchSource.WIKI,doc/master/TAttLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html
https://root.cern/doc/master/TAttLine_8cxx_source.html:2965,Testability,test,test,2965,"ity of 35% (i.e. a transparency of 65%).; 61(The color `kBlue` itself is internally stored as fully opaque.); 62 ; 63~~~ {.cpp}; 64histo->SetLineColorAlpha(kBlue, 0.35);; 65~~~; 66 ; 67The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 68in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 69it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 70 ; 71Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 72Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 73 ; 74\anchor ATTLINE2; 75## Line Width; 76The line width is expressed in pixel units.; 77The line width of any class inheriting from `TAttLine` can; 78be changed using the method `SetLineWidth` and retrieved using the; 79method `GetLineWidth`.; 80The following picture shows the line widths from 1 to 10 pixels.; 81 ; 82Begin_Macro; 83{; 84 TCanvas *Lw = new TCanvas(""Lw"",""test"",500,200);; 85 TText t;; 86 t.SetTextAlign(32);; 87 t.SetTextSize(0.08);; 88 Int_t i=1;; 89 for (float s=0.1; s<1.0 ; s+=0.092) {; 90 TLine *lh = new TLine(0.15,s,.85,s);; 91 lh->SetLineWidth(i);; 92 t.DrawText(0.1,s,Form(""%d"",i++));; 93 lh->Draw();; 94 }; 95}; 96End_Macro; 97 ; 98\anchor ATTLINE3; 99## Line Style; 100Line styles are identified via integer numbers. The line style of any class; 101inheriting from `TAttLine` can be changed using the method; 102`SetLineStyle` and retrieved using the method `GetLineStyle`.; 103 ; 104The first 10 line styles are predefined as shown on the following picture:; 105 ; 106Begin_Macro; 107{; 108 TCanvas *Ls = new TCanvas(""Ls"",""test"",500,200);; 109 TText t;; 110 t.SetTextAlign(32);; 111 t.SetTextSize(0.08);; 112 Int_t i=1;; 113 for (float s=0.1; s<1.0 ; s+=0.092) {; 114 TLine *lh = new TLine(0.15,s,.85,s);; 115 lh->SetLineStyle(i);; 116 lh->SetLineWidth(3);; 117 t.DrawText(0.1,s,Form(""%d"",i++));; 118 lh->Draw();; 119 }; 120}; 121",MatchSource.WIKI,doc/master/TAttLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html
https://root.cern/doc/master/TAttLine_8cxx_source.html:3645,Testability,test,test,3645,"; 73 ; 74\anchor ATTLINE2; 75## Line Width; 76The line width is expressed in pixel units.; 77The line width of any class inheriting from `TAttLine` can; 78be changed using the method `SetLineWidth` and retrieved using the; 79method `GetLineWidth`.; 80The following picture shows the line widths from 1 to 10 pixels.; 81 ; 82Begin_Macro; 83{; 84 TCanvas *Lw = new TCanvas(""Lw"",""test"",500,200);; 85 TText t;; 86 t.SetTextAlign(32);; 87 t.SetTextSize(0.08);; 88 Int_t i=1;; 89 for (float s=0.1; s<1.0 ; s+=0.092) {; 90 TLine *lh = new TLine(0.15,s,.85,s);; 91 lh->SetLineWidth(i);; 92 t.DrawText(0.1,s,Form(""%d"",i++));; 93 lh->Draw();; 94 }; 95}; 96End_Macro; 97 ; 98\anchor ATTLINE3; 99## Line Style; 100Line styles are identified via integer numbers. The line style of any class; 101inheriting from `TAttLine` can be changed using the method; 102`SetLineStyle` and retrieved using the method `GetLineStyle`.; 103 ; 104The first 10 line styles are predefined as shown on the following picture:; 105 ; 106Begin_Macro; 107{; 108 TCanvas *Ls = new TCanvas(""Ls"",""test"",500,200);; 109 TText t;; 110 t.SetTextAlign(32);; 111 t.SetTextSize(0.08);; 112 Int_t i=1;; 113 for (float s=0.1; s<1.0 ; s+=0.092) {; 114 TLine *lh = new TLine(0.15,s,.85,s);; 115 lh->SetLineStyle(i);; 116 lh->SetLineWidth(3);; 117 t.DrawText(0.1,s,Form(""%d"",i++));; 118 lh->Draw();; 119 }; 120}; 121End_Macro; 122 ; 123Some line styles can be accessed via the following enum:; 124 ; 125~~~ {.cpp}; 126 kSolid = 1; 127 kDashed = 2; 128 kDotted = 3; 129 kDashDotted = 4; 130~~~; 131 ; 132Additional line styles can be defined using `TStyle::SetLineStyleString`.; 133For example the line style number 11 can be defined as follow:; 134~~~ {.cpp}; 135 gStyle->SetLineStyleString(11,""400 200"");; 136~~~; 137Existing line styles (1 to 10) can be redefined using the same method.; 138 */; 139 ; 140////////////////////////////////////////////////////////////////////////////////; 141/// AttLine default constructor.; 142 ; 143TAttLine::TAttLin",MatchSource.WIKI,doc/master/TAttLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html
https://root.cern/doc/master/TAttLine_8h.html:212,Integrability,depend,dependency,212,". ROOT: core/base/inc/TAttLine.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TAttLine.h File Reference. #include ""Rtypes.h"". Include dependency graph for TAttLine.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TAttLine;  Line Attributes class. More...;  . Enumerations; enum  ELineStyle { kSolid = 1; , kDashed; , kDotted; , kDashDotted; };  . Enumeration Type Documentation. ◆ ELineStyle. enum ELineStyle. EnumeratorkSolid ; kDashed ; kDotted ; kDashDotted . Definition at line 48 of file TAttLine.h. corebaseincTAttLine.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TAttLine_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8h.html
https://root.cern/doc/master/TAttMarker_8cxx_source.html:2237,Availability,avail,available,2237,"ef ATTMARKER2); 38 - [Marker line width](\ref ATTMARKER21); 39 - [Marker size](\ref M3); 40 ; 41\anchor ATTMARKER1; 42## Marker color; 43The marker color is a color index (integer) pointing in the ROOT color; 44table.; 45The marker color of any class inheriting from `TAttMarker` can; 46be changed using the method `SetMarkerColor` and retrieved using the; 47method `GetMarkerColor`.; 48The following table shows the first 50 default colors.; 49 ; 50Begin_Macro; 51{; 52 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 53 c->DrawColorTable();; 54 return c;; 55}; 56End_Macro; 57 ; 58### Color transparency; 59 ; 60`SetMarkerColorAlpha()`, allows to set a transparent color.; 61In the following example the marker color of the histogram `histo`; 62is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 63(The color `kBlue` itself is internally stored as fully opaque.); 64 ; 65~~~ {.cpp}; 66histo->SetMarkerColorAlpha(kBlue, 0.35);; 67~~~; 68 ; 69The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 70in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 71it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 72 ; 73Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 74Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 75 ; 76\anchor ATTMARKER2; 77## Marker style; 78 ; 79The Marker style defines the markers' shape.; 80The marker style of any class inheriting from `TAttMarker` can; 81be changed using the method `SetMarkerStyle` and retrieved using the; 82method `GetMarkerStyle`.; 83 ; 84The following list gives the currently supported markers (screen; 85and PostScript) style. Each marker style is identified by an integer number; 86(first column) corresponding to a marker shape (second column) and can be also; 87accessed via a global name (third column).; 88 ; 89~~~ {.cpp}; 90 Mark",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
https://root.cern/doc/master/TAttMarker_8cxx_source.html:3613,Availability,down,down,3613,"reen; 85and PostScript) style. Each marker style is identified by an integer number; 86(first column) corresponding to a marker shape (second column) and can be also; 87accessed via a global name (third column).; 88 ; 89~~~ {.cpp}; 90 Marker number Marker shape Marker name; 91 1 dot kDot; 92 2 + kPlus; 93 3 * kStar; 94 4 o kCircle; 95 5 x kMultiply; 96 6 small dot kFullDotSmall; 97 7 medium dot kFullDotMedium; 98 8 large scalable dot kFullDotLarge; 99 9 -->19 large scalable dot; 100 20 full circle kFullCircle; 101 21 full square kFullSquare; 102 22 full triangle up kFullTriangleUp; 103 23 full triangle down kFullTriangleDown; 104 24 open circle kOpenCircle; 105 25 open square kOpenSquare; 106 26 open triangle up kOpenTriangleUp; 107 27 open diamond kOpenDiamond; 108 28 open cross kOpenCross; 109 29 full star kFullStar; 110 30 open star kOpenStar; 111 31 *; 112 32 open triangle down kOpenTriangleDown; 113 33 full diamond kFullDiamond; 114 34 full cross kFullCross; 115 35 open diamond cross kOpenDiamondCross; 116 36 open square diagonal kOpenSquareDiagonal; 117 37 open three triangle kOpenThreeTriangles; 118 38 octagon with cross kOctagonCross; 119 39 full three triangles kFullThreeTriangles; 120 40 open four triangleX kOpenFourTrianglesX; 121 41 full four triangleX kFullFourTrianglesX; 122 42 open double diamond kOpenDoubleDiamond; 123 43 full double diamond kFullDoubleDiamond; 124 44 open four triangle+ kOpenFourTrianglesPlus; 125 45 full four triangle+ kFullFourTrianglesPlus; 126 46 open cross X kOpenCrossX; 127 47 full cross X kFullCrossX; 128 48 four squares X kFourSquaresX; 129 49 four squares+ kFourSquaresPlus; 130~~~; 131 ; 132Begin_Macro; 133{; 134 TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; 135 TMarker marker;; 136 marker.DisplayMarkerTypes();; 137}; 138End_Macro; 139 ; 140\warning Non-symmetric symbols should be used carefully. See markerwarning.C; 141 ; 142\anchor ATTMARKER21; 143### Marker line width; 144 ; 145The line width of a marker is n",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
https://root.cern/doc/master/TAttMarker_8cxx_source.html:3893,Availability,down,down,3893,"reen; 85and PostScript) style. Each marker style is identified by an integer number; 86(first column) corresponding to a marker shape (second column) and can be also; 87accessed via a global name (third column).; 88 ; 89~~~ {.cpp}; 90 Marker number Marker shape Marker name; 91 1 dot kDot; 92 2 + kPlus; 93 3 * kStar; 94 4 o kCircle; 95 5 x kMultiply; 96 6 small dot kFullDotSmall; 97 7 medium dot kFullDotMedium; 98 8 large scalable dot kFullDotLarge; 99 9 -->19 large scalable dot; 100 20 full circle kFullCircle; 101 21 full square kFullSquare; 102 22 full triangle up kFullTriangleUp; 103 23 full triangle down kFullTriangleDown; 104 24 open circle kOpenCircle; 105 25 open square kOpenSquare; 106 26 open triangle up kOpenTriangleUp; 107 27 open diamond kOpenDiamond; 108 28 open cross kOpenCross; 109 29 full star kFullStar; 110 30 open star kOpenStar; 111 31 *; 112 32 open triangle down kOpenTriangleDown; 113 33 full diamond kFullDiamond; 114 34 full cross kFullCross; 115 35 open diamond cross kOpenDiamondCross; 116 36 open square diagonal kOpenSquareDiagonal; 117 37 open three triangle kOpenThreeTriangles; 118 38 octagon with cross kOctagonCross; 119 39 full three triangles kFullThreeTriangles; 120 40 open four triangleX kOpenFourTrianglesX; 121 41 full four triangleX kFullFourTrianglesX; 122 42 open double diamond kOpenDoubleDiamond; 123 43 full double diamond kFullDoubleDiamond; 124 44 open four triangle+ kOpenFourTrianglesPlus; 125 45 full four triangle+ kFullFourTrianglesPlus; 126 46 open cross X kOpenCrossX; 127 47 full cross X kFullCrossX; 128 48 four squares X kFourSquaresX; 129 49 four squares+ kFourSquaresPlus; 130~~~; 131 ; 132Begin_Macro; 133{; 134 TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; 135 TMarker marker;; 136 marker.DisplayMarkerTypes();; 137}; 138End_Macro; 139 ; 140\warning Non-symmetric symbols should be used carefully. See markerwarning.C; 141 ; 142\anchor ATTMARKER21; 143### Marker line width; 144 ; 145The line width of a marker is n",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
https://root.cern/doc/master/TAttMarker_8cxx_source.html:1014,Modifiability,inherit,inheritance,1014,"src/TAttMarker.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TAttMarker.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 12/05/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""Strlen.h""; 14#include ""TAttMarker.h""; 15#include ""TVirtualPad.h""; 16#include ""TStyle.h""; 17#include ""TVirtualX.h""; 18#include ""TVirtualPadEditor.h""; 19#include ""TColor.h""; 20 ; 21ClassImp(TAttMarker);; 22 ; 23/** \class TAttMarker; 24\ingroup Base; 25\ingroup GraphicsAtt; 26 ; 27Marker Attributes class.; 28 ; 29This class is used (in general by secondary inheritance); 30by many other classes (graphics, histograms). It holds all the markers; 31attributes.; 32 ; 33## Marker attributes; 34The marker attributes are:; 35 ; 36 - [Marker color](\ref ATTMARKER1); 37 - [Marker style](\ref ATTMARKER2); 38 - [Marker line width](\ref ATTMARKER21); 39 - [Marker size](\ref M3); 40 ; 41\anchor ATTMARKER1; 42## Marker color; 43The marker color is a color index (integer) pointing in the ROOT color; 44table.; 45The marker color of any class inheriting from `TAttMarker` can; 46be changed using the method `SetMarkerColor` and retrieved using the; 47method `GetMarkerColor`.; 48The following table shows the first 50 default colors.; 49 ; 50Begin_Macro; 51{; 52 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 53 c->DrawColorTable();; 54 return c;; 55}; 56End_Macro; 57 ; 58### Color transparency; 59 ; 60`SetMarkerColorAlpha()`, allows to set a transparent color.; 61In the following example the marker color of the histogram `histo`; 62is set to blue ",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
https://root.cern/doc/master/TAttMarker_8cxx_source.html:1492,Modifiability,inherit,inheriting,1492,"*************************************************************************/; 11 ; 12#include <iostream>; 13#include ""Strlen.h""; 14#include ""TAttMarker.h""; 15#include ""TVirtualPad.h""; 16#include ""TStyle.h""; 17#include ""TVirtualX.h""; 18#include ""TVirtualPadEditor.h""; 19#include ""TColor.h""; 20 ; 21ClassImp(TAttMarker);; 22 ; 23/** \class TAttMarker; 24\ingroup Base; 25\ingroup GraphicsAtt; 26 ; 27Marker Attributes class.; 28 ; 29This class is used (in general by secondary inheritance); 30by many other classes (graphics, histograms). It holds all the markers; 31attributes.; 32 ; 33## Marker attributes; 34The marker attributes are:; 35 ; 36 - [Marker color](\ref ATTMARKER1); 37 - [Marker style](\ref ATTMARKER2); 38 - [Marker line width](\ref ATTMARKER21); 39 - [Marker size](\ref M3); 40 ; 41\anchor ATTMARKER1; 42## Marker color; 43The marker color is a color index (integer) pointing in the ROOT color; 44table.; 45The marker color of any class inheriting from `TAttMarker` can; 46be changed using the method `SetMarkerColor` and retrieved using the; 47method `GetMarkerColor`.; 48The following table shows the first 50 default colors.; 49 ; 50Begin_Macro; 51{; 52 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 53 c->DrawColorTable();; 54 return c;; 55}; 56End_Macro; 57 ; 58### Color transparency; 59 ; 60`SetMarkerColorAlpha()`, allows to set a transparent color.; 61In the following example the marker color of the histogram `histo`; 62is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 63(The color `kBlue` itself is internally stored as fully opaque.); 64 ; 65~~~ {.cpp}; 66histo->SetMarkerColorAlpha(kBlue, 0.35);; 67~~~; 68 ; 69The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 70in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 71it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 72 ; 73Alternatively, you can call at the top of your scrip",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
https://root.cern/doc/master/TAttMarker_8cxx_source.html:2802,Modifiability,inherit,inheriting,2802,"ansparency; 59 ; 60`SetMarkerColorAlpha()`, allows to set a transparent color.; 61In the following example the marker color of the histogram `histo`; 62is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 63(The color `kBlue` itself is internally stored as fully opaque.); 64 ; 65~~~ {.cpp}; 66histo->SetMarkerColorAlpha(kBlue, 0.35);; 67~~~; 68 ; 69The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 70in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 71it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 72 ; 73Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 74Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 75 ; 76\anchor ATTMARKER2; 77## Marker style; 78 ; 79The Marker style defines the markers' shape.; 80The marker style of any class inheriting from `TAttMarker` can; 81be changed using the method `SetMarkerStyle` and retrieved using the; 82method `GetMarkerStyle`.; 83 ; 84The following list gives the currently supported markers (screen; 85and PostScript) style. Each marker style is identified by an integer number; 86(first column) corresponding to a marker shape (second column) and can be also; 87accessed via a global name (third column).; 88 ; 89~~~ {.cpp}; 90 Marker number Marker shape Marker name; 91 1 dot kDot; 92 2 + kPlus; 93 3 * kStar; 94 4 o kCircle; 95 5 x kMultiply; 96 6 small dot kFullDotSmall; 97 7 medium dot kFullDotMedium; 98 8 large scalable dot kFullDotLarge; 99 9 -->19 large scalable dot; 100 20 full circle kFullCircle; 101 21 full square kFullSquare; 102 22 full triangle up kFullTriangleUp; 103 23 full triangle down kFullTriangleDown; 104 24 open circle kOpenCircle; 105 25 open square kOpenSquare; 106 26 open triangle up kOpenTriangleUp; 107 27 open diamond kOpenDiamond; 108 28 open cross kOpenCross; 109 29 full star kFullStar; 110 30 open star ",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
https://root.cern/doc/master/TAttMarker_8cxx_source.html:6111,Modifiability,inherit,inheriting,6111,"s are redefined with thicker lines by style numbers; 148starting from 50:; 149 ; 150~~~ {.cpp}; 151 Marker numbers Line width; 152 50 - 67 2; 153 68 - 85 3; 154 86 - 103 4; 155 104 - 121 5; 156 ...; 157~~~; 158 ; 159Begin_Macro; 160{; 161 TCanvas *c = new TCanvas(""c"",""Marker line widths"",0,0,600,266);; 162 TMarker marker;; 163 marker.DisplayMarkerLineWidths();; 164}; 165End_Macro; 166 ; 167\anchor M3; 168## Marker size; 169 ; 170Various marker sizes are shown in the figure below. The default marker size=1; 171is shown in the top left corner. Marker sizes smaller than 1 can be; 172specified. The marker size does not refer to any coordinate systems, it is an; 173absolute value. Therefore the marker size is not affected by any change; 174in TPad's scale. A marker size equal to 1 correspond to 8 pixels.; 175That is, a square marker with size 1 will be drawn with a side equal to 8; 176pixels on the screen.; 177 ; 178The marker size of any class inheriting from `TAttMarker` can; 179be changed using the method `SetMarkerSize` and retrieved using the; 180method `GetMarkerSize`.; 181 ; 182Begin_Macro; 183{; 184 auto c = new TCanvas(""c"",""Marker sizes"",0,0,500,200);; 185 TMarker marker;; 186 marker.SetMarkerStyle(3);; 187 Double_t x = 0;; 188 Double_t dx = 1/6.0;; 189 for (Int_t i=1; i<6; i++) {; 190 x += dx;; 191 marker.SetMarkerSize(i*0.2); marker.DrawMarker(x,.165);; 192 marker.SetMarkerSize(i*0.8); marker.DrawMarker(x,.495);; 193 marker.SetMarkerSize(i*1.0); marker.DrawMarker(x,.835);; 194 }; 195}; 196End_Macro; 197 ; 198Note that the marker styles number 1 6 and 7 (the dots), cannot be scaled. They; 199are meant to be very fast to draw and are always drawn with the same number of; 200pixels; therefore `SetMarkerSize` does not apply on them. To have a; 201""scalable dot"" a filled circle should be used instead, i.e. the marker style; 202number 20. By default (if `SetMarkerStyle` is not specified), the marker; 203style used is 1. That's the most common one to draw scatter plo",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
https://root.cern/doc/master/TAttMarker_8cxx_source.html:3428,Performance,scalab,scalable,3428,"reen; 85and PostScript) style. Each marker style is identified by an integer number; 86(first column) corresponding to a marker shape (second column) and can be also; 87accessed via a global name (third column).; 88 ; 89~~~ {.cpp}; 90 Marker number Marker shape Marker name; 91 1 dot kDot; 92 2 + kPlus; 93 3 * kStar; 94 4 o kCircle; 95 5 x kMultiply; 96 6 small dot kFullDotSmall; 97 7 medium dot kFullDotMedium; 98 8 large scalable dot kFullDotLarge; 99 9 -->19 large scalable dot; 100 20 full circle kFullCircle; 101 21 full square kFullSquare; 102 22 full triangle up kFullTriangleUp; 103 23 full triangle down kFullTriangleDown; 104 24 open circle kOpenCircle; 105 25 open square kOpenSquare; 106 26 open triangle up kOpenTriangleUp; 107 27 open diamond kOpenDiamond; 108 28 open cross kOpenCross; 109 29 full star kFullStar; 110 30 open star kOpenStar; 111 31 *; 112 32 open triangle down kOpenTriangleDown; 113 33 full diamond kFullDiamond; 114 34 full cross kFullCross; 115 35 open diamond cross kOpenDiamondCross; 116 36 open square diagonal kOpenSquareDiagonal; 117 37 open three triangle kOpenThreeTriangles; 118 38 octagon with cross kOctagonCross; 119 39 full three triangles kFullThreeTriangles; 120 40 open four triangleX kOpenFourTrianglesX; 121 41 full four triangleX kFullFourTrianglesX; 122 42 open double diamond kOpenDoubleDiamond; 123 43 full double diamond kFullDoubleDiamond; 124 44 open four triangle+ kOpenFourTrianglesPlus; 125 45 full four triangle+ kFullFourTrianglesPlus; 126 46 open cross X kOpenCrossX; 127 47 full cross X kFullCrossX; 128 48 four squares X kFourSquaresX; 129 49 four squares+ kFourSquaresPlus; 130~~~; 131 ; 132Begin_Macro; 133{; 134 TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; 135 TMarker marker;; 136 marker.DisplayMarkerTypes();; 137}; 138End_Macro; 139 ; 140\warning Non-symmetric symbols should be used carefully. See markerwarning.C; 141 ; 142\anchor ATTMARKER21; 143### Marker line width; 144 ; 145The line width of a marker is n",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
https://root.cern/doc/master/TAttMarker_8cxx_source.html:3473,Performance,scalab,scalable,3473,"reen; 85and PostScript) style. Each marker style is identified by an integer number; 86(first column) corresponding to a marker shape (second column) and can be also; 87accessed via a global name (third column).; 88 ; 89~~~ {.cpp}; 90 Marker number Marker shape Marker name; 91 1 dot kDot; 92 2 + kPlus; 93 3 * kStar; 94 4 o kCircle; 95 5 x kMultiply; 96 6 small dot kFullDotSmall; 97 7 medium dot kFullDotMedium; 98 8 large scalable dot kFullDotLarge; 99 9 -->19 large scalable dot; 100 20 full circle kFullCircle; 101 21 full square kFullSquare; 102 22 full triangle up kFullTriangleUp; 103 23 full triangle down kFullTriangleDown; 104 24 open circle kOpenCircle; 105 25 open square kOpenSquare; 106 26 open triangle up kOpenTriangleUp; 107 27 open diamond kOpenDiamond; 108 28 open cross kOpenCross; 109 29 full star kFullStar; 110 30 open star kOpenStar; 111 31 *; 112 32 open triangle down kOpenTriangleDown; 113 33 full diamond kFullDiamond; 114 34 full cross kFullCross; 115 35 open diamond cross kOpenDiamondCross; 116 36 open square diagonal kOpenSquareDiagonal; 117 37 open three triangle kOpenThreeTriangles; 118 38 octagon with cross kOctagonCross; 119 39 full three triangles kFullThreeTriangles; 120 40 open four triangleX kOpenFourTrianglesX; 121 41 full four triangleX kFullFourTrianglesX; 122 42 open double diamond kOpenDoubleDiamond; 123 43 full double diamond kFullDoubleDiamond; 124 44 open four triangle+ kOpenFourTrianglesPlus; 125 45 full four triangle+ kFullFourTrianglesPlus; 126 46 open cross X kOpenCrossX; 127 47 full cross X kFullCrossX; 128 48 four squares X kFourSquaresX; 129 49 four squares+ kFourSquaresPlus; 130~~~; 131 ; 132Begin_Macro; 133{; 134 TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; 135 TMarker marker;; 136 marker.DisplayMarkerTypes();; 137}; 138End_Macro; 139 ; 140\warning Non-symmetric symbols should be used carefully. See markerwarning.C; 141 ; 142\anchor ATTMARKER21; 143### Marker line width; 144 ; 145The line width of a marker is n",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
https://root.cern/doc/master/TAttMarker_8cxx_source.html:6937,Performance,scalab,scalable,6937," 8 pixels.; 175That is, a square marker with size 1 will be drawn with a side equal to 8; 176pixels on the screen.; 177 ; 178The marker size of any class inheriting from `TAttMarker` can; 179be changed using the method `SetMarkerSize` and retrieved using the; 180method `GetMarkerSize`.; 181 ; 182Begin_Macro; 183{; 184 auto c = new TCanvas(""c"",""Marker sizes"",0,0,500,200);; 185 TMarker marker;; 186 marker.SetMarkerStyle(3);; 187 Double_t x = 0;; 188 Double_t dx = 1/6.0;; 189 for (Int_t i=1; i<6; i++) {; 190 x += dx;; 191 marker.SetMarkerSize(i*0.2); marker.DrawMarker(x,.165);; 192 marker.SetMarkerSize(i*0.8); marker.DrawMarker(x,.495);; 193 marker.SetMarkerSize(i*1.0); marker.DrawMarker(x,.835);; 194 }; 195}; 196End_Macro; 197 ; 198Note that the marker styles number 1 6 and 7 (the dots), cannot be scaled. They; 199are meant to be very fast to draw and are always drawn with the same number of; 200pixels; therefore `SetMarkerSize` does not apply on them. To have a; 201""scalable dot"" a filled circle should be used instead, i.e. the marker style; 202number 20. By default (if `SetMarkerStyle` is not specified), the marker; 203style used is 1. That's the most common one to draw scatter plots.; 204*/; 205 ; 206////////////////////////////////////////////////////////////////////////////////; 207/// TAttMarker default constructor.; 208///; 209/// Default text attributes are taking from the current style.; 210 ; 211TAttMarker::TAttMarker(); 212{; 213 if (!gStyle) {fMarkerColor=1; fMarkerStyle=1; fMarkerSize=1; return;}; 214 fMarkerColor = gStyle->GetMarkerColor();; 215 fMarkerStyle = gStyle->GetMarkerStyle();; 216 fMarkerSize = gStyle->GetMarkerSize();; 217}; 218 ; 219////////////////////////////////////////////////////////////////////////////////; 220/// TAttMarker normal constructor.; 221///; 222/// Text attributes are taking from the argument list; 223/// - color : Marker Color Index; 224/// - style : Marker style (from 1 to 30); 225/// - size : marker size (float); 226 ; 22",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
https://root.cern/doc/master/TAttMarker_8h.html:216,Integrability,depend,dependency,216,". ROOT: core/base/inc/TAttMarker.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TAttMarker.h File Reference. #include ""Rtypes.h"". Include dependency graph for TAttMarker.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TAttMarker;  Marker Attributes class. More...;  . Enumerations; enum  EMarkerStyle { ;   kDot =1; , kPlus; , kStar; , kCircle =4; , ;   kMultiply =5; , kFullDotSmall =6; , kFullDotMedium =7; , kFullDotLarge =8; , ;   kFullCircle =20; , kFullSquare =21; , kFullTriangleUp =22; , kFullTriangleDown =23; , ;   kOpenCircle =24; , kOpenSquare =25; , kOpenTriangleUp =26; , kOpenDiamond =27; , ;   kOpenCross =28; , kFullStar =29; , kOpenStar =30; , kOpenTriangleDown =32; , ;   kFullDiamond =33; , kFullCross =34; , kOpenDiamondCross =35; , kOpenSquareDiagonal =36; , ;   kOpenThreeTriangles =37; , kOctagonCross =38; , kFullThreeTriangles =39; , kOpenFourTrianglesX =40; , ;   kFullFourTrianglesX =41; , kOpenDoubleDiamond =42; , kFullDoubleDiamond =43; , kOpenFourTrianglesPlus =44; , ;   kFullFourTrianglesPlus =45; , kOpenCrossX =46; , kFullCrossX =47; , kFourSquaresX =48; , ;   kFourSquaresPlus =49. };  . Enumeration Type Documentation. ◆ EMarkerStyle. enum EMarkerStyle. EnumeratorkDot ; kPlus ; kStar ; kCircle ; kMultiply ; kFullDotSmall ; kFullDotMedium ; kFullDotLarge ; kFullCircle ; kFullSquare ; kFullTriangleUp ; kFullTriangleDown ; kOpenCircle ; kOpenSquare ; kOpenTriangleUp ; kOpenDiamond ; kOpenCross ; kFullStar ; kOpenStar ; kOpenTriangleDown ; kFullDiamond ; kFullCross ; kOpenDiamondCross ; kOpenSquareDiagonal ; kOpenThreeTriangles ; kOctagonCross ; kFullThreeTriangles ; kOpenFourTrianglesX ; kFullFourTrianglesX ; kOpenDoubleDiamond ; kFullDoubleDiamond ; kOpenFourTria",MatchSource.WIKI,doc/master/TAttMarker_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8h.html
https://root.cern/doc/master/TAttText_8cxx_source.html:2526,Availability,avail,available,2526,"ported fonts](\ref ATTTEXT53); 45 ; 46\anchor ATTTEXT1; 47## Text Alignment; 48 ; 49The text alignment is an integer number (`align`) allowing to control; 50the horizontal and vertical position of the text string with respect; 51to the text position.; 52The text alignment of any class inheriting from `TAttText` can; 53be changed using the method `SetTextAlign` and retrieved using the; 54method `GetTextAlign`.; 55 ; 56~~~ {.cpp}; 57 align = 10*HorizontalAlign + VerticalAlign; 58~~~; 59 ; 60For horizontal alignment the following convention applies:; 61 ; 62~~~ {.cpp}; 63 1=left adjusted, 2=centered, 3=right adjusted; 64~~~; 65 ; 66For vertical alignment the following convention applies:; 67 ; 68~~~ {.cpp}; 69 1=bottom adjusted, 2=centered, 3=top adjusted; 70~~~; 71 ; 72For example:; 73 ; 74~~~ {.cpp}; 75 align = 11 = left adjusted and bottom adjusted; 76 align = 32 = right adjusted and vertically centered; 77~~~; 78 ; 79Begin_Macro(source); 80textalign.C; 81End_Macro; 82 ; 83Mnemonic constants are available:; 84 ; 85~~~ {.cpp}; 86kHAlignLeft = 10, kHAlignCenter = 20, kHAlignRight = 30,; 87kVAlignBottom = 1, kVAlignCenter = 2, kVAlignTop = 3; 88~~~; 89 ; 90They allow to write:; 91 ; 92~~~ {.cpp}; 93object->SetTextAlign(kHAlignLeft+kVAlignTop);; 94~~~; 95 ; 96\anchor ATTTEXT2; 97## Text Angle; 98 ; 99Text angle in degrees.; 100The text angle of any class inheriting from `TAttText` can; 101be changed using the method `SetTextAngle` and retrieved using the; 102method `GetTextAngle`.; 103The following picture shows the text angle:; 104 ; 105Begin_Macro(source); 106textangle.C; 107End_Macro; 108 ; 109\anchor ATTTEXT3; 110## Text Color; 111 ; 112The text color is a color index (integer) pointing in the ROOT; 113color table.; 114The text color of any class inheriting from `TAttText` can; 115be changed using the method `SetTextColor` and retrieved using the; 116method `GetTextColor`.; 117The following table shows the first 50 default colors.; 118 ; 119Begin_Macro; 120{; 121 TCa",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:4036,Availability,avail,available,4036,"ure shows the text angle:; 104 ; 105Begin_Macro(source); 106textangle.C; 107End_Macro; 108 ; 109\anchor ATTTEXT3; 110## Text Color; 111 ; 112The text color is a color index (integer) pointing in the ROOT; 113color table.; 114The text color of any class inheriting from `TAttText` can; 115be changed using the method `SetTextColor` and retrieved using the; 116method `GetTextColor`.; 117The following table shows the first 50 default colors.; 118 ; 119Begin_Macro; 120{; 121 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 122 c->DrawColorTable();; 123 return c;; 124}; 125End_Macro; 126 ; 127### Color transparency; 128`SetTextColorAlpha()`, allows to set a transparent color.; 129In the following example the text color of the text `text`; 130is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 131(The color `kBlue` itself is internally stored as fully opaque.); 132 ; 133~~~ {.cpp}; 134text->SetTextColorAlpha(kBlue, 0.35);; 135~~~; 136 ; 137The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 138in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 139it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 140 ; 141Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 142Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 143 ; 144\anchor ATTTEXT4; 145## Text Size; 146 ; 147If the text precision (see next paragraph) is smaller than 3, the text; 148size (`textsize`) is a fraction of the current pad size. Therefore the; 149same `textsize` value can generate text outputs with different absolute; 150sizes in two different pads.; 151The text size in pixels (`charheight`) is computed the following way:; 152 ; 153~~~ {.cpp}; 154 pad_width = gPad->XtoPixel(gPad->GetX2());; 155 pad_height = gPad->YtoPixel(gPad->GetY1());; 156 if (pad_width < pad_height) charheight = textsize*pad_width",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:8365,Availability,avail,available,8365,".cpp}; 222 Font number TTF Names PostScript/PDF Names; 223 1 : ""Free Serif Italic"" ""Times-Italic""; 224 2 : ""Free Serif Bold"" ""Times-Bold""; 225 3 : ""Free Serif Bold Italic"" ""Times-BoldItalic""; 226 4 : ""Tex Gyre Regular"" ""Helvetica""; 227 5 : ""Tex Gyre Italic"" ""Helvetica-Oblique""; 228 6 : ""Tex Gyre Bold"" ""Helvetica-Bold""; 229 7 : ""Tex Gyre Bold Italic"" ""Helvetica-BoldOblique""; 230 8 : ""Free Mono"" ""Courier""; 231 9 : ""Free Mono Oblique"" ""Courier-Oblique""; 232 10 : ""Free Mono Bold"" ""Courier-Bold""; 233 11 : ""Free Mono Bold Oblique"" ""Courier-BoldOblique""; 234 12 : ""Symbol"" ""Symbol""; 235 13 : ""Free Serif"" ""Times-Roman""; 236 14 : ""Wingdings"" ""ZapfDingbats""; 237~~~; 238 ; 239The PostScript and PDF backends use the original PostScript-defined 13 fonts' styles; 240forming four type families (Courier, Helvetica, Times, Symbol) as listed in the; 241""Core Font Set"" section of [this page](https://en.wikipedia.org/wiki/PostScript_fonts).; 242These fonts are always available and do not need to be loaded in the PS or PDF files; 243allowing to keep the files' sizes small.; 244 ; 245On screen, text is rendered using free TTF fonts similar to the PDF ones. The corresponding; 246font files are coming with the ROOT distribution in `$ROOTSYS/fonts/Free*`.; 247 ; 248Begin_Macro; 249fonts.C; 250End_Macro; 251*/; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// AttText default constructor.; 255///; 256/// Default text attributes are taken from the current style.; 257 ; 258TAttText::TAttText(); 259{; 260 if (!gStyle) {; 261 ResetAttText();; 262 return;; 263 }; 264 fTextAlign = gStyle->GetTextAlign();; 265 fTextAngle = gStyle->GetTextAngle();; 266 fTextColor = gStyle->GetTextColor();; 267 fTextFont = gStyle->GetTextFont();; 268 fTextSize = gStyle->GetTextSize();; 269}; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// AttText normal constructor.; 273///; 274/// Text attributes are taken from the argum",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:5162,Integrability,depend,depend,5162," available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 138in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 139it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 140 ; 141Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 142Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 143 ; 144\anchor ATTTEXT4; 145## Text Size; 146 ; 147If the text precision (see next paragraph) is smaller than 3, the text; 148size (`textsize`) is a fraction of the current pad size. Therefore the; 149same `textsize` value can generate text outputs with different absolute; 150sizes in two different pads.; 151The text size in pixels (`charheight`) is computed the following way:; 152 ; 153~~~ {.cpp}; 154 pad_width = gPad->XtoPixel(gPad->GetX2());; 155 pad_height = gPad->YtoPixel(gPad->GetY1());; 156 if (pad_width < pad_height) charheight = textsize*pad_width;; 157 else charheight = textsize*pad_height;; 158~~~; 159 ; 160If the text precision is equal to 3, the text size doesn't depend on the pad's; 161dimensions. A given `textsize` value always generates the same absolute; 162size. The text size (`charheight`) is given in pixels:; 163 ; 164~~~ {.cpp}; 165 charheight = textsize;; 166~~~; 167 ; 168Note that to scale fonts to the same size as the old True Type package a; 169scale factor of `0.93376068` is apply to the text size before drawing.; 170 ; 171The text size of any class inheriting from `TAttText` can; 172be changed using the method `SetTextSize` and retrieved using the; 173method `GetTextSize`.; 174 ; 175\anchor ATTTEXT5; 176## Text Font and Precision; 177 ; 178The text font code is combination of the font number and the precision.; 179~~~ {.cpp}; 180 Text font code = 10*fontnumber + precision; 181~~~; 182Font numbers must be between 1 and 14.; 183 ; 184The precision can be:; 185 ; 186 - `precision = 0` fast hardware fonts (ste",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:6849,Integrability,depend,depending,6849,"; 180 Text font code = 10*fontnumber + precision; 181~~~; 182Font numbers must be between 1 and 14.; 183 ; 184The precision can be:; 185 ; 186 - `precision = 0` fast hardware fonts (steps in the size); 187 - `precision = 1` scalable and rotatable hardware fonts (see below); 188 - `precision = 2` scalable and rotatable hardware fonts; 189 - `precision = 3` scalable and rotatable hardware fonts. Text size; 190 is given in pixels.; 191 ; 192The text font and precision of any class inheriting from `TAttText` can; 193be changed using the method `SetTextFont` and retrieved using the; 194method `GetTextFont`.; 195 ; 196\anchor ATTTEXT51; 197### Font quality and speed; 198 ; 199When precision 0 is used, only the original non-scaled X11 system fonts are; 200used. The fonts have a minimum (4) and maximum (37) size in pixels. These; 201fonts are fast and are of good quality. Their size varies with large steps; 202and they cannot be rotated.; 203Precision 1 and 2 fonts have a different behaviour depending if the; 204True Type Fonts (TTF) are used or not. If TTF are used, you always get very good; 205quality scalable and rotatable fonts.; 206These days TTF fonts are rendered fast enough and can be used in all cases.; 207 ; 208\anchor ATTTEXT52; 209### How to use True Type Fonts; 210 ; 211TTF fonts are used by default. They can be deactivated via the following line; 212in the `.rootrc` file:; 213 ; 214~~~ {.cpp}; 215 Unix.*.Root.UseTTFonts: false; 216~~~; 217 ; 218\anchor ATTTEXT53; 219### List of the currently supported fonts; 220 ; 221~~~ {.cpp}; 222 Font number TTF Names PostScript/PDF Names; 223 1 : ""Free Serif Italic"" ""Times-Italic""; 224 2 : ""Free Serif Bold"" ""Times-Bold""; 225 3 : ""Free Serif Bold Italic"" ""Times-BoldItalic""; 226 4 : ""Tex Gyre Regular"" ""Helvetica""; 227 5 : ""Tex Gyre Italic"" ""Helvetica-Oblique""; 228 6 : ""Tex Gyre Bold"" ""Helvetica-Bold""; 229 7 : ""Tex Gyre Bold Italic"" ""Helvetica-BoldOblique""; 230 8 : ""Free Mono"" ""Courier""; 231 9 : ""Free Mono Oblique"" ""Courier-Ob",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:1047,Modifiability,inherit,inheritance,1047,"OOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TAttText.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 12/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""Strlen.h""; 14#include ""TROOT.h""; 15#include ""TAttText.h""; 16#include ""TVirtualPad.h""; 17#include ""TStyle.h""; 18#include ""TVirtualX.h""; 19#include ""TError.h""; 20#include ""TVirtualPadEditor.h""; 21#include ""TColor.h""; 22 ; 23ClassImp(TAttText);; 24 ; 25/** \class TAttText; 26\ingroup Base; 27\ingroup GraphicsAtt; 28 ; 29Text Attributes class.; 30 ; 31This class is used (in general by secondary inheritance); 32by many other classes (graphics, histograms). It holds all the text attributes.; 33 ; 34## Text attributes; 35Text attributes are:; 36 ; 37 - [Text Alignment](\ref ATTTEXT1); 38 - [Text Angle](\ref ATTTEXT2); 39 - [Text Color](\ref ATTTEXT3); 40 - [Text Size](\ref ATTTEXT4); 41 - [Text Font and Precision](\ref ATTTEXT5); 42 - [Font quality and speed](\ref ATTTEXT51); 43 - [How to use True Type Fonts](\ref ATTTEXT52); 44 - [List of the currently supported fonts](\ref ATTTEXT53); 45 ; 46\anchor ATTTEXT1; 47## Text Alignment; 48 ; 49The text alignment is an integer number (`align`) allowing to control; 50the horizontal and vertical position of the text string with respect; 51to the text position.; 52The text alignment of any class inheriting from `TAttText` can; 53be changed using the method `SetTextAlign` and retrieved using the; 54method `GetTextAlign`.; 55 ; 56~~~ {.cpp}; 57 align = 10*HorizontalAlign + VerticalAlign; 58~~~; 59 ; 60For horizontal alignment the following con",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:1801,Modifiability,inherit,inheriting,1801,"1#include ""TColor.h""; 22 ; 23ClassImp(TAttText);; 24 ; 25/** \class TAttText; 26\ingroup Base; 27\ingroup GraphicsAtt; 28 ; 29Text Attributes class.; 30 ; 31This class is used (in general by secondary inheritance); 32by many other classes (graphics, histograms). It holds all the text attributes.; 33 ; 34## Text attributes; 35Text attributes are:; 36 ; 37 - [Text Alignment](\ref ATTTEXT1); 38 - [Text Angle](\ref ATTTEXT2); 39 - [Text Color](\ref ATTTEXT3); 40 - [Text Size](\ref ATTTEXT4); 41 - [Text Font and Precision](\ref ATTTEXT5); 42 - [Font quality and speed](\ref ATTTEXT51); 43 - [How to use True Type Fonts](\ref ATTTEXT52); 44 - [List of the currently supported fonts](\ref ATTTEXT53); 45 ; 46\anchor ATTTEXT1; 47## Text Alignment; 48 ; 49The text alignment is an integer number (`align`) allowing to control; 50the horizontal and vertical position of the text string with respect; 51to the text position.; 52The text alignment of any class inheriting from `TAttText` can; 53be changed using the method `SetTextAlign` and retrieved using the; 54method `GetTextAlign`.; 55 ; 56~~~ {.cpp}; 57 align = 10*HorizontalAlign + VerticalAlign; 58~~~; 59 ; 60For horizontal alignment the following convention applies:; 61 ; 62~~~ {.cpp}; 63 1=left adjusted, 2=centered, 3=right adjusted; 64~~~; 65 ; 66For vertical alignment the following convention applies:; 67 ; 68~~~ {.cpp}; 69 1=bottom adjusted, 2=centered, 3=top adjusted; 70~~~; 71 ; 72For example:; 73 ; 74~~~ {.cpp}; 75 align = 11 = left adjusted and bottom adjusted; 76 align = 32 = right adjusted and vertically centered; 77~~~; 78 ; 79Begin_Macro(source); 80textalign.C; 81End_Macro; 82 ; 83Mnemonic constants are available:; 84 ; 85~~~ {.cpp}; 86kHAlignLeft = 10, kHAlignCenter = 20, kHAlignRight = 30,; 87kVAlignBottom = 1, kVAlignCenter = 2, kVAlignTop = 3; 88~~~; 89 ; 90They allow to write:; 91 ; 92~~~ {.cpp}; 93object->SetTextAlign(kHAlignLeft+kVAlignTop);; 94~~~; 95 ; 96\anchor ATTTEXT2; 97## Text Angle; 98 ; 99Text angle in",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:2888,Modifiability,inherit,inheriting,2888,"6~~~ {.cpp}; 57 align = 10*HorizontalAlign + VerticalAlign; 58~~~; 59 ; 60For horizontal alignment the following convention applies:; 61 ; 62~~~ {.cpp}; 63 1=left adjusted, 2=centered, 3=right adjusted; 64~~~; 65 ; 66For vertical alignment the following convention applies:; 67 ; 68~~~ {.cpp}; 69 1=bottom adjusted, 2=centered, 3=top adjusted; 70~~~; 71 ; 72For example:; 73 ; 74~~~ {.cpp}; 75 align = 11 = left adjusted and bottom adjusted; 76 align = 32 = right adjusted and vertically centered; 77~~~; 78 ; 79Begin_Macro(source); 80textalign.C; 81End_Macro; 82 ; 83Mnemonic constants are available:; 84 ; 85~~~ {.cpp}; 86kHAlignLeft = 10, kHAlignCenter = 20, kHAlignRight = 30,; 87kVAlignBottom = 1, kVAlignCenter = 2, kVAlignTop = 3; 88~~~; 89 ; 90They allow to write:; 91 ; 92~~~ {.cpp}; 93object->SetTextAlign(kHAlignLeft+kVAlignTop);; 94~~~; 95 ; 96\anchor ATTTEXT2; 97## Text Angle; 98 ; 99Text angle in degrees.; 100The text angle of any class inheriting from `TAttText` can; 101be changed using the method `SetTextAngle` and retrieved using the; 102method `GetTextAngle`.; 103The following picture shows the text angle:; 104 ; 105Begin_Macro(source); 106textangle.C; 107End_Macro; 108 ; 109\anchor ATTTEXT3; 110## Text Color; 111 ; 112The text color is a color index (integer) pointing in the ROOT; 113color table.; 114The text color of any class inheriting from `TAttText` can; 115be changed using the method `SetTextColor` and retrieved using the; 116method `GetTextColor`.; 117The following table shows the first 50 default colors.; 118 ; 119Begin_Macro; 120{; 121 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 122 c->DrawColorTable();; 123 return c;; 124}; 125End_Macro; 126 ; 127### Color transparency; 128`SetTextColorAlpha()`, allows to set a transparent color.; 129In the following example the text color of the text `text`; 130is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 131(The color `kBlue` itself is internally stored as fully opaque.); ",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:3292,Modifiability,inherit,inheriting,3292," = left adjusted and bottom adjusted; 76 align = 32 = right adjusted and vertically centered; 77~~~; 78 ; 79Begin_Macro(source); 80textalign.C; 81End_Macro; 82 ; 83Mnemonic constants are available:; 84 ; 85~~~ {.cpp}; 86kHAlignLeft = 10, kHAlignCenter = 20, kHAlignRight = 30,; 87kVAlignBottom = 1, kVAlignCenter = 2, kVAlignTop = 3; 88~~~; 89 ; 90They allow to write:; 91 ; 92~~~ {.cpp}; 93object->SetTextAlign(kHAlignLeft+kVAlignTop);; 94~~~; 95 ; 96\anchor ATTTEXT2; 97## Text Angle; 98 ; 99Text angle in degrees.; 100The text angle of any class inheriting from `TAttText` can; 101be changed using the method `SetTextAngle` and retrieved using the; 102method `GetTextAngle`.; 103The following picture shows the text angle:; 104 ; 105Begin_Macro(source); 106textangle.C; 107End_Macro; 108 ; 109\anchor ATTTEXT3; 110## Text Color; 111 ; 112The text color is a color index (integer) pointing in the ROOT; 113color table.; 114The text color of any class inheriting from `TAttText` can; 115be changed using the method `SetTextColor` and retrieved using the; 116method `GetTextColor`.; 117The following table shows the first 50 default colors.; 118 ; 119Begin_Macro; 120{; 121 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 122 c->DrawColorTable();; 123 return c;; 124}; 125End_Macro; 126 ; 127### Color transparency; 128`SetTextColorAlpha()`, allows to set a transparent color.; 129In the following example the text color of the text `text`; 130is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 131(The color `kBlue` itself is internally stored as fully opaque.); 132 ; 133~~~ {.cpp}; 134text->SetTextColorAlpha(kBlue, 0.35);; 135~~~; 136 ; 137The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 138in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 139it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 140 ; 141Alternatively, you can call at the top of your s",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:5569,Modifiability,inherit,inheriting,5569,"tsize`) is a fraction of the current pad size. Therefore the; 149same `textsize` value can generate text outputs with different absolute; 150sizes in two different pads.; 151The text size in pixels (`charheight`) is computed the following way:; 152 ; 153~~~ {.cpp}; 154 pad_width = gPad->XtoPixel(gPad->GetX2());; 155 pad_height = gPad->YtoPixel(gPad->GetY1());; 156 if (pad_width < pad_height) charheight = textsize*pad_width;; 157 else charheight = textsize*pad_height;; 158~~~; 159 ; 160If the text precision is equal to 3, the text size doesn't depend on the pad's; 161dimensions. A given `textsize` value always generates the same absolute; 162size. The text size (`charheight`) is given in pixels:; 163 ; 164~~~ {.cpp}; 165 charheight = textsize;; 166~~~; 167 ; 168Note that to scale fonts to the same size as the old True Type package a; 169scale factor of `0.93376068` is apply to the text size before drawing.; 170 ; 171The text size of any class inheriting from `TAttText` can; 172be changed using the method `SetTextSize` and retrieved using the; 173method `GetTextSize`.; 174 ; 175\anchor ATTTEXT5; 176## Text Font and Precision; 177 ; 178The text font code is combination of the font number and the precision.; 179~~~ {.cpp}; 180 Text font code = 10*fontnumber + precision; 181~~~; 182Font numbers must be between 1 and 14.; 183 ; 184The precision can be:; 185 ; 186 - `precision = 0` fast hardware fonts (steps in the size); 187 - `precision = 1` scalable and rotatable hardware fonts (see below); 188 - `precision = 2` scalable and rotatable hardware fonts; 189 - `precision = 3` scalable and rotatable hardware fonts. Text size; 190 is given in pixels.; 191 ; 192The text font and precision of any class inheriting from `TAttText` can; 193be changed using the method `SetTextFont` and retrieved using the; 194method `GetTextFont`.; 195 ; 196\anchor ATTTEXT51; 197### Font quality and speed; 198 ; 199When precision 0 is used, only the original non-scaled X11 system fonts are; 200used",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:6333,Modifiability,inherit,inheriting,6333,"~~~; 167 ; 168Note that to scale fonts to the same size as the old True Type package a; 169scale factor of `0.93376068` is apply to the text size before drawing.; 170 ; 171The text size of any class inheriting from `TAttText` can; 172be changed using the method `SetTextSize` and retrieved using the; 173method `GetTextSize`.; 174 ; 175\anchor ATTTEXT5; 176## Text Font and Precision; 177 ; 178The text font code is combination of the font number and the precision.; 179~~~ {.cpp}; 180 Text font code = 10*fontnumber + precision; 181~~~; 182Font numbers must be between 1 and 14.; 183 ; 184The precision can be:; 185 ; 186 - `precision = 0` fast hardware fonts (steps in the size); 187 - `precision = 1` scalable and rotatable hardware fonts (see below); 188 - `precision = 2` scalable and rotatable hardware fonts; 189 - `precision = 3` scalable and rotatable hardware fonts. Text size; 190 is given in pixels.; 191 ; 192The text font and precision of any class inheriting from `TAttText` can; 193be changed using the method `SetTextFont` and retrieved using the; 194method `GetTextFont`.; 195 ; 196\anchor ATTTEXT51; 197### Font quality and speed; 198 ; 199When precision 0 is used, only the original non-scaled X11 system fonts are; 200used. The fonts have a minimum (4) and maximum (37) size in pixels. These; 201fonts are fast and are of good quality. Their size varies with large steps; 202and they cannot be rotated.; 203Precision 1 and 2 fonts have a different behaviour depending if the; 204True Type Fonts (TTF) are used or not. If TTF are used, you always get very good; 205quality scalable and rotatable fonts.; 206These days TTF fonts are rendered fast enough and can be used in all cases.; 207 ; 208\anchor ATTTEXT52; 209### How to use True Type Fonts; 210 ; 211TTF fonts are used by default. They can be deactivated via the following line; 212in the `.rootrc` file:; 213 ; 214~~~ {.cpp}; 215 Unix.*.Root.UseTTFonts: false; 216~~~; 217 ; 218\anchor ATTTEXT53; 219### List of the current",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:6074,Performance,scalab,scalable,6074," ; 160If the text precision is equal to 3, the text size doesn't depend on the pad's; 161dimensions. A given `textsize` value always generates the same absolute; 162size. The text size (`charheight`) is given in pixels:; 163 ; 164~~~ {.cpp}; 165 charheight = textsize;; 166~~~; 167 ; 168Note that to scale fonts to the same size as the old True Type package a; 169scale factor of `0.93376068` is apply to the text size before drawing.; 170 ; 171The text size of any class inheriting from `TAttText` can; 172be changed using the method `SetTextSize` and retrieved using the; 173method `GetTextSize`.; 174 ; 175\anchor ATTTEXT5; 176## Text Font and Precision; 177 ; 178The text font code is combination of the font number and the precision.; 179~~~ {.cpp}; 180 Text font code = 10*fontnumber + precision; 181~~~; 182Font numbers must be between 1 and 14.; 183 ; 184The precision can be:; 185 ; 186 - `precision = 0` fast hardware fonts (steps in the size); 187 - `precision = 1` scalable and rotatable hardware fonts (see below); 188 - `precision = 2` scalable and rotatable hardware fonts; 189 - `precision = 3` scalable and rotatable hardware fonts. Text size; 190 is given in pixels.; 191 ; 192The text font and precision of any class inheriting from `TAttText` can; 193be changed using the method `SetTextFont` and retrieved using the; 194method `GetTextFont`.; 195 ; 196\anchor ATTTEXT51; 197### Font quality and speed; 198 ; 199When precision 0 is used, only the original non-scaled X11 system fonts are; 200used. The fonts have a minimum (4) and maximum (37) size in pixels. These; 201fonts are fast and are of good quality. Their size varies with large steps; 202and they cannot be rotated.; 203Precision 1 and 2 fonts have a different behaviour depending if the; 204True Type Fonts (TTF) are used or not. If TTF are used, you always get very good; 205quality scalable and rotatable fonts.; 206These days TTF fonts are rendered fast enough and can be used in all cases.; 207 ; 208\anchor ATTTEXT",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:6147,Performance,scalab,scalable,6147," ; 160If the text precision is equal to 3, the text size doesn't depend on the pad's; 161dimensions. A given `textsize` value always generates the same absolute; 162size. The text size (`charheight`) is given in pixels:; 163 ; 164~~~ {.cpp}; 165 charheight = textsize;; 166~~~; 167 ; 168Note that to scale fonts to the same size as the old True Type package a; 169scale factor of `0.93376068` is apply to the text size before drawing.; 170 ; 171The text size of any class inheriting from `TAttText` can; 172be changed using the method `SetTextSize` and retrieved using the; 173method `GetTextSize`.; 174 ; 175\anchor ATTTEXT5; 176## Text Font and Precision; 177 ; 178The text font code is combination of the font number and the precision.; 179~~~ {.cpp}; 180 Text font code = 10*fontnumber + precision; 181~~~; 182Font numbers must be between 1 and 14.; 183 ; 184The precision can be:; 185 ; 186 - `precision = 0` fast hardware fonts (steps in the size); 187 - `precision = 1` scalable and rotatable hardware fonts (see below); 188 - `precision = 2` scalable and rotatable hardware fonts; 189 - `precision = 3` scalable and rotatable hardware fonts. Text size; 190 is given in pixels.; 191 ; 192The text font and precision of any class inheriting from `TAttText` can; 193be changed using the method `SetTextFont` and retrieved using the; 194method `GetTextFont`.; 195 ; 196\anchor ATTTEXT51; 197### Font quality and speed; 198 ; 199When precision 0 is used, only the original non-scaled X11 system fonts are; 200used. The fonts have a minimum (4) and maximum (37) size in pixels. These; 201fonts are fast and are of good quality. Their size varies with large steps; 202and they cannot be rotated.; 203Precision 1 and 2 fonts have a different behaviour depending if the; 204True Type Fonts (TTF) are used or not. If TTF are used, you always get very good; 205quality scalable and rotatable fonts.; 206These days TTF fonts are rendered fast enough and can be used in all cases.; 207 ; 208\anchor ATTTEXT",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:6208,Performance,scalab,scalable,6208," ; 160If the text precision is equal to 3, the text size doesn't depend on the pad's; 161dimensions. A given `textsize` value always generates the same absolute; 162size. The text size (`charheight`) is given in pixels:; 163 ; 164~~~ {.cpp}; 165 charheight = textsize;; 166~~~; 167 ; 168Note that to scale fonts to the same size as the old True Type package a; 169scale factor of `0.93376068` is apply to the text size before drawing.; 170 ; 171The text size of any class inheriting from `TAttText` can; 172be changed using the method `SetTextSize` and retrieved using the; 173method `GetTextSize`.; 174 ; 175\anchor ATTTEXT5; 176## Text Font and Precision; 177 ; 178The text font code is combination of the font number and the precision.; 179~~~ {.cpp}; 180 Text font code = 10*fontnumber + precision; 181~~~; 182Font numbers must be between 1 and 14.; 183 ; 184The precision can be:; 185 ; 186 - `precision = 0` fast hardware fonts (steps in the size); 187 - `precision = 1` scalable and rotatable hardware fonts (see below); 188 - `precision = 2` scalable and rotatable hardware fonts; 189 - `precision = 3` scalable and rotatable hardware fonts. Text size; 190 is given in pixels.; 191 ; 192The text font and precision of any class inheriting from `TAttText` can; 193be changed using the method `SetTextFont` and retrieved using the; 194method `GetTextFont`.; 195 ; 196\anchor ATTTEXT51; 197### Font quality and speed; 198 ; 199When precision 0 is used, only the original non-scaled X11 system fonts are; 200used. The fonts have a minimum (4) and maximum (37) size in pixels. These; 201fonts are fast and are of good quality. Their size varies with large steps; 202and they cannot be rotated.; 203Precision 1 and 2 fonts have a different behaviour depending if the; 204True Type Fonts (TTF) are used or not. If TTF are used, you always get very good; 205quality scalable and rotatable fonts.; 206These days TTF fonts are rendered fast enough and can be used in all cases.; 207 ; 208\anchor ATTTEXT",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:6963,Performance,scalab,scalable,6963," 183 ; 184The precision can be:; 185 ; 186 - `precision = 0` fast hardware fonts (steps in the size); 187 - `precision = 1` scalable and rotatable hardware fonts (see below); 188 - `precision = 2` scalable and rotatable hardware fonts; 189 - `precision = 3` scalable and rotatable hardware fonts. Text size; 190 is given in pixels.; 191 ; 192The text font and precision of any class inheriting from `TAttText` can; 193be changed using the method `SetTextFont` and retrieved using the; 194method `GetTextFont`.; 195 ; 196\anchor ATTTEXT51; 197### Font quality and speed; 198 ; 199When precision 0 is used, only the original non-scaled X11 system fonts are; 200used. The fonts have a minimum (4) and maximum (37) size in pixels. These; 201fonts are fast and are of good quality. Their size varies with large steps; 202and they cannot be rotated.; 203Precision 1 and 2 fonts have a different behaviour depending if the; 204True Type Fonts (TTF) are used or not. If TTF are used, you always get very good; 205quality scalable and rotatable fonts.; 206These days TTF fonts are rendered fast enough and can be used in all cases.; 207 ; 208\anchor ATTTEXT52; 209### How to use True Type Fonts; 210 ; 211TTF fonts are used by default. They can be deactivated via the following line; 212in the `.rootrc` file:; 213 ; 214~~~ {.cpp}; 215 Unix.*.Root.UseTTFonts: false; 216~~~; 217 ; 218\anchor ATTTEXT53; 219### List of the currently supported fonts; 220 ; 221~~~ {.cpp}; 222 Font number TTF Names PostScript/PDF Names; 223 1 : ""Free Serif Italic"" ""Times-Italic""; 224 2 : ""Free Serif Bold"" ""Times-Bold""; 225 3 : ""Free Serif Bold Italic"" ""Times-BoldItalic""; 226 4 : ""Tex Gyre Regular"" ""Helvetica""; 227 5 : ""Tex Gyre Italic"" ""Helvetica-Oblique""; 228 6 : ""Tex Gyre Bold"" ""Helvetica-Bold""; 229 7 : ""Tex Gyre Bold Italic"" ""Helvetica-BoldOblique""; 230 8 : ""Free Mono"" ""Courier""; 231 9 : ""Free Mono Oblique"" ""Courier-Oblique""; 232 10 : ""Free Mono Bold"" ""Courier-Bold""; 233 11 : ""Free Mono Bold Oblique"" ""Courier-BoldOb",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8cxx_source.html:8397,Performance,load,loaded,8397,".cpp}; 222 Font number TTF Names PostScript/PDF Names; 223 1 : ""Free Serif Italic"" ""Times-Italic""; 224 2 : ""Free Serif Bold"" ""Times-Bold""; 225 3 : ""Free Serif Bold Italic"" ""Times-BoldItalic""; 226 4 : ""Tex Gyre Regular"" ""Helvetica""; 227 5 : ""Tex Gyre Italic"" ""Helvetica-Oblique""; 228 6 : ""Tex Gyre Bold"" ""Helvetica-Bold""; 229 7 : ""Tex Gyre Bold Italic"" ""Helvetica-BoldOblique""; 230 8 : ""Free Mono"" ""Courier""; 231 9 : ""Free Mono Oblique"" ""Courier-Oblique""; 232 10 : ""Free Mono Bold"" ""Courier-Bold""; 233 11 : ""Free Mono Bold Oblique"" ""Courier-BoldOblique""; 234 12 : ""Symbol"" ""Symbol""; 235 13 : ""Free Serif"" ""Times-Roman""; 236 14 : ""Wingdings"" ""ZapfDingbats""; 237~~~; 238 ; 239The PostScript and PDF backends use the original PostScript-defined 13 fonts' styles; 240forming four type families (Courier, Helvetica, Times, Symbol) as listed in the; 241""Core Font Set"" section of [this page](https://en.wikipedia.org/wiki/PostScript_fonts).; 242These fonts are always available and do not need to be loaded in the PS or PDF files; 243allowing to keep the files' sizes small.; 244 ; 245On screen, text is rendered using free TTF fonts similar to the PDF ones. The corresponding; 246font files are coming with the ROOT distribution in `$ROOTSYS/fonts/Free*`.; 247 ; 248Begin_Macro; 249fonts.C; 250End_Macro; 251*/; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// AttText default constructor.; 255///; 256/// Default text attributes are taken from the current style.; 257 ; 258TAttText::TAttText(); 259{; 260 if (!gStyle) {; 261 ResetAttText();; 262 return;; 263 }; 264 fTextAlign = gStyle->GetTextAlign();; 265 fTextAngle = gStyle->GetTextAngle();; 266 fTextColor = gStyle->GetTextColor();; 267 fTextFont = gStyle->GetTextFont();; 268 fTextSize = gStyle->GetTextSize();; 269}; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// AttText normal constructor.; 273///; 274/// Text attributes are taken from the argum",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
https://root.cern/doc/master/TAttText_8h.html:212,Integrability,depend,dependency,212,". ROOT: core/base/inc/TAttText.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TAttText.h File Reference. #include ""Rtypes.h"". Include dependency graph for TAttText.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TAttText;  Text Attributes class. More...;  . Enumerations; enum  ETextAlign { ;   kHAlignLeft =10; , kHAlignCenter =20; , kHAlignRight =30; , kVAlignBottom =1; , ;   kVAlignCenter =2; , kVAlignTop =3. };  . Enumeration Type Documentation. ◆ ETextAlign. enum ETextAlign. EnumeratorkHAlignLeft ; kHAlignCenter ; kHAlignRight ; kVAlignBottom ; kVAlignCenter ; kVAlignTop . Definition at line 53 of file TAttText.h. corebaseincTAttText.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TAttText_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8h.html
https://root.cern/doc/master/TAxis_8cxx_source.html:21959,Availability,down,down,21959,"fTimeFormat.Index(""%F"")+2;; 617 if (idF<2) {; 618 Warning(""GetGMTimeOffset"",""Time format is not set!"");; 619 return 0;; 620 }; 621 TString stime=fTimeFormat(idF,19);; 622 if (stime.Length() != 19) {; 623 Warning(""GetGMTimeOffset"",""Bad time format!"");; 624 return 0;; 625 }; 626 ; 627 TDatime datime(stime.Data());; 628 return datime.Convert(kTRUE); // Convert to unix gmt time; 629}; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// Return the ticks option (see SetTicks); 633 ; 634const char *TAxis::GetTicks() const; 635{; 636 if (TestBit(kTickPlus) && TestBit(kTickMinus)) return ""+-"";; 637 if (TestBit(kTickMinus)) return ""-"";; 638 if (TestBit(kTickPlus)) return ""+"";; 639 return """";; 640}; 641 ; 642////////////////////////////////////////////////////////////////////////////////; 643/// This helper function checks if there is a bin without a label; 644/// if all bins have labels, the axis can / will become alphanumeric; 645 ; 646Bool_t TAxis::HasBinWithoutLabel() const; 647{; 648 return fLabels->GetSize() != fNbins;; 649}; 650 ; 651////////////////////////////////////////////////////////////////////////////////; 652/// Set option(s) to draw axis with labels; 653/// option can be:; 654/// - ""a"" sort by alphabetic order; 655/// - "">"" sort by decreasing values; 656/// - ""<"" sort by increasing values; 657/// - ""h"" draw labels horizontal; 658/// - ""v"" draw labels vertical; 659/// - ""u"" draw labels up (end of label right adjusted); 660/// - ""d"" draw labels down (start of label left adjusted); 661 ; 662void TAxis::LabelsOption(Option_t *option); 663{; 664 if (!fLabels) {; 665 Warning(""Sort"",""Cannot sort. No labels"");; 666 return;; 667 }; 668 TH1 *h = (TH1*)GetParent();; 669 if (!h) {; 670 Error(""Sort"",""Axis has no parent"");; 671 return;; 672 }; 673 ; 674 h->LabelsOption(option,GetName());; 675}; 676 ; 677////////////////////////////////////////////////////////////////////////////////; 678/// Copy axis attributes to this; 679 ; 680",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:34859,Availability,avail,available,34859," Double_t labAngle, Double_t labSize,; 1010 Int_t labAlign, Int_t labColor, Int_t labFont,; 1011 const TString &labText); 1012{; 1013 if (!fModLabs) fModLabs = new TList();; 1014 ; 1015 TAxisModLab *ml = FindModLab(0, labValue, 0.);; 1016 if (!ml) {; 1017 ml = new TAxisModLab();; 1018 ml->SetLabValue(labValue);; 1019 fModLabs->Add(ml);; 1020 }; 1021 ; 1022 ml->SetAngle(labAngle);; 1023 ml->SetSize(labSize);; 1024 ml->SetAlign(labAlign);; 1025 ml->SetColor(labColor);; 1026 ml->SetFont(labFont);; 1027 ml->SetText(labText);; 1028}; 1029 ; 1030 ; 1031////////////////////////////////////////////////////////////////////////////////; 1032/// Set the viewing range for the axis using bin numbers.; 1033///; 1034/// \param first First bin of the range.; 1035/// \param last Last bin of the range.; 1036/// To set a range using the axis coordinates, use TAxis::SetRangeUser.; 1037///; 1038/// If `first == last == 0` or if `first > last` or if the range specified does; 1039/// not intersect at all with the maximum available range `[0, fNbins + 1]`,; 1040/// then the viewing range is reset by removing the bit TAxis::kAxisRange. In this; 1041/// case, the functions TAxis::GetFirst() and TAxis::GetLast() will return 1; 1042/// and fNbins.; 1043///; 1044/// If the range specified partially intersects with `[0, fNbins + 1]`, then the; 1045/// intersection range is accepted. For instance, if `first == -2` and `last == fNbins`,; 1046/// the accepted range will be `[0, fNbins]` (`fFirst = 0` and `fLast = fNbins`).; 1047///; 1048/// \note For historical reasons, SetRange(0,0) resets the range even though bin 0 is; 1049/// technically reserved for the underflow; in order to set the range of the axis; 1050/// so that it only includes the underflow, use `SetRange(-1,0)`.; 1051 ; 1052void TAxis::SetRange(Int_t first, Int_t last); 1053{; 1054 ; 1055 Int_t nCells = fNbins + 1; // bins + overflow; 1056 ; 1057 // special reset range cases; 1058 if (last < first || (first < 0 && last < 0) ||; 1059 (",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:37282,Availability,error,error,37282,"; 1063 SetBit(kAxisRange, false);; 1064 } else {; 1065 if (first<0) Warning(""TAxis::SetRange"",""first < 0, 0 is used"");; 1066 fFirst = std::max(first, 0);; 1067 if (last>nCells) Warning(""TAxis::SetRange"",""last > fNbins+1, fNbins+1 is used"");; 1068 fLast = std::min(last, nCells);; 1069 SetBit(kAxisRange, true);; 1070 }; 1071 ; 1072}; 1073 ; 1074 ; 1075////////////////////////////////////////////////////////////////////////////////; 1076/// Set the viewing range for the axis from ufirst to ulast (in user coordinates,; 1077/// that is, the ""natural"" axis coordinates).; 1078/// To set a range using the axis bin numbers, use TAxis::SetRange.; 1079 ; 1080void TAxis::SetRangeUser(Double_t ufirst, Double_t ulast); 1081{; 1082 if (!strstr(GetName(),""xaxis"")) {; 1083 TH1 *hobj = (TH1*)GetParent();; 1084 if (hobj &&; 1085 ((hobj->GetDimension() == 2 && strstr(GetName(),""zaxis"")); 1086 || (hobj->GetDimension() == 1 && strstr(GetName(),""yaxis"")))) {; 1087 hobj->SetMinimum(ufirst);; 1088 hobj->SetMaximum(ulast);; 1089 return;; 1090 }; 1091 }; 1092 if (ufirst<fXmin) Warning(""TAxis::SetRangeUser"",""ufirst < fXmin, fXmin is used"");; 1093 if (ulast>fXmax) Warning(""TAxis::SetRangeUser"",""ulast > fXmax, fXmax is used"");; 1094 Int_t ifirst = FindFixBin(ufirst);; 1095 Int_t ilast = FindFixBin(ulast);; 1096 // fixes for numerical error and for https://savannah.cern.ch/bugs/index.php?99777; 1097 if (GetBinUpEdge(ifirst) <= ufirst ) ifirst += 1;; 1098 if (GetBinLowEdge(ilast) >= ulast ) ilast -= 1;; 1099 SetRange(ifirst, ilast);; 1100}; 1101 ; 1102////////////////////////////////////////////////////////////////////////////////; 1103/// Set ticks orientation.; 1104/// option = ""+"" ticks drawn on the ""positive side"" (default); 1105/// option = ""-"" ticks drawn on the ""negative side""; 1106/// option = ""+-"" ticks drawn on both sides; 1107/// option = """" ticks will be drawn as whatever is defined as default. No bit is set internally.; 1108 ; 1109void TAxis::SetTicks(Option_t *option); 1110{; 1111 Re",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:42275,Availability,repair,repair,42275,"212 ; 1213////////////////////////////////////////////////////////////////////////////////; 1214/// Stream an object of class TAxis.; 1215 ; 1216void TAxis::Streamer(TBuffer &R__b); 1217{; 1218 if (R__b.IsReading()) {; 1219 UInt_t R__s, R__c;; 1220 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 1221 if (R__v > 5) {; 1222 R__b.ReadClassBuffer(TAxis::Class(), this, R__v, R__s, R__c);; 1223 return;; 1224 }; 1225 //====process old versions before automatic schema evolution; 1226 TNamed::Streamer(R__b);; 1227 TAttAxis::Streamer(R__b);; 1228 R__b >> fNbins;; 1229 if (R__v < 5) {; 1230 Float_t xmin,xmax;; 1231 R__b >> xmin; fXmin = xmin;; 1232 R__b >> xmax; fXmax = xmax;; 1233 Float_t *xbins = nullptr;; 1234 Int_t n = R__b.ReadArray(xbins);; 1235 fXbins.Set(n);; 1236 for (Int_t i=0;i<n;i++) fXbins.fArray[i] = xbins[i];; 1237 delete [] xbins;; 1238 } else {; 1239 R__b >> fXmin;; 1240 R__b >> fXmax;; 1241 fXbins.Streamer(R__b);; 1242 }; 1243 if (R__v > 2) {; 1244 R__b >> fFirst;; 1245 R__b >> fLast;; 1246 // following lines required to repair for a bug in Root version 1.03; 1247 if (fFirst < 0 || fFirst > fNbins) fFirst = 0;; 1248 if (fLast < 0 || fLast > fNbins) fLast = 0;; 1249 if (fLast < fFirst) { fFirst = 0; fLast = 0;}; 1250 if (fFirst ==0 && fLast == 0) SetBit(kAxisRange,false);; 1251 }; 1252 if (R__v > 3) {; 1253 R__b >> fTimeDisplay;; 1254 fTimeFormat.Streamer(R__b);; 1255 } else {; 1256 SetTimeFormat();; 1257 }; 1258 R__b.CheckByteCount(R__s, R__c, TAxis::IsA());; 1259 //====end of old versions; 1260 ; 1261 } else {; 1262 R__b.WriteClassBuffer(TAxis::Class(),this);; 1263 }; 1264}; 1265 ; 1266////////////////////////////////////////////////////////////////////////////////; 1267/// Reset first & last bin to the full range; 1268 ; 1269void TAxis::UnZoom(); 1270{; 1271 if (!gPad) {; 1272 Warning(""TAxis::UnZoom"",""Cannot UnZoom if gPad does not exist. Did you mean to draw the TAxis first?"");; 1273 return;; 1274 }; 1275 gPad->SetView();; 1276 ; 1277 //unzoom object owni",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:65672,Availability,error,error,65672,"le string class.Definition TObjString.h:28; TObjString::SetStringvoid SetString(const char *s)Definition TObjString.h:45; TObjString::GetNameconst char * GetName() const overrideReturns name of object.Definition TObjString.h:38; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::AppendTString & Append(const char *cs)Definition",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:67243,Availability,down,downward,67243,"finition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TStyle::GetTimeOffsetDouble_t GetTimeOffset() constDefinition TStyle.h:269; bool; double; int; unsigned int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699. histhistsrcTAxis.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:7718,Deployability,release,released,7718,"tUniqueID(label->GetUniqueID());; 244 }; 245 }; 246 if (axis.fModLabs) {; 247 axis.fModLabs->Delete();; 248 delete axis.fModLabs;; 249 axis.fModLabs = nullptr;; 250 }; 251 if (fModLabs) {; 252 axis.fModLabs = new TList();; 253 TIter next(fModLabs);; 254 while(auto modlabel = (TAxisModLab *)next()) {; 255 TAxisModLab *copyModLabel = new TAxisModLab(*modlabel);; 256 axis.fModLabs->Add(copyModLabel);; 257 copyModLabel->SetUniqueID(modlabel->GetUniqueID());; 258 }; 259 }; 260}; 261 ; 262////////////////////////////////////////////////////////////////////////////////; 263/// Compute distance from point px,py to an axis; 264 ; 265Int_t TAxis::DistancetoPrimitive(Int_t, Int_t); 266{; 267 return 9999;; 268}; 269 ; 270////////////////////////////////////////////////////////////////////////////////; 271/// Execute action corresponding to one event; 272///; 273/// This member function is called when an axis is clicked with the locator.; 274/// The axis range is set between the position where the mouse is pressed; 275/// and the position where it is released.; 276/// If the mouse position is outside the current axis range when it is released; 277/// the axis is unzoomed with the corresponding proportions.; 278/// Note that the mouse does not need to be in the pad or even canvas; 279/// when it is released.; 280 ; 281void TAxis::ExecuteEvent(Int_t event, Int_t px, Int_t py); 282{; 283 if (!gPad) return;; 284 gPad->ExecuteEventAxis(event,px,py,this);; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// Find bin number corresponding to abscissa x. NOTE: this method does not work with alphanumeric bins !!!; 289///; 290/// If x is underflow or overflow, attempt to extend the axis if TAxis::kCanExtend is true.; 291/// Otherwise, return 0 or fNbins+1.; 292 ; 293Int_t TAxis::FindBin(Double_t x); 294{; 295 Int_t bin;; 296 // NOTE: This should not be allowed for Alphanumeric histograms,; 297 // but it is heavily used (legacy) in the TTre",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:7803,Deployability,release,released,7803,"is.fModLabs = nullptr;; 250 }; 251 if (fModLabs) {; 252 axis.fModLabs = new TList();; 253 TIter next(fModLabs);; 254 while(auto modlabel = (TAxisModLab *)next()) {; 255 TAxisModLab *copyModLabel = new TAxisModLab(*modlabel);; 256 axis.fModLabs->Add(copyModLabel);; 257 copyModLabel->SetUniqueID(modlabel->GetUniqueID());; 258 }; 259 }; 260}; 261 ; 262////////////////////////////////////////////////////////////////////////////////; 263/// Compute distance from point px,py to an axis; 264 ; 265Int_t TAxis::DistancetoPrimitive(Int_t, Int_t); 266{; 267 return 9999;; 268}; 269 ; 270////////////////////////////////////////////////////////////////////////////////; 271/// Execute action corresponding to one event; 272///; 273/// This member function is called when an axis is clicked with the locator.; 274/// The axis range is set between the position where the mouse is pressed; 275/// and the position where it is released.; 276/// If the mouse position is outside the current axis range when it is released; 277/// the axis is unzoomed with the corresponding proportions.; 278/// Note that the mouse does not need to be in the pad or even canvas; 279/// when it is released.; 280 ; 281void TAxis::ExecuteEvent(Int_t event, Int_t px, Int_t py); 282{; 283 if (!gPad) return;; 284 gPad->ExecuteEventAxis(event,px,py,this);; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// Find bin number corresponding to abscissa x. NOTE: this method does not work with alphanumeric bins !!!; 289///; 290/// If x is underflow or overflow, attempt to extend the axis if TAxis::kCanExtend is true.; 291/// Otherwise, return 0 or fNbins+1.; 292 ; 293Int_t TAxis::FindBin(Double_t x); 294{; 295 Int_t bin;; 296 // NOTE: This should not be allowed for Alphanumeric histograms,; 297 // but it is heavily used (legacy) in the TTreePlayer to fill alphanumeric histograms.; 298 // but in case of alphanumeric do-not extend the axis. It makes no sense; 299 if (IsAlphanu",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:7970,Deployability,release,released,7970,"o modlabel = (TAxisModLab *)next()) {; 255 TAxisModLab *copyModLabel = new TAxisModLab(*modlabel);; 256 axis.fModLabs->Add(copyModLabel);; 257 copyModLabel->SetUniqueID(modlabel->GetUniqueID());; 258 }; 259 }; 260}; 261 ; 262////////////////////////////////////////////////////////////////////////////////; 263/// Compute distance from point px,py to an axis; 264 ; 265Int_t TAxis::DistancetoPrimitive(Int_t, Int_t); 266{; 267 return 9999;; 268}; 269 ; 270////////////////////////////////////////////////////////////////////////////////; 271/// Execute action corresponding to one event; 272///; 273/// This member function is called when an axis is clicked with the locator.; 274/// The axis range is set between the position where the mouse is pressed; 275/// and the position where it is released.; 276/// If the mouse position is outside the current axis range when it is released; 277/// the axis is unzoomed with the corresponding proportions.; 278/// Note that the mouse does not need to be in the pad or even canvas; 279/// when it is released.; 280 ; 281void TAxis::ExecuteEvent(Int_t event, Int_t px, Int_t py); 282{; 283 if (!gPad) return;; 284 gPad->ExecuteEventAxis(event,px,py,this);; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// Find bin number corresponding to abscissa x. NOTE: this method does not work with alphanumeric bins !!!; 289///; 290/// If x is underflow or overflow, attempt to extend the axis if TAxis::kCanExtend is true.; 291/// Otherwise, return 0 or fNbins+1.; 292 ; 293Int_t TAxis::FindBin(Double_t x); 294{; 295 Int_t bin;; 296 // NOTE: This should not be allowed for Alphanumeric histograms,; 297 // but it is heavily used (legacy) in the TTreePlayer to fill alphanumeric histograms.; 298 // but in case of alphanumeric do-not extend the axis. It makes no sense; 299 if (IsAlphanumeric() && gDebug) Info(""FindBin"",""Numeric query on alphanumeric axis - Sorting the bins or extending the axes / rebinning can",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:10130,Integrability,depend,depending,10130,"0;; 302 if (fParent == nullptr) return bin;; 303 if (!CanExtend() || IsAlphanumeric() ) return bin;; 304 ((TH1*)fParent)->ExtendAxis(x,this);; 305 return FindFixBin(x);; 306 } else if ( !(x < fXmax)) { //*-* overflow (note the way to catch NaN); 307 bin = fNbins+1;; 308 if (fParent == nullptr) return bin;; 309 if (!CanExtend() || IsAlphanumeric() ) return bin;; 310 ((TH1*)fParent)->ExtendAxis(x,this);; 311 return FindFixBin(x);; 312 } else {; 313 if (!fXbins.fN) { //*-* fix bins; 314 bin = 1 + int (fNbins*(x-fXmin)/(fXmax-fXmin) );; 315 } else { //*-* variable bin sizes; 316 //for (bin =1; x >= fXbins.fArray[bin]; bin++);; 317 bin = 1 + TMath::BinarySearch(fXbins.fN,fXbins.fArray,x);; 318 }; 319 }; 320 return bin;; 321}; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Find bin number with label.; 325/// If the List of labels does not exist create it and make the axis alphanumeric; 326/// If one wants just to add a single label- just call TAxis::SetBinLabel; 327/// If label is not in the list of labels do the following depending on the; 328/// bit TAxis::kCanExtend; of the axis.; 329/// - if the bit is set add the new label and if the number of labels exceeds; 330/// the number of bins, double the number of bins via TH1::LabelsInflate; 331/// - if the bit is not set and the histogram has labels in each bin; 332/// set the bit automatically and consider the histogram as alphanumeric; 333/// if histogram has only some bins with labels then the histogram is not; 334/// consider alphanumeric and return -1; 335///; 336/// -1 is returned only when the Axis has no parent histogram; 337 ; 338Int_t TAxis::FindBin(const char *label); 339{; 340 //create list of labels if it does not exist yet; 341 if (!fLabels) {; 342 if (!fParent) return -1;; 343 fLabels = new THashList(fNbins,3);; 344 // we set the axis alphanumeric; 345 // when list of labels does not exist; 346 // do we want to do this also when histogram is not empty ?????;",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:65259,Integrability,message,message,65259,"d.h:29; TNamed::Copyvoid Copy(TObject &named) const overrideCopy this to obj.Definition TNamed.cxx:94; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::SetStringvoid SetString(const char *s)Definition TObjString.h:45; TObjString::GetNameconst char * GetName() const overrideReturns name of object.Definition TObjString.h:38; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() con",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:65678,Integrability,message,message,65678,"le string class.Definition TObjString.h:28; TObjString::SetStringvoid SetString(const char *s)Definition TObjString.h:45; TObjString::GetNameconst char * GetName() const overrideReturns name of object.Definition TObjString.h:38; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::AppendTString & Append(const char *cs)Definition",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:65980,Integrability,message,message,65980,"tR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TStyle::GetTimeOffsetDouble_t GetTimeOffset() constDefinition TStyle",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:1493,Modifiability,variab,variable,1493,"ntributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TAxis.h""; 13#include ""TVirtualPad.h""; 14#include ""TStyle.h""; 15#include ""TError.h""; 16#include ""THashList.h""; 17#include ""TList.h""; 18#include ""TAxisModLab.h""; 19#include ""TH1.h""; 20#include ""TObjString.h""; 21#include ""TDatime.h""; 22#include ""TTimeStamp.h""; 23#include ""TBuffer.h""; 24#include ""TMath.h""; 25#include ""THLimitsFinder.h""; 26#include ""strlcpy.h""; 27#include ""snprintf.h""; 28 ; 29#include <iostream>; 30#include <ctime>; 31#include <cassert>; 32 ; 33ClassImp(TAxis);; 34 ; 35////////////////////////////////////////////////////////////////////////////////; 36/** \class TAxis; 37 \ingroup Histograms; 38 \brief Class to manage histogram axis; 39 ; 40This class manages histogram axis. It is referenced by TH1 and TGraph.; 41To make a graphical representation of an histogram axis, this class; 42references the TGaxis class. TAxis supports axis with fixed or variable bin sizes.; 43Labels may be associated to individual bins.; 44See examples of various axis representations drawn by class TGaxis.; 45*///////////////////////////////////////////////////////////////////////////////; 46 ; 47////////////////////////////////////////////////////////////////////////////////; 48/// Default constructor.; 49 ; 50TAxis::TAxis(); 51{; 52 fNbins = 1;; 53 fXmin = 0;; 54 fXmax = 1;; 55 fFirst = 0;; 56 fLast = 0;; 57 fParent = nullptr;; 58 fLabels = nullptr;; 59 fModLabs = nullptr;; 60 fBits2 = 0;; 61 fTimeDisplay = false;; 62}; 63 ; 64////////////////////////////////////////////////////////////////////////////////; 65/// Axis constructor for axis with fix bin size; 66 ; 67TAxis::TAxis(Int_t nbins,Double_t xlow,Double_t xup); 68{; 69 fParent = nullptr;; 70 fLabels = nullptr;; 71 fModLabs = nullptr;; 72 Set(nbins,xlow,xup);; 73}; 74 ; 75////////////////////////////////////////////////////////////////////////////////; 76/// Axis constructor for variabl",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:2478,Modifiability,variab,variable,2478,"manages histogram axis. It is referenced by TH1 and TGraph.; 41To make a graphical representation of an histogram axis, this class; 42references the TGaxis class. TAxis supports axis with fixed or variable bin sizes.; 43Labels may be associated to individual bins.; 44See examples of various axis representations drawn by class TGaxis.; 45*///////////////////////////////////////////////////////////////////////////////; 46 ; 47////////////////////////////////////////////////////////////////////////////////; 48/// Default constructor.; 49 ; 50TAxis::TAxis(); 51{; 52 fNbins = 1;; 53 fXmin = 0;; 54 fXmax = 1;; 55 fFirst = 0;; 56 fLast = 0;; 57 fParent = nullptr;; 58 fLabels = nullptr;; 59 fModLabs = nullptr;; 60 fBits2 = 0;; 61 fTimeDisplay = false;; 62}; 63 ; 64////////////////////////////////////////////////////////////////////////////////; 65/// Axis constructor for axis with fix bin size; 66 ; 67TAxis::TAxis(Int_t nbins,Double_t xlow,Double_t xup); 68{; 69 fParent = nullptr;; 70 fLabels = nullptr;; 71 fModLabs = nullptr;; 72 Set(nbins,xlow,xup);; 73}; 74 ; 75////////////////////////////////////////////////////////////////////////////////; 76/// Axis constructor for variable bin size; 77 ; 78TAxis::TAxis(Int_t nbins,const Double_t *xbins); 79{; 80 fParent = nullptr;; 81 fLabels = nullptr;; 82 fModLabs = nullptr;; 83 Set(nbins,xbins);; 84}; 85 ; 86////////////////////////////////////////////////////////////////////////////////; 87/// Destructor.; 88 ; 89TAxis::~TAxis(); 90{; 91 if (fLabels) {; 92 fLabels->Delete();; 93 delete fLabels;; 94 fLabels = nullptr;; 95 }; 96 if (fModLabs) {; 97 fModLabs->Delete();; 98 delete fModLabs;; 99 fModLabs = nullptr;; 100 }; 101}; 102 ; 103////////////////////////////////////////////////////////////////////////////////; 104/// Copy constructor.; 105 ; 106TAxis::TAxis(const TAxis &axis) : TNamed(axis), TAttAxis(axis); 107{; 108 fParent = nullptr;; 109 fLabels = nullptr;; 110 fModLabs = nullptr;; 111 ; 112 axis.TAxis::Copy(*this);; 113}; 1",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:8392,Modifiability,extend,extend,8392,"eturn 9999;; 268}; 269 ; 270////////////////////////////////////////////////////////////////////////////////; 271/// Execute action corresponding to one event; 272///; 273/// This member function is called when an axis is clicked with the locator.; 274/// The axis range is set between the position where the mouse is pressed; 275/// and the position where it is released.; 276/// If the mouse position is outside the current axis range when it is released; 277/// the axis is unzoomed with the corresponding proportions.; 278/// Note that the mouse does not need to be in the pad or even canvas; 279/// when it is released.; 280 ; 281void TAxis::ExecuteEvent(Int_t event, Int_t px, Int_t py); 282{; 283 if (!gPad) return;; 284 gPad->ExecuteEventAxis(event,px,py,this);; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// Find bin number corresponding to abscissa x. NOTE: this method does not work with alphanumeric bins !!!; 289///; 290/// If x is underflow or overflow, attempt to extend the axis if TAxis::kCanExtend is true.; 291/// Otherwise, return 0 or fNbins+1.; 292 ; 293Int_t TAxis::FindBin(Double_t x); 294{; 295 Int_t bin;; 296 // NOTE: This should not be allowed for Alphanumeric histograms,; 297 // but it is heavily used (legacy) in the TTreePlayer to fill alphanumeric histograms.; 298 // but in case of alphanumeric do-not extend the axis. It makes no sense; 299 if (IsAlphanumeric() && gDebug) Info(""FindBin"",""Numeric query on alphanumeric axis - Sorting the bins or extending the axes / rebinning can alter the correspondence between the label and the bin interval."");; 300 if (x < fXmin) { //*-* underflow; 301 bin = 0;; 302 if (fParent == nullptr) return bin;; 303 if (!CanExtend() || IsAlphanumeric() ) return bin;; 304 ((TH1*)fParent)->ExtendAxis(x,this);; 305 return FindFixBin(x);; 306 } else if ( !(x < fXmax)) { //*-* overflow (note the way to catch NaN); 307 bin = fNbins+1;; 308 if (fParent == nullptr) return bin;; 30",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:8749,Modifiability,extend,extend,8749," If the mouse position is outside the current axis range when it is released; 277/// the axis is unzoomed with the corresponding proportions.; 278/// Note that the mouse does not need to be in the pad or even canvas; 279/// when it is released.; 280 ; 281void TAxis::ExecuteEvent(Int_t event, Int_t px, Int_t py); 282{; 283 if (!gPad) return;; 284 gPad->ExecuteEventAxis(event,px,py,this);; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// Find bin number corresponding to abscissa x. NOTE: this method does not work with alphanumeric bins !!!; 289///; 290/// If x is underflow or overflow, attempt to extend the axis if TAxis::kCanExtend is true.; 291/// Otherwise, return 0 or fNbins+1.; 292 ; 293Int_t TAxis::FindBin(Double_t x); 294{; 295 Int_t bin;; 296 // NOTE: This should not be allowed for Alphanumeric histograms,; 297 // but it is heavily used (legacy) in the TTreePlayer to fill alphanumeric histograms.; 298 // but in case of alphanumeric do-not extend the axis. It makes no sense; 299 if (IsAlphanumeric() && gDebug) Info(""FindBin"",""Numeric query on alphanumeric axis - Sorting the bins or extending the axes / rebinning can alter the correspondence between the label and the bin interval."");; 300 if (x < fXmin) { //*-* underflow; 301 bin = 0;; 302 if (fParent == nullptr) return bin;; 303 if (!CanExtend() || IsAlphanumeric() ) return bin;; 304 ((TH1*)fParent)->ExtendAxis(x,this);; 305 return FindFixBin(x);; 306 } else if ( !(x < fXmax)) { //*-* overflow (note the way to catch NaN); 307 bin = fNbins+1;; 308 if (fParent == nullptr) return bin;; 309 if (!CanExtend() || IsAlphanumeric() ) return bin;; 310 ((TH1*)fParent)->ExtendAxis(x,this);; 311 return FindFixBin(x);; 312 } else {; 313 if (!fXbins.fN) { //*-* fix bins; 314 bin = 1 + int (fNbins*(x-fXmin)/(fXmax-fXmin) );; 315 } else { //*-* variable bin sizes; 316 //for (bin =1; x >= fXbins.fArray[bin]; bin++);; 317 bin = 1 + TMath::BinarySearch(fXbins.fN,fXbins.fArray,",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:8894,Modifiability,extend,extending,8894,"78/// Note that the mouse does not need to be in the pad or even canvas; 279/// when it is released.; 280 ; 281void TAxis::ExecuteEvent(Int_t event, Int_t px, Int_t py); 282{; 283 if (!gPad) return;; 284 gPad->ExecuteEventAxis(event,px,py,this);; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// Find bin number corresponding to abscissa x. NOTE: this method does not work with alphanumeric bins !!!; 289///; 290/// If x is underflow or overflow, attempt to extend the axis if TAxis::kCanExtend is true.; 291/// Otherwise, return 0 or fNbins+1.; 292 ; 293Int_t TAxis::FindBin(Double_t x); 294{; 295 Int_t bin;; 296 // NOTE: This should not be allowed for Alphanumeric histograms,; 297 // but it is heavily used (legacy) in the TTreePlayer to fill alphanumeric histograms.; 298 // but in case of alphanumeric do-not extend the axis. It makes no sense; 299 if (IsAlphanumeric() && gDebug) Info(""FindBin"",""Numeric query on alphanumeric axis - Sorting the bins or extending the axes / rebinning can alter the correspondence between the label and the bin interval."");; 300 if (x < fXmin) { //*-* underflow; 301 bin = 0;; 302 if (fParent == nullptr) return bin;; 303 if (!CanExtend() || IsAlphanumeric() ) return bin;; 304 ((TH1*)fParent)->ExtendAxis(x,this);; 305 return FindFixBin(x);; 306 } else if ( !(x < fXmax)) { //*-* overflow (note the way to catch NaN); 307 bin = fNbins+1;; 308 if (fParent == nullptr) return bin;; 309 if (!CanExtend() || IsAlphanumeric() ) return bin;; 310 ((TH1*)fParent)->ExtendAxis(x,this);; 311 return FindFixBin(x);; 312 } else {; 313 if (!fXbins.fN) { //*-* fix bins; 314 bin = 1 + int (fNbins*(x-fXmin)/(fXmax-fXmin) );; 315 } else { //*-* variable bin sizes; 316 //for (bin =1; x >= fXbins.fArray[bin]; bin++);; 317 bin = 1 + TMath::BinarySearch(fXbins.fN,fXbins.fArray,x);; 318 }; 319 }; 320 return bin;; 321}; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Find",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:9604,Modifiability,variab,variable,9604,"ed for Alphanumeric histograms,; 297 // but it is heavily used (legacy) in the TTreePlayer to fill alphanumeric histograms.; 298 // but in case of alphanumeric do-not extend the axis. It makes no sense; 299 if (IsAlphanumeric() && gDebug) Info(""FindBin"",""Numeric query on alphanumeric axis - Sorting the bins or extending the axes / rebinning can alter the correspondence between the label and the bin interval."");; 300 if (x < fXmin) { //*-* underflow; 301 bin = 0;; 302 if (fParent == nullptr) return bin;; 303 if (!CanExtend() || IsAlphanumeric() ) return bin;; 304 ((TH1*)fParent)->ExtendAxis(x,this);; 305 return FindFixBin(x);; 306 } else if ( !(x < fXmax)) { //*-* overflow (note the way to catch NaN); 307 bin = fNbins+1;; 308 if (fParent == nullptr) return bin;; 309 if (!CanExtend() || IsAlphanumeric() ) return bin;; 310 ((TH1*)fParent)->ExtendAxis(x,this);; 311 return FindFixBin(x);; 312 } else {; 313 if (!fXbins.fN) { //*-* fix bins; 314 bin = 1 + int (fNbins*(x-fXmin)/(fXmax-fXmin) );; 315 } else { //*-* variable bin sizes; 316 //for (bin =1; x >= fXbins.fArray[bin]; bin++);; 317 bin = 1 + TMath::BinarySearch(fXbins.fN,fXbins.fArray,x);; 318 }; 319 }; 320 return bin;; 321}; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Find bin number with label.; 325/// If the List of labels does not exist create it and make the axis alphanumeric; 326/// If one wants just to add a single label- just call TAxis::SetBinLabel; 327/// If label is not in the list of labels do the following depending on the; 328/// bit TAxis::kCanExtend; of the axis.; 329/// - if the bit is set add the new label and if the number of labels exceeds; 330/// the number of bins, double the number of bins via TH1::LabelsInflate; 331/// - if the bit is not set and the histogram has labels in each bin; 332/// set the bit automatically and consider the histogram as alphanumeric; 333/// if histogram has only some bins with labels then the histogram is not; 334",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:12059,Modifiability,extend,extend,12059,");; 360 if (obj) return (Int_t)obj->GetUniqueID();; 361 ; 362 // if labels is not in the list and we have already labels; 363 if (!IsAlphanumeric()) {; 364 // if bins without labels exist or if the axis cannot be set to alphanumeric; 365 if (HasBinWithoutLabel() || !CanBeAlphanumeric() ) {; 366 Info(""FindBin"",""Label %s is not in the list and the axis is not alphanumeric - ignore it"",label);; 367 return -1;; 368 }; 369 else {; 370 Info(""FindBin"",""Label %s not in the list. It will be added to the histogram"",label);; 371 SetCanExtend(kTRUE);; 372 SetAlphanumeric(kTRUE);; 373 }; 374 }; 375 ; 376 //Not yet in the list. Can we extend the axis ?; 377 assert ( CanExtend() && IsAlphanumeric() );; 378 // {; 379 // if (gDebug>0); 380 // Info(""FindBin"",""Label %s is not in the list and the axis cannot be extended - the entry will be added in the underflow bin"",label);; 381 // return 0;; 382 // }; 383 ; 384 Int_t n = fLabels->GetEntries();; 385 ; 386 //may be we have to resize the histogram (doubling number of channels); 387 if (n >= fNbins) ((TH1*)fParent)->LabelsInflate(GetName());; 388 ; 389 //add new label to the list: assign bin number; 390 obj = new TObjString(label);; 391 fLabels->Add(obj);; 392 obj->SetUniqueID(n+1);; 393 return n+1;; 394}; 395 ; 396////////////////////////////////////////////////////////////////////////////////; 397/// Find bin number with label.; 398/// If the List of labels does not exist or the label does not exist just return -1 .; 399/// Do not attempt to modify the axis. This is different than FindBin; 400 ; 401Int_t TAxis::FindFixBin(const char *label) const; 402{; 403 //create list of labels if it does not exist yet; 404 if (!fLabels) return -1;; 405 ; 406 // search for label in the existing list and return it if it exists; 407 TObjString *obj = (TObjString*)fLabels->FindObject(label);; 408 if (obj) return (Int_t)obj->GetUniqueID();; 409 return -1;; 410}; 411 ; 412 ; 413//////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:12233,Modifiability,extend,extended,12233,");; 360 if (obj) return (Int_t)obj->GetUniqueID();; 361 ; 362 // if labels is not in the list and we have already labels; 363 if (!IsAlphanumeric()) {; 364 // if bins without labels exist or if the axis cannot be set to alphanumeric; 365 if (HasBinWithoutLabel() || !CanBeAlphanumeric() ) {; 366 Info(""FindBin"",""Label %s is not in the list and the axis is not alphanumeric - ignore it"",label);; 367 return -1;; 368 }; 369 else {; 370 Info(""FindBin"",""Label %s not in the list. It will be added to the histogram"",label);; 371 SetCanExtend(kTRUE);; 372 SetAlphanumeric(kTRUE);; 373 }; 374 }; 375 ; 376 //Not yet in the list. Can we extend the axis ?; 377 assert ( CanExtend() && IsAlphanumeric() );; 378 // {; 379 // if (gDebug>0); 380 // Info(""FindBin"",""Label %s is not in the list and the axis cannot be extended - the entry will be added in the underflow bin"",label);; 381 // return 0;; 382 // }; 383 ; 384 Int_t n = fLabels->GetEntries();; 385 ; 386 //may be we have to resize the histogram (doubling number of channels); 387 if (n >= fNbins) ((TH1*)fParent)->LabelsInflate(GetName());; 388 ; 389 //add new label to the list: assign bin number; 390 obj = new TObjString(label);; 391 fLabels->Add(obj);; 392 obj->SetUniqueID(n+1);; 393 return n+1;; 394}; 395 ; 396////////////////////////////////////////////////////////////////////////////////; 397/// Find bin number with label.; 398/// If the List of labels does not exist or the label does not exist just return -1 .; 399/// Do not attempt to modify the axis. This is different than FindBin; 400 ; 401Int_t TAxis::FindFixBin(const char *label) const; 402{; 403 //create list of labels if it does not exist yet; 404 if (!fLabels) return -1;; 405 ; 406 // search for label in the existing list and return it if it exists; 407 TObjString *obj = (TObjString*)fLabels->FindObject(label);; 408 if (obj) return (Int_t)obj->GetUniqueID();; 409 return -1;; 410}; 411 ; 412 ; 413//////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:13602,Modifiability,extend,extend,13602,"flow bin"",label);; 381 // return 0;; 382 // }; 383 ; 384 Int_t n = fLabels->GetEntries();; 385 ; 386 //may be we have to resize the histogram (doubling number of channels); 387 if (n >= fNbins) ((TH1*)fParent)->LabelsInflate(GetName());; 388 ; 389 //add new label to the list: assign bin number; 390 obj = new TObjString(label);; 391 fLabels->Add(obj);; 392 obj->SetUniqueID(n+1);; 393 return n+1;; 394}; 395 ; 396////////////////////////////////////////////////////////////////////////////////; 397/// Find bin number with label.; 398/// If the List of labels does not exist or the label does not exist just return -1 .; 399/// Do not attempt to modify the axis. This is different than FindBin; 400 ; 401Int_t TAxis::FindFixBin(const char *label) const; 402{; 403 //create list of labels if it does not exist yet; 404 if (!fLabels) return -1;; 405 ; 406 // search for label in the existing list and return it if it exists; 407 TObjString *obj = (TObjString*)fLabels->FindObject(label);; 408 if (obj) return (Int_t)obj->GetUniqueID();; 409 return -1;; 410}; 411 ; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Find bin number corresponding to abscissa x; 415///; 416/// Identical to TAxis::FindBin except that if x is an underflow/overflow; 417/// no attempt is made to extend the axis.; 418 ; 419Int_t TAxis::FindFixBin(Double_t x) const; 420{; 421 Int_t bin;; 422 if (x < fXmin) { //*-* underflow; 423 bin = 0;; 424 } else if ( !(x < fXmax)) { //*-* overflow (note the way to catch NaN; 425 bin = fNbins+1;; 426 } else {; 427 if (!fXbins.fN) { //*-* fix bins; 428 bin = 1 + int (fNbins*(x-fXmin)/(fXmax-fXmin) );; 429 } else { //*-* variable bin sizes; 430// for (bin =1; x >= fXbins.fArray[bin]; bin++);; 431 bin = 1 + TMath::BinarySearch(fXbins.fN,fXbins.fArray,x);; 432 }; 433 }; 434 return bin;; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Return label for bin; 439 ; 440const char *",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:13967,Modifiability,variab,variable,13967,"his is different than FindBin; 400 ; 401Int_t TAxis::FindFixBin(const char *label) const; 402{; 403 //create list of labels if it does not exist yet; 404 if (!fLabels) return -1;; 405 ; 406 // search for label in the existing list and return it if it exists; 407 TObjString *obj = (TObjString*)fLabels->FindObject(label);; 408 if (obj) return (Int_t)obj->GetUniqueID();; 409 return -1;; 410}; 411 ; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Find bin number corresponding to abscissa x; 415///; 416/// Identical to TAxis::FindBin except that if x is an underflow/overflow; 417/// no attempt is made to extend the axis.; 418 ; 419Int_t TAxis::FindFixBin(Double_t x) const; 420{; 421 Int_t bin;; 422 if (x < fXmin) { //*-* underflow; 423 bin = 0;; 424 } else if ( !(x < fXmax)) { //*-* overflow (note the way to catch NaN; 425 bin = fNbins+1;; 426 } else {; 427 if (!fXbins.fN) { //*-* fix bins; 428 bin = 1 + int (fNbins*(x-fXmin)/(fXmax-fXmin) );; 429 } else { //*-* variable bin sizes; 430// for (bin =1; x >= fXbins.fArray[bin]; bin++);; 431 bin = 1 + TMath::BinarySearch(fXbins.fN,fXbins.fArray,x);; 432 }; 433 }; 434 return bin;; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Return label for bin; 439 ; 440const char *TAxis::GetBinLabel(Int_t bin) const; 441{; 442 if (!fLabels) return """";; 443 if (bin <= 0 || bin > fNbins) return """";; 444 TIter next(fLabels);; 445 TObjString *obj;; 446 while ((obj=(TObjString*)next())) {; 447 Int_t binid = (Int_t)obj->GetUniqueID();; 448 if (binid == bin) return obj->GetName();; 449 }; 450 return """";; 451}; 452 ; 453////////////////////////////////////////////////////////////////////////////////; 454/// Return first bin on the axis; 455/// i.e. 1 if no range defined; 456/// NOTE: in some cases a zero is returned (see TAxis::SetRange); 457 ; 458Int_t TAxis::GetFirst() const; 459{; 460 if (!TestBit(kAxisRange)) return 1;; 461 return fFirs",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:26779,Modifiability,variab,variable,26779," 773 if (fModLabs) {; 774 TIter next(fModLabs);; 775 while (auto ml = (TAxisModLab*)next()) {; 776 if (ml->GetLabNum() == 0); 777 out<<"" ""<<name<<subname<<""->ChangeLabelByValue(""<<ml->GetLabValue()<<"","";; 778 else; 779 out<<"" ""<<name<<subname<<""->ChangeLabel(""<<ml->GetLabNum()<<"","";; 780 out<<ml->GetAngle()<<"",""; 781 <<ml->GetSize()<<"",""; 782 <<ml->GetAlign()<<"",""; 783 <<ml->GetColor()<<"",""; 784 <<ml->GetFont()<<"",""; 785 <<quote<<ml->GetText()<<quote<<"");""<<std::endl;; 786 }; 787 }; 788 TAttAxis::SaveAttributes(out,name,subname);; 789}; 790 ; 791////////////////////////////////////////////////////////////////////////////////; 792/// Initialize axis with fix bins; 793 ; 794void TAxis::Set(Int_t nbins, Double_t xlow, Double_t xup); 795{; 796 fNbins = nbins;; 797 fXmin = xlow;; 798 fXmax = xup;; 799 if (!fParent) SetDefaults();; 800 if (fXbins.fN > 0) fXbins.Set(0);; 801}; 802 ; 803////////////////////////////////////////////////////////////////////////////////; 804/// Initialize axis with variable bins; 805 ; 806void TAxis::Set(Int_t nbins, const Float_t *xbins); 807{; 808 Int_t bin;; 809 fNbins = nbins;; 810 fXbins.Set(fNbins+1);; 811 for (bin=0; bin<= fNbins; bin++); 812 fXbins.fArray[bin] = xbins[bin];; 813 for (bin=1; bin<= fNbins; bin++); 814 if (fXbins.fArray[bin] < fXbins.fArray[bin-1]); 815 Error(""TAxis::Set"", ""bins must be in increasing order"");; 816 fXmin = fXbins.fArray[0];; 817 fXmax = fXbins.fArray[fNbins];; 818 if (!fParent) SetDefaults();; 819}; 820 ; 821////////////////////////////////////////////////////////////////////////////////; 822/// Initialize axis with variable bins; 823 ; 824void TAxis::Set(Int_t nbins, const Double_t *xbins); 825{; 826 Int_t bin;; 827 fNbins = nbins;; 828 fXbins.Set(fNbins+1);; 829 for (bin=0; bin<= fNbins; bin++); 830 fXbins.fArray[bin] = xbins[bin];; 831 for (bin=1; bin<= fNbins; bin++); 832 if (fXbins.fArray[bin] < fXbins.fArray[bin-1]); 833 Error(""TAxis::Set"", ""bins must be in increasing order"");; 834 fXmin = fXbins.fArr",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:27379,Modifiability,variab,variable,27379,"/////////////////////////////////////////////////////; 792/// Initialize axis with fix bins; 793 ; 794void TAxis::Set(Int_t nbins, Double_t xlow, Double_t xup); 795{; 796 fNbins = nbins;; 797 fXmin = xlow;; 798 fXmax = xup;; 799 if (!fParent) SetDefaults();; 800 if (fXbins.fN > 0) fXbins.Set(0);; 801}; 802 ; 803////////////////////////////////////////////////////////////////////////////////; 804/// Initialize axis with variable bins; 805 ; 806void TAxis::Set(Int_t nbins, const Float_t *xbins); 807{; 808 Int_t bin;; 809 fNbins = nbins;; 810 fXbins.Set(fNbins+1);; 811 for (bin=0; bin<= fNbins; bin++); 812 fXbins.fArray[bin] = xbins[bin];; 813 for (bin=1; bin<= fNbins; bin++); 814 if (fXbins.fArray[bin] < fXbins.fArray[bin-1]); 815 Error(""TAxis::Set"", ""bins must be in increasing order"");; 816 fXmin = fXbins.fArray[0];; 817 fXmax = fXbins.fArray[fNbins];; 818 if (!fParent) SetDefaults();; 819}; 820 ; 821////////////////////////////////////////////////////////////////////////////////; 822/// Initialize axis with variable bins; 823 ; 824void TAxis::Set(Int_t nbins, const Double_t *xbins); 825{; 826 Int_t bin;; 827 fNbins = nbins;; 828 fXbins.Set(fNbins+1);; 829 for (bin=0; bin<= fNbins; bin++); 830 fXbins.fArray[bin] = xbins[bin];; 831 for (bin=1; bin<= fNbins; bin++); 832 if (fXbins.fArray[bin] < fXbins.fArray[bin-1]); 833 Error(""TAxis::Set"", ""bins must be in increasing order"");; 834 fXmin = fXbins.fArray[0];; 835 fXmax = fXbins.fArray[fNbins];; 836 if (!fParent) SetDefaults();; 837}; 838 ; 839////////////////////////////////////////////////////////////////////////////////; 840/// Set axis alphanumeric; 841 ; 842void TAxis::SetAlphanumeric(Bool_t alphanumeric); 843{; 844 if (alphanumeric) fBits2 |= kAlphanumeric;; 845 else fBits2 &= ~kAlphanumeric;; 846 ; 847 // clear underflow and overflow (in an alphanumeric situation they do not make sense); 848 // NOTE: using AddBinContent instead of SetBinContent in order to not change; 849 // the number of entries; 850 //((TH1 *)fPa",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:29417,Modifiability,extend,extendable,29417,"low();; 851 // L.M. 26.1.15 Keep underflow and overflows (see ROOT-7034); 852 if (gDebug && fParent) {; 853 TH1 * h = dynamic_cast<TH1*>( fParent);; 854 if (!h) return;; 855 double s[TH1::kNstat];; 856 h->GetStats(s);; 857 if (s[0] != 0. && gDebug > 0); 858 Info(""SetAlphanumeric"",""Cannot switch axis %s of histogram %s to alphanumeric: it has non-zero content"",GetName(),h->GetName());; 859 }; 860}; 861 ; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Set axis default values (from TStyle); 865 ; 866void TAxis::SetDefaults(); 867{; 868 fFirst = 0;; 869 fLast = 0;; 870 fBits2 = 0;; 871 char name[2];; 872 strlcpy(name,GetName(),2);; 873 name[1] = 0;; 874 TAttAxis::ResetAttAxis(name);; 875 fTimeDisplay = false;; 876 SetTimeFormat();; 877}; 878 ; 879////////////////////////////////////////////////////////////////////////////////; 880/// Set label for bin.; 881/// If no label list exists, it is created. If all the bins have labels, the; 882/// axis becomes alphanumeric and extendable.; 883/// New labels will not be added with the Fill method but will end-up in the; 884/// underflow bin. See documentation of TAxis::FindBin(const char*); 885 ; 886void TAxis::SetBinLabel(Int_t bin, const char *label); 887{; 888 if (!fLabels) fLabels = new THashList(fNbins,3);; 889 ; 890 if (bin <= 0 || bin > fNbins) {; 891 Error(""SetBinLabel"",""Illegal bin number: %d"",bin);; 892 return;; 893 }; 894 ; 895 // Check whether this bin already has a label.; 896 TIter next(fLabels);; 897 TObjString *obj;; 898 while ((obj=(TObjString*)next())) {; 899 if ( obj->GetUniqueID()==(UInt_t)bin ) {; 900 // It does. Overwrite it.; 901 obj->SetString(label);; 902 // LM need to rehash the labels list (see ROOT-5025); 903 fLabels->Rehash(fLabels->GetSize() );; 904 return;; 905 }; 906 }; 907 // It doesn't. Add this new label.; 908 obj = new TObjString(label);; 909 fLabels->Add(obj);; 910 obj->SetUniqueID((UInt_t)bin);; 911 ; 912 // check for Alphanumeric case (label",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:65524,Modifiability,inherit,inherits,65524,"onst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::SetStringvoid SetString(const char *s)Definition TObjString.h:45; TObjString::GetNameconst char * GetName() const overrideReturns name of object.Definition TObjString.h:38; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t ",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:19188,Performance,optimiz,optimization,19188,"(center + bin - 1) = GetBinCenter(bin);; 557}; 558 ; 559////////////////////////////////////////////////////////////////////////////////; 560/// Return an array with the low edge of all bins; 561 ; 562void TAxis::GetLowEdge(Double_t *edge) const; 563{; 564 for (Int_t bin = 1; bin <= fNbins; bin++); 565 *(edge + bin - 1) = GetBinLowEdge(bin);; 566}; 567 ; 568////////////////////////////////////////////////////////////////////////////////; 569/// Return the number of axis labels.; 570///; 571/// It is sometimes useful to know the number of labels on an axis. For instance; 572/// when changing the labels with TAxis::ChangeLabel. The number of labels is equal; 573/// to `the_number_of_divisions + 1`. By default the number of divisions is; 574/// optimised to show a coherent labeling of the main tick marks. After optimisation the; 575/// real number of divisions will be smaller or equal to number of divisions requested.; 576/// In order to turn off the labeling optimization, it is enough to give a negative; 577/// number of divisions to TAttAxis::SetNdivisions. The absolute value of this number will be use as; 578/// the exact number of divisions. This method takes the two cases (optimised or not) into; 579/// account.; 580 ; 581Int_t TAxis::GetNlabels() const; 582{; 583 if (fNdivisions > 0) {; 584 Int_t divxo = 0;; 585 Double_t x1o = 0.;; 586 Double_t x2o = 0.;; 587 Double_t bwx = 0.;; 588 THLimitsFinder::Optimize(fXmin, fXmax,fNdivisions%100,x1o,x2o,divxo,bwx,"""");; 589 return divxo+1;; 590 } else {; 591 Int_t divx = -fNdivisions;; 592 return divx%100+1;; 593 }; 594}; 595 ; 596////////////////////////////////////////////////////////////////////////////////; 597/// Return *only* the time format from the string fTimeFormat; 598 ; 599const char *TAxis::GetTimeFormatOnly() const; 600{; 601 static TString timeformat;; 602 Int_t idF = fTimeFormat.Index(""%F"");; 603 if (idF>=0) {; 604 timeformat = fTimeFormat(0,idF);; 605 } else {; 606 timeformat = fTimeFormat;; 607 }; 608 retu",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:63422,Security,hash,hash,63422,"virtual Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden b...Definition TH1.cxx:8545; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; THLimitsFinder::Optimizestatic void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t &BinLow, Double_t &BinHigh, Int_t &nbins, Double_t &BWID, Option_t *option="""")Static function to compute reasonable axis limits.Definition THLimitsFinder.cxx:184; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::Rehashvoid Rehash(Int_t newCapacity)Rehash the hashlist.Definition THashList.cxx:368; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::Copyvoid Copy(TObject &named) const overrideCopy this to obj.Definition TNamed.cxx:94; TNamed::SetTitlevirtual void SetTitle(const ch",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:63703,Security,hash,hashlist,63703,"1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; THLimitsFinder::Optimizestatic void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t &BinLow, Double_t &BinHigh, Int_t &nbins, Double_t &BWID, Option_t *option="""")Static function to compute reasonable axis limits.Definition THLimitsFinder.cxx:184; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::Rehashvoid Rehash(Int_t newCapacity)Rehash the hashlist.Definition THashList.cxx:368; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::Copyvoid Copy(TObject &named) const overrideCopy this to obj.Definition TNamed.cxx:94; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TObjStringCollectable",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:12082,Testability,assert,assert,12082,");; 360 if (obj) return (Int_t)obj->GetUniqueID();; 361 ; 362 // if labels is not in the list and we have already labels; 363 if (!IsAlphanumeric()) {; 364 // if bins without labels exist or if the axis cannot be set to alphanumeric; 365 if (HasBinWithoutLabel() || !CanBeAlphanumeric() ) {; 366 Info(""FindBin"",""Label %s is not in the list and the axis is not alphanumeric - ignore it"",label);; 367 return -1;; 368 }; 369 else {; 370 Info(""FindBin"",""Label %s not in the list. It will be added to the histogram"",label);; 371 SetCanExtend(kTRUE);; 372 SetAlphanumeric(kTRUE);; 373 }; 374 }; 375 ; 376 //Not yet in the list. Can we extend the axis ?; 377 assert ( CanExtend() && IsAlphanumeric() );; 378 // {; 379 // if (gDebug>0); 380 // Info(""FindBin"",""Label %s is not in the list and the axis cannot be extended - the entry will be added in the underflow bin"",label);; 381 // return 0;; 382 // }; 383 ; 384 Int_t n = fLabels->GetEntries();; 385 ; 386 //may be we have to resize the histogram (doubling number of channels); 387 if (n >= fNbins) ((TH1*)fParent)->LabelsInflate(GetName());; 388 ; 389 //add new label to the list: assign bin number; 390 obj = new TObjString(label);; 391 fLabels->Add(obj);; 392 obj->SetUniqueID(n+1);; 393 return n+1;; 394}; 395 ; 396////////////////////////////////////////////////////////////////////////////////; 397/// Find bin number with label.; 398/// If the List of labels does not exist or the label does not exist just return -1 .; 399/// Do not attempt to modify the axis. This is different than FindBin; 400 ; 401Int_t TAxis::FindFixBin(const char *label) const; 402{; 403 //create list of labels if it does not exist yet; 404 if (!fLabels) return -1;; 405 ; 406 // search for label in the existing list and return it if it exists; 407 TObjString *obj = (TObjString*)fLabels->FindObject(label);; 408 if (obj) return (Int_t)obj->GetUniqueID();; 409 return -1;; 410}; 411 ; 412 ; 413//////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:15923,Testability,log,log,15923,"stBit(kAxisRange)) return 1;; 461 return fFirst;; 462}; 463 ; 464////////////////////////////////////////////////////////////////////////////////; 465/// Return last bin on the axis; 466/// i.e. fNbins if no range defined; 467/// NOTE: in some cases a zero is returned (see TAxis::SetRange); 468 ; 469Int_t TAxis::GetLast() const; 470{; 471 if (!TestBit(kAxisRange)) return fNbins;; 472 return fLast;; 473}; 474 ; 475////////////////////////////////////////////////////////////////////////////////; 476/// Return center of bin; 477 ; 478Double_t TAxis::GetBinCenter(Int_t bin) const; 479{; 480 Double_t binwidth;; 481 if (!fXbins.fN || bin<1 || bin>fNbins) {; 482 binwidth = (fXmax - fXmin) / Double_t(fNbins);; 483 return fXmin + (bin-1) * binwidth + 0.5*binwidth;; 484 } else {; 485 binwidth = fXbins.fArray[bin] - fXbins.fArray[bin-1];; 486 return fXbins.fArray[bin-1] + 0.5*binwidth;; 487 }; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Return center of bin in log; 492/// With a log-equidistant binning for a bin with low and up edges, the mean is :; 493/// 0.5*(ln low + ln up) i.e. sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10).; 494/// Imagine a bin with low=1 and up=100 :; 495/// - the center in lin is (100-1)/2=50.5; 496/// - the center in log would be sqrt(1*100)=10 (!=log(50.5)); 497///; 498/// NB: if the low edge of the bin is negative, the function returns the bin center; 499/// as computed by TAxis::GetBinCenter; 500 ; 501Double_t TAxis::GetBinCenterLog(Int_t bin) const; 502{; 503 Double_t low,up;; 504 if (!fXbins.fN || bin<1 || bin>fNbins) {; 505 Double_t binwidth = (fXmax - fXmin) / Double_t(fNbins);; 506 low = fXmin + (bin-1) * binwidth;; 507 up = low+binwidth;; 508 } else {; 509 low = fXbins.fArray[bin-1];; 510 up = fXbins.fArray[bin];; 511 }; 512 if (low <=0 ) return GetBinCenter(bin);; 513 return TMath::Sqrt(low*up);; 514}; 515////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:15942,Testability,log,log-equidistant,15942,"stBit(kAxisRange)) return 1;; 461 return fFirst;; 462}; 463 ; 464////////////////////////////////////////////////////////////////////////////////; 465/// Return last bin on the axis; 466/// i.e. fNbins if no range defined; 467/// NOTE: in some cases a zero is returned (see TAxis::SetRange); 468 ; 469Int_t TAxis::GetLast() const; 470{; 471 if (!TestBit(kAxisRange)) return fNbins;; 472 return fLast;; 473}; 474 ; 475////////////////////////////////////////////////////////////////////////////////; 476/// Return center of bin; 477 ; 478Double_t TAxis::GetBinCenter(Int_t bin) const; 479{; 480 Double_t binwidth;; 481 if (!fXbins.fN || bin<1 || bin>fNbins) {; 482 binwidth = (fXmax - fXmin) / Double_t(fNbins);; 483 return fXmin + (bin-1) * binwidth + 0.5*binwidth;; 484 } else {; 485 binwidth = fXbins.fArray[bin] - fXbins.fArray[bin-1];; 486 return fXbins.fArray[bin-1] + 0.5*binwidth;; 487 }; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Return center of bin in log; 492/// With a log-equidistant binning for a bin with low and up edges, the mean is :; 493/// 0.5*(ln low + ln up) i.e. sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10).; 494/// Imagine a bin with low=1 and up=100 :; 495/// - the center in lin is (100-1)/2=50.5; 496/// - the center in log would be sqrt(1*100)=10 (!=log(50.5)); 497///; 498/// NB: if the low edge of the bin is negative, the function returns the bin center; 499/// as computed by TAxis::GetBinCenter; 500 ; 501Double_t TAxis::GetBinCenterLog(Int_t bin) const; 502{; 503 Double_t low,up;; 504 if (!fXbins.fN || bin<1 || bin>fNbins) {; 505 Double_t binwidth = (fXmax - fXmin) / Double_t(fNbins);; 506 low = fXmin + (bin-1) * binwidth;; 507 up = low+binwidth;; 508 } else {; 509 low = fXbins.fArray[bin-1];; 510 up = fXbins.fArray[bin];; 511 }; 512 if (low <=0 ) return GetBinCenter(bin);; 513 return TMath::Sqrt(low*up);; 514}; 515////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:16063,Testability,log,logx,16063,"n last bin on the axis; 466/// i.e. fNbins if no range defined; 467/// NOTE: in some cases a zero is returned (see TAxis::SetRange); 468 ; 469Int_t TAxis::GetLast() const; 470{; 471 if (!TestBit(kAxisRange)) return fNbins;; 472 return fLast;; 473}; 474 ; 475////////////////////////////////////////////////////////////////////////////////; 476/// Return center of bin; 477 ; 478Double_t TAxis::GetBinCenter(Int_t bin) const; 479{; 480 Double_t binwidth;; 481 if (!fXbins.fN || bin<1 || bin>fNbins) {; 482 binwidth = (fXmax - fXmin) / Double_t(fNbins);; 483 return fXmin + (bin-1) * binwidth + 0.5*binwidth;; 484 } else {; 485 binwidth = fXbins.fArray[bin] - fXbins.fArray[bin-1];; 486 return fXbins.fArray[bin-1] + 0.5*binwidth;; 487 }; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Return center of bin in log; 492/// With a log-equidistant binning for a bin with low and up edges, the mean is :; 493/// 0.5*(ln low + ln up) i.e. sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10).; 494/// Imagine a bin with low=1 and up=100 :; 495/// - the center in lin is (100-1)/2=50.5; 496/// - the center in log would be sqrt(1*100)=10 (!=log(50.5)); 497///; 498/// NB: if the low edge of the bin is negative, the function returns the bin center; 499/// as computed by TAxis::GetBinCenter; 500 ; 501Double_t TAxis::GetBinCenterLog(Int_t bin) const; 502{; 503 Double_t low,up;; 504 if (!fXbins.fN || bin<1 || bin>fNbins) {; 505 Double_t binwidth = (fXmax - fXmin) / Double_t(fNbins);; 506 low = fXmin + (bin-1) * binwidth;; 507 up = low+binwidth;; 508 } else {; 509 low = fXbins.fArray[bin-1];; 510 up = fXbins.fArray[bin];; 511 }; 512 if (low <=0 ) return GetBinCenter(bin);; 513 return TMath::Sqrt(low*up);; 514}; 515////////////////////////////////////////////////////////////////////////////////; 516/// Return low edge of bin; 517 ; 518Double_t TAxis::GetBinLowEdge(Int_t bin) const; 519{; 520 if (fXbins.fN && bin > 0 && bin <=fNbins) return fXbins.",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:16213,Testability,log,log,16213,"t() const; 470{; 471 if (!TestBit(kAxisRange)) return fNbins;; 472 return fLast;; 473}; 474 ; 475////////////////////////////////////////////////////////////////////////////////; 476/// Return center of bin; 477 ; 478Double_t TAxis::GetBinCenter(Int_t bin) const; 479{; 480 Double_t binwidth;; 481 if (!fXbins.fN || bin<1 || bin>fNbins) {; 482 binwidth = (fXmax - fXmin) / Double_t(fNbins);; 483 return fXmin + (bin-1) * binwidth + 0.5*binwidth;; 484 } else {; 485 binwidth = fXbins.fArray[bin] - fXbins.fArray[bin-1];; 486 return fXbins.fArray[bin-1] + 0.5*binwidth;; 487 }; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Return center of bin in log; 492/// With a log-equidistant binning for a bin with low and up edges, the mean is :; 493/// 0.5*(ln low + ln up) i.e. sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10).; 494/// Imagine a bin with low=1 and up=100 :; 495/// - the center in lin is (100-1)/2=50.5; 496/// - the center in log would be sqrt(1*100)=10 (!=log(50.5)); 497///; 498/// NB: if the low edge of the bin is negative, the function returns the bin center; 499/// as computed by TAxis::GetBinCenter; 500 ; 501Double_t TAxis::GetBinCenterLog(Int_t bin) const; 502{; 503 Double_t low,up;; 504 if (!fXbins.fN || bin<1 || bin>fNbins) {; 505 Double_t binwidth = (fXmax - fXmin) / Double_t(fNbins);; 506 low = fXmin + (bin-1) * binwidth;; 507 up = low+binwidth;; 508 } else {; 509 low = fXbins.fArray[bin-1];; 510 up = fXbins.fArray[bin];; 511 }; 512 if (low <=0 ) return GetBinCenter(bin);; 513 return TMath::Sqrt(low*up);; 514}; 515////////////////////////////////////////////////////////////////////////////////; 516/// Return low edge of bin; 517 ; 518Double_t TAxis::GetBinLowEdge(Int_t bin) const; 519{; 520 if (fXbins.fN && bin > 0 && bin <=fNbins) return fXbins.fArray[bin-1];; 521 Double_t binwidth = (fXmax - fXmin) / Double_t(fNbins);; 522 return fXmin + (bin-1) * binwidth;; 523}; 524 ; 525////////////////////////////",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:16244,Testability,log,log,16244,"t() const; 470{; 471 if (!TestBit(kAxisRange)) return fNbins;; 472 return fLast;; 473}; 474 ; 475////////////////////////////////////////////////////////////////////////////////; 476/// Return center of bin; 477 ; 478Double_t TAxis::GetBinCenter(Int_t bin) const; 479{; 480 Double_t binwidth;; 481 if (!fXbins.fN || bin<1 || bin>fNbins) {; 482 binwidth = (fXmax - fXmin) / Double_t(fNbins);; 483 return fXmin + (bin-1) * binwidth + 0.5*binwidth;; 484 } else {; 485 binwidth = fXbins.fArray[bin] - fXbins.fArray[bin-1];; 486 return fXbins.fArray[bin-1] + 0.5*binwidth;; 487 }; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Return center of bin in log; 492/// With a log-equidistant binning for a bin with low and up edges, the mean is :; 493/// 0.5*(ln low + ln up) i.e. sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10).; 494/// Imagine a bin with low=1 and up=100 :; 495/// - the center in lin is (100-1)/2=50.5; 496/// - the center in log would be sqrt(1*100)=10 (!=log(50.5)); 497///; 498/// NB: if the low edge of the bin is negative, the function returns the bin center; 499/// as computed by TAxis::GetBinCenter; 500 ; 501Double_t TAxis::GetBinCenterLog(Int_t bin) const; 502{; 503 Double_t low,up;; 504 if (!fXbins.fN || bin<1 || bin>fNbins) {; 505 Double_t binwidth = (fXmax - fXmin) / Double_t(fNbins);; 506 low = fXmin + (bin-1) * binwidth;; 507 up = low+binwidth;; 508 } else {; 509 low = fXbins.fArray[bin-1];; 510 up = fXbins.fArray[bin];; 511 }; 512 if (low <=0 ) return GetBinCenter(bin);; 513 return TMath::Sqrt(low*up);; 514}; 515////////////////////////////////////////////////////////////////////////////////; 516/// Return low edge of bin; 517 ; 518Double_t TAxis::GetBinLowEdge(Int_t bin) const; 519{; 520 if (fXbins.fN && bin > 0 && bin <=fNbins) return fXbins.fArray[bin-1];; 521 Double_t binwidth = (fXmax - fXmin) / Double_t(fNbins);; 522 return fXmin + (bin-1) * binwidth;; 523}; 524 ; 525////////////////////////////",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:58461,Testability,log,log,58461,"n(Double_t x) constFind bin number corresponding to abscissa x.Definition TAxis.cxx:419; TAxis::ChooseTimeFormatconst char * ChooseTimeFormat(Double_t axislength=0)Choose a reasonable time format from the coordinates in the active pad and the number of divisions in...Definition TAxis.cxx:132; TAxis::SaveAttributesvoid SaveAttributes(std::ostream &out, const char *name, const char *subname) overrideSave axis attributes as C++ statement(s) on output stream out.Definition TAxis.cxx:710; TAxis::IsATClass * IsA() const overrideDefinition TAxis.h:177; TAxis::GetLastInt_t GetLast() constReturn last bin on the axis i.e.Definition TAxis.cxx:469; TAxis::ImportAttributesvirtual void ImportAttributes(const TAxis *axis)Copy axis attributes to this.Definition TAxis.cxx:680; TAxis::GetTimeFormatOnlyvirtual const char * GetTimeFormatOnly() constReturn only the time format from the string fTimeFormat.Definition TAxis.cxx:599; TAxis::GetBinCenterLogvirtual Double_t GetBinCenterLog(Int_t bin) constReturn center of bin in log With a log-equidistant binning for a bin with low and up edges,...Definition TAxis.cxx:501; TAxis::SetAlphanumericvoid SetAlphanumeric(Bool_t alphanumeric=kTRUE)Set axis alphanumeric.Definition TAxis.cxx:842; TAxis::Streamervoid Streamer(TBuffer &) overrideStream an object of class TAxis.Definition TAxis.cxx:1216; TAxis::operator=TAxis & operator=(const TAxis &)Assignment operator.Definition TAxis.cxx:118; TAxis::~TAxis~TAxis() overrideDestructor.Definition TAxis.cxx:89; TAxis::ChangeLabelByValuevoid ChangeLabelByValue(Double_t labValue, Double_t labAngle=-1., Double_t labSize=-1., Int_t labAlign=-1, Int_t labColor=-1, Int_t labFont=-1, const TString &labText="""")Define new text attributes for the label value ""labValue"".Definition TAxis.cxx:1009; TAxis::SetRangeUservirtual void SetRangeUser(Double_t ufirst, Double_t ulast)Set the viewing range for the axis from ufirst to ulast (in user coordinates, that is,...Definition TAxis.cxx:1080; TAxis::GetTimeFormatvirtual c",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:58472,Testability,log,log-equidistant,58472,"n(Double_t x) constFind bin number corresponding to abscissa x.Definition TAxis.cxx:419; TAxis::ChooseTimeFormatconst char * ChooseTimeFormat(Double_t axislength=0)Choose a reasonable time format from the coordinates in the active pad and the number of divisions in...Definition TAxis.cxx:132; TAxis::SaveAttributesvoid SaveAttributes(std::ostream &out, const char *name, const char *subname) overrideSave axis attributes as C++ statement(s) on output stream out.Definition TAxis.cxx:710; TAxis::IsATClass * IsA() const overrideDefinition TAxis.h:177; TAxis::GetLastInt_t GetLast() constReturn last bin on the axis i.e.Definition TAxis.cxx:469; TAxis::ImportAttributesvirtual void ImportAttributes(const TAxis *axis)Copy axis attributes to this.Definition TAxis.cxx:680; TAxis::GetTimeFormatOnlyvirtual const char * GetTimeFormatOnly() constReturn only the time format from the string fTimeFormat.Definition TAxis.cxx:599; TAxis::GetBinCenterLogvirtual Double_t GetBinCenterLog(Int_t bin) constReturn center of bin in log With a log-equidistant binning for a bin with low and up edges,...Definition TAxis.cxx:501; TAxis::SetAlphanumericvoid SetAlphanumeric(Bool_t alphanumeric=kTRUE)Set axis alphanumeric.Definition TAxis.cxx:842; TAxis::Streamervoid Streamer(TBuffer &) overrideStream an object of class TAxis.Definition TAxis.cxx:1216; TAxis::operator=TAxis & operator=(const TAxis &)Assignment operator.Definition TAxis.cxx:118; TAxis::~TAxis~TAxis() overrideDestructor.Definition TAxis.cxx:89; TAxis::ChangeLabelByValuevoid ChangeLabelByValue(Double_t labValue, Double_t labAngle=-1., Double_t labSize=-1., Int_t labAlign=-1, Int_t labColor=-1, Int_t labFont=-1, const TString &labText="""")Define new text attributes for the label value ""labValue"".Definition TAxis.cxx:1009; TAxis::SetRangeUservirtual void SetRangeUser(Double_t ufirst, Double_t ulast)Set the viewing range for the axis from ufirst to ulast (in user coordinates, that is,...Definition TAxis.cxx:1080; TAxis::GetTimeFormatvirtual c",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8cxx_source.html:28144,Usability,clear,clear,28144,"Axis::Set"", ""bins must be in increasing order"");; 816 fXmin = fXbins.fArray[0];; 817 fXmax = fXbins.fArray[fNbins];; 818 if (!fParent) SetDefaults();; 819}; 820 ; 821////////////////////////////////////////////////////////////////////////////////; 822/// Initialize axis with variable bins; 823 ; 824void TAxis::Set(Int_t nbins, const Double_t *xbins); 825{; 826 Int_t bin;; 827 fNbins = nbins;; 828 fXbins.Set(fNbins+1);; 829 for (bin=0; bin<= fNbins; bin++); 830 fXbins.fArray[bin] = xbins[bin];; 831 for (bin=1; bin<= fNbins; bin++); 832 if (fXbins.fArray[bin] < fXbins.fArray[bin-1]); 833 Error(""TAxis::Set"", ""bins must be in increasing order"");; 834 fXmin = fXbins.fArray[0];; 835 fXmax = fXbins.fArray[fNbins];; 836 if (!fParent) SetDefaults();; 837}; 838 ; 839////////////////////////////////////////////////////////////////////////////////; 840/// Set axis alphanumeric; 841 ; 842void TAxis::SetAlphanumeric(Bool_t alphanumeric); 843{; 844 if (alphanumeric) fBits2 |= kAlphanumeric;; 845 else fBits2 &= ~kAlphanumeric;; 846 ; 847 // clear underflow and overflow (in an alphanumeric situation they do not make sense); 848 // NOTE: using AddBinContent instead of SetBinContent in order to not change; 849 // the number of entries; 850 //((TH1 *)fParent)->ClearUnderflowAndOverflow();; 851 // L.M. 26.1.15 Keep underflow and overflows (see ROOT-7034); 852 if (gDebug && fParent) {; 853 TH1 * h = dynamic_cast<TH1*>( fParent);; 854 if (!h) return;; 855 double s[TH1::kNstat];; 856 h->GetStats(s);; 857 if (s[0] != 0. && gDebug > 0); 858 Info(""SetAlphanumeric"",""Cannot switch axis %s of histogram %s to alphanumeric: it has non-zero content"",GetName(),h->GetName());; 859 }; 860}; 861 ; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Set axis default values (from TStyle); 865 ; 866void TAxis::SetDefaults(); 867{; 868 fFirst = 0;; 869 fLast = 0;; 870 fBits2 = 0;; 871 char name[2];; 872 strlcpy(name,GetName(),2);; 873 name[1] = 0;; 874 TAttAxis:",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
https://root.cern/doc/master/TAxis_8h.html:235,Integrability,depend,dependency,235,". ROOT: hist/hist/inc/TAxis.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TAxis.h File Reference. #include ""TNamed.h""; #include ""TAttAxis.h""; #include ""TArrayD.h"". Include dependency graph for TAxis.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TAxis;  Class to manage histogram axis. More...;  . histhistincTAxis.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TAxis_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h.html
https://root.cern/doc/master/TAxis_8h_source.html:1849,Modifiability,extend,extended,1849,"$ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TAxis; 13#define ROOT_TAxis; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TAxis //; 19// //; 20// Axis class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TNamed.h""; 25#include ""TAttAxis.h""; 26#include ""TArrayD.h""; 27 ; 28class THashList;; 29class TAxisModLab;; 30 ; 31class TAxis : public TNamed, public TAttAxis {; 32 ; 33private:; 34 Int_t fNbins; ///< Number of bins; 35 Double_t fXmin; ///< Low edge of first bin; 36 Double_t fXmax; ///< Upper edge of last bin; 37 TArrayD fXbins; ///< Bin edges array in X; 38 Int_t fFirst; ///< First bin to display; 39 Int_t fLast; ///< Last bin to display; 40 UShort_t fBits2; ///< Second bit status word; 41 Bool_t fTimeDisplay; ///< On/off displaying time values instead of numerics; 42 TString fTimeFormat; ///< Date&time format, ex: 09/12/99 12:34:00; 43 TObject *fParent; ///<! Object owning this axis; 44 THashList *fLabels; ///< List of labels; 45 TList *fModLabs; ///< List of modified labels; 46 ; 47 /// TAxis extra status bits (stored in fBits2); 48 enum {; 49 kAlphanumeric = BIT(0), ///< Axis is alphanumeric; 50 kCanExtend = BIT(1), ///< Axis can be extended; 51 kNotAlpha = BIT(2) ///< Axis is forced to be not alphanumeric; 52 };; 53 ; 54 Bool_t HasBinWithoutLabel() const;; 55 ; 56 ; 57 TAxisModLab *FindModLab(Int_t num, Double_t v = 0., Double_t eps = 0.) const;; 58 ; 59public:; 60 /// TAxis status bits; 61 enum EStatusBits {; 62 kDecimals = BIT(7),; 63 kTickPlus = BIT(9),; 64 kTickMinus = BIT(10),; 65 kAxisRange = BIT(11),; 66 kCenterTitle = BIT(12),; 67 kCenterLabels = BIT(14), ///< Bit 13 is used by TObject; 68 kRotateTitle = BIT(15),; 69 kPalette = BIT(16),; 70 kNoExponent = BIT(17),; 71 kLabelsHori = BIT(18),; 72 kLabelsVert = BIT(19),; 73 kLabelsDown = BIT(20),; 74 kLabelsUp = B",MatchSource.WIKI,doc/master/TAxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html
https://root.cern/doc/master/TAxis_8h_source.html:5823,Modifiability,variab,variable,5823,"const { return fLabels; }; 122 TList *GetModifiedLabels() const { return fModLabs; }; 123 virtual void GetLowEdge(Double_t *edge) const;; 124 Bool_t GetMoreLogLabels() const { return TestBit(kMoreLogLabels); }; 125 Int_t GetNbins() const { return fNbins; }; 126 Int_t GetNlabels() const;; 127 Bool_t GetNoExponent() const { return TestBit(kNoExponent); }; 128 virtual TObject *GetParent() const {return fParent;}; 129 Bool_t GetRotateTitle() const { return TestBit(kRotateTitle); }; 130 virtual const char *GetTicks() const;; 131 virtual Bool_t GetTimeDisplay() const {return fTimeDisplay;}; 132 virtual const char *GetTimeFormat() const {return fTimeFormat.Data();}; 133 virtual const char *GetTimeFormatOnly() const;; 134 UInt_t GetTimeOffset();; 135 const char *GetTitle() const override {return fTitle.Data();}; 136 const TArrayD *GetXbins() const {return &fXbins;}; 137 Int_t GetFirst() const;; 138 Int_t GetLast() const;; 139 Double_t GetXmin() const {return fXmin;}; 140 Double_t GetXmax() const {return fXmax;}; 141 virtual void ImportAttributes(const TAxis *axis);; 142 Bool_t IsVariableBinSize() const {; 143 // true if axis has variable bin sizes, false otherwise; 144 return (fXbins.GetSize() != 0);; 145 }; 146 virtual void LabelsOption(Option_t *option=""h""); // *MENU*; 147 void RotateTitle(Bool_t rotate=kTRUE); // *TOGGLE* *GETTER=GetRotateTitle; 148 void SaveAttributes(std::ostream &out, const char *name, const char *subname) override;; 149 virtual void Set(Int_t nbins, Double_t xmin, Double_t xmax);; 150 virtual void Set(Int_t nbins, const Float_t *xbins);; 151 virtual void Set(Int_t nbins, const Double_t *xbins);; 152 virtual void SetBinLabel(Int_t bin, const char *label);; 153 void SetDecimals(Bool_t dot = kTRUE); // *TOGGLE* *GETTER=GetDecimals; 154 virtual void SetDefaults();; 155 void SetDrawOption(Option_t * /*option*/ ="""") override { }; 156 void ChangeLabel(Int_t labNum=0, Double_t labAngle = -1.,; 157 Double_t labSize = -1., Int_t labAlign = -1,; 158 Int_t labCol",MatchSource.WIKI,doc/master/TAxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html
https://root.cern/doc/master/TAxis_8h_source.html:19344,Modifiability,extend,extended,19344,"xis.h:62; TAxis::kCenterLabels@ kCenterLabelsBit 13 is used by TObject.Definition TAxis.h:67; TAxis::kLabelsVert@ kLabelsVertDefinition TAxis.h:72; TAxis::fTimeDisplayBool_t fTimeDisplayOn/off displaying time values instead of numerics.Definition TAxis.h:41; TAxis::GetNoExponentBool_t GetNoExponent() constDefinition TAxis.h:127; TAxis::fModLabsTList * fModLabsList of modified labels.Definition TAxis.h:45; TAxis::GetBinLabelconst char * GetBinLabel(Int_t bin) constReturn label for bin.Definition TAxis.cxx:440; TAxis::FindBinvirtual Int_t FindBin(Double_t x)Find bin number corresponding to abscissa x.Definition TAxis.cxx:293; TAxis::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn low edge of bin.Definition TAxis.cxx:518; TAxis::fNbinsInt_t fNbinsNumber of bins.Definition TAxis.h:34; TAxis::kAlphanumeric@ kAlphanumericAxis is alphanumeric.Definition TAxis.h:49; TAxis::kNotAlpha@ kNotAlphaAxis is forced to be not alphanumeric.Definition TAxis.h:51; TAxis::kCanExtend@ kCanExtendAxis can be extended.Definition TAxis.h:50; TAxis::SetTimeDisplayvirtual void SetTimeDisplay(Int_t value)Definition TAxis.h:171; TAxis::fXminDouble_t fXminLow edge of first bin.Definition TAxis.h:35; TAxis::Setvirtual void Set(Int_t nbins, Double_t xmin, Double_t xmax)Initialize axis with fix bins.Definition TAxis.cxx:794; TAxis::HasBinWithoutLabelBool_t HasBinWithoutLabel() constThis helper function checks if there is a bin without a label if all bins have labels,...Definition TAxis.cxx:646; TAxis::RotateTitlevoid RotateTitle(Bool_t rotate=kTRUE)Rotate title by 180 degrees.Definition TAxis.h:203; TAxis::FindModLabTAxisModLab * FindModLab(Int_t num, Double_t v=0., Double_t eps=0.) constSearch for axis modifier by index or value.Definition TAxis.cxx:922; TAxis::CenterTitlevoid CenterTitle(Bool_t center=kTRUE)Center axis title.Definition TAxis.h:194; TAxis::FindFixBinvirtual Int_t FindFixBin(Double_t x) constFind bin number corresponding to abscissa x.Definition TAxis.cxx:419; TAx",MatchSource.WIKI,doc/master/TAxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html
https://root.cern/doc/master/TAxis_8h_source.html:24323,Security,hash,hash,24323," TAxis.cxx:1157; TAxis::CanBeAlphanumericBool_t CanBeAlphanumeric()Definition TAxis.h:87; TAxis::fTimeFormatTString fTimeFormatDate&time format, ex: 09/12/99 12:34:00.Definition TAxis.h:42; TAxis::GetParentvirtual TObject * GetParent() constDefinition TAxis.h:128; TAxis::SetRangevirtual void SetRange(Int_t first=0, Int_t last=0)Set the viewing range for the axis using bin numbers.Definition TAxis.cxx:1052; TAxis::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width.Definition TAxis.cxx:540; TAxis::GetBinUpEdgevirtual Double_t GetBinUpEdge(Int_t bin) constReturn up edge of bin.Definition TAxis.cxx:528; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TAxis::GetTicksvirtual const char * GetTicks() constReturn the ticks option (see SetTicks)Definition TAxis.cxx:634; TAxis::fBits2UShort_t fBits2Second bit status word.Definition TAxis.h:40; TAxis::fFirstInt_t fFirstFirst bin to display.Definition TAxis.h:38; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; bool; double; int; xDouble_t x[n]Definition legend1.C:17; v@ vDefinition rootcling_impl.cxx:3699. histhistincTAxis.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TAxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html
https://root.cern/doc/master/TAxis_8h_source.html:9670,Testability,log,log,9670,"is right adjusted; 193 ; 194inline void TAxis::CenterTitle(Bool_t center); 195{; 196 SetBit(kCenterTitle, center);; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// Rotate title by 180 degrees. By default the title is drawn right adjusted.; 201/// If rotate is TRUE, the title is left adjusted at the end of the axis and rotated by 180 degrees; 202 ; 203inline void TAxis::RotateTitle(Bool_t rotate); 204{; 205 SetBit(kRotateTitle, rotate);; 206}; 207 ; 208////////////////////////////////////////////////////////////////////////////////; 209/// Sets the decimals flag; 210/// By default, blank characters are stripped, and then the label is correctly aligned.; 211/// If the dot is the last character of the string, it is also stripped, unless this option is specified.; 212 ; 213inline void TAxis::SetDecimals(Bool_t dot) {; 214 SetBit(kDecimals, dot);; 215}; 216 ; 217////////////////////////////////////////////////////////////////////////////////; 218/// Set the kMoreLogLabels bit flag; 219/// When this option is selected more labels are drawn when in log scale and there is a small number; 220/// of decades (<3).; 221/// The flag (in fBits) is passed to the drawing function TGaxis::PaintAxis; 222 ; 223inline void TAxis::SetMoreLogLabels(Bool_t more); 224{; 225 SetBit(kMoreLogLabels, more);; 226}; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Set the NoExponent flag; 230/// By default, an exponent of the form 10^N is used when the label value are either all very small or very large.; 231/// The flag (in fBits) is passed to the drawing function TGaxis::PaintAxis; 232 ; 233inline void TAxis::SetNoExponent(Bool_t noExponent); 234{; 235 SetBit(kNoExponent, noExponent);; 236}; 237 ; 238 ; 239#endif; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinitio",MatchSource.WIKI,doc/master/TAxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html
https://root.cern/doc/master/TAxis_8h_source.html:16165,Testability,log,log,16165,"t offset=0)Zoom out by a factor of 'factor' (default =2) uses previous zoom factor by default Keep center define...Definition TAxis.cxx:1344; TAxis::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TAxis.h:135; TAxis::GetNlabelsInt_t GetNlabels() constReturn the number of axis labels.Definition TAxis.cxx:581; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TAxis::fParentTObject * fParent! Object owning this axisDefinition TAxis.h:43; TAxis::fXmaxDouble_t fXmaxUpper edge of last bin.Definition TAxis.h:36; TAxis::SetNoAlphanumericvoid SetNoAlphanumeric(Bool_t noalpha=kTRUE)Definition TAxis.h:91; TAxis::GetCenterTitleBool_t GetCenterTitle() constDefinition TAxis.h:119; TAxis::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to an axis.Definition TAxis.cxx:265; TAxis::SetMoreLogLabelsvoid SetMoreLogLabels(Bool_t more=kTRUE)Set the kMoreLogLabels bit flag When this option is selected more labels are drawn when in log scale ...Definition TAxis.h:223; TAxis::CanExtendBool_t CanExtend() constDefinition TAxis.h:86; TAxis::fXbinsTArrayD fXbinsBin edges array in X.Definition TAxis.h:37; TAxis::SetParentvirtual void SetParent(TObject *obj)Definition TAxis.h:167; TAxis::TAxisTAxis()Default constructor.Definition TAxis.cxx:50; TAxis::DrawCloneTObject * DrawClone(Option_t *="""") const overrideDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TAxis.h:104; TAxis::GetTimeOffsetUInt_t GetTimeOffset()Return the time offset in GMT.Definition TAxis.cxx:614; TAxis::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TAxis.cxx:281; TAxis::UnZoomvirtual void UnZoom()Reset first & last bin to the full range.Definition TAxis.cxx:1269; TAxis::fLabelsTHashList * fLabelsList of labels.Definition TAxis.h:44; TAxis::GetXbinscons",MatchSource.WIKI,doc/master/TAxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html
https://root.cern/doc/master/TAxis_8h_source.html:21655,Testability,log,log,21655,":155; TAxis::SetNoExponentvoid SetNoExponent(Bool_t noExponent=kTRUE)Set the NoExponent flag By default, an exponent of the form 10^N is used when the label value are eit...Definition TAxis.h:233; TAxis::SaveAttributesvoid SaveAttributes(std::ostream &out, const char *name, const char *subname) overrideSave axis attributes as C++ statement(s) on output stream out.Definition TAxis.cxx:710; TAxis::GetDecimalsBool_t GetDecimals() constDefinition TAxis.h:120; TAxis::GetLastInt_t GetLast() constReturn last bin on the axis i.e.Definition TAxis.cxx:469; TAxis::SetLimitsvirtual void SetLimits(Double_t xmin, Double_t xmax)Definition TAxis.h:164; TAxis::ImportAttributesvirtual void ImportAttributes(const TAxis *axis)Copy axis attributes to this.Definition TAxis.cxx:680; TAxis::GetTimeFormatOnlyvirtual const char * GetTimeFormatOnly() constReturn only the time format from the string fTimeFormat.Definition TAxis.cxx:599; TAxis::GetBinCenterLogvirtual Double_t GetBinCenterLog(Int_t bin) constReturn center of bin in log With a log-equidistant binning for a bin with low and up edges,...Definition TAxis.cxx:501; TAxis::SetAlphanumericvoid SetAlphanumeric(Bool_t alphanumeric=kTRUE)Set axis alphanumeric.Definition TAxis.cxx:842; TAxis::GetXminDouble_t GetXmin() constDefinition TAxis.h:139; TAxis::operator=TAxis & operator=(const TAxis &)Assignment operator.Definition TAxis.cxx:118; TAxis::~TAxis~TAxis() overrideDestructor.Definition TAxis.cxx:89; TAxis::GetModifiedLabelsTList * GetModifiedLabels() constDefinition TAxis.h:122; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::ChangeLabelByValuevoid ChangeLabelByValue(Double_t labValue, Double_t labAngle=-1., Double_t labSize=-1., Int_t labAlign=-1, Int_t labColor=-1, Int_t labFont=-1, const TString &labText="""")Define new text attributes for the label value ""labValue"".Definition TAxis.cxx:1009; TAxis::SetRangeUservirtual void SetRangeUser(Double_t ufirst, Double_t ulast)Set the viewing range for the axis from ufirst t",MatchSource.WIKI,doc/master/TAxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html
https://root.cern/doc/master/TAxis_8h_source.html:21666,Testability,log,log-equidistant,21666,":155; TAxis::SetNoExponentvoid SetNoExponent(Bool_t noExponent=kTRUE)Set the NoExponent flag By default, an exponent of the form 10^N is used when the label value are eit...Definition TAxis.h:233; TAxis::SaveAttributesvoid SaveAttributes(std::ostream &out, const char *name, const char *subname) overrideSave axis attributes as C++ statement(s) on output stream out.Definition TAxis.cxx:710; TAxis::GetDecimalsBool_t GetDecimals() constDefinition TAxis.h:120; TAxis::GetLastInt_t GetLast() constReturn last bin on the axis i.e.Definition TAxis.cxx:469; TAxis::SetLimitsvirtual void SetLimits(Double_t xmin, Double_t xmax)Definition TAxis.h:164; TAxis::ImportAttributesvirtual void ImportAttributes(const TAxis *axis)Copy axis attributes to this.Definition TAxis.cxx:680; TAxis::GetTimeFormatOnlyvirtual const char * GetTimeFormatOnly() constReturn only the time format from the string fTimeFormat.Definition TAxis.cxx:599; TAxis::GetBinCenterLogvirtual Double_t GetBinCenterLog(Int_t bin) constReturn center of bin in log With a log-equidistant binning for a bin with low and up edges,...Definition TAxis.cxx:501; TAxis::SetAlphanumericvoid SetAlphanumeric(Bool_t alphanumeric=kTRUE)Set axis alphanumeric.Definition TAxis.cxx:842; TAxis::GetXminDouble_t GetXmin() constDefinition TAxis.h:139; TAxis::operator=TAxis & operator=(const TAxis &)Assignment operator.Definition TAxis.cxx:118; TAxis::~TAxis~TAxis() overrideDestructor.Definition TAxis.cxx:89; TAxis::GetModifiedLabelsTList * GetModifiedLabels() constDefinition TAxis.h:122; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::ChangeLabelByValuevoid ChangeLabelByValue(Double_t labValue, Double_t labAngle=-1., Double_t labSize=-1., Int_t labAlign=-1, Int_t labColor=-1, Int_t labFont=-1, const TString &labText="""")Define new text attributes for the label value ""labValue"".Definition TAxis.cxx:1009; TAxis::SetRangeUservirtual void SetRangeUser(Double_t ufirst, Double_t ulast)Set the viewing range for the axis from ufirst t",MatchSource.WIKI,doc/master/TAxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html
https://root.cern/doc/master/TBaseClass_8h_source.html:5060,Integrability,interface,interface,5060,"g_t Property() const overrideGet property description word. For meaning of bits see EProperty.Definition TBaseClass.cxx:134; TBaseClass::~TBaseClassvirtual ~TBaseClass()TBaseClass dtor deletes adopted CINT BaseClassInfo object.Definition TBaseClass.cxx:46; TBaseClass::TBaseClassTBaseClass(const TBaseClass &)=delete; TBaseClass::fClassPtrTClassRef fClassPtrpointer to CINT base class infoDefinition TBaseClass.h:50; TBaseClass::fDeltaAtomicInt_t fDeltapointer to parent classDefinition TBaseClass.h:52; TBaseClass::fClassTClass * fClassDefinition TBaseClass.h:51; TBaseClass::fSTLTypeInt_t fSTLTypeDefinition TBaseClass.h:54; TBaseClass::fPropertyAtomicInt_t fPropertyDefinition TBaseClass.h:53; TBaseClass::SetClassvoid SetClass(TClass *cl)Definition TBaseClass.h:67; TBaseClass::fInfoBaseClassInfo_t * fInfoDefinition TBaseClass.h:49; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBaseClass::AtomicInt_tstd::atomic< Int_t > AtomicInt_tDefinition TBaseClass.h:35; TBaseClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TBaseClass.h:64; TBaseClass::GetTitleconst char * GetTitle() const overrideGet base class description (comment).Definition TBaseClass.cxx:92; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; bool; int; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28. coremetaincTBaseClass.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBaseClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBaseClass_8h_source.html
https://root.cern/doc/master/TBaseClass_8h_source.html:1916,Performance,cache,cache,1916,"//////////////; 17// //; 18// TBaseClass //; 19// //; 20// Description of a base class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24 ; 25#include ""TDictionary.h""; 26#include ""TClassRef.h""; 27 ; 28#include <atomic>; 29 ; 30class TBrowser;; 31class TClass;; 32 ; 33class TBaseClass : public TDictionary {; 34#ifndef __CLING__; 35 using AtomicInt_t = std::atomic<Int_t>;; 36 static_assert(sizeof(std::atomic<Int_t>) == sizeof(Int_t),; 37 ""We requiqre atomic<int> and <int> to have the same size but they are not"");; 38#else; 39 // std::atomic is not yet supported in the I/O, so; 40 // we hide them from Cling; 41 using AtomicInt_t = Int_t;; 42#endif; 43 ; 44private:; 45 TBaseClass(const TBaseClass &) = delete;; 46 TBaseClass&operator=(const TBaseClass &) = delete;; 47 ; 48private:; 49 BaseClassInfo_t *fInfo; //!pointer to CINT base class info; 50 TClassRef fClassPtr; // pointer to the base class TClass; 51 TClass *fClass; //!pointer to parent class; 52 AtomicInt_t fDelta; // BaseClassInfo_t offset (INT_MAX if unset); 53 mutable AtomicInt_t fProperty; // BaseClassInfo_t's properties; 54 Int_t fSTLType; // cache of IsSTLContainer(); 55 ; 56public:; 57 TBaseClass(BaseClassInfo_t *info = nullptr, TClass *cl = nullptr);; 58 virtual ~TBaseClass();; 59 ; 60 void Browse(TBrowser *b) override;; 61 const char *GetTitle() const override;; 62 TClass *GetClassPointer(Bool_t load=kTRUE);; 63 Int_t GetDelta();; 64 Bool_t IsFolder() const override {return kTRUE;}; 65 ROOT::ESTLType IsSTLContainer();; 66 Long_t Property() const override;; 67 void SetClass(TClass* cl) { fClass = cl; }; 68 ; 69 ClassDefOverride(TBaseClass,2) //Description of a base class; 70};; 71 ; 72#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TClassRef.h; ",MatchSource.WIKI,doc/master/TBaseClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBaseClass_8h_source.html
https://root.cern/doc/master/TBaseClass_8h_source.html:2178,Performance,load,load,2178,"//////////////; 17// //; 18// TBaseClass //; 19// //; 20// Description of a base class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24 ; 25#include ""TDictionary.h""; 26#include ""TClassRef.h""; 27 ; 28#include <atomic>; 29 ; 30class TBrowser;; 31class TClass;; 32 ; 33class TBaseClass : public TDictionary {; 34#ifndef __CLING__; 35 using AtomicInt_t = std::atomic<Int_t>;; 36 static_assert(sizeof(std::atomic<Int_t>) == sizeof(Int_t),; 37 ""We requiqre atomic<int> and <int> to have the same size but they are not"");; 38#else; 39 // std::atomic is not yet supported in the I/O, so; 40 // we hide them from Cling; 41 using AtomicInt_t = Int_t;; 42#endif; 43 ; 44private:; 45 TBaseClass(const TBaseClass &) = delete;; 46 TBaseClass&operator=(const TBaseClass &) = delete;; 47 ; 48private:; 49 BaseClassInfo_t *fInfo; //!pointer to CINT base class info; 50 TClassRef fClassPtr; // pointer to the base class TClass; 51 TClass *fClass; //!pointer to parent class; 52 AtomicInt_t fDelta; // BaseClassInfo_t offset (INT_MAX if unset); 53 mutable AtomicInt_t fProperty; // BaseClassInfo_t's properties; 54 Int_t fSTLType; // cache of IsSTLContainer(); 55 ; 56public:; 57 TBaseClass(BaseClassInfo_t *info = nullptr, TClass *cl = nullptr);; 58 virtual ~TBaseClass();; 59 ; 60 void Browse(TBrowser *b) override;; 61 const char *GetTitle() const override;; 62 TClass *GetClassPointer(Bool_t load=kTRUE);; 63 Int_t GetDelta();; 64 Bool_t IsFolder() const override {return kTRUE;}; 65 ROOT::ESTLType IsSTLContainer();; 66 Long_t Property() const override;; 67 void SetClass(TClass* cl) { fClass = cl; }; 68 ; 69 ClassDefOverride(TBaseClass,2) //Description of a base class; 70};; 71 ; 72#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TClassRef.h; ",MatchSource.WIKI,doc/master/TBaseClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBaseClass_8h_source.html
https://root.cern/doc/master/TBaseClass_8h_source.html:4248,Performance,load,load,4248,"r *b) overrideCalled by the browser, to browse a baseclass.Definition TBaseClass.cxx:54; TBaseClass::PropertyLong_t Property() const overrideGet property description word. For meaning of bits see EProperty.Definition TBaseClass.cxx:134; TBaseClass::~TBaseClassvirtual ~TBaseClass()TBaseClass dtor deletes adopted CINT BaseClassInfo object.Definition TBaseClass.cxx:46; TBaseClass::TBaseClassTBaseClass(const TBaseClass &)=delete; TBaseClass::fClassPtrTClassRef fClassPtrpointer to CINT base class infoDefinition TBaseClass.h:50; TBaseClass::fDeltaAtomicInt_t fDeltapointer to parent classDefinition TBaseClass.h:52; TBaseClass::fClassTClass * fClassDefinition TBaseClass.h:51; TBaseClass::fSTLTypeInt_t fSTLTypeDefinition TBaseClass.h:54; TBaseClass::fPropertyAtomicInt_t fPropertyDefinition TBaseClass.h:53; TBaseClass::SetClassvoid SetClass(TClass *cl)Definition TBaseClass.h:67; TBaseClass::fInfoBaseClassInfo_t * fInfoDefinition TBaseClass.h:49; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBaseClass::AtomicInt_tstd::atomic< Int_t > AtomicInt_tDefinition TBaseClass.h:35; TBaseClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TBaseClass.h:64; TBaseClass::GetTitleconst char * GetTitle() const overrideGet base class description (comment).Definition TBaseClass.cxx:92; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; bool; int; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28. coremetaincTBaseCl",MatchSource.WIKI,doc/master/TBaseClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBaseClass_8h_source.html
https://root.cern/doc/master/TBox_8cxx_source.html:19648,Deployability,release,released,19648,"A) {; 563 fX1 = gPad->AbsPixeltoX(pxold);; 564 fY1 = gPad->AbsPixeltoY(pyt);; 565 fX2 = gPad->AbsPixeltoX(pxt);; 566 fY2 = gPad->AbsPixeltoY(pyold);; 567 }; 568 if (pB) {; 569 fX1 = gPad->AbsPixeltoX(pxl);; 570 fY1 = gPad->AbsPixeltoY(pyt);; 571 fX2 = gPad->AbsPixeltoX(pxold);; 572 fY2 = gPad->AbsPixeltoY(pyold);; 573 }; 574 if (pC) {; 575 fX1 = gPad->AbsPixeltoX(pxl);; 576 fY1 = gPad->AbsPixeltoY(pyold);; 577 fX2 = gPad->AbsPixeltoX(pxold);; 578 fY2 = gPad->AbsPixeltoY(pyl);; 579 }; 580 if (pD) {; 581 fX1 = gPad->AbsPixeltoX(pxold);; 582 fY1 = gPad->AbsPixeltoY(pyold);; 583 fX2 = gPad->AbsPixeltoX(pxt);; 584 fY2 = gPad->AbsPixeltoY(pyl);; 585 }; 586 if (pTop || pBot || pL || pR || pINSIDE) {; 587 fX1 = gPad->AbsPixeltoX(px1);; 588 fY1 = gPad->AbsPixeltoY(py1);; 589 fX2 = gPad->AbsPixeltoX(px2);; 590 fY2 = gPad->AbsPixeltoY(py2);; 591 }; 592 ; 593 if (isBox) {; 594 if (gPad->GetLogx()) {; 595 fX1 = TMath::Power(10,fX1);; 596 fX2 = TMath::Power(10,fX2);; 597 }; 598 if (gPad->GetLogy()) {; 599 fY1 = TMath::Power(10,fY1);; 600 fY2 = TMath::Power(10,fY2);; 601 }; 602 }; 603 if (pINSIDE) {; 604 // if it was not a pad that was moved then it must have been; 605 // a box or something like that so we have to redraw the pad; 606 if (parent == gPad) gPad->Modified(kTRUE);; 607 }; 608 }; 609 ; 610 if (pA || pB || pC || pD || pTop || pL || pR || pBot) gPad->Modified(kTRUE);; 611 ; 612 if (!opaque) {; 613 gVirtualX->SetLineColor(-1);; 614 gVirtualX->SetLineWidth(-1);; 615 }; 616 ; 617 break;; 618 ; 619 case kButton1Locate:; 620 ; 621 ExecuteEvent(kButton1Down, px, py);; 622 ; 623 while (true) {; 624 px = py = 0;; 625 event = gVirtualX->RequestLocator(1, 1, px, py);; 626 ; 627 ExecuteEvent(kButton1Motion, px, py);; 628 ; 629 if (event != -1) { // button is released; 630 ExecuteEvent(kButton1Up, px, py);; 631 return;; 632 }; 633 }; 634 }; 635}; 636 ; 637////////////////////////////////////////////////////////////////////////////////; 638/// Hide tool tip depending on the event type.",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
https://root.cern/doc/master/TBox_8cxx_source.html:40631,Energy Efficiency,power,power,40631,"Point.h:47; TPoint::GetXSCoord_t GetX() constDefinition TPoint.h:46; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::YtoAbsPixelvirtual Int_t YtoAbsPixel(Double_t y) const =0; TVirtualPad::GetX2virtual Double_t GetX2() const =0; TVirtualPad::XtoAbsPixelvirtual Int_t XtoAbsPixel(Double_t x) const =0; TVirtualPad::GetY1virtual Double_t GetY1() const =0; TVirtualPad::GetY2virtual Double_t GetY2() const =0; TVirtualPad::GetBorderSizevirtual Short_t GetBorderSize() const =0; TVirtualPad::GetX1virtual Double_t GetX1() const =0; TVirtualX::kHollow@ kHollowDefinition TVirtualX.h:50; bool; double; int; unsigned int; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; Rectangle_tRectangle structure (maps to the X11 XRectangle structure)Definition GuiTypes.h:361. graf2dgrafsrcTBox.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
https://root.cern/doc/master/TBox_8cxx_source.html:19849,Integrability,depend,depending,19849,"A) {; 563 fX1 = gPad->AbsPixeltoX(pxold);; 564 fY1 = gPad->AbsPixeltoY(pyt);; 565 fX2 = gPad->AbsPixeltoX(pxt);; 566 fY2 = gPad->AbsPixeltoY(pyold);; 567 }; 568 if (pB) {; 569 fX1 = gPad->AbsPixeltoX(pxl);; 570 fY1 = gPad->AbsPixeltoY(pyt);; 571 fX2 = gPad->AbsPixeltoX(pxold);; 572 fY2 = gPad->AbsPixeltoY(pyold);; 573 }; 574 if (pC) {; 575 fX1 = gPad->AbsPixeltoX(pxl);; 576 fY1 = gPad->AbsPixeltoY(pyold);; 577 fX2 = gPad->AbsPixeltoX(pxold);; 578 fY2 = gPad->AbsPixeltoY(pyl);; 579 }; 580 if (pD) {; 581 fX1 = gPad->AbsPixeltoX(pxold);; 582 fY1 = gPad->AbsPixeltoY(pyold);; 583 fX2 = gPad->AbsPixeltoX(pxt);; 584 fY2 = gPad->AbsPixeltoY(pyl);; 585 }; 586 if (pTop || pBot || pL || pR || pINSIDE) {; 587 fX1 = gPad->AbsPixeltoX(px1);; 588 fY1 = gPad->AbsPixeltoY(py1);; 589 fX2 = gPad->AbsPixeltoX(px2);; 590 fY2 = gPad->AbsPixeltoY(py2);; 591 }; 592 ; 593 if (isBox) {; 594 if (gPad->GetLogx()) {; 595 fX1 = TMath::Power(10,fX1);; 596 fX2 = TMath::Power(10,fX2);; 597 }; 598 if (gPad->GetLogy()) {; 599 fY1 = TMath::Power(10,fY1);; 600 fY2 = TMath::Power(10,fY2);; 601 }; 602 }; 603 if (pINSIDE) {; 604 // if it was not a pad that was moved then it must have been; 605 // a box or something like that so we have to redraw the pad; 606 if (parent == gPad) gPad->Modified(kTRUE);; 607 }; 608 }; 609 ; 610 if (pA || pB || pC || pD || pTop || pL || pR || pBot) gPad->Modified(kTRUE);; 611 ; 612 if (!opaque) {; 613 gVirtualX->SetLineColor(-1);; 614 gVirtualX->SetLineWidth(-1);; 615 }; 616 ; 617 break;; 618 ; 619 case kButton1Locate:; 620 ; 621 ExecuteEvent(kButton1Down, px, py);; 622 ; 623 while (true) {; 624 px = py = 0;; 625 event = gVirtualX->RequestLocator(1, 1, px, py);; 626 ; 627 ExecuteEvent(kButton1Motion, px, py);; 628 ; 629 if (event != -1) { // button is released; 630 ExecuteEvent(kButton1Up, px, py);; 631 return;; 632 }; 633 }; 634 }; 635}; 636 ; 637////////////////////////////////////////////////////////////////////////////////; 638/// Hide tool tip depending on the event type.",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
https://root.cern/doc/master/TBox_8cxx_source.html:34512,Integrability,depend,depending,34512,"t x2, Double_t y2, Option_t *option="""")Draw this box with new coordinates.Definition TBox.cxx:678; TBox::Classstatic TClass * Class(); TBox::Streamervoid Streamer(TBuffer &) overrideStream an object of class TBox.Definition TBox.cxx:751; TBox::SetBBoxX1void SetBBoxX1(const Int_t x) overrideSet left hand side of BoundingBox to a value (resize in x direction on left)Definition TBox.cxx:880; TBox::~TBox~TBox() overrideBox destructor.Definition TBox.cxx:69; TBox::operator=TBox & operator=(const TBox &)Assignment operator.Definition TBox.cxx:93; TBox::SetBBoxY2void SetBBoxY2(const Int_t y) overrideSet bottom of BoundingBox to a value (resize in y direction on bottom)Definition TBox.cxx:912; TBox::SetBBoxY1void SetBBoxY1(const Int_t y) overrideSet top of BoundingBox to a value (resize in y direction on top)Definition TBox.cxx:901; TBox::fX1Double_t fX1X of 1st point.Definition TBox.h:28; TBox::IsATClass * IsA() const overrideDefinition TBox.h:77; TBox::HideToolTipvirtual void HideToolTip(Int_t event)Hide tool tip depending on the event type.Definition TBox.cxx:642; TBox::SetBBoxCenterYvoid SetBBoxCenterY(const Int_t y) overrideSet Y coordinate of the center of the Box.Definition TBox.cxx:861; TBox::GetX2Double_t GetX2() constDefinition TBox.h:52; TBox::lsvoid ls(Option_t *option="""") const overrideList this box with its attributes.Definition TBox.cxx:661; TBox::GetY1Double_t GetY1() constDefinition TBox.h:53; TBox::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TBox.cxx:232; TBox::SetX1virtual void SetX1(Double_t x1)Definition TBox.h:62; TBox::Paintvoid Paint(Option_t *option="""") overridePaint this box with its current attributes.Definition TBox.cxx:670; TBox::GetY2Double_t GetY2() constDefinition TBox.h:54; TBox::IsInsidevirtual Int_t IsInside(Double_t x, Double_t y) constFunction which returns 1 if point x,y lies inside the box, 0 otherwise.Definition TBox.cxx:651; TBox::GetBBoxCenterTPoint GetB",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
https://root.cern/doc/master/TBox_8cxx_source.html:38490,Integrability,message,message,38490,"*bcnt=nullptr, const TClass *cl=nullptr)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::ReadClassBuffervirtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, const TClass *onfile_class=nullptr)=0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPointDefinition TPoint.h:31; TPoint::GetYSCoord_t GetY() constDefinition TPoint.h:47; TPoint::GetXSCoord_t GetX() constDefinition TPoint.h:46; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Chang",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
https://root.cern/doc/master/TBox_8cxx_source.html:38882,Modifiability,inherit,inherits,38882,"sBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPointDefinition TPoint.h:31; TPoint::GetYSCoord_t GetY() constDefinition TPoint.h:47; TPoint::GetXSCoord_t GetX() constDefinition TPoint.h:46; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::YtoAbsPixelvirtual Int_t YtoAbsPixel(Double_t y) const =0; TVirtualPad::GetX2vi",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
https://root.cern/doc/master/TBox_8cxx_source.html:40833,Testability,log,logarithm,40833,"Point.h:47; TPoint::GetXSCoord_t GetX() constDefinition TPoint.h:46; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::YtoAbsPixelvirtual Int_t YtoAbsPixel(Double_t y) const =0; TVirtualPad::GetX2virtual Double_t GetX2() const =0; TVirtualPad::XtoAbsPixelvirtual Int_t XtoAbsPixel(Double_t x) const =0; TVirtualPad::GetY1virtual Double_t GetY1() const =0; TVirtualPad::GetY2virtual Double_t GetY2() const =0; TVirtualPad::GetBorderSizevirtual Short_t GetBorderSize() const =0; TVirtualPad::GetX1virtual Double_t GetX1() const =0; TVirtualX::kHollow@ kHollowDefinition TVirtualX.h:50; bool; double; int; unsigned int; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; Rectangle_tRectangle structure (maps to the X11 XRectangle structure)Definition GuiTypes.h:361. graf2dgrafsrcTBox.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
https://root.cern/doc/master/TBox_8h_source.html:5539,Integrability,depend,depending,5539,"t tool tip text associated with this box.Definition TBox.cxx:732; TBox::SetY2virtual void SetY2(Double_t y2)Definition TBox.h:65; TBox::PaintBoxvirtual void PaintBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Option_t *option="""")Draw this box with new coordinates.Definition TBox.cxx:678; TBox::SetBBoxX1void SetBBoxX1(const Int_t x) overrideSet left hand side of BoundingBox to a value (resize in x direction on left)Definition TBox.cxx:880; TBox::~TBox~TBox() overrideBox destructor.Definition TBox.cxx:69; TBox::operator=TBox & operator=(const TBox &)Assignment operator.Definition TBox.cxx:93; TBox::SetBBoxY2void SetBBoxY2(const Int_t y) overrideSet bottom of BoundingBox to a value (resize in y direction on bottom)Definition TBox.cxx:912; TBox::SetBBoxY1void SetBBoxY1(const Int_t y) overrideSet top of BoundingBox to a value (resize in y direction on top)Definition TBox.cxx:901; TBox::fX1Double_t fX1X of 1st point.Definition TBox.h:28; TBox::HideToolTipvirtual void HideToolTip(Int_t event)Hide tool tip depending on the event type.Definition TBox.cxx:642; TBox::SetBBoxCenterYvoid SetBBoxCenterY(const Int_t y) overrideSet Y coordinate of the center of the Box.Definition TBox.cxx:861; TBox::GetX2Double_t GetX2() constDefinition TBox.h:52; TBox::lsvoid ls(Option_t *option="""") const overrideList this box with its attributes.Definition TBox.cxx:661; TBox::GetY1Double_t GetY1() constDefinition TBox.h:53; TBox::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TBox.cxx:232; TBox::SetX1virtual void SetX1(Double_t x1)Definition TBox.h:62; TBox::Paintvoid Paint(Option_t *option="""") overridePaint this box with its current attributes.Definition TBox.cxx:670; TBox::GetY2Double_t GetY2() constDefinition TBox.h:54; TBox::IsInsidevirtual Int_t IsInside(Double_t x, Double_t y) constFunction which returns 1 if point x,y lies inside the box, 0 otherwise.Definition TBox.cxx:651; TBox::GetBBoxCenterTPoint GetB",MatchSource.WIKI,doc/master/TBox_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8h_source.html
https://root.cern/doc/master/TBox_8h_source.html:1230,Testability,test,test,1230,"h""; 19 ; 20class TPoint;; 21 ; 22class TBox : public TObject, public TAttLine, public TAttFill, public TAttBBox2D {; 23 ; 24private:; 25 TObject *fTip{nullptr}; ///<! tool tip associated with box; 26 ; 27protected:; 28 Double_t fX1; ///< X of 1st point; 29 Double_t fY1; ///< Y of 1st point; 30 Double_t fX2; ///< X of 2nd point; 31 Double_t fY2; ///< Y of 2nd point; 32 Bool_t fResizing; ///<! True if box is being resized; 33 ; 34public:; 35 // Private bits, clients can only test but not change them; 36 enum {; 37 kCannotMove = BIT(12) //if set the box cannot be moved/resized; 38 };; 39 TBox();; 40 TBox(Double_t x1, Double_t y1,Double_t x2, Double_t y2);; 41 TBox(const TBox &box);; 42 TBox& operator=(const TBox&);; 43 ~TBox() override;; 44 ; 45 void Copy(TObject &box) const override;; 46 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 47 void Draw(Option_t *option="""") override;; 48 virtual TBox *DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2);; 49 void ExecuteEvent(Int_t event, Int_t px, Int_t py) override;; 50 Bool_t IsBeingResized() const { return fResizing; }; 51 Double_t GetX1() const { return fX1; }; 52 Double_t GetX2() const { return fX2; }; 53 Double_t GetY1() const { return fY1; }; 54 Double_t GetY2() c",MatchSource.WIKI,doc/master/TBox_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8h_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:15711,Availability,down,downwards,15711,"ement->CannotSplit()) {; 432 fSplitLevel = 0;; 433 } else if (element->IsA() == TStreamerBase::Class()) {; 434 // -- We are a base class element.; 435 // Note: This does not include an STL container class which is; 436 // being used as a base class because the streamer element; 437 // in that case is not the base streamer element it is the; 438 // STL streamer element.; 439 fType = 1;; 440 TClass* clOfElement = element->GetClassPointer();; 441 Int_t nbranches = fBranches.GetEntriesFast();; 442 // Note: The following code results in base class branches; 443 // having two different cases for what their parent; 444 // class will be, this is very annoying. It is also; 445 // very annoying that the naming conventions for the; 446 // sub-branch names are different as well.; 447 if (!strcmp(name, clOfElement->GetName())) {; 448 // -- If the branch's name is the same as the base class name,; 449 // which happens when we are a child branch of a top-level; 450 // branch whose name does not end in a dot and also has no; 451 // internal dots, elide the branch name, and keep the branch; 452 // hierarchy rooted at the ultimate parent, this keeps the base; 453 // class part of the branch name from propagating downwards.; 454 // FIXME: We are eliding the base class here, creating a break in the branch hierarchy.; 455 // Note: We can use parent class (cltop) != branch class (elemClass) to detection elision.; 456 Unroll("""", fBranchClass.GetClass(), clOfElement, pointer, basketsize, splitlevel+splitSTLP, 0);; 457 SetReadLeavesPtr();; 458 SetFillLeavesPtr();; 459 return;; 460 }; 461 // If the branch's name is not the same as the base class name,; 462 // keep the branch name as a prefix (i.e., continue the branch; 463 // hierarchy), but start a new class hierarchy at the base class.; 464 //; 465 // Note: If the parent branch was created by the branch constructor; 466 // which takes a folder as a parameter, then this case will; 467 // be used, because the branch name will be the same as t",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:19197,Availability,avail,available,19197,"7 }; 498 SetName(name);; 499 SetTitle(name);; 500 }; 501 SetReadLeavesPtr();; 502 SetFillLeavesPtr();; 503 return;; 504 } else if (element->GetClassPointer() == TClonesArray::Class()) {; 505 // -- We are a TClonesArray element.; 506 bool ispointer = element->IsaPointer();; 507 TClonesArray *clones;; 508 if (ispointer) {; 509 char **ppointer = (char**)(pointer);; 510 clones = (TClonesArray*)(*ppointer);; 511 } else {; 512 clones = (TClonesArray*)pointer;; 513 }; 514 // basket->DeleteEntryOffset(); //entryoffset not required for the clonesarray counter; 515 fEntryOffsetLen = 0;; 516 // ===> Create a leafcount; 517 TLeaf* leaf = new TLeafElement(this, name, fID, fStreamerType);; 518 fNleaves = 1;; 519 fLeaves.Add(leaf);; 520 fTree->GetListOfLeaves()->Add(leaf);; 521 if (!clones) {; 522 SetFillLeavesPtr();; 523 return;; 524 }; 525 TClass* clOfClones = clones->GetClass();; 526 if (!clOfClones) {; 527 SetReadLeavesPtr();; 528 SetFillLeavesPtr();; 529 return;; 530 }; 531 fType = 3;; 532 // ===> create sub branches for each data member of a TClonesArray; 533 //check that the contained objects class name is part of the element title; 534 //This name is mandatory when reading the Tree later on and; 535 //the parent class with the pointer to the TClonesArray is not available.; 536 fClonesName = clOfClones->GetName();; 537 fClonesClass = clOfClones;; 538 TString aname;; 539 aname.Form("" (%s)"", clOfClones->GetName());; 540 TString atitle = element->GetTitle();; 541 if (!atitle.Contains(aname)) {; 542 atitle += aname;; 543 element->SetTitle(atitle.Data());; 544 }; 545 TString branchname( name );; 546 if (branchname.EndsWith(""."")); 547 branchname.Remove(branchname.Length()-1);; 548 branchname += ""_"";; 549 SetTitle(branchname);; 550 leaf->SetName(branchname);; 551 leaf->SetTitle(branchname);; 552 leaf->SetRange(true);; 553 Unroll(name, clOfClones, clOfClones, pointer, basketsize, splitlevel+splitSTLP, 31);; 554 BuildTitle(name);; 555 SetReadLeavesPtr();; 556 SetFillLeavesPtr();; 557",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:21536,Availability,avail,available,21536,"lass == TClass::GetClass(""string""))) {; 568 cansplit = false;; 569 } else if (GetCollectionProxy()->HasPointers() && !splitSTLP ) {; 570 cansplit = false;; 571 } else if (!valueClass->CanSplit() && !(GetCollectionProxy()->HasPointers() && splitSTLP)) {; 572 cansplit = false;; 573 } else if (valueClass->GetCollectionProxy()) {; 574 // -- A collection was stored in a collection, we choose not to split it.; 575 // Note: Splitting it would require extending TTreeFormula; 576 // to understand how to access it.; 577 cansplit = false;; 578 }; 579 if (cansplit) {; 580 // -- Do the splitting work if we are allowed to.; 581 fType = 4;; 582 // Create a leaf for the master branch (the counter).; 583 TLeaf *leaf = new TLeafElement(this, name, fID, fStreamerType);; 584 fNleaves = 1;; 585 fLeaves.Add(leaf);; 586 fTree->GetListOfLeaves()->Add(leaf);; 587 // Check that the contained objects class name is part of the element title.; 588 // This name is mandatory when reading the tree later on and; 589 // the parent class with the pointer to the STL container is not available.; 590 fClonesName = valueClass->GetName();; 591 fClonesClass = valueClass;; 592 TString aname;; 593 aname.Form("" (%s)"", valueClass->GetName());; 594 TString atitle = element->GetTitle();; 595 if (!atitle.Contains(aname)) {; 596 atitle += aname;; 597 element->SetTitle(atitle.Data());; 598 }; 599 TString branchname (name);; 600 if (branchname.EndsWith(""."")); 601 branchname.Remove(branchname.Length()-1);; 602 branchname += ""_"";; 603 SetTitle(branchname);; 604 leaf->SetName(branchname);; 605 leaf->SetTitle(branchname);; 606 leaf->SetRange(true);; 607 // Create sub branches for each data member of an STL container.; 608 Unroll(name, valueClass, valueClass, pointer, basketsize, splitlevel+splitSTLP, 41);; 609 BuildTitle(name);; 610 SetReadLeavesPtr();; 611 SetFillLeavesPtr();; 612 return;; 613 }; 614 } else if (!strchr(elemType, '*') && ((fStreamerType == TVirtualStreamerInfo::kObject) || (fStreamerType == TVirtualStrea",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:22936,Availability,error,error,22936,"04 leaf->SetName(branchname);; 605 leaf->SetTitle(branchname);; 606 leaf->SetRange(true);; 607 // Create sub branches for each data member of an STL container.; 608 Unroll(name, valueClass, valueClass, pointer, basketsize, splitlevel+splitSTLP, 41);; 609 BuildTitle(name);; 610 SetReadLeavesPtr();; 611 SetFillLeavesPtr();; 612 return;; 613 }; 614 } else if (!strchr(elemType, '*') && ((fStreamerType == TVirtualStreamerInfo::kObject) || (fStreamerType == TVirtualStreamerInfo::kAny))) {; 615 // -- Create sub-branches for members that are classes.; 616 //; 617 // Note: This can only happen if we were called directly; 618 // (usually by TClass::Bronch) because Unroll never; 619 // calls us for an element of this type.; 620 fType = 2;; 621 TClass* clm = elementClass;; 622 Int_t err = Unroll(name, clm, clm, pointer, basketsize, splitlevel+splitSTLP, 0);; 623 if (err >= 0) {; 624 // Return on success.; 625 // FIXME: Why not on error too?; 626 SetReadLeavesPtr();; 627 SetFillLeavesPtr();; 628 return;; 629 }; 630 }; 631 }; 632 }; 633 ; 634 //; 635 // Create a leaf to represent this branch.; 636 //; 637 ; 638 TLeaf* leaf = new TLeafElement(this, GetTitle(), fID, fStreamerType);; 639 leaf->SetTitle(GetTitle());; 640 fNleaves = 1;; 641 fLeaves.Add(leaf);; 642 fTree->GetListOfLeaves()->Add(leaf);; 643 ; 644 //; 645 // If we have a counter branch set it now that we have; 646 // created our leaf, we cannot do it before then.; 647 //; 648 ; 649 if (brOfCounter) {; 650 SetBranchCount(brOfCounter);; 651 }; 652 ; 653 SetReadLeavesPtr();; 654 SetFillLeavesPtr();; 655}; 656 ; 657////////////////////////////////////////////////////////////////////////////////; 658/// Constructor when the branch object is a TClonesArray.; 659///; 660/// If splitlevel > 0 this branch in turn is split into sub branches.; 661 ; 662TBranchElement::TBranchElement(TTree *tree, const char* bname, TClonesArray* clones, Int_t basketsize, Int_t splitlevel, Int_t compress); 663: TBranch(); 664, fClassName(""TClonesArra",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:42855,Availability,error,error,42855,"cks; 1199 // -its secondary branchcount pointing to fTracks.fNpoint; 1200 Int_t stype = bre->GetStreamerType();; 1201 // FIXME: Should 60 be included here?; 1202 if ((stype > 40) && (stype < 61)) {; 1203 TString name2 (bre->GetName());; 1204 Ssiz_t bn = name2.Last('.');; 1205 if (bn<0) {; 1206 continue;; 1207 }; 1208 TStreamerBasicPointer *el = (TStreamerBasicPointer*)bre->GetInfoImp()->GetElements()->FindObject(name2.Data()+bn+1);; 1209 name2.Remove(bn+1);; 1210 if (el) name2 += el->GetCountName();; 1211 TBranchElement *bc2 = (TBranchElement*)fBranches.FindObject(name2);; 1212 bre->SetBranchCount2(bc2);; 1213 }; 1214 bre->SetReadLeavesPtr();; 1215 bre->SetFillLeavesPtr();; 1216 }; 1217}; 1218 ; 1219////////////////////////////////////////////////////////////////////////////////; 1220/// Loop on all leaves of this branch to fill the basket buffer.; 1221///; 1222/// The function returns the number of bytes committed to the; 1223/// individual branches. If a write error occurs, the number of; 1224/// bytes returned is -1. If no data are written, because, e.g.,; 1225/// the branch is disabled, the number of bytes returned is 0.; 1226///; 1227/// Note: We not not use any member functions from TLeafElement!; 1228 ; 1229Int_t TBranchElement::FillImpl(ROOT::Internal::TBranchIMTHelper *imtHelper); 1230{; 1231 Int_t nbytes = 0;; 1232 Int_t nwrite = 0;; 1233 Int_t nerror = 0;; 1234 Int_t nbranches = fBranches.GetEntriesFast();; 1235 ; 1236 ValidateAddress();; 1237 ; 1238 //; 1239 // If we are a top-level branch, update addresses.; 1240 //; 1241 ; 1242 if (fID < 0) {; 1243 if (!fObject) {; 1244 Error(""Fill"", ""attempt to fill branch %s while address is not set"", GetName());; 1245 return 0;; 1246 }; 1247 }; 1248 ; 1249 //; 1250 // If the tree has a TRefTable, set the current branch if; 1251 // branch is not a basic type.; 1252 //; 1253 ; 1254 // FIXME: This test probably needs to be extended past 10.; 1255 if ((fType >= -1) && (fType < 10)) {; 1256 TBranchRef* bref = fTree->GetB",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:95231,Availability,error,error,95231,">GetClassPointer()); 2637 newType = newElems->GetClassPointer()->GetName();; 2638 else; 2639 newType = newElems->GetTypeName();; 2640 }; 2641 }; 2642 if (newType.Length()==0) {; 2643 if (currentStreamerElement->GetClassPointer()); 2644 newType = currentStreamerElement->GetClassPointer()->GetName();; 2645 else; 2646 newType = currentStreamerElement->GetTypeName();; 2647 }; 2648 }; 2649 } else {; 2650 newType = dm->GetTypeName();; 2651 }; 2652 cl = TClass::GetClass(newType);; 2653 if (cl) {; 2654 fCurrentClass = cl;; 2655 }; 2656 return cl;; 2657}; 2658 ; 2659////////////////////////////////////////////////////////////////////////////////; 2660/// Read all branches of a BranchElement and return total number of bytes.; 2661///; 2662/// - If entry = 0, then use current entry number + 1.; 2663/// - If entry < 0, then reset entry number to 0.; 2664///; 2665/// Returns the number of bytes read from the input buffer.; 2666/// - If entry does not exist, then returns 0.; 2667/// - If an I/O error occurs, then returns -1.; 2668///; 2669/// See IMPORTANT REMARKS in TTree::GetEntry.; 2670 ; 2671Int_t TBranchElement::GetEntry(Long64_t entry, Int_t getall); 2672{; 2673 // Remember which entry we are reading.; 2674 fReadEntry = entry;; 2675 ; 2676 // If our tree has a branch ref, make it remember the entry and; 2677 // this branch. This allows a TRef::GetObject() call done during; 2678 // the following I/O operation, for example in a custom streamer,; 2679 // to search for the referenced object in the proper element of the; 2680 // proper branch.; 2681 TBranchRef* bref = fTree->GetBranchRef();; 2682 if (R__unlikely(bref)) {; 2683 R__LOCKGUARD_IMT(gROOTMutex); // Lock for parallel TTree I/O; 2684 fBranchID = bref->SetParent(this, fBranchID);; 2685 bref->SetRequestedEntry(entry);; 2686 }; 2687 ; 2688 Int_t nbytes = 0;; 2689 ; 2690 if (R__unlikely(IsAutoDelete())) {; 2691 SetBit(kDeleteObject);; 2692 SetAddress(fAddress);; 2693 } else {; 2694 if (R__unlikely(!fAddress && !TestBit(kDec",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:100027,Availability,failure,failure,100027,"onProxy::TPushPop helper(proxy, fObject);; 2763 ; 2764 TVirtualCollectionIterators *iter = fIterators;; 2765 b.ApplySequence(*fReadActionSequence,iter->fBegin,iter->fEnd);; 2766 } else {; 2767 // Apply the unattached rules; by definition they do not need any; 2768 // input from a buffer.; 2769 TBufferFile b(TBufferFile::kRead, 1);; 2770 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,fNdata);; 2771 b.ApplySequence(*fReadActionSequence, fObject);; 2772 }; 2773 }; 2774 } else {; 2775 // -- Terminal branch.; 2776 if (fBranchCount && (fBranchCount->GetReadEntry() != entry)) {; 2777 Int_t nb = fBranchCount->TBranch::GetEntry(entry, getall);; 2778 if (nb < 0) {; 2779 return nb;; 2780 }; 2781 nbytes += nb;; 2782 }; 2783 Int_t nb = TBranch::GetEntry(entry, getall);; 2784 if (nb < 0) {; 2785 return nb;; 2786 }; 2787 nbytes += nb;; 2788 }; 2789 ; 2790 if (R__unlikely(fTree->Debug() > 0)) {; 2791 if ((entry >= fTree->GetDebugMin()) && (entry <= fTree->GetDebugMax())) {; 2792 Info(""GetEntry"", ""%lld, branch=%s, nbytes=%d"", entry, GetName(), nbytes);; 2793 }; 2794 }; 2795 return nbytes;; 2796}; 2797 ; 2798////////////////////////////////////////////////////////////////////////////////; 2799/// Fill expectedClass and expectedType with information on the data type of the; 2800/// object/values contained in this branch (and thus the type of pointers; 2801/// expected to be passed to Set[Branch]Address; 2802/// return 0 in case of success and > 0 in case of failure.; 2803 ; 2804Int_t TBranchElement::GetExpectedType(TClass *&expectedClass,EDataType &expectedType); 2805{; 2806 expectedClass = nullptr;; 2807 expectedType = kOther_t;; 2808 ; 2809 Int_t type = GetStreamerType();; 2810 if ((type == -1) || (fID == -1)) {; 2811 expectedClass = fBranchClass;; 2812 } else {; 2813 // Case of an object data member. Here we allow for the; 2814 // variable name to be omitted. Eg, for Event.root with split; 2815 // level 1 or above Draw(""GetXaxis"") is the same as Draw(""fH.GetXaxis()""); 281",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:111884,Availability,failure,failure,111884,"ta members so that when; 3124/// SetAddress recursively sets their address, they will get the; 3125/// same address as their containing class because i/o is based; 3126/// on streamer info offsets from the address of the containing; 3127/// class.; 3128///; 3129/// Offsets are non-zero for base-class sub-branches that are; 3130/// not the leftmost direct base class. They are laid out in; 3131/// memory sequentially and only the leftmost direct base class; 3132/// has the same address as the derived class. The streamer; 3133/// offsets need to be added to the address of the base class; 3134/// subobject which is not the same as the address of the; 3135/// derived class for the non-leftmost direct base classes.; 3136 ; 3137void TBranchElement::InitializeOffsets(); 3138{; 3139 Int_t nbranches = fBranches.GetEntriesFast();; 3140 ; 3141 // See https://sft.its.cern.ch/jira/browse/ROOT-8742; 3142 // and https://sft.its.cern.ch/jira/browse/ROOT-9253; 3143 // As of commit e21b4f1a3b, removing this lock lead to a failure; 3144 // in the test testSetAddress[Loop].; 3145 // As of commit 4f8b237849, removing this lock does not lead to; 3146 // a visible failure in test. This might be due to the underlying; 3147 // problem (missing lock or ?) being solved somewhere else or some; 3148 // other perturbation reducing the failure rate.; 3149 // Having the lock here is not too costly as InitializeOffsets is; 3150 // one called once in the lifetime of the TBranch.; 3151 R__LOCKGUARD(gInterpreterMutex);; 3152 ; 3153 if (fID < 0) {; 3154 // -- We are a top-level branch. Let's mark whether we need to use MapObject.; 3155 if (CanSelfReference(fBranchClass)) {; 3156 if (fBranchClass.GetClass()->IsTObject()) {; 3157 SetBit(kBranchObject);; 3158 } else {; 3159 SetBit(kBranchAny);; 3160 }; 3161 }; 3162 }; 3163 if (nbranches) {; 3164 // Allocate space for the new sub-branch offsets.; 3165 delete[] fBranchOffset;; 3166 fBranchOffset = nullptr;; 3167 fBranchOffset = new Int_t[nbranches];; 3168 //",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:112024,Availability,failure,failure,112024,"ir containing class because i/o is based; 3126/// on streamer info offsets from the address of the containing; 3127/// class.; 3128///; 3129/// Offsets are non-zero for base-class sub-branches that are; 3130/// not the leftmost direct base class. They are laid out in; 3131/// memory sequentially and only the leftmost direct base class; 3132/// has the same address as the derived class. The streamer; 3133/// offsets need to be added to the address of the base class; 3134/// subobject which is not the same as the address of the; 3135/// derived class for the non-leftmost direct base classes.; 3136 ; 3137void TBranchElement::InitializeOffsets(); 3138{; 3139 Int_t nbranches = fBranches.GetEntriesFast();; 3140 ; 3141 // See https://sft.its.cern.ch/jira/browse/ROOT-8742; 3142 // and https://sft.its.cern.ch/jira/browse/ROOT-9253; 3143 // As of commit e21b4f1a3b, removing this lock lead to a failure; 3144 // in the test testSetAddress[Loop].; 3145 // As of commit 4f8b237849, removing this lock does not lead to; 3146 // a visible failure in test. This might be due to the underlying; 3147 // problem (missing lock or ?) being solved somewhere else or some; 3148 // other perturbation reducing the failure rate.; 3149 // Having the lock here is not too costly as InitializeOffsets is; 3150 // one called once in the lifetime of the TBranch.; 3151 R__LOCKGUARD(gInterpreterMutex);; 3152 ; 3153 if (fID < 0) {; 3154 // -- We are a top-level branch. Let's mark whether we need to use MapObject.; 3155 if (CanSelfReference(fBranchClass)) {; 3156 if (fBranchClass.GetClass()->IsTObject()) {; 3157 SetBit(kBranchObject);; 3158 } else {; 3159 SetBit(kBranchAny);; 3160 }; 3161 }; 3162 }; 3163 if (nbranches) {; 3164 // Allocate space for the new sub-branch offsets.; 3165 delete[] fBranchOffset;; 3166 fBranchOffset = nullptr;; 3167 fBranchOffset = new Int_t[nbranches];; 3168 // Make sure we can instantiate our class meta info.; 3169 if (!fBranchClass.GetClass()) {; 3170 Warning(""InitializeOffsets""",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:112191,Availability,failure,failure,112191," 3129/// Offsets are non-zero for base-class sub-branches that are; 3130/// not the leftmost direct base class. They are laid out in; 3131/// memory sequentially and only the leftmost direct base class; 3132/// has the same address as the derived class. The streamer; 3133/// offsets need to be added to the address of the base class; 3134/// subobject which is not the same as the address of the; 3135/// derived class for the non-leftmost direct base classes.; 3136 ; 3137void TBranchElement::InitializeOffsets(); 3138{; 3139 Int_t nbranches = fBranches.GetEntriesFast();; 3140 ; 3141 // See https://sft.its.cern.ch/jira/browse/ROOT-8742; 3142 // and https://sft.its.cern.ch/jira/browse/ROOT-9253; 3143 // As of commit e21b4f1a3b, removing this lock lead to a failure; 3144 // in the test testSetAddress[Loop].; 3145 // As of commit 4f8b237849, removing this lock does not lead to; 3146 // a visible failure in test. This might be due to the underlying; 3147 // problem (missing lock or ?) being solved somewhere else or some; 3148 // other perturbation reducing the failure rate.; 3149 // Having the lock here is not too costly as InitializeOffsets is; 3150 // one called once in the lifetime of the TBranch.; 3151 R__LOCKGUARD(gInterpreterMutex);; 3152 ; 3153 if (fID < 0) {; 3154 // -- We are a top-level branch. Let's mark whether we need to use MapObject.; 3155 if (CanSelfReference(fBranchClass)) {; 3156 if (fBranchClass.GetClass()->IsTObject()) {; 3157 SetBit(kBranchObject);; 3158 } else {; 3159 SetBit(kBranchAny);; 3160 }; 3161 }; 3162 }; 3163 if (nbranches) {; 3164 // Allocate space for the new sub-branch offsets.; 3165 delete[] fBranchOffset;; 3166 fBranchOffset = nullptr;; 3167 fBranchOffset = new Int_t[nbranches];; 3168 // Make sure we can instantiate our class meta info.; 3169 if (!fBranchClass.GetClass()) {; 3170 Warning(""InitializeOffsets"", ""No branch class set for branch: %s"", GetName());; 3171 fInitOffsets = true;; 3172 return;; 3173 }; 3174 // Make sure we can instanti",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:113231,Availability,avail,available,113231,"he lock here is not too costly as InitializeOffsets is; 3150 // one called once in the lifetime of the TBranch.; 3151 R__LOCKGUARD(gInterpreterMutex);; 3152 ; 3153 if (fID < 0) {; 3154 // -- We are a top-level branch. Let's mark whether we need to use MapObject.; 3155 if (CanSelfReference(fBranchClass)) {; 3156 if (fBranchClass.GetClass()->IsTObject()) {; 3157 SetBit(kBranchObject);; 3158 } else {; 3159 SetBit(kBranchAny);; 3160 }; 3161 }; 3162 }; 3163 if (nbranches) {; 3164 // Allocate space for the new sub-branch offsets.; 3165 delete[] fBranchOffset;; 3166 fBranchOffset = nullptr;; 3167 fBranchOffset = new Int_t[nbranches];; 3168 // Make sure we can instantiate our class meta info.; 3169 if (!fBranchClass.GetClass()) {; 3170 Warning(""InitializeOffsets"", ""No branch class set for branch: %s"", GetName());; 3171 fInitOffsets = true;; 3172 return;; 3173 }; 3174 // Make sure we can instantiate our class streamer info.; 3175 if (!GetInfoImp()) {; 3176 Warning(""InitializeOffsets"", ""No streamer info available for branch: %s of class: %s"", GetName(), fBranchClass.GetClass()->GetName());; 3177 fInitOffsets = true;; 3178 return;; 3179 }; 3180 ; 3181 // Get the class we are a member of now (which is the; 3182 // type of our containing subobject) and get our offset; 3183 // inside of our containing subobject (our local offset).; 3184 // Note: branchElem stays zero if we are a top-level branch,; 3185 // we have to be careful about this later.; 3186 TStreamerElement* branchElem = nullptr;; 3187 Int_t localOffset = 0;; 3188 TClass* branchClass = fBranchClass.GetClass();; 3189 bool renamed = false;; 3190 if (fID > -1) {; 3191 // -- Branch is *not* a top-level branch.; 3192 // Instead of the streamer info class, we want the class of our; 3193 // specific element in the streamer info. We could be a data; 3194 // member of a base class or a split class, in which case our; 3195 // streamer info will be for our containing sub-object, while; 3196 // we are actually a different type.; 319",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:114326,Availability,avail,available,114326,"fBranchClass.GetClass()->GetName());; 3177 fInitOffsets = true;; 3178 return;; 3179 }; 3180 ; 3181 // Get the class we are a member of now (which is the; 3182 // type of our containing subobject) and get our offset; 3183 // inside of our containing subobject (our local offset).; 3184 // Note: branchElem stays zero if we are a top-level branch,; 3185 // we have to be careful about this later.; 3186 TStreamerElement* branchElem = nullptr;; 3187 Int_t localOffset = 0;; 3188 TClass* branchClass = fBranchClass.GetClass();; 3189 bool renamed = false;; 3190 if (fID > -1) {; 3191 // -- Branch is *not* a top-level branch.; 3192 // Instead of the streamer info class, we want the class of our; 3193 // specific element in the streamer info. We could be a data; 3194 // member of a base class or a split class, in which case our; 3195 // streamer info will be for our containing sub-object, while; 3196 // we are actually a different type.; 3197 TVirtualStreamerInfo* si = GetInfoImp();; 3198 // Note: We tested to make sure the streamer info was available previously.; 3199 if (!si->IsCompiled()) {; 3200 Warning(""InitializeOffsets"", ""Streamer info for branch: %s has no elements array!"", GetName());; 3201 fInitOffsets = true;; 3202 return;; 3203 }; 3204 // FIXME: Check that fID is in range.; 3205 branchElem = si->GetElement(fID);; 3206 if (!branchElem) {; 3207 Warning(""InitializeOffsets"", ""Cannot get streamer element for branch: %s!"", GetName());; 3208 fInitOffsets = true;; 3209 return;; 3210 } else if (branchElem->TestBit(TStreamerElement::kRepeat)) {; 3211 // If we have a repeating streamerElement, use the next; 3212 // one as it actually hold the 'real' data member('s offset); 3213 if (si->GetElement(fID+1)) {; 3214 branchElem = si->GetElement(fID+1);; 3215 }; 3216 }; 3217 localOffset = branchElem->GetOffset();; 3218 branchClass = branchElem->GetClassPointer();; 3219 if (localOffset == TStreamerInfo::kMissing) {; 3220 fObject = nullptr;; 3221 } else {; 3222 renamed = branchClass && b",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:133232,Availability,error,error,133232,"f (alternateElement) {; 3623 Ssiz_t dotpos = dataName.Last('.');; 3624 Ssiz_t endpos = dataName.Length();; 3625 if (dotpos != kNPOS) ++dotpos; else dotpos = 0;; 3626 dataName.Replace(dotpos,endpos-dotpos,subBranchElement->GetFullName());; 3627 }; 3628 TRealData* rd = pClass->GetRealData(dataName);; 3629 if (rd && (!rd->TestBit(TRealData::kTransient) || alternateElement)) {; 3630 // -- Data member exists in the dictionary meta info, get the offset.; 3631 // If we are using an alternateElement, it is the target of a rule; 3632 // and might be indeed transient.; 3633 offset = rd->GetThisOffset();; 3634 } else if (subBranchElement->TestBit(TStreamerElement::kWholeObject)) {; 3635 // We are a rule with no specific target, it applies to the whole; 3636 // object, let's set the offset to zero; 3637 offset = 0;; 3638 } else {; 3639 // -- No dictionary meta info for this data member, it must no; 3640 // longer exist; 3641 if (fEntries == 0) {; 3642 // ... unless we creating the branch in which case; 3643 // we have an internal error.; 3644 if (pClass->GetListOfRealData()->GetEntries() == 0) {; 3645 // We are probably missing the ShowMember, let's; 3646 // just issue an error.; 3647 Error(""InitializeOffsets"",; 3648 ""Could not find the real data member '%s' when constructing the branch '%s' [Likely missing ShowMember]."",; 3649 dataName.Data(),GetName());; 3650 } else if (subInfo && subInfo->GetClassVersion()!=subInfo->GetClass()->GetClassVersion()) {; 3651 // In the case where we are cloning a TTree that was created with an older version of the layout, we may not; 3652 // able to find all the members; 3653 Info(""InitializeOffsets"",; 3654 ""TTree created with an older schema, some data might not be copied in 'slow-cloning' mode; fast-cloning should have the correct result. '%s' is missing when constructing the branch '%s'. "",; 3655 dataName.Data(),GetName());; 3656 } else {; 3657 // Something really bad happen.; 3658 Fatal(""InitializeOffsets"",; 3659 ""Could not find the real data",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:133377,Availability,error,error,133377,"if (dotpos != kNPOS) ++dotpos; else dotpos = 0;; 3626 dataName.Replace(dotpos,endpos-dotpos,subBranchElement->GetFullName());; 3627 }; 3628 TRealData* rd = pClass->GetRealData(dataName);; 3629 if (rd && (!rd->TestBit(TRealData::kTransient) || alternateElement)) {; 3630 // -- Data member exists in the dictionary meta info, get the offset.; 3631 // If we are using an alternateElement, it is the target of a rule; 3632 // and might be indeed transient.; 3633 offset = rd->GetThisOffset();; 3634 } else if (subBranchElement->TestBit(TStreamerElement::kWholeObject)) {; 3635 // We are a rule with no specific target, it applies to the whole; 3636 // object, let's set the offset to zero; 3637 offset = 0;; 3638 } else {; 3639 // -- No dictionary meta info for this data member, it must no; 3640 // longer exist; 3641 if (fEntries == 0) {; 3642 // ... unless we creating the branch in which case; 3643 // we have an internal error.; 3644 if (pClass->GetListOfRealData()->GetEntries() == 0) {; 3645 // We are probably missing the ShowMember, let's; 3646 // just issue an error.; 3647 Error(""InitializeOffsets"",; 3648 ""Could not find the real data member '%s' when constructing the branch '%s' [Likely missing ShowMember]."",; 3649 dataName.Data(),GetName());; 3650 } else if (subInfo && subInfo->GetClassVersion()!=subInfo->GetClass()->GetClassVersion()) {; 3651 // In the case where we are cloning a TTree that was created with an older version of the layout, we may not; 3652 // able to find all the members; 3653 Info(""InitializeOffsets"",; 3654 ""TTree created with an older schema, some data might not be copied in 'slow-cloning' mode; fast-cloning should have the correct result. '%s' is missing when constructing the branch '%s'. "",; 3655 dataName.Data(),GetName());; 3656 } else {; 3657 // Something really bad happen.; 3658 Fatal(""InitializeOffsets"",; 3659 ""Could not find the real data member '%s' when constructing the branch '%s' [Likely an internal error, please report to the developers]."",; 36",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:134265,Availability,error,error,134265,"ve an internal error.; 3644 if (pClass->GetListOfRealData()->GetEntries() == 0) {; 3645 // We are probably missing the ShowMember, let's; 3646 // just issue an error.; 3647 Error(""InitializeOffsets"",; 3648 ""Could not find the real data member '%s' when constructing the branch '%s' [Likely missing ShowMember]."",; 3649 dataName.Data(),GetName());; 3650 } else if (subInfo && subInfo->GetClassVersion()!=subInfo->GetClass()->GetClassVersion()) {; 3651 // In the case where we are cloning a TTree that was created with an older version of the layout, we may not; 3652 // able to find all the members; 3653 Info(""InitializeOffsets"",; 3654 ""TTree created with an older schema, some data might not be copied in 'slow-cloning' mode; fast-cloning should have the correct result. '%s' is missing when constructing the branch '%s'. "",; 3655 dataName.Data(),GetName());; 3656 } else {; 3657 // Something really bad happen.; 3658 Fatal(""InitializeOffsets"",; 3659 ""Could not find the real data member '%s' when constructing the branch '%s' [Likely an internal error, please report to the developers]."",; 3660 dataName.Data(),GetName());; 3661 }; 3662 }; 3663 localOffset = TStreamerInfo::kMissing;; 3664 }; 3665 } else {; 3666 // -- We have no data member name, ok for a base class, not good otherwise.; 3667 if (isBaseSubBranch) {; 3668 // I am a direct base class of my parent class, my local offset is enough.; 3669 } else {; 3670 Warning(""InitializeOffsets"", ""Could not find the data member name for branch '%s' with parent branch '%s', assuming offset is zero!"", subBranch->GetName(), GetName());; 3671 }; 3672 }; 3673 ; 3674 //; 3675 // Ok, do final calculations for fOffset and fBranchOffset.; 3676 //; 3677 ; 3678 if (isContDataMember) {; 3679 // -- Container data members set fOffset instead of fBranchOffset.; 3680 // The fOffset is what should be added to the start of the entry; 3681 // in the collection (i.e., its current absolute address) to find; 3682 // the beginning of the data member describe",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:154555,Availability,recover,recover,154555,"k;}; 4143 case 17: {b.ReadFastArray((ULong64_t*)fAddress, n); break;}; 4144 case 18: {b.ReadFastArray((bool*) fAddress, n); break;}; 4145 case 9: {; 4146 TVirtualStreamerInfo* si = GetInfoImp();; 4147 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 4148 Double_t *xx = (Double_t*) fAddress;; 4149 for (Int_t ii=0;ii<n;ii++) {; 4150 b.ReadDouble32(&(xx[ii]),se);; 4151 }; 4152 break;; 4153 }; 4154 case 19: {; 4155 TVirtualStreamerInfo* si = GetInfoImp();; 4156 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 4157 Float_t *xx = (Float_t*) fAddress;; 4158 for (Int_t ii=0;ii<n;ii++) {; 4159 b.ReadFloat16(&(xx[ii]),se);; 4160 }; 4161 break;; 4162 }; 4163 }; 4164 return;; 4165 } else if (fType <= 2) { // branch in split mode; 4166 // FIXME: This should probably be < 60 instead.; 4167 if (fStreamerType > 40 && fStreamerType < 55) {; 4168 Int_t atype = fStreamerType - 40;; 4169 Int_t n;; 4170 if (fBranchCount==nullptr) {; 4171 // Missing fBranchCount. let's attempts to recover.; 4172 ; 4173 TString countname( GetName() );; 4174 Ssiz_t dot = countname.Last('.');; 4175 if (dot>=0) {; 4176 countname.Remove(dot+1);; 4177 } else {; 4178 countname = """";; 4179 }; 4180 TString counter( GetTitle() );; 4181 Ssiz_t loc = counter.Last('[');; 4182 if (loc>=0) {; 4183 counter.Remove(0,loc+1);; 4184 }; 4185 loc = counter.Last(']');; 4186 if (loc>=0) {; 4187 counter.Remove(loc);; 4188 }; 4189 countname += counter;; 4190 SetBranchCount((TBranchElement *)fTree->GetBranch(countname));; 4191 }; 4192 if (fBranchCount) {; 4193 n = (Int_t)fBranchCount->GetValue(0,0);; 4194 } else {; 4195 Warning(""ReadLeaves"",""Missing fBranchCount for %s. Data will not be read correctly by the MakeClass mode."",GetName());; 4196 n = 0;; 4197 }; 4198 fNdata = n;; 4199 Char_t isArray;; 4200 b >> isArray;; 4201 switch (atype) {; 4202 case 1: {b.ReadFastArray((Char_t*) fAddress, n); break;}; 4203 case 2: {b.ReadFastArray((Short_t*) fAddress, n); break;}; 4204 case 3: {b.ReadFastArray((Int_t",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:159934,Availability,failure,failure,159934,"ace"" the entire; 4294 // streaming of this STL container if the container; 4295 // is a set/multiset/map/multimap (what we do not; 4296 // know here).; 4297 // For vector/list/deque Allocate == Resize; 4298 // and Commit == noop.; 4299 // TODO: Exception safety a la TPushPop; 4300 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4301 TVirtualCollectionProxy::TPushPop helper(proxy, fObject);; 4302 void* alternate = proxy->Allocate(fNdata, true);; 4303 if(fSTLtype != ROOT::kSTLvector && proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ) {; 4304 fPtrIterators->CreateIterators(alternate, proxy);; 4305 } else {; 4306 fIterators->CreateIterators(alternate, proxy);; 4307 }; 4308 ; 4309 Int_t nbranches = fBranches.GetEntriesFast();; 4310 switch (fSTLtype) {; 4311 case ROOT::kSTLset:; 4312 case ROOT::kSTLunorderedset:; 4313 case ROOT::kSTLunorderedmultiset:; 4314 case ROOT::kSTLmultiset:; 4315 case ROOT::kSTLmap:; 4316 case ROOT::kSTLmultimap:; 4317 case ROOT::kSTLunorderedmap:; 4318 case ROOT::kSTLunorderedmultimap:; 4319 for (Int_t i = 0; i < nbranches; ++i) {; 4320 TBranch *branch = (TBranch*) fBranches[i];; 4321 Int_t nb = branch->GetEntry(GetReadEntry(), 1);; 4322 if (nb < 0) {; 4323 // Give up on i/o failure.; 4324 // FIXME: We need an error message here.; 4325 break;; 4326 }; 4327 }; 4328 break;; 4329 default:; 4330 break;; 4331 }; 4332 //------------------------------------------------------------------------; 4333 // We have split this stuff, so we need to create the pointers; 4334 /////////////////////////////////////////////////////////////////////////////; 4335 ; 4336 if( proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ); 4337 {; 4338 TClass *elClass = proxy->GetValueClass();; 4339 ; 4340 //--------------------------------------------------------------------; 4341 // The allocation is done in this strange way because ReadLeaves; 4342 // is being called many times by TTreeFormula!!!; 4343 ///////////////////////",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:159970,Availability,error,error,159970,"300 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4301 TVirtualCollectionProxy::TPushPop helper(proxy, fObject);; 4302 void* alternate = proxy->Allocate(fNdata, true);; 4303 if(fSTLtype != ROOT::kSTLvector && proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ) {; 4304 fPtrIterators->CreateIterators(alternate, proxy);; 4305 } else {; 4306 fIterators->CreateIterators(alternate, proxy);; 4307 }; 4308 ; 4309 Int_t nbranches = fBranches.GetEntriesFast();; 4310 switch (fSTLtype) {; 4311 case ROOT::kSTLset:; 4312 case ROOT::kSTLunorderedset:; 4313 case ROOT::kSTLunorderedmultiset:; 4314 case ROOT::kSTLmultiset:; 4315 case ROOT::kSTLmap:; 4316 case ROOT::kSTLmultimap:; 4317 case ROOT::kSTLunorderedmap:; 4318 case ROOT::kSTLunorderedmultimap:; 4319 for (Int_t i = 0; i < nbranches; ++i) {; 4320 TBranch *branch = (TBranch*) fBranches[i];; 4321 Int_t nb = branch->GetEntry(GetReadEntry(), 1);; 4322 if (nb < 0) {; 4323 // Give up on i/o failure.; 4324 // FIXME: We need an error message here.; 4325 break;; 4326 }; 4327 }; 4328 break;; 4329 default:; 4330 break;; 4331 }; 4332 //------------------------------------------------------------------------; 4333 // We have split this stuff, so we need to create the pointers; 4334 /////////////////////////////////////////////////////////////////////////////; 4335 ; 4336 if( proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ); 4337 {; 4338 TClass *elClass = proxy->GetValueClass();; 4339 ; 4340 //--------------------------------------------------------------------; 4341 // The allocation is done in this strange way because ReadLeaves; 4342 // is being called many times by TTreeFormula!!!; 4343 //////////////////////////////////////////////////////////////////////////; 4344 ; 4345 Int_t i = 0;; 4346 // coverity[returned_null] the fNdata is check enough to prevent the use of null value of At(0); 4347 if( !fNdata || *(void**)proxy->At( 0 ) != nullptr ); 4348 i = fNdata;; 4349 ; 4350 for( ; i ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:184690,Availability,failure,failure,184690," return;; 4978 }; 4979 ; 4980 //; 4981 // FIXME: When would this happen?; 4982 //; 4983 ; 4984 if (fType < -1) {; 4985 return;; 4986 }; 4987 ; 4988 //; 4989 // Special case when called from code generated by TTree::MakeClass.; 4990 //; 4991 ; 4992 if (Longptr_t(addr) == -1) {; 4993 // FIXME: Do we have to release an object here?; 4994 // ReleaseObject();; 4995 fAddress = (char*) -1;; 4996 fObject = (char*) -1;; 4997 ResetBit(kDeleteObject);; 4998 ResetBit(kAddressSet);; 4999 return;; 5000 }; 5001 ; 5002 //; 5003 // Reset last read entry number, we have a new user object now.; 5004 //; 5005 ; 5006 fReadEntry = -1;; 5007 ; 5008 //; 5009 // Make sure our branch class is instantiated.; 5010 //; 5011 TClass* clOfBranch = fBranchClass.GetClass();; 5012 if( fTargetClass.GetClassName()[0] ) {; 5013 clOfBranch = fTargetClass;; 5014 }; 5015 ; 5016 //; 5017 // Try to build the streamer info.; 5018 //; 5019 ; 5020 TStreamerInfo *info = GetInfoImp();; 5021 ; 5022 // FIXME: Warn about failure to get the streamer info here?; 5023 ; 5024 //; 5025 // We may have allocated an object last time we were called.; 5026 //; 5027 ; 5028 if (fObject && TestBit(kDeleteObject)){; 5029 ReleaseObject();; 5030 }; 5031 ; 5032 //; 5033 // Remember the pointer to the pointer to our object.; 5034 //; 5035 ; 5036 fAddress = (char*) addr;; 5037 if (fAddress != (char*)(&fObject)) {; 5038 fObject = nullptr;; 5039 }; 5040 ResetBit(kDeleteObject);; 5041 SetBit(kAddressSet);; 5042 ; 5043 //; 5044 // Do special stuff if we got called from a MakeClass class.; 5045 // Allow sub-branches to have independently set addresses.; 5046 //; 5047 ; 5048 if (TestBit(kDecomposedObj)) {; 5049 if (fID > -1) {; 5050 // We are *not* a top-level branch.; 5051 if (!info) {; 5052 // No streamer info, give up.; 5053 // FIXME: We should have an error message here.; 5054 fObject = fAddress;; 5055 } else {; 5056 // Compensate for the fact that the i/o routines; 5057 // will add the streamer offset to the address.; 5058 fObject = fA",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:185516,Availability,error,error,185516,"OfBranch = fTargetClass;; 5014 }; 5015 ; 5016 //; 5017 // Try to build the streamer info.; 5018 //; 5019 ; 5020 TStreamerInfo *info = GetInfoImp();; 5021 ; 5022 // FIXME: Warn about failure to get the streamer info here?; 5023 ; 5024 //; 5025 // We may have allocated an object last time we were called.; 5026 //; 5027 ; 5028 if (fObject && TestBit(kDeleteObject)){; 5029 ReleaseObject();; 5030 }; 5031 ; 5032 //; 5033 // Remember the pointer to the pointer to our object.; 5034 //; 5035 ; 5036 fAddress = (char*) addr;; 5037 if (fAddress != (char*)(&fObject)) {; 5038 fObject = nullptr;; 5039 }; 5040 ResetBit(kDeleteObject);; 5041 SetBit(kAddressSet);; 5042 ; 5043 //; 5044 // Do special stuff if we got called from a MakeClass class.; 5045 // Allow sub-branches to have independently set addresses.; 5046 //; 5047 ; 5048 if (TestBit(kDecomposedObj)) {; 5049 if (fID > -1) {; 5050 // We are *not* a top-level branch.; 5051 if (!info) {; 5052 // No streamer info, give up.; 5053 // FIXME: We should have an error message here.; 5054 fObject = fAddress;; 5055 } else {; 5056 // Compensate for the fact that the i/o routines; 5057 // will add the streamer offset to the address.; 5058 fObject = fAddress - info->TStreamerInfo::GetElementOffset(fID);; 5059 }; 5060 return;; 5061 }; 5062 }; 5063 ; 5064 //; 5065 // Check whether the container type is still the same; 5066 // to support schema evolution; what is written on the file; 5067 // may no longer match the class code which is loaded.; 5068 //; 5069 ; 5070 if (fType == 3) {; 5071 // split TClonesArray, counter/master branch.; 5072 TClass* clm = fClonesClass;; 5073 if (clm) {; 5074 // In case clm derives from an abstract class.; 5075 clm->BuildRealData();; 5076 clm->GetStreamerInfo();; 5077 }; 5078 TClass* newType = GetCurrentClass();; 5079 if (newType && (newType != TClonesArray::Class())) {; 5080 // The data type of the container has changed.; 5081 //; 5082 // Let's check if it is a compatible type:; 5083 bool matched = false;; 5084 i",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:203456,Availability,error,error,203456,"onProxy();; 5446 // We are not at top-level branch.; 5447 fObject = fAddress;; 5448 } else if (fID < 0) {; 5449 // -- We are a top-level branch.; 5450 char** pp = (char**) fAddress;; 5451 if (pp && *pp) {; 5452 // -- Caller provided an i/o buffer for us to use.; 5453 fObject = *pp;; 5454 } else {; 5455 // -- Caller did not provide an i/o buffer for us to use, we must make one for ourselves.; 5456 if (clOfBranch) {; 5457 if (!pp) {; 5458 // -- Caller wants us to own the object.; 5459 SetBit(kDeleteObject);; 5460 }; 5461 fObject = (char*) clOfBranch->New();; 5462 if (pp) {; 5463 *pp = fObject;; 5464 } else {; 5465 fAddress = (char*) &fObject;; 5466 }; 5467 } else {; 5468 Error(""SetAddress"", ""I have no TClass for branch %s, so I cannot allocate an I/O buffer!"", GetName());; 5469 if (pp) {; 5470 fObject = nullptr;; 5471 *pp = nullptr;; 5472 }; 5473 }; 5474 }; 5475 } else {; 5476 // -- We are *not* a top-level branch.; 5477 fObject = fAddress;; 5478 }; 5479 ; 5480 if (!info) {; 5481 // FIXME: We need and error message here, no streamer info, so cannot set offsets.; 5482 return;; 5483 }; 5484 ; 5485 // We do this only once because it depends only on; 5486 // the type of our object, not on its address.; 5487 if (!fInitOffsets) {; 5488 InitializeOffsets();; 5489 }; 5490 ; 5491 // We are split, recurse down to our sub-branches.; 5492 //; 5493 // FIXME: This is a tail recursion, we burn stack.; 5494 Int_t nbranches = fBranches.GetEntriesFast();; 5495 for (Int_t i = 0; i < nbranches; ++i) {; 5496 TBranch *abranch = (TBranch*) fBranches.UncheckedAt(i);; 5497 // FIXME: This is a tail recursion!; 5498 if (fBranchOffset[i] != TStreamerInfo::kMissing && !(implied && abranch->TestBit(kAddressSet))) {; 5499 abranch->SetAddressImpl(fObject + fBranchOffset[i], implied);; 5500 abranch->SetBit(kAddressSet);; 5501 if (TestBit(kDecomposedObj) != abranch->TestBit(kDecomposedObj)); 5502 abranch->SetMakeClass(TestBit(kDecomposedObj));; 5503 } else {; 5504 // When the member is missing, just le",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:203756,Availability,down,down,203756," *pp;; 5454 } else {; 5455 // -- Caller did not provide an i/o buffer for us to use, we must make one for ourselves.; 5456 if (clOfBranch) {; 5457 if (!pp) {; 5458 // -- Caller wants us to own the object.; 5459 SetBit(kDeleteObject);; 5460 }; 5461 fObject = (char*) clOfBranch->New();; 5462 if (pp) {; 5463 *pp = fObject;; 5464 } else {; 5465 fAddress = (char*) &fObject;; 5466 }; 5467 } else {; 5468 Error(""SetAddress"", ""I have no TClass for branch %s, so I cannot allocate an I/O buffer!"", GetName());; 5469 if (pp) {; 5470 fObject = nullptr;; 5471 *pp = nullptr;; 5472 }; 5473 }; 5474 }; 5475 } else {; 5476 // -- We are *not* a top-level branch.; 5477 fObject = fAddress;; 5478 }; 5479 ; 5480 if (!info) {; 5481 // FIXME: We need and error message here, no streamer info, so cannot set offsets.; 5482 return;; 5483 }; 5484 ; 5485 // We do this only once because it depends only on; 5486 // the type of our object, not on its address.; 5487 if (!fInitOffsets) {; 5488 InitializeOffsets();; 5489 }; 5490 ; 5491 // We are split, recurse down to our sub-branches.; 5492 //; 5493 // FIXME: This is a tail recursion, we burn stack.; 5494 Int_t nbranches = fBranches.GetEntriesFast();; 5495 for (Int_t i = 0; i < nbranches; ++i) {; 5496 TBranch *abranch = (TBranch*) fBranches.UncheckedAt(i);; 5497 // FIXME: This is a tail recursion!; 5498 if (fBranchOffset[i] != TStreamerInfo::kMissing && !(implied && abranch->TestBit(kAddressSet))) {; 5499 abranch->SetAddressImpl(fObject + fBranchOffset[i], implied);; 5500 abranch->SetBit(kAddressSet);; 5501 if (TestBit(kDecomposedObj) != abranch->TestBit(kDecomposedObj)); 5502 abranch->SetMakeClass(TestBit(kDecomposedObj));; 5503 } else {; 5504 // When the member is missing, just leave the address alone; 5505 // (since setting explicitly to 0 would trigger error/warning; 5506 // messages).; 5507 // abranch->SetAddress(0);; 5508 abranch->SetBit(kAddressSet);; 5509 }; 5510 }; 5511}; 5512 ; 5513//////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:204518,Availability,error,error,204518,"p = nullptr;; 5472 }; 5473 }; 5474 }; 5475 } else {; 5476 // -- We are *not* a top-level branch.; 5477 fObject = fAddress;; 5478 }; 5479 ; 5480 if (!info) {; 5481 // FIXME: We need and error message here, no streamer info, so cannot set offsets.; 5482 return;; 5483 }; 5484 ; 5485 // We do this only once because it depends only on; 5486 // the type of our object, not on its address.; 5487 if (!fInitOffsets) {; 5488 InitializeOffsets();; 5489 }; 5490 ; 5491 // We are split, recurse down to our sub-branches.; 5492 //; 5493 // FIXME: This is a tail recursion, we burn stack.; 5494 Int_t nbranches = fBranches.GetEntriesFast();; 5495 for (Int_t i = 0; i < nbranches; ++i) {; 5496 TBranch *abranch = (TBranch*) fBranches.UncheckedAt(i);; 5497 // FIXME: This is a tail recursion!; 5498 if (fBranchOffset[i] != TStreamerInfo::kMissing && !(implied && abranch->TestBit(kAddressSet))) {; 5499 abranch->SetAddressImpl(fObject + fBranchOffset[i], implied);; 5500 abranch->SetBit(kAddressSet);; 5501 if (TestBit(kDecomposedObj) != abranch->TestBit(kDecomposedObj)); 5502 abranch->SetMakeClass(TestBit(kDecomposedObj));; 5503 } else {; 5504 // When the member is missing, just leave the address alone; 5505 // (since setting explicitly to 0 would trigger error/warning; 5506 // messages).; 5507 // abranch->SetAddress(0);; 5508 abranch->SetBit(kAddressSet);; 5509 }; 5510 }; 5511}; 5512 ; 5513////////////////////////////////////////////////////////////////////////////////; 5514/// Reset the basket size for all sub-branches of this branch element.; 5515 ; 5516void TBranchElement::SetBasketSize(Int_t buffsize); 5517{; 5518 TBranch::SetBasketSize(buffsize);; 5519 Int_t nbranches = fBranches.GetEntriesFast();; 5520 for (Int_t i = 0; i < nbranches; ++i) {; 5521 TBranch* branch = (TBranch*) fBranches[i];; 5522 branch->SetBasketSize(fBasketSize);; 5523 }; 5524}; 5525 ; 5526////////////////////////////////////////////////////////////////////////////////; 5527/// Set the branch counter for this branch.; 55",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:245483,Availability,error,error,245483,"e_tDefinition RtypesCore.h:61; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBasket.h; PrintElementsstatic void PrintElements(const TStreamerInfo *info, const TStreamerInfoActions::TIDs &ids)Print branch parameters.Definition TBranchElement.cxx:3816; R__CleanNamestatic void R__CleanName(std::string &name)Remove trailing dimensions and make sure there is a trailing dot.Definition TBranchElement.cxx:1771; TBranchElement.h; TBranchObject.h; TBranchRef.h; TBranchSTL.h; TBrowser.h; TBufferFile.h; TClassEdit.h; TClass.h; TClonesArray.h; TDataMember.h; TDataType.h; EDataTypeEDataTypeDefinition TDataType.h:28; kOther_t@ kOther_tDefinition TDataType.h:32; kIsAbstract@ kIsAbstractDefinition TDictionary.h:71; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TFile.h; TFolder.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t cursorDefinition TGWin32VirtualXProxy.cxx:160; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:245618,Availability,error,error,245618,"igned long long ULong64_tDefinition RtypesCore.h:70; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBasket.h; PrintElementsstatic void PrintElements(const TStreamerInfo *info, const TStreamerInfoActions::TIDs &ids)Print branch parameters.Definition TBranchElement.cxx:3816; R__CleanNamestatic void R__CleanName(std::string &name)Remove trailing dimensions and make sure there is a trailing dot.Definition TBranchElement.cxx:1771; TBranchElement.h; TBranchObject.h; TBranchRef.h; TBranchSTL.h; TBrowser.h; TBufferFile.h; TClassEdit.h; TClass.h; TClonesArray.h; TDataMember.h; TDataType.h; EDataTypeEDataTypeDefinition TDataType.h:28; kOther_t@ kOther_tDefinition TDataType.h:32; kIsAbstract@ kIsAbstractDefinition TDictionary.h:71; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TFile.h; TFolder.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t cursorDefinition TGWin32VirtualXProxy.cxx:160; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wi",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:291028,Availability,error,error,291028,"ay.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TClonesArrayfriend class TClonesArrayDefinition TObject.h:240; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TStreamerArtificial::Classstatic TClass * Class(); TStreamerBase::Classstatic TClass * Class(); TStreamerBasicPointerDefinition TStreamerElement.h:198; TStreamerBasicPointer::Classstatic TClass * Class(); TStreamerBasicPointer::GetCountNameconst char * GetCountName() constDefinition TStreamerElement.h:",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:291164,Availability,error,error,291164,"h:240; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TStreamerArtificial::Classstatic TClass * Class(); TStreamerBase::Classstatic TClass * Class(); TStreamerBasicPointerDefinition TStreamerElement.h:198; TStreamerBasicPointer::Classstatic TClass * Class(); TStreamerBasicPointer::GetCountNameconst char * GetCountName() constDefinition TStreamerElement.h:218; TStreamerElementDefinition TStreamerElement.h:32; TStreamerElement::GetNewTypeInt_t GetNewType() constDefinition TStreamerElemen",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:36771,Deployability,update,updated,36771,"reamer info for the branch class.; 1023 ; 1024TStreamerInfo* TBranchElement::GetInfo() const; 1025{; 1026 return GetInfoImp();; 1027}; 1028 ; 1029////////////////////////////////////////////////////////////////////////////////; 1030/// Browse the branch content.; 1031 ; 1032void TBranchElement::Browse(TBrowser* b); 1033{; 1034 Int_t nbranches = fBranches.GetEntriesFast();; 1035 if (nbranches > 0) {; 1036 TList persistentBranches;; 1037 TBranch* branch=nullptr;; 1038 TIter iB(&fBranches);; 1039 while((branch=(TBranch*)iB())) {; 1040 if (branch->IsFolder()) persistentBranches.Add(branch);; 1041 else {; 1042 // only show branches corresponding to persistent members; 1043 TClass* cl=nullptr;; 1044 if (strlen(GetClonesName())); 1045 // this works both for top level branches and for sub-branches,; 1046 // as GetClonesName() is properly updated for sub-branches; 1047 cl=fClonesClass;; 1048 else {; 1049 cl=TClass::GetClass(GetClassName());; 1050 ; 1051 // check if we're in a sub-branch of this class; 1052 // we can only find out asking the streamer given our ID; 1053 TStreamerElement *element=nullptr;; 1054 TClass* clsub=nullptr;; 1055 if (fID>=0 && GetInfoImp(); 1056 && GetInfoImp()->IsCompiled(); 1057 && ((element=GetInfoImp()->GetElement(fID))); 1058 && ((clsub=element->GetClassPointer()))); 1059 cl=clsub;; 1060 }; 1061 if (cl) {; 1062 TString strMember=branch->GetName();; 1063 Size_t mempos=strMember.Last('.');; 1064 if (mempos!=kNPOS); 1065 strMember.Remove(0, (Int_t)mempos+1);; 1066 mempos=strMember.First('[');; 1067 if (mempos!=kNPOS); 1068 strMember.Remove((Int_t)mempos);; 1069 TDataMember* m=cl->GetDataMember(strMember);; 1070 if (!m || m->IsPersistent()) persistentBranches.Add(branch);; 1071 } else persistentBranches.Add(branch);; 1072 } // branch if not a folder; 1073 }; 1074 persistentBranches.Browse(b);; 1075 // add all public const methods without params; 1076 if (GetBrowsables() && GetBrowsables()->GetSize()); 1077 GetBrowsables()->Browse(b);; 1078 } else {; 1",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:43406,Deployability,update,update,43406," el->GetCountName();; 1211 TBranchElement *bc2 = (TBranchElement*)fBranches.FindObject(name2);; 1212 bre->SetBranchCount2(bc2);; 1213 }; 1214 bre->SetReadLeavesPtr();; 1215 bre->SetFillLeavesPtr();; 1216 }; 1217}; 1218 ; 1219////////////////////////////////////////////////////////////////////////////////; 1220/// Loop on all leaves of this branch to fill the basket buffer.; 1221///; 1222/// The function returns the number of bytes committed to the; 1223/// individual branches. If a write error occurs, the number of; 1224/// bytes returned is -1. If no data are written, because, e.g.,; 1225/// the branch is disabled, the number of bytes returned is 0.; 1226///; 1227/// Note: We not not use any member functions from TLeafElement!; 1228 ; 1229Int_t TBranchElement::FillImpl(ROOT::Internal::TBranchIMTHelper *imtHelper); 1230{; 1231 Int_t nbytes = 0;; 1232 Int_t nwrite = 0;; 1233 Int_t nerror = 0;; 1234 Int_t nbranches = fBranches.GetEntriesFast();; 1235 ; 1236 ValidateAddress();; 1237 ; 1238 //; 1239 // If we are a top-level branch, update addresses.; 1240 //; 1241 ; 1242 if (fID < 0) {; 1243 if (!fObject) {; 1244 Error(""Fill"", ""attempt to fill branch %s while address is not set"", GetName());; 1245 return 0;; 1246 }; 1247 }; 1248 ; 1249 //; 1250 // If the tree has a TRefTable, set the current branch if; 1251 // branch is not a basic type.; 1252 //; 1253 ; 1254 // FIXME: This test probably needs to be extended past 10.; 1255 if ((fType >= -1) && (fType < 10)) {; 1256 TBranchRef* bref = fTree->GetBranchRef();; 1257 if (bref) {; 1258 fBranchID = bref->SetParent(this, fBranchID);; 1259 }; 1260 }; 1261 ; 1262 if (!nbranches) {; 1263 // No sub-branches.; 1264 if (!TestBit(kDoNotProcess)) {; 1265 nwrite = TBranch::FillImpl(imtHelper);; 1266 if (nwrite < 0) {; 1267 Error(""Fill"", ""Failed filling branch:%s, nbytes=%d"", GetName(), nwrite);; 1268 ++nerror;; 1269 } else {; 1270 nbytes += nwrite;; 1271 }; 1272 }; 1273 } else {; 1274 // We have sub-branches.; 1275 if (fType == 3 || fTy",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:184011,Deployability,release,release,184011,"toDelete),; 4958/// the top level objet will be deleted and recreate; 4959/// each time an entry is read, whether or not the; 4960/// TTree owns the object.; 4961 ; 4962void TBranchElement::SetAddress(void* addr); 4963{; 4964 SetAddressImpl(addr, (addr == nullptr));; 4965}; 4966 ; 4967/// See TBranchElement::SetAddress.; 4968/// If implied is true, we do not over-ride existing address for; 4969/// sub-branches.; 4970void TBranchElement::SetAddressImpl(void* addr, bool implied); 4971{; 4972 //; 4973 // Don't bother if we are disabled.; 4974 //; 4975 ; 4976 if (TestBit(kDoNotProcess)) {; 4977 return;; 4978 }; 4979 ; 4980 //; 4981 // FIXME: When would this happen?; 4982 //; 4983 ; 4984 if (fType < -1) {; 4985 return;; 4986 }; 4987 ; 4988 //; 4989 // Special case when called from code generated by TTree::MakeClass.; 4990 //; 4991 ; 4992 if (Longptr_t(addr) == -1) {; 4993 // FIXME: Do we have to release an object here?; 4994 // ReleaseObject();; 4995 fAddress = (char*) -1;; 4996 fObject = (char*) -1;; 4997 ResetBit(kDeleteObject);; 4998 ResetBit(kAddressSet);; 4999 return;; 5000 }; 5001 ; 5002 //; 5003 // Reset last read entry number, we have a new user object now.; 5004 //; 5005 ; 5006 fReadEntry = -1;; 5007 ; 5008 //; 5009 // Make sure our branch class is instantiated.; 5010 //; 5011 TClass* clOfBranch = fBranchClass.GetClass();; 5012 if( fTargetClass.GetClassName()[0] ) {; 5013 clOfBranch = fTargetClass;; 5014 }; 5015 ; 5016 //; 5017 // Try to build the streamer info.; 5018 //; 5019 ; 5020 TStreamerInfo *info = GetInfoImp();; 5021 ; 5022 // FIXME: Warn about failure to get the streamer info here?; 5023 ; 5024 //; 5025 // We may have allocated an object last time we were called.; 5026 //; 5027 ; 5028 if (fObject && TestBit(kDeleteObject)){; 5029 ReleaseObject();; 5030 }; 5031 ; 5032 //; 5033 // Remember the pointer to the pointer to our object.; 5034 //; 5035 ; 5036 fAddress = (char*) addr;; 5037 if (fAddress != (char*)(&fObject)) {; 5038 fObject = nullptr;; 5039 }; 50",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:207455,Deployability,configurat,configuration,207455,ss); 5558 else; 5559 ResetBit(kDecomposedObj);; 5560 ; 5561 Int_t nbranches = fBranches.GetEntriesFast();; 5562 for (Int_t i = 0; i < nbranches; ++i) {; 5563 TBranchElement* branch = (TBranchElement*) fBranches[i];; 5564 branch->SetMakeClass(decomposeObj);; 5565 }; 5566 SetReadLeavesPtr();; 5567 SetFillLeavesPtr();; 5568 ; 5569 return true;; 5570}; 5571 ; 5572////////////////////////////////////////////////////////////////////////////////; 5573/// Set object this branch is pointing to.; 5574 ; 5575void TBranchElement::SetObject(void* obj); 5576{; 5577 if (TestBit(kDoNotProcess)) {; 5578 return;; 5579 }; 5580 fObject = (char*)obj;; 5581 SetAddress( &fObject );; 5582}; 5583 ; 5584////////////////////////////////////////////////////////////////////////////////; 5585/// Set offset of the object (to which the data member represented by this; 5586/// branch belongs) inside its containing object (if any).; 5587 ; 5588void TBranchElement::SetOffset(Int_t offset); 5589{; 5590 // We need to make sure that the Read and Write action's configuration; 5591 // properly reflect this value.; 5592 ; 5593 if (offset == TVirtualStreamerInfo::kMissing) {; 5594 SetMissing();; 5595 return;; 5596 }; 5597 ; 5598 if (fReadActionSequence) {; 5599 fReadActionSequence->AddToOffset(offset - fOffset);; 5600 }; 5601 if (fFillActionSequence) {; 5602 fFillActionSequence->AddToOffset(offset - fOffset);; 5603 }; 5604 fOffset = offset;; 5605}; 5606 ; 5607////////////////////////////////////////////////////////////////////////////////; 5608/// Set offset of the object (to which the data member represented by this; 5609/// branch belongs) inside its containing object (if any) to mark it as missing.; 5610 ; 5611void TBranchElement::SetMissing(); 5612{; 5613 // We need to make sure that the Read and Write action's configuration; 5614 // properly reflect this value.; 5615 ; 5616 if (fReadActionSequence) {; 5617 fReadActionSequence->SetMissing();; 5618 }; 5619 if (fFillActionSequence) {; 5620 fFillActionSeque,MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:208221,Deployability,configurat,configuration,208221,"5/// Set offset of the object (to which the data member represented by this; 5586/// branch belongs) inside its containing object (if any).; 5587 ; 5588void TBranchElement::SetOffset(Int_t offset); 5589{; 5590 // We need to make sure that the Read and Write action's configuration; 5591 // properly reflect this value.; 5592 ; 5593 if (offset == TVirtualStreamerInfo::kMissing) {; 5594 SetMissing();; 5595 return;; 5596 }; 5597 ; 5598 if (fReadActionSequence) {; 5599 fReadActionSequence->AddToOffset(offset - fOffset);; 5600 }; 5601 if (fFillActionSequence) {; 5602 fFillActionSequence->AddToOffset(offset - fOffset);; 5603 }; 5604 fOffset = offset;; 5605}; 5606 ; 5607////////////////////////////////////////////////////////////////////////////////; 5608/// Set offset of the object (to which the data member represented by this; 5609/// branch belongs) inside its containing object (if any) to mark it as missing.; 5610 ; 5611void TBranchElement::SetMissing(); 5612{; 5613 // We need to make sure that the Read and Write action's configuration; 5614 // properly reflect this value.; 5615 ; 5616 if (fReadActionSequence) {; 5617 fReadActionSequence->SetMissing();; 5618 }; 5619 if (fFillActionSequence) {; 5620 fFillActionSequence->SetMissing();; 5621 }; 5622 fOffset = TVirtualStreamerInfo::kMissing;; 5623}; 5624 ; 5625 ; 5626////////////////////////////////////////////////////////////////////////////////; 5627/// Set the sequence of actions needed to read the data out of the buffer.; 5628void TBranchElement::SetActionSequence(TClass *originalClass, TStreamerInfo *localInfo, TStreamerInfoActions::TActionSequence::SequenceGetter_t create, TStreamerInfoActions::TActionSequence *&actionSequence); 5629{; 5630 // A 'split' node does not store data itself (it has not associated baskets); 5631 const bool isSplitNode = (fType == 3 || fType == 4 || fType == 2 || fType == 1 || (fType == 0 && fID == -2)) && !fBranches.IsEmpty();; 5632 ; 5633 if (!isSplitNode) {; 5634 fNewIDs.insert(fNewIDs.begi",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:220235,Deployability,update,updated,220235," 5850 ; 5851////////////////////////////////////////////////////////////////////////////////; 5852/// Set the name of the class of the in-memory object into which the data will; 5853/// loaded.; 5854 ; 5855void TBranchElement::SetTargetClass(const char *name); 5856{; 5857 if (name == nullptr) return;; 5858 ; 5859 if (strcmp(fTargetClass.GetClassName(),name) != 0 ); 5860 {; 5861 // We are changing target class, let's reset the meta information and; 5862 // the sub-branches.; 5863 ; 5864 ResetInitInfo(/*recurse=*/ false);; 5865 ; 5866 Int_t nbranches = fBranches.GetEntriesFast();; 5867 for (Int_t i = 0; i < nbranches; ++i) {; 5868 TBranchElement *sub = (TBranchElement*) fBranches[i];; 5869 ; 5870 if (sub->fTargetClass == fTargetClass ) {; 5871 sub->SetTargetClass(name);; 5872 } else {; 5873 // Since the top level changes, the StreamerInfo (in particular for split collection); 5874 // may still need to change (and the info might be updated else (see for example SetAddress for the; 5875 // the case fType 4/41); 5876 sub->ResetInitInfo(true);; 5877 }; 5878 if (sub->fParentClass == fTargetClass ) {; 5879 sub->SetParentClass(TClass::GetClass(name));; 5880 }; 5881 }; 5882 fTargetClass = name;; 5883 }; 5884 ; 5885}; 5886 ; 5887////////////////////////////////////////////////////////////////////////////////; 5888/// If the branch address is not set, we set all addresses starting with; 5889/// the top level parent branch. This is required to be done in order for; 5890/// GetOffset to be correct and for GetEntry to run.; 5891 ; 5892void TBranchElement::SetupAddresses(); 5893{; 5894 // Check to see if the user changed the branch address on us.; 5895 ValidateAddress();; 5896 ; 5897 if (fAddress || TestBit(kDecomposedObj)) {; 5898 // -- Do nothing if already setup or if we are a MakeClass branch.; 5899 return;; 5900 }; 5901 SetupAddressesImpl();; 5902}; 5903 ; 5904////////////////////////////////////////////////////////////////////////////////; 5905/// If the branch address is not ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:242997,Deployability,update,update,242997,"lemID, ptr + offset, basketsize, splitlevel-1+splitSTLP, btype);; 6399 branch->SetParentClass(clParent);; 6400 fBranches.Add(branch);; 6401 } else {; 6402 // -- We are not going to split this element any farther.; 6403 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, nullptr, basketsize, splitSTLP, btype);; 6404 branch->SetType(btype);; 6405 branch->SetParentClass(clParent);; 6406 fBranches.Add(branch);; 6407 }; 6408 }; 6409 }; 6410 ; 6411 if (!fBranches.IsEmpty()) {; 6412 // Refresh this branch's action now that we know whether it is split or not.; 6413 SetReadActionSequence();; 6414 SetFillActionSequence();; 6415 }; 6416 return 1;; 6417}; 6418 ; 6419////////////////////////////////////////////////////////////////////////////////; 6420/// Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); 6421/// with the current value of fTree->GetCurrentFile unless this branch has been; 6422/// redirected to a different file. Also update the sub-branches.; 6423 ; 6424void TBranchElement::UpdateFile(); 6425{; 6426 // The BranchCount and BranchCount2 are part of higher level branches' list of; 6427 // branches.; 6428 // if (fBranchCount) fBranchCount->UpdateFile();; 6429 // if (fBranchCount2) fBranchCount2->UpdateFile();; 6430 TBranch::UpdateFile();; 6431}; unrollstatic void unroll(CPyCppyy_PyArgs_t packed_args, CPyCppyy_PyArgs_t unrolled, Py_ssize_t nArgs)Definition CPPGetSetItem.cxx:9; fBufferfBufferDefinition Converters.cxx:2972; kNoneconst Handle_t kNoneDefinition GuiTypes.h:88; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; b#define b(i)Definition RSha256.hxx:100; e#define e(i)Definition RSha256.hxx:103; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; Size_tfloat Size_tDefinition RtypesCore.h:89; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; UChar_tunsigned char UChar_t",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:304335,Deployability,release,release,304335,"; TTree::GetListOfLeavesvirtual TObjArray * GetListOfLeaves()Definition TTree.h:529; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::DebugInt_t Debug() constDefinition TTree.h:429; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetDebugMinLong64_t GetDebugMin() constDefinition TTree.h:461; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualArray::GetObjectAtchar * GetObjectAt(UInt_t ind) constDefinition TVirtualArray.h:41; TVirtualArray::SetSizevoid SetSize(UInt_t size)Definition TVirtualArray.h:43; TVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators.Definition TVirtualCollectionIterators.h:26; TVirtualCollectionIterators::CreateIteratorsvoid CreateIterators(void *collection, TVirtualCollectionProxy *proxy)Definition TVirtualCollectionIterators.h:65; TVirtualCollectionIterators::fBeginvoid * fBeginDefinition TVirtualCollectionIterators.h:41; TVirtualCollectionIterators::fEndvoid * fEndDefinition TVirtualCollectionIterators.h:42; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:34573,Energy Efficiency,allocate,allocated,34573,")->Add(leaf);; 944 // ===> create sub branches for each data member of an STL container value class; 945 TClass* valueClass = cont->GetValueClass();; 946 if (!valueClass) {; 947 return;; 948 }; 949 fClonesName = valueClass->GetName();; 950 fClonesClass = valueClass;; 951 TString branchname( name );; 952 branchname += ""_"";; 953 SetTitle(branchname);; 954 leaf->SetName(branchname);; 955 leaf->SetTitle(branchname);; 956 Unroll(name, valueClass, valueClass, nullptr, basketsize, splitlevel, 41);; 957 BuildTitle(name);; 958 SetReadLeavesPtr();; 959 SetFillLeavesPtr();; 960 return;; 961 }; 962 ; 963 TLeaf *leaf = new TLeafElement(this, GetTitle(), fID, fStreamerType);; 964 leaf->SetTitle(GetTitle());; 965 fNleaves = 1;; 966 fLeaves.Add(leaf);; 967 fTree->GetListOfLeaves()->Add(leaf);; 968 SetReadLeavesPtr();; 969 SetFillLeavesPtr();; 970}; 971 ; 972////////////////////////////////////////////////////////////////////////////////; 973/// Destructor.; 974 ; 975TBranchElement::~TBranchElement(); 976{; 977 // Release any allocated I/O buffers.; 978 if (fOnfileObject && TestBit(kOwnOnfileObj)) {; 979 delete fOnfileObject;; 980 fOnfileObject = nullptr;; 981 }; 982 ResetAddress();; 983 ; 984 delete[] fBranchOffset;; 985 fBranchOffset = nullptr;; 986 ; 987 fInfo = nullptr;; 988 fBranchCount2 = nullptr;; 989 fBranchCount = nullptr;; 990 ; 991 if (fType == 4 || fType == 0) {; 992 // Only the top level TBranchElement containing an STL container,; 993 // owns the collectionproxy.; 994 delete fCollProxy;; 995 }; 996 fCollProxy = nullptr;; 997 ; 998 delete fReadActionSequence;; 999 delete fFillActionSequence;; 1000 delete fIterators;; 1001 delete fWriteIterators;; 1002 delete fPtrIterators;; 1003}; 1004 ; 1005//; 1006// This function is located here to allow inlining by the optimizer.; 1007//; 1008////////////////////////////////////////////////////////////////////////////////; 1009/// Get streamer info for the branch class.; 1010 ; 1011inline TStreamerInfo* TBranchElement::GetInfoImp() c",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:35601,Energy Efficiency,reduce,reduce,35601,"llocated I/O buffers.; 978 if (fOnfileObject && TestBit(kOwnOnfileObj)) {; 979 delete fOnfileObject;; 980 fOnfileObject = nullptr;; 981 }; 982 ResetAddress();; 983 ; 984 delete[] fBranchOffset;; 985 fBranchOffset = nullptr;; 986 ; 987 fInfo = nullptr;; 988 fBranchCount2 = nullptr;; 989 fBranchCount = nullptr;; 990 ; 991 if (fType == 4 || fType == 0) {; 992 // Only the top level TBranchElement containing an STL container,; 993 // owns the collectionproxy.; 994 delete fCollProxy;; 995 }; 996 fCollProxy = nullptr;; 997 ; 998 delete fReadActionSequence;; 999 delete fFillActionSequence;; 1000 delete fIterators;; 1001 delete fWriteIterators;; 1002 delete fPtrIterators;; 1003}; 1004 ; 1005//; 1006// This function is located here to allow inlining by the optimizer.; 1007//; 1008////////////////////////////////////////////////////////////////////////////////; 1009/// Get streamer info for the branch class.; 1010 ; 1011inline TStreamerInfo* TBranchElement::GetInfoImp() const; 1012{; 1013 // Note: we need to find a way to reduce the complexity of; 1014 // this often executed condition.; 1015 if (!fInfo || (fInfo && (!fInit || !fInfo->IsCompiled()))) {; 1016 const_cast<TBranchElement*>(this)->InitInfo();; 1017 }; 1018 return fInfo;; 1019}; 1020 ; 1021////////////////////////////////////////////////////////////////////////////////; 1022/// Get streamer info for the branch class.; 1023 ; 1024TStreamerInfo* TBranchElement::GetInfo() const; 1025{; 1026 return GetInfoImp();; 1027}; 1028 ; 1029////////////////////////////////////////////////////////////////////////////////; 1030/// Browse the branch content.; 1031 ; 1032void TBranchElement::Browse(TBrowser* b); 1033{; 1034 Int_t nbranches = fBranches.GetEntriesFast();; 1035 if (nbranches > 0) {; 1036 TList persistentBranches;; 1037 TBranch* branch=nullptr;; 1038 TIter iB(&fBranches);; 1039 while((branch=(TBranch*)iB())) {; 1040 if (branch->IsFolder()) persistentBranches.Add(branch);; 1041 else {; 1042 // only show branches correspondi",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:173029,Energy Efficiency,allocate,allocated,173029,"t) GetValue(0, 0);; 4641}; 4642 ; 4643////////////////////////////////////////////////////////////////////////////////; 4644/// Read leaves into i/o buffers for this branch.; 4645/// Non TObject, Non collection classes with a custom streamer.; 4646 ; 4647void TBranchElement::ReadLeavesCustomStreamer(TBuffer& b); 4648{; 4649 ValidateAddress();; 4650 if (fObject == nullptr); 4651 {; 4652 // We have nowhere to copy the data (probably because the data member was; 4653 // 'dropped' from the current schema) so let's no copy it in a random place.; 4654 return;; 4655 }; 4656 ; 4657 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,1);; 4658 fBranchClass->Streamer(fObject,b);; 4659}; 4660 ; 4661////////////////////////////////////////////////////////////////////////////////; 4662/// Unconfiguration Fill Leave function.; 4663 ; 4664void TBranchElement::FillLeavesImpl(TBuffer&); 4665{; 4666 Fatal(""FillLeaves"",""The FillLeaves function has not been configured for %s"",GetName());; 4667}; 4668 ; 4669////////////////////////////////////////////////////////////////////////////////; 4670/// Delete any object we may have allocated on a previous call to SetAddress.; 4671 ; 4672void TBranchElement::ReleaseObject(); 4673{; 4674 if (fObject && TestBit(kDeleteObject)) {; 4675 if (IsAutoDelete() && fAddress != (char*)&fObject) {; 4676 *((char**) fAddress) = nullptr;; 4677 }; 4678 ResetBit(kDeleteObject);; 4679 if (fType == 3) {; 4680 // -- We are a TClonesArray master branch.; 4681 TClonesArray::Class()->Destructor(fObject);; 4682 fObject = nullptr;; 4683 if ((fStreamerType == TVirtualStreamerInfo::kObjectp) ||; 4684 (fStreamerType == TVirtualStreamerInfo::kObjectP)) {; 4685 // -- We are a pointer to a TClonesArray.; 4686 // We must zero the pointer in the object.; 4687 *((char**) fAddress) = nullptr;; 4688 }; 4689 } else if (fType == 4) {; 4690 // -- We are an STL container master branch.; 4691 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4692 ; 4693 if (!proxy) {; 4694 ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:173941,Energy Efficiency,allocate,allocated,173941,"76 *((char**) fAddress) = nullptr;; 4677 }; 4678 ResetBit(kDeleteObject);; 4679 if (fType == 3) {; 4680 // -- We are a TClonesArray master branch.; 4681 TClonesArray::Class()->Destructor(fObject);; 4682 fObject = nullptr;; 4683 if ((fStreamerType == TVirtualStreamerInfo::kObjectp) ||; 4684 (fStreamerType == TVirtualStreamerInfo::kObjectP)) {; 4685 // -- We are a pointer to a TClonesArray.; 4686 // We must zero the pointer in the object.; 4687 *((char**) fAddress) = nullptr;; 4688 }; 4689 } else if (fType == 4) {; 4690 // -- We are an STL container master branch.; 4691 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4692 ; 4693 if (!proxy) {; 4694 Warning(""ReleaseObject"", ""Cannot delete allocated STL container because I do not have a proxy! branch: %s"", GetName());; 4695 fObject = nullptr;; 4696 } else {; 4697 bool needDelete = proxy->GetProperties()&TVirtualCollectionProxy::kNeedDelete;; 4698 if (needDelete && fID >= 0) {; 4699 TVirtualStreamerInfo* si = GetInfoImp();; 4700 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 4701 needDelete = !se->TestBit(TStreamerElement::kDoNotDelete);; 4702 }; 4703 if (needDelete) {; 4704 TVirtualCollectionProxy::TPushPop helper(proxy,fObject);; 4705 proxy->Clear(""force"");; 4706 }; 4707 proxy->Destructor(fObject);; 4708 fObject = nullptr;; 4709 }; 4710 if (fStreamerType == TVirtualStreamerInfo::kSTLp) {; 4711 // -- We are a pointer to an STL container.; 4712 // We must zero the pointer in the object.; 4713 *((char**) fAddress) = nullptr;; 4714 }; 4715 } else {; 4716 // We are *not* a TClonesArray master branch and we are *not* an STL container master branch.; 4717 TClass* cl = fBranchClass.GetClass();; 4718 if (!cl) {; 4719 Warning(""ReleaseObject"", ""Cannot delete allocated object because I cannot instantiate a TClass object for its class! branch: '%s' class: '%s'"", GetName(), fBranchClass.GetClassName());; 4720 fObject = nullptr;; 4721 } else {; 4722 TVirtualCollectionProxy* proxy = cl->GetCollectionProxy();;",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:174988,Energy Efficiency,allocate,allocated,174988,"me());; 4695 fObject = nullptr;; 4696 } else {; 4697 bool needDelete = proxy->GetProperties()&TVirtualCollectionProxy::kNeedDelete;; 4698 if (needDelete && fID >= 0) {; 4699 TVirtualStreamerInfo* si = GetInfoImp();; 4700 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 4701 needDelete = !se->TestBit(TStreamerElement::kDoNotDelete);; 4702 }; 4703 if (needDelete) {; 4704 TVirtualCollectionProxy::TPushPop helper(proxy,fObject);; 4705 proxy->Clear(""force"");; 4706 }; 4707 proxy->Destructor(fObject);; 4708 fObject = nullptr;; 4709 }; 4710 if (fStreamerType == TVirtualStreamerInfo::kSTLp) {; 4711 // -- We are a pointer to an STL container.; 4712 // We must zero the pointer in the object.; 4713 *((char**) fAddress) = nullptr;; 4714 }; 4715 } else {; 4716 // We are *not* a TClonesArray master branch and we are *not* an STL container master branch.; 4717 TClass* cl = fBranchClass.GetClass();; 4718 if (!cl) {; 4719 Warning(""ReleaseObject"", ""Cannot delete allocated object because I cannot instantiate a TClass object for its class! branch: '%s' class: '%s'"", GetName(), fBranchClass.GetClassName());; 4720 fObject = nullptr;; 4721 } else {; 4722 TVirtualCollectionProxy* proxy = cl->GetCollectionProxy();; 4723 ; 4724 if (proxy) {; 4725 if (fID >= 0) {; 4726 TVirtualStreamerInfo* si = GetInfoImp();; 4727 TStreamerElement* se = si->GetElement(fID);; 4728 if (!se->TestBit(TStreamerElement::kDoNotDelete) && proxy->GetProperties()&TVirtualCollectionProxy::kNeedDelete) {; 4729 TVirtualCollectionProxy::TPushPop helper(proxy,fObject);; 4730 proxy->Clear(""force"");; 4731 }; 4732 } else if (proxy->GetProperties()&TVirtualCollectionProxy::kNeedDelete) {; 4733 TVirtualCollectionProxy::TPushPop helper(proxy,fObject);; 4734 proxy->Clear(""force"");; 4735 }; 4736 ; 4737 }; 4738 cl->Destructor(fObject);; 4739 fObject = nullptr;; 4740 }; 4741 }; 4742 }; 4743}; 4744 ; 4745////////////////////////////////////////////////////////////////////////////////; 4746/// Reset a Branch.; 4747///; 4",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:177056,Energy Efficiency,allocate,allocated,177056,"; 4745////////////////////////////////////////////////////////////////////////////////; 4746/// Reset a Branch.; 4747///; 4748/// Existing i/o buffers are deleted.; 4749/// Entries, max and min are reset.; 4750///; 4751 ; 4752void TBranchElement::Reset(Option_t* option); 4753{; 4754 Int_t nbranches = fBranches.GetEntriesFast();; 4755 for (Int_t i = 0; i < nbranches; ++i) {; 4756 TBranch* branch = (TBranch*) fBranches[i];; 4757 branch->Reset(option);; 4758 }; 4759 fBranchID = -1;; 4760 TBranch::Reset(option);; 4761}; 4762 ; 4763////////////////////////////////////////////////////////////////////////////////; 4764/// Reset a Branch after a Merge operation (drop data but keep customizations); 4765///; 4766 ; 4767void TBranchElement::ResetAfterMerge(TFileMergeInfo *info); 4768{; 4769 Int_t nbranches = fBranches.GetEntriesFast();; 4770 for (Int_t i = 0; i < nbranches; ++i) {; 4771 TBranch* branch = (TBranch*) fBranches[i];; 4772 branch->ResetAfterMerge(info);; 4773 }; 4774 TBranch::ResetAfterMerge(info);; 4775}; 4776 ; 4777////////////////////////////////////////////////////////////////////////////////; 4778/// Set branch address to zero and free all allocated memory.; 4779 ; 4780void TBranchElement::ResetAddress(); 4781{; 4782 for (Int_t i = 0; i < fNleaves; ++i) {; 4783 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4784 //if (leaf) leaf->SetAddress(0);; 4785 leaf->SetAddress(nullptr);; 4786 }; 4787 ; 4788 // Note: We *must* do the sub-branches first, otherwise; 4789 // we may delete the object containing the sub-branches; 4790 // before giving them a chance to cleanup.; 4791 Int_t nbranches = fBranches.GetEntriesFast();; 4792 for (Int_t i = 0; i < nbranches; ++i) {; 4793 TBranch* br = (TBranch*) fBranches[i];; 4794 if (br) br->ResetAddress();; 4795 }; 4796 ; 4797 //; 4798 // SetAddress may have allocated an object.; 4799 //; 4800 ; 4801 ReleaseObject();; 4802 ; 4803 ResetBit(kAddressSet);; 4804 fAddress = nullptr;; 4805 fObject = nullptr;; 4806}; 4807 ; 4808/////////",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:177717,Energy Efficiency,allocate,allocated,177717,"t::ResetAfterMerge(TFileMergeInfo *info); 4768{; 4769 Int_t nbranches = fBranches.GetEntriesFast();; 4770 for (Int_t i = 0; i < nbranches; ++i) {; 4771 TBranch* branch = (TBranch*) fBranches[i];; 4772 branch->ResetAfterMerge(info);; 4773 }; 4774 TBranch::ResetAfterMerge(info);; 4775}; 4776 ; 4777////////////////////////////////////////////////////////////////////////////////; 4778/// Set branch address to zero and free all allocated memory.; 4779 ; 4780void TBranchElement::ResetAddress(); 4781{; 4782 for (Int_t i = 0; i < fNleaves; ++i) {; 4783 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4784 //if (leaf) leaf->SetAddress(0);; 4785 leaf->SetAddress(nullptr);; 4786 }; 4787 ; 4788 // Note: We *must* do the sub-branches first, otherwise; 4789 // we may delete the object containing the sub-branches; 4790 // before giving them a chance to cleanup.; 4791 Int_t nbranches = fBranches.GetEntriesFast();; 4792 for (Int_t i = 0; i < nbranches; ++i) {; 4793 TBranch* br = (TBranch*) fBranches[i];; 4794 if (br) br->ResetAddress();; 4795 }; 4796 ; 4797 //; 4798 // SetAddress may have allocated an object.; 4799 //; 4800 ; 4801 ReleaseObject();; 4802 ; 4803 ResetBit(kAddressSet);; 4804 fAddress = nullptr;; 4805 fObject = nullptr;; 4806}; 4807 ; 4808////////////////////////////////////////////////////////////////////////////////; 4809/// Release ownership of any allocated objects.; 4810///; 4811/// Note: This interface was added so that clone trees could; 4812/// be told they do not own the allocated objects.; 4813 ; 4814void TBranchElement::ResetDeleteObject(); 4815{; 4816 ResetBit(kDeleteObject);; 4817 Int_t nb = fBranches.GetEntriesFast();; 4818 for (Int_t i = 0; i < nb; ++i) {; 4819 TBranch* br = (TBranch*) fBranches[i];; 4820 if (br->InheritsFrom(TBranchElement::Class())) {; 4821 ((TBranchElement*) br)->ResetDeleteObject();; 4822 }; 4823 }; 4824}; 4825 ; 4826////////////////////////////////////////////////////////////////////////////////; 4827/// \brief Reset offset and Stream",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:177998,Energy Efficiency,allocate,allocated,177998,"Branch::ResetAfterMerge(info);; 4775}; 4776 ; 4777////////////////////////////////////////////////////////////////////////////////; 4778/// Set branch address to zero and free all allocated memory.; 4779 ; 4780void TBranchElement::ResetAddress(); 4781{; 4782 for (Int_t i = 0; i < fNleaves; ++i) {; 4783 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4784 //if (leaf) leaf->SetAddress(0);; 4785 leaf->SetAddress(nullptr);; 4786 }; 4787 ; 4788 // Note: We *must* do the sub-branches first, otherwise; 4789 // we may delete the object containing the sub-branches; 4790 // before giving them a chance to cleanup.; 4791 Int_t nbranches = fBranches.GetEntriesFast();; 4792 for (Int_t i = 0; i < nbranches; ++i) {; 4793 TBranch* br = (TBranch*) fBranches[i];; 4794 if (br) br->ResetAddress();; 4795 }; 4796 ; 4797 //; 4798 // SetAddress may have allocated an object.; 4799 //; 4800 ; 4801 ReleaseObject();; 4802 ; 4803 ResetBit(kAddressSet);; 4804 fAddress = nullptr;; 4805 fObject = nullptr;; 4806}; 4807 ; 4808////////////////////////////////////////////////////////////////////////////////; 4809/// Release ownership of any allocated objects.; 4810///; 4811/// Note: This interface was added so that clone trees could; 4812/// be told they do not own the allocated objects.; 4813 ; 4814void TBranchElement::ResetDeleteObject(); 4815{; 4816 ResetBit(kDeleteObject);; 4817 Int_t nb = fBranches.GetEntriesFast();; 4818 for (Int_t i = 0; i < nb; ++i) {; 4819 TBranch* br = (TBranch*) fBranches[i];; 4820 if (br->InheritsFrom(TBranchElement::Class())) {; 4821 ((TBranchElement*) br)->ResetDeleteObject();; 4822 }; 4823 }; 4824}; 4825 ; 4826////////////////////////////////////////////////////////////////////////////////; 4827/// \brief Reset offset and StreamerInfo information from this branch.; 4828/// \param[in] recurse When true call ResetInitInfo on all subbranches.; 4829///; 4830 ; 4831void TBranchElement::ResetInitInfo(bool recurse); 4832{; 4833 fInfo = nullptr;; 4834 fInit = false;; 4835 fInitOf",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:178129,Energy Efficiency,allocate,allocated,178129," 4780void TBranchElement::ResetAddress(); 4781{; 4782 for (Int_t i = 0; i < fNleaves; ++i) {; 4783 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4784 //if (leaf) leaf->SetAddress(0);; 4785 leaf->SetAddress(nullptr);; 4786 }; 4787 ; 4788 // Note: We *must* do the sub-branches first, otherwise; 4789 // we may delete the object containing the sub-branches; 4790 // before giving them a chance to cleanup.; 4791 Int_t nbranches = fBranches.GetEntriesFast();; 4792 for (Int_t i = 0; i < nbranches; ++i) {; 4793 TBranch* br = (TBranch*) fBranches[i];; 4794 if (br) br->ResetAddress();; 4795 }; 4796 ; 4797 //; 4798 // SetAddress may have allocated an object.; 4799 //; 4800 ; 4801 ReleaseObject();; 4802 ; 4803 ResetBit(kAddressSet);; 4804 fAddress = nullptr;; 4805 fObject = nullptr;; 4806}; 4807 ; 4808////////////////////////////////////////////////////////////////////////////////; 4809/// Release ownership of any allocated objects.; 4810///; 4811/// Note: This interface was added so that clone trees could; 4812/// be told they do not own the allocated objects.; 4813 ; 4814void TBranchElement::ResetDeleteObject(); 4815{; 4816 ResetBit(kDeleteObject);; 4817 Int_t nb = fBranches.GetEntriesFast();; 4818 for (Int_t i = 0; i < nb; ++i) {; 4819 TBranch* br = (TBranch*) fBranches[i];; 4820 if (br->InheritsFrom(TBranchElement::Class())) {; 4821 ((TBranchElement*) br)->ResetDeleteObject();; 4822 }; 4823 }; 4824}; 4825 ; 4826////////////////////////////////////////////////////////////////////////////////; 4827/// \brief Reset offset and StreamerInfo information from this branch.; 4828/// \param[in] recurse When true call ResetInitInfo on all subbranches.; 4829///; 4830 ; 4831void TBranchElement::ResetInitInfo(bool recurse); 4832{; 4833 fInfo = nullptr;; 4834 fInit = false;; 4835 fInitOffsets = false;; 4836 fCurrentClass = nullptr;; 4837 delete fReadActionSequence;; 4838 fReadActionSequence = nullptr;; 4839 delete fFillActionSequence;; 4840 fFillActionSequence = nullptr;; 4841 ; 4842 if (",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:179635,Energy Efficiency,allocate,allocate,179635,"information from this branch.; 4828/// \param[in] recurse When true call ResetInitInfo on all subbranches.; 4829///; 4830 ; 4831void TBranchElement::ResetInitInfo(bool recurse); 4832{; 4833 fInfo = nullptr;; 4834 fInit = false;; 4835 fInitOffsets = false;; 4836 fCurrentClass = nullptr;; 4837 delete fReadActionSequence;; 4838 fReadActionSequence = nullptr;; 4839 delete fFillActionSequence;; 4840 fFillActionSequence = nullptr;; 4841 ; 4842 if (recurse) {; 4843 Int_t nbranches = fBranches.GetEntriesFast();; 4844 for (Int_t i = 0; i < nbranches; ++i) {; 4845 TBranchElement *sub = (TBranchElement*) fBranches[i];; 4846 sub->ResetInitInfo(true);; 4847 }; 4848 }; 4849}; 4850 ; 4851////////////////////////////////////////////////////////////////////////////////; 4852/// Point this branch at an object.; 4853///; 4854/// For a sub-branch, addr is a pointer to the branch object.; 4855///; 4856/// For a top-level branch the meaning of addr is as follows:; 4857///; 4858/// If addr is zero, then we allocate a branch object; 4859/// internally and the branch is the owner of the allocated; 4860/// object, not the caller. However the caller may obtain; 4861/// a pointer to the branch object with GetObject().; 4862/// The pointer is reset to zero (nullptr) when the relevant; 4863/// branch object is destroyed.; 4864///; 4865/// Example:; 4866/// ~~~ {.cpp}; 4867/// branch->SetAddress(0);; 4868/// Event* event = branch->GetObject();; 4869/// ... Do some work.; 4870/// ~~~; 4871/// If addr is not zero, but the pointer addr points at is; 4872/// zero, then we allocate a branch object and set the passed; 4873/// pointer to point at the allocated object. The caller; 4874/// owns the allocated object and is responsible for deleting; 4875/// it when it is no longer needed.; 4876///; 4877/// Example:; 4878/// ~~~ {.cpp}; 4879/// Event* event = 0;; 4880/// branch->SetAddress(&event);; 4881/// ... Do some work.; 4882/// delete event;; 4883/// event = 0;; 4884/// ~~~; 4885/// If addr is not zero",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:179715,Energy Efficiency,allocate,allocated,179715,"information from this branch.; 4828/// \param[in] recurse When true call ResetInitInfo on all subbranches.; 4829///; 4830 ; 4831void TBranchElement::ResetInitInfo(bool recurse); 4832{; 4833 fInfo = nullptr;; 4834 fInit = false;; 4835 fInitOffsets = false;; 4836 fCurrentClass = nullptr;; 4837 delete fReadActionSequence;; 4838 fReadActionSequence = nullptr;; 4839 delete fFillActionSequence;; 4840 fFillActionSequence = nullptr;; 4841 ; 4842 if (recurse) {; 4843 Int_t nbranches = fBranches.GetEntriesFast();; 4844 for (Int_t i = 0; i < nbranches; ++i) {; 4845 TBranchElement *sub = (TBranchElement*) fBranches[i];; 4846 sub->ResetInitInfo(true);; 4847 }; 4848 }; 4849}; 4850 ; 4851////////////////////////////////////////////////////////////////////////////////; 4852/// Point this branch at an object.; 4853///; 4854/// For a sub-branch, addr is a pointer to the branch object.; 4855///; 4856/// For a top-level branch the meaning of addr is as follows:; 4857///; 4858/// If addr is zero, then we allocate a branch object; 4859/// internally and the branch is the owner of the allocated; 4860/// object, not the caller. However the caller may obtain; 4861/// a pointer to the branch object with GetObject().; 4862/// The pointer is reset to zero (nullptr) when the relevant; 4863/// branch object is destroyed.; 4864///; 4865/// Example:; 4866/// ~~~ {.cpp}; 4867/// branch->SetAddress(0);; 4868/// Event* event = branch->GetObject();; 4869/// ... Do some work.; 4870/// ~~~; 4871/// If addr is not zero, but the pointer addr points at is; 4872/// zero, then we allocate a branch object and set the passed; 4873/// pointer to point at the allocated object. The caller; 4874/// owns the allocated object and is responsible for deleting; 4875/// it when it is no longer needed.; 4876///; 4877/// Example:; 4878/// ~~~ {.cpp}; 4879/// Event* event = 0;; 4880/// branch->SetAddress(&event);; 4881/// ... Do some work.; 4882/// delete event;; 4883/// event = 0;; 4884/// ~~~; 4885/// If addr is not zero",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:180200,Energy Efficiency,allocate,allocate,180200," TBranchElement *sub = (TBranchElement*) fBranches[i];; 4846 sub->ResetInitInfo(true);; 4847 }; 4848 }; 4849}; 4850 ; 4851////////////////////////////////////////////////////////////////////////////////; 4852/// Point this branch at an object.; 4853///; 4854/// For a sub-branch, addr is a pointer to the branch object.; 4855///; 4856/// For a top-level branch the meaning of addr is as follows:; 4857///; 4858/// If addr is zero, then we allocate a branch object; 4859/// internally and the branch is the owner of the allocated; 4860/// object, not the caller. However the caller may obtain; 4861/// a pointer to the branch object with GetObject().; 4862/// The pointer is reset to zero (nullptr) when the relevant; 4863/// branch object is destroyed.; 4864///; 4865/// Example:; 4866/// ~~~ {.cpp}; 4867/// branch->SetAddress(0);; 4868/// Event* event = branch->GetObject();; 4869/// ... Do some work.; 4870/// ~~~; 4871/// If addr is not zero, but the pointer addr points at is; 4872/// zero, then we allocate a branch object and set the passed; 4873/// pointer to point at the allocated object. The caller; 4874/// owns the allocated object and is responsible for deleting; 4875/// it when it is no longer needed.; 4876///; 4877/// Example:; 4878/// ~~~ {.cpp}; 4879/// Event* event = 0;; 4880/// branch->SetAddress(&event);; 4881/// ... Do some work.; 4882/// delete event;; 4883/// event = 0;; 4884/// ~~~; 4885/// If addr is not zero and the pointer addr points at is; 4886/// also not zero, then the caller has allocated a branch; 4887/// object and is asking us to use it. The caller owns it; 4888/// and must delete it when it is no longer needed.; 4889///; 4890/// Example:; 4891/// ~~~ {.cpp}; 4892/// Event* event = new Event();; 4893/// branch->SetAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well b",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:180277,Energy Efficiency,allocate,allocated,180277," TBranchElement *sub = (TBranchElement*) fBranches[i];; 4846 sub->ResetInitInfo(true);; 4847 }; 4848 }; 4849}; 4850 ; 4851////////////////////////////////////////////////////////////////////////////////; 4852/// Point this branch at an object.; 4853///; 4854/// For a sub-branch, addr is a pointer to the branch object.; 4855///; 4856/// For a top-level branch the meaning of addr is as follows:; 4857///; 4858/// If addr is zero, then we allocate a branch object; 4859/// internally and the branch is the owner of the allocated; 4860/// object, not the caller. However the caller may obtain; 4861/// a pointer to the branch object with GetObject().; 4862/// The pointer is reset to zero (nullptr) when the relevant; 4863/// branch object is destroyed.; 4864///; 4865/// Example:; 4866/// ~~~ {.cpp}; 4867/// branch->SetAddress(0);; 4868/// Event* event = branch->GetObject();; 4869/// ... Do some work.; 4870/// ~~~; 4871/// If addr is not zero, but the pointer addr points at is; 4872/// zero, then we allocate a branch object and set the passed; 4873/// pointer to point at the allocated object. The caller; 4874/// owns the allocated object and is responsible for deleting; 4875/// it when it is no longer needed.; 4876///; 4877/// Example:; 4878/// ~~~ {.cpp}; 4879/// Event* event = 0;; 4880/// branch->SetAddress(&event);; 4881/// ... Do some work.; 4882/// delete event;; 4883/// event = 0;; 4884/// ~~~; 4885/// If addr is not zero and the pointer addr points at is; 4886/// also not zero, then the caller has allocated a branch; 4887/// object and is asking us to use it. The caller owns it; 4888/// and must delete it when it is no longer needed.; 4889///; 4890/// Example:; 4891/// ~~~ {.cpp}; 4892/// Event* event = new Event();; 4893/// branch->SetAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well b",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:180324,Energy Efficiency,allocate,allocated,180324,"/////////////////////////////////////////////; 4852/// Point this branch at an object.; 4853///; 4854/// For a sub-branch, addr is a pointer to the branch object.; 4855///; 4856/// For a top-level branch the meaning of addr is as follows:; 4857///; 4858/// If addr is zero, then we allocate a branch object; 4859/// internally and the branch is the owner of the allocated; 4860/// object, not the caller. However the caller may obtain; 4861/// a pointer to the branch object with GetObject().; 4862/// The pointer is reset to zero (nullptr) when the relevant; 4863/// branch object is destroyed.; 4864///; 4865/// Example:; 4866/// ~~~ {.cpp}; 4867/// branch->SetAddress(0);; 4868/// Event* event = branch->GetObject();; 4869/// ... Do some work.; 4870/// ~~~; 4871/// If addr is not zero, but the pointer addr points at is; 4872/// zero, then we allocate a branch object and set the passed; 4873/// pointer to point at the allocated object. The caller; 4874/// owns the allocated object and is responsible for deleting; 4875/// it when it is no longer needed.; 4876///; 4877/// Example:; 4878/// ~~~ {.cpp}; 4879/// Event* event = 0;; 4880/// branch->SetAddress(&event);; 4881/// ... Do some work.; 4882/// delete event;; 4883/// event = 0;; 4884/// ~~~; 4885/// If addr is not zero and the pointer addr points at is; 4886/// also not zero, then the caller has allocated a branch; 4887/// object and is asking us to use it. The caller owns it; 4888/// and must delete it when it is no longer needed.; 4889///; 4890/// Example:; 4891/// ~~~ {.cpp}; 4892/// Event* event = new Event();; 4893/// branch->SetAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well because those routines call this one.; 4901///; 4902/// An example of a tree with branches with objects allocated; 4903/// and owned by us:; 4904/// ~~~ {.cpp",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:180715,Energy Efficiency,allocate,allocated,180715,"9/// internally and the branch is the owner of the allocated; 4860/// object, not the caller. However the caller may obtain; 4861/// a pointer to the branch object with GetObject().; 4862/// The pointer is reset to zero (nullptr) when the relevant; 4863/// branch object is destroyed.; 4864///; 4865/// Example:; 4866/// ~~~ {.cpp}; 4867/// branch->SetAddress(0);; 4868/// Event* event = branch->GetObject();; 4869/// ... Do some work.; 4870/// ~~~; 4871/// If addr is not zero, but the pointer addr points at is; 4872/// zero, then we allocate a branch object and set the passed; 4873/// pointer to point at the allocated object. The caller; 4874/// owns the allocated object and is responsible for deleting; 4875/// it when it is no longer needed.; 4876///; 4877/// Example:; 4878/// ~~~ {.cpp}; 4879/// Event* event = 0;; 4880/// branch->SetAddress(&event);; 4881/// ... Do some work.; 4882/// delete event;; 4883/// event = 0;; 4884/// ~~~; 4885/// If addr is not zero and the pointer addr points at is; 4886/// also not zero, then the caller has allocated a branch; 4887/// object and is asking us to use it. The caller owns it; 4888/// and must delete it when it is no longer needed.; 4889///; 4890/// Example:; 4891/// ~~~ {.cpp}; 4892/// Event* event = new Event();; 4893/// branch->SetAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well because those routines call this one.; 4901///; 4902/// An example of a tree with branches with objects allocated; 4903/// and owned by us:; 4904/// ~~~ {.cpp}; 4905/// TFile* f1 = new TFile(""myfile_original.root"");; 4906/// TTree* t1 = (TTree*) f->Get(""MyTree"");; 4907/// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; 4908/// TTree* t2 = t1->Clone(0);; 4909/// for (Int_t i = 0; i < 10; ++i) {; 4910/// t1->GetEntry(i);; 4911/// t2->Fill();; 4912/// }; 4913",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:181300,Energy Efficiency,allocate,allocated,181300,"t. The caller; 4874/// owns the allocated object and is responsible for deleting; 4875/// it when it is no longer needed.; 4876///; 4877/// Example:; 4878/// ~~~ {.cpp}; 4879/// Event* event = 0;; 4880/// branch->SetAddress(&event);; 4881/// ... Do some work.; 4882/// delete event;; 4883/// event = 0;; 4884/// ~~~; 4885/// If addr is not zero and the pointer addr points at is; 4886/// also not zero, then the caller has allocated a branch; 4887/// object and is asking us to use it. The caller owns it; 4888/// and must delete it when it is no longer needed.; 4889///; 4890/// Example:; 4891/// ~~~ {.cpp}; 4892/// Event* event = new Event();; 4893/// branch->SetAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well because those routines call this one.; 4901///; 4902/// An example of a tree with branches with objects allocated; 4903/// and owned by us:; 4904/// ~~~ {.cpp}; 4905/// TFile* f1 = new TFile(""myfile_original.root"");; 4906/// TTree* t1 = (TTree*) f->Get(""MyTree"");; 4907/// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; 4908/// TTree* t2 = t1->Clone(0);; 4909/// for (Int_t i = 0; i < 10; ++i) {; 4910/// t1->GetEntry(i);; 4911/// t2->Fill();; 4912/// }; 4913/// t2->Write(); 4914/// delete f2;; 4915/// f2 = 0;; 4916/// delete f1;; 4917/// f1 = 0;; 4918/// ~~~; 4919/// An example of a branch with an object allocated by us,; 4920/// but owned by the caller:; 4921/// ~~~ {.cpp}; 4922/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4923/// TTree* t = new TTree(""t"", ""A test tree.""); 4924/// Event* event = 0;; 4925/// TBranchElement* br = t->Branch(""event."", &event);; 4926/// for (Int_t i = 0; i < 10; ++i) {; 4927/// ... Fill event with meaningful data in some way.; 4928/// t->Fill();; 4929/// }; 4930/// t->Write();; 4931/// delete event;; 4932/// event = 0;; 4933/// delete f",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:181814,Energy Efficiency,allocate,allocated,181814,"o, then the caller has allocated a branch; 4887/// object and is asking us to use it. The caller owns it; 4888/// and must delete it when it is no longer needed.; 4889///; 4890/// Example:; 4891/// ~~~ {.cpp}; 4892/// Event* event = new Event();; 4893/// branch->SetAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well because those routines call this one.; 4901///; 4902/// An example of a tree with branches with objects allocated; 4903/// and owned by us:; 4904/// ~~~ {.cpp}; 4905/// TFile* f1 = new TFile(""myfile_original.root"");; 4906/// TTree* t1 = (TTree*) f->Get(""MyTree"");; 4907/// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; 4908/// TTree* t2 = t1->Clone(0);; 4909/// for (Int_t i = 0; i < 10; ++i) {; 4910/// t1->GetEntry(i);; 4911/// t2->Fill();; 4912/// }; 4913/// t2->Write(); 4914/// delete f2;; 4915/// f2 = 0;; 4916/// delete f1;; 4917/// f1 = 0;; 4918/// ~~~; 4919/// An example of a branch with an object allocated by us,; 4920/// but owned by the caller:; 4921/// ~~~ {.cpp}; 4922/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4923/// TTree* t = new TTree(""t"", ""A test tree.""); 4924/// Event* event = 0;; 4925/// TBranchElement* br = t->Branch(""event."", &event);; 4926/// for (Int_t i = 0; i < 10; ++i) {; 4927/// ... Fill event with meaningful data in some way.; 4928/// t->Fill();; 4929/// }; 4930/// t->Write();; 4931/// delete event;; 4932/// event = 0;; 4933/// delete f;; 4934/// f = 0;; 4935/// ~~~; 4936/// Notice that the only difference between this example; 4937/// and the following example is that the event pointer; 4938/// is zero when the branch is created.; 4939///; 4940/// An example of a branch with an object allocated and; 4941/// owned by the caller:; 4942/// ~~~ {.cpp}; 4943/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4944/// TTree* t = new",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:182547,Energy Efficiency,allocate,allocated,182547,">Clone(0);; 4909/// for (Int_t i = 0; i < 10; ++i) {; 4910/// t1->GetEntry(i);; 4911/// t2->Fill();; 4912/// }; 4913/// t2->Write(); 4914/// delete f2;; 4915/// f2 = 0;; 4916/// delete f1;; 4917/// f1 = 0;; 4918/// ~~~; 4919/// An example of a branch with an object allocated by us,; 4920/// but owned by the caller:; 4921/// ~~~ {.cpp}; 4922/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4923/// TTree* t = new TTree(""t"", ""A test tree.""); 4924/// Event* event = 0;; 4925/// TBranchElement* br = t->Branch(""event."", &event);; 4926/// for (Int_t i = 0; i < 10; ++i) {; 4927/// ... Fill event with meaningful data in some way.; 4928/// t->Fill();; 4929/// }; 4930/// t->Write();; 4931/// delete event;; 4932/// event = 0;; 4933/// delete f;; 4934/// f = 0;; 4935/// ~~~; 4936/// Notice that the only difference between this example; 4937/// and the following example is that the event pointer; 4938/// is zero when the branch is created.; 4939///; 4940/// An example of a branch with an object allocated and; 4941/// owned by the caller:; 4942/// ~~~ {.cpp}; 4943/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4944/// TTree* t = new TTree(""t"", ""A test tree.""); 4945/// Event* event = new Event();; 4946/// TBranchElement* br = t->Branch(""event."", &event);; 4947/// for (Int_t i = 0; i < 10; ++i) {; 4948/// ... Fill event with meaningful data in some way.; 4949/// t->Fill();; 4950/// }; 4951/// t->Write();; 4952/// delete event;; 4953/// event = 0;; 4954/// delete f;; 4955/// f = 0;; 4956/// ~~~; 4957/// If AutoDelete is on (see TBranch::SetAutoDelete),; 4958/// the top level objet will be deleted and recreate; 4959/// each time an entry is read, whether or not the; 4960/// TTree owns the object.; 4961 ; 4962void TBranchElement::SetAddress(void* addr); 4963{; 4964 SetAddressImpl(addr, (addr == nullptr));; 4965}; 4966 ; 4967/// See TBranchElement::SetAddress.; 4968/// If implied is true, we do not over-ride existing address for; 4969/// sub-branches.; 4970void TBranchElement::",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:184766,Energy Efficiency,allocate,allocated,184766," return;; 4978 }; 4979 ; 4980 //; 4981 // FIXME: When would this happen?; 4982 //; 4983 ; 4984 if (fType < -1) {; 4985 return;; 4986 }; 4987 ; 4988 //; 4989 // Special case when called from code generated by TTree::MakeClass.; 4990 //; 4991 ; 4992 if (Longptr_t(addr) == -1) {; 4993 // FIXME: Do we have to release an object here?; 4994 // ReleaseObject();; 4995 fAddress = (char*) -1;; 4996 fObject = (char*) -1;; 4997 ResetBit(kDeleteObject);; 4998 ResetBit(kAddressSet);; 4999 return;; 5000 }; 5001 ; 5002 //; 5003 // Reset last read entry number, we have a new user object now.; 5004 //; 5005 ; 5006 fReadEntry = -1;; 5007 ; 5008 //; 5009 // Make sure our branch class is instantiated.; 5010 //; 5011 TClass* clOfBranch = fBranchClass.GetClass();; 5012 if( fTargetClass.GetClassName()[0] ) {; 5013 clOfBranch = fTargetClass;; 5014 }; 5015 ; 5016 //; 5017 // Try to build the streamer info.; 5018 //; 5019 ; 5020 TStreamerInfo *info = GetInfoImp();; 5021 ; 5022 // FIXME: Warn about failure to get the streamer info here?; 5023 ; 5024 //; 5025 // We may have allocated an object last time we were called.; 5026 //; 5027 ; 5028 if (fObject && TestBit(kDeleteObject)){; 5029 ReleaseObject();; 5030 }; 5031 ; 5032 //; 5033 // Remember the pointer to the pointer to our object.; 5034 //; 5035 ; 5036 fAddress = (char*) addr;; 5037 if (fAddress != (char*)(&fObject)) {; 5038 fObject = nullptr;; 5039 }; 5040 ResetBit(kDeleteObject);; 5041 SetBit(kAddressSet);; 5042 ; 5043 //; 5044 // Do special stuff if we got called from a MakeClass class.; 5045 // Allow sub-branches to have independently set addresses.; 5046 //; 5047 ; 5048 if (TestBit(kDecomposedObj)) {; 5049 if (fID > -1) {; 5050 // We are *not* a top-level branch.; 5051 if (!info) {; 5052 // No streamer info, give up.; 5053 // FIXME: We should have an error message here.; 5054 fObject = fAddress;; 5055 } else {; 5056 // Compensate for the fact that the i/o routines; 5057 // will add the streamer offset to the address.; 5058 fObject = fA",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:194903,Energy Efficiency,allocate,allocate,194903,"; 5253 if(fSTLtype != ROOT::kSTLvector && GetCollectionProxy()->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ) {; 5254 fPtrIterators = new TVirtualCollectionPtrIterators(GetCollectionProxy());; 5255 } else if (fCollProxy->GetProperties() & TVirtualCollectionProxy::kIsAssociative) {; 5256 fWriteIterators = new TVirtualCollectionIterators(fCollProxy,false);; 5257 fIterators = new TVirtualCollectionIterators(fCollProxy);; 5258 } else {; 5259 fIterators = new TVirtualCollectionIterators(GetCollectionProxy());; 5260 }; 5261 }; 5262 }; 5263 }; 5264 ; 5265 //; 5266 // Establish the semantics of fObject and fAddress.; 5267 //; 5268 // Top-level branch:; 5269 // fObject is a ptr to the object,; 5270 // fAddress is a ptr to a pointer to the object.; 5271 //; 5272 // Sub-branch:; 5273 // fObject is a ptr to the object,; 5274 // fAddress is the same as fObject.; 5275 //; 5276 //; 5277 // There are special cases for TClonesArray and STL containers.; 5278 // If there is no user-provided object, we allocate one. We must; 5279 // also initialize any STL container proxy.; 5280 //; 5281 ; 5282 if (fType == 3) {; 5283 // -- We are a TClonesArray master branch.; 5284 if (fAddress) {; 5285 // -- We have been given a non-zero address, allocate if necessary.; 5286 if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5287 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5288 // Case of an embedded TClonesArray.; 5289 fObject = fAddress;; 5290 // Check if it has already been properly built.; 5291 TClonesArray* clones = (TClonesArray*) fObject;; 5292 if (!clones->GetClass()) {; 5293 new(fObject) TClonesArray(fClonesClass);; 5294 }; 5295 } else {; 5296 // -- We are either a top-level branch or we are a subbranch which is a pointer to a TClonesArray.; 5297 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5298 if ((fStreamerType != -1) &&; 5299 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5300 (fStrea",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:195137,Energy Efficiency,allocate,allocate,195137,"f (fCollProxy->GetProperties() & TVirtualCollectionProxy::kIsAssociative) {; 5256 fWriteIterators = new TVirtualCollectionIterators(fCollProxy,false);; 5257 fIterators = new TVirtualCollectionIterators(fCollProxy);; 5258 } else {; 5259 fIterators = new TVirtualCollectionIterators(GetCollectionProxy());; 5260 }; 5261 }; 5262 }; 5263 }; 5264 ; 5265 //; 5266 // Establish the semantics of fObject and fAddress.; 5267 //; 5268 // Top-level branch:; 5269 // fObject is a ptr to the object,; 5270 // fAddress is a ptr to a pointer to the object.; 5271 //; 5272 // Sub-branch:; 5273 // fObject is a ptr to the object,; 5274 // fAddress is the same as fObject.; 5275 //; 5276 //; 5277 // There are special cases for TClonesArray and STL containers.; 5278 // If there is no user-provided object, we allocate one. We must; 5279 // also initialize any STL container proxy.; 5280 //; 5281 ; 5282 if (fType == 3) {; 5283 // -- We are a TClonesArray master branch.; 5284 if (fAddress) {; 5285 // -- We have been given a non-zero address, allocate if necessary.; 5286 if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5287 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5288 // Case of an embedded TClonesArray.; 5289 fObject = fAddress;; 5290 // Check if it has already been properly built.; 5291 TClonesArray* clones = (TClonesArray*) fObject;; 5292 if (!clones->GetClass()) {; 5293 new(fObject) TClonesArray(fClonesClass);; 5294 }; 5295 } else {; 5296 // -- We are either a top-level branch or we are a subbranch which is a pointer to a TClonesArray.; 5297 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5298 if ((fStreamerType != -1) &&; 5299 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5300 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5301 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5302 } else if (fStreamerType == -1) {; 5303 // -- We are a top-level branch.; 5304 TClonesArray**",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:196193,Energy Efficiency,allocate,allocate,196193," if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5287 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5288 // Case of an embedded TClonesArray.; 5289 fObject = fAddress;; 5290 // Check if it has already been properly built.; 5291 TClonesArray* clones = (TClonesArray*) fObject;; 5292 if (!clones->GetClass()) {; 5293 new(fObject) TClonesArray(fClonesClass);; 5294 }; 5295 } else {; 5296 // -- We are either a top-level branch or we are a subbranch which is a pointer to a TClonesArray.; 5297 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5298 if ((fStreamerType != -1) &&; 5299 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5300 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5301 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5302 } else if (fStreamerType == -1) {; 5303 // -- We are a top-level branch.; 5304 TClonesArray** pp = (TClonesArray**) fAddress;; 5305 if (!*pp) {; 5306 // -- Caller wants us to allocate the clones array, but they will own it.; 5307 *pp = new TClonesArray(fClonesClass);; 5308 }; 5309 fObject = (char*) *pp;; 5310 } else {; 5311 // -- We are a pointer to a TClonesArray.; 5312 // Note: We do this so that the default constructor,; 5313 // or the i/o constructor can be lazy.; 5314 TClonesArray** pp = (TClonesArray**) fAddress;; 5315 if (!*pp) {; 5316 // -- Caller wants us to allocate the clones array, but they will own it.; 5317 *pp = new TClonesArray(fClonesClass);; 5318 }; 5319 fObject = (char*) *pp;; 5320 }; 5321 }; 5322 } else {; 5323 // -- We have been given a zero address, allocate for top-level only.; 5324 if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5325 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5326 // Case of an embedded TClonesArray.; 5327 Error(""SetAddress"", ""Embedded TClonesArray given a zero address for branch '%s'"", GetName());; 5328 } else {; 5329 // -- We are either a t",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:196592,Energy Efficiency,allocate,allocate,196592,");; 5294 }; 5295 } else {; 5296 // -- We are either a top-level branch or we are a subbranch which is a pointer to a TClonesArray.; 5297 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5298 if ((fStreamerType != -1) &&; 5299 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5300 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5301 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5302 } else if (fStreamerType == -1) {; 5303 // -- We are a top-level branch.; 5304 TClonesArray** pp = (TClonesArray**) fAddress;; 5305 if (!*pp) {; 5306 // -- Caller wants us to allocate the clones array, but they will own it.; 5307 *pp = new TClonesArray(fClonesClass);; 5308 }; 5309 fObject = (char*) *pp;; 5310 } else {; 5311 // -- We are a pointer to a TClonesArray.; 5312 // Note: We do this so that the default constructor,; 5313 // or the i/o constructor can be lazy.; 5314 TClonesArray** pp = (TClonesArray**) fAddress;; 5315 if (!*pp) {; 5316 // -- Caller wants us to allocate the clones array, but they will own it.; 5317 *pp = new TClonesArray(fClonesClass);; 5318 }; 5319 fObject = (char*) *pp;; 5320 }; 5321 }; 5322 } else {; 5323 // -- We have been given a zero address, allocate for top-level only.; 5324 if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5325 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5326 // Case of an embedded TClonesArray.; 5327 Error(""SetAddress"", ""Embedded TClonesArray given a zero address for branch '%s'"", GetName());; 5328 } else {; 5329 // -- We are either a top-level branch or we are a subbranch which is a pointer to a TClonesArray.; 5330 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5331 if ((fStreamerType != -1) &&; 5332 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5333 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5334 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5335 ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:196800,Energy Efficiency,allocate,allocate,196800,"r a top-level branch) or kObject(p|P) here.; 5298 if ((fStreamerType != -1) &&; 5299 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5300 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5301 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5302 } else if (fStreamerType == -1) {; 5303 // -- We are a top-level branch.; 5304 TClonesArray** pp = (TClonesArray**) fAddress;; 5305 if (!*pp) {; 5306 // -- Caller wants us to allocate the clones array, but they will own it.; 5307 *pp = new TClonesArray(fClonesClass);; 5308 }; 5309 fObject = (char*) *pp;; 5310 } else {; 5311 // -- We are a pointer to a TClonesArray.; 5312 // Note: We do this so that the default constructor,; 5313 // or the i/o constructor can be lazy.; 5314 TClonesArray** pp = (TClonesArray**) fAddress;; 5315 if (!*pp) {; 5316 // -- Caller wants us to allocate the clones array, but they will own it.; 5317 *pp = new TClonesArray(fClonesClass);; 5318 }; 5319 fObject = (char*) *pp;; 5320 }; 5321 }; 5322 } else {; 5323 // -- We have been given a zero address, allocate for top-level only.; 5324 if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5325 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5326 // Case of an embedded TClonesArray.; 5327 Error(""SetAddress"", ""Embedded TClonesArray given a zero address for branch '%s'"", GetName());; 5328 } else {; 5329 // -- We are either a top-level branch or we are a subbranch which is a pointer to a TClonesArray.; 5330 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5331 if ((fStreamerType != -1) &&; 5332 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5333 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5334 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5335 } else if (fStreamerType == -1) {; 5336 // -- We are a top-level branch.; 5337 // Idea: Consider making a zero address not allocate.; 5338 SetBit(kDeleteObject);; 5339 f",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:197688,Energy Efficiency,allocate,allocate,197688,"ay(fClonesClass);; 5318 }; 5319 fObject = (char*) *pp;; 5320 }; 5321 }; 5322 } else {; 5323 // -- We have been given a zero address, allocate for top-level only.; 5324 if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5325 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5326 // Case of an embedded TClonesArray.; 5327 Error(""SetAddress"", ""Embedded TClonesArray given a zero address for branch '%s'"", GetName());; 5328 } else {; 5329 // -- We are either a top-level branch or we are a subbranch which is a pointer to a TClonesArray.; 5330 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5331 if ((fStreamerType != -1) &&; 5332 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5333 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5334 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5335 } else if (fStreamerType == -1) {; 5336 // -- We are a top-level branch.; 5337 // Idea: Consider making a zero address not allocate.; 5338 SetBit(kDeleteObject);; 5339 fObject = (char*) new TClonesArray(fClonesClass);; 5340 fAddress = (char*) &fObject;; 5341 } else {; 5342 // -- We are a sub-branch which is a pointer to a TClonesArray.; 5343 Error(""SetAddress"", ""Embedded pointer to a TClonesArray given a zero address for branch '%s'"", GetName());; 5344 }; 5345 }; 5346 }; 5347 } else if (fType == 4) {; 5348 // -- We are an STL container master branch.; 5349 //; 5350 // Initialize fCollProxy.; 5351 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 5352 if (fAddress) {; 5353 // -- We have been given a non-zero address, allocate if necessary.; 5354 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5355 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5356 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5357 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5358 // Case of an embedded STL container.; 5359 // Note: We test for the kObject and",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:198297,Energy Efficiency,allocate,allocate,198297,".; 5330 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5331 if ((fStreamerType != -1) &&; 5332 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5333 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5334 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5335 } else if (fStreamerType == -1) {; 5336 // -- We are a top-level branch.; 5337 // Idea: Consider making a zero address not allocate.; 5338 SetBit(kDeleteObject);; 5339 fObject = (char*) new TClonesArray(fClonesClass);; 5340 fAddress = (char*) &fObject;; 5341 } else {; 5342 // -- We are a sub-branch which is a pointer to a TClonesArray.; 5343 Error(""SetAddress"", ""Embedded pointer to a TClonesArray given a zero address for branch '%s'"", GetName());; 5344 }; 5345 }; 5346 }; 5347 } else if (fType == 4) {; 5348 // -- We are an STL container master branch.; 5349 //; 5350 // Initialize fCollProxy.; 5351 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 5352 if (fAddress) {; 5353 // -- We have been given a non-zero address, allocate if necessary.; 5354 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5355 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5356 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5357 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5358 // Case of an embedded STL container.; 5359 // Note: We test for the kObject and kAny types to support; 5360 // the (unwise) choice of inheriting from an STL container.; 5361 fObject = fAddress;; 5362 } else {; 5363 // We are either a top-level branch or subbranch which is a pointer to an STL container.; 5364 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5365 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5366 Error(""SetAddress"",; 5367 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5368 GetName(), fStreamerType);; 5369 } else if (fStream",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:199382,Energy Efficiency,allocate,allocate,199382,"rInfo::kObject) ||; 5355 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5356 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5357 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5358 // Case of an embedded STL container.; 5359 // Note: We test for the kObject and kAny types to support; 5360 // the (unwise) choice of inheriting from an STL container.; 5361 fObject = fAddress;; 5362 } else {; 5363 // We are either a top-level branch or subbranch which is a pointer to an STL container.; 5364 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5365 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5366 Error(""SetAddress"",; 5367 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5368 GetName(), fStreamerType);; 5369 } else if (fStreamerType == -1) {; 5370 // -- We are a top-level branch.; 5371 void** pp = (void**) fAddress;; 5372 if (!*pp) {; 5373 // -- Caller wants us to allocate the STL container, but they will own it.; 5374 *pp = proxy->New();; 5375 if (!(*pp)) {; 5376 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5377 // FIXME: Should we do this? Lots of other code wants; 5378 // fAddress to be zero if no fObject, but is; 5379 // that a good thing?; 5380 fAddress = nullptr;; 5381 ResetBit(kAddressSet);; 5382 }; 5383 }; 5384 fObject = (char*) *pp;; 5385 } else {; 5386 // -- We are a pointer to an STL container.; 5387 // Note: We do this so that the default constructor,; 5388 // or the i/o constructor can be lazy.; 5389 void** pp = (void**) fAddress;; 5390 if (!*pp) {; 5391 // -- Caller wants us to allocate the STL container, but they will own it.; 5392 *pp = proxy->New();; 5393 if (!(*pp)) {; 5394 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5395 // FIXME: Should we do this? Lots of other code wants; 5396 // fAddress to be zero if no fObject, but is; 539",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:199515,Energy Efficiency,allocate,allocate,199515," the kObject and kAny types to support; 5360 // the (unwise) choice of inheriting from an STL container.; 5361 fObject = fAddress;; 5362 } else {; 5363 // We are either a top-level branch or subbranch which is a pointer to an STL container.; 5364 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5365 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5366 Error(""SetAddress"",; 5367 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5368 GetName(), fStreamerType);; 5369 } else if (fStreamerType == -1) {; 5370 // -- We are a top-level branch.; 5371 void** pp = (void**) fAddress;; 5372 if (!*pp) {; 5373 // -- Caller wants us to allocate the STL container, but they will own it.; 5374 *pp = proxy->New();; 5375 if (!(*pp)) {; 5376 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5377 // FIXME: Should we do this? Lots of other code wants; 5378 // fAddress to be zero if no fObject, but is; 5379 // that a good thing?; 5380 fAddress = nullptr;; 5381 ResetBit(kAddressSet);; 5382 }; 5383 }; 5384 fObject = (char*) *pp;; 5385 } else {; 5386 // -- We are a pointer to an STL container.; 5387 // Note: We do this so that the default constructor,; 5388 // or the i/o constructor can be lazy.; 5389 void** pp = (void**) fAddress;; 5390 if (!*pp) {; 5391 // -- Caller wants us to allocate the STL container, but they will own it.; 5392 *pp = proxy->New();; 5393 if (!(*pp)) {; 5394 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5395 // FIXME: Should we do this? Lots of other code wants; 5396 // fAddress to be zero if no fObject, but is; 5397 // that a good thing?; 5398 fAddress = nullptr;; 5399 ResetBit(kAddressSet);; 5400 }; 5401 }; 5402 fObject = (char*) *pp;; 5403 }; 5404 }; 5405 } else {; 5406 // -- We have been given a zero address, allocate for top-level only.; 5407 if ((fStreamerType == TVirtualStreamerInfo::kObject",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:200062,Energy Efficiency,allocate,allocate,200062,"kSTLp)) {; 5366 Error(""SetAddress"",; 5367 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5368 GetName(), fStreamerType);; 5369 } else if (fStreamerType == -1) {; 5370 // -- We are a top-level branch.; 5371 void** pp = (void**) fAddress;; 5372 if (!*pp) {; 5373 // -- Caller wants us to allocate the STL container, but they will own it.; 5374 *pp = proxy->New();; 5375 if (!(*pp)) {; 5376 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5377 // FIXME: Should we do this? Lots of other code wants; 5378 // fAddress to be zero if no fObject, but is; 5379 // that a good thing?; 5380 fAddress = nullptr;; 5381 ResetBit(kAddressSet);; 5382 }; 5383 }; 5384 fObject = (char*) *pp;; 5385 } else {; 5386 // -- We are a pointer to an STL container.; 5387 // Note: We do this so that the default constructor,; 5388 // or the i/o constructor can be lazy.; 5389 void** pp = (void**) fAddress;; 5390 if (!*pp) {; 5391 // -- Caller wants us to allocate the STL container, but they will own it.; 5392 *pp = proxy->New();; 5393 if (!(*pp)) {; 5394 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5395 // FIXME: Should we do this? Lots of other code wants; 5396 // fAddress to be zero if no fObject, but is; 5397 // that a good thing?; 5398 fAddress = nullptr;; 5399 ResetBit(kAddressSet);; 5400 }; 5401 }; 5402 fObject = (char*) *pp;; 5403 }; 5404 }; 5405 } else {; 5406 // -- We have been given a zero address, allocate for top-level only.; 5407 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5408 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5409 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5410 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5411 // Case of an embedded STL container.; 5412 // Note: We test for the kObject and kAny types to support; 5413 // the (unwise) choice of inheriting from an STL container.; 5414 Error(""",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:200195,Energy Efficiency,allocate,allocate,200195,"5373 // -- Caller wants us to allocate the STL container, but they will own it.; 5374 *pp = proxy->New();; 5375 if (!(*pp)) {; 5376 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5377 // FIXME: Should we do this? Lots of other code wants; 5378 // fAddress to be zero if no fObject, but is; 5379 // that a good thing?; 5380 fAddress = nullptr;; 5381 ResetBit(kAddressSet);; 5382 }; 5383 }; 5384 fObject = (char*) *pp;; 5385 } else {; 5386 // -- We are a pointer to an STL container.; 5387 // Note: We do this so that the default constructor,; 5388 // or the i/o constructor can be lazy.; 5389 void** pp = (void**) fAddress;; 5390 if (!*pp) {; 5391 // -- Caller wants us to allocate the STL container, but they will own it.; 5392 *pp = proxy->New();; 5393 if (!(*pp)) {; 5394 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5395 // FIXME: Should we do this? Lots of other code wants; 5396 // fAddress to be zero if no fObject, but is; 5397 // that a good thing?; 5398 fAddress = nullptr;; 5399 ResetBit(kAddressSet);; 5400 }; 5401 }; 5402 fObject = (char*) *pp;; 5403 }; 5404 }; 5405 } else {; 5406 // -- We have been given a zero address, allocate for top-level only.; 5407 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5408 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5409 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5410 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5411 // Case of an embedded STL container.; 5412 // Note: We test for the kObject and kAny types to support; 5413 // the (unwise) choice of inheriting from an STL container.; 5414 Error(""SetAddress"", ""Embedded STL container given a zero address for branch '%s'"", GetName());; 5415 } else {; 5416 // We are either a top-level branch or sub-branch which is a pointer to an STL container.; 5417 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5418 if ((fStreamerType != -1) &&",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:200565,Energy Efficiency,allocate,allocate,200565,"5373 // -- Caller wants us to allocate the STL container, but they will own it.; 5374 *pp = proxy->New();; 5375 if (!(*pp)) {; 5376 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5377 // FIXME: Should we do this? Lots of other code wants; 5378 // fAddress to be zero if no fObject, but is; 5379 // that a good thing?; 5380 fAddress = nullptr;; 5381 ResetBit(kAddressSet);; 5382 }; 5383 }; 5384 fObject = (char*) *pp;; 5385 } else {; 5386 // -- We are a pointer to an STL container.; 5387 // Note: We do this so that the default constructor,; 5388 // or the i/o constructor can be lazy.; 5389 void** pp = (void**) fAddress;; 5390 if (!*pp) {; 5391 // -- Caller wants us to allocate the STL container, but they will own it.; 5392 *pp = proxy->New();; 5393 if (!(*pp)) {; 5394 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5395 // FIXME: Should we do this? Lots of other code wants; 5396 // fAddress to be zero if no fObject, but is; 5397 // that a good thing?; 5398 fAddress = nullptr;; 5399 ResetBit(kAddressSet);; 5400 }; 5401 }; 5402 fObject = (char*) *pp;; 5403 }; 5404 }; 5405 } else {; 5406 // -- We have been given a zero address, allocate for top-level only.; 5407 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5408 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5409 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5410 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5411 // Case of an embedded STL container.; 5412 // Note: We test for the kObject and kAny types to support; 5413 // the (unwise) choice of inheriting from an STL container.; 5414 Error(""SetAddress"", ""Embedded STL container given a zero address for branch '%s'"", GetName());; 5415 } else {; 5416 // We are either a top-level branch or sub-branch which is a pointer to an STL container.; 5417 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5418 if ((fStreamerType != -1) &&",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:201646,Energy Efficiency,allocate,allocate,201646,"; 5407 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5408 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5409 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5410 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5411 // Case of an embedded STL container.; 5412 // Note: We test for the kObject and kAny types to support; 5413 // the (unwise) choice of inheriting from an STL container.; 5414 Error(""SetAddress"", ""Embedded STL container given a zero address for branch '%s'"", GetName());; 5415 } else {; 5416 // We are either a top-level branch or sub-branch which is a pointer to an STL container.; 5417 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5418 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5419 Error(""SetAddress"",; 5420 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5421 GetName(), fStreamerType);; 5422 } else if (fStreamerType == -1) {; 5423 // -- We are a top-level branch, allocate.; 5424 SetBit(kDeleteObject);; 5425 fObject = (char*) proxy->New();; 5426 if (fObject) {; 5427 fAddress = (char*) &fObject;; 5428 } else {; 5429 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5430 // FIXME: Should we do this? Lots of other code wants; 5431 // fAddress to be zero if no fObject, but is; 5432 // that a good thing?; 5433 fAddress = nullptr;; 5434 ResetBit(kAddressSet);; 5435 }; 5436 } else {; 5437 // -- We are a sub-branch which is a pointer to an STL container.; 5438 Error(""SetAddress"", ""Embedded pointer to an STL container given a zero address for branch '%s'"", GetName());; 5439 }; 5440 }; 5441 }; 5442 } else if (fType == 41) {; 5443 // -- We are an STL container sub-branch.; 5444 // Initialize fCollProxy.; 5445 GetCollectionProxy();; 5446 // We are not at top-level branch.; 5447 fObject = fAddress;; 5448 } else if (fID < 0) {; 5449 // -- We are a top-level branch.; 5450 c",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:201831,Energy Efficiency,allocate,allocate,201831," We test for the kObject and kAny types to support; 5413 // the (unwise) choice of inheriting from an STL container.; 5414 Error(""SetAddress"", ""Embedded STL container given a zero address for branch '%s'"", GetName());; 5415 } else {; 5416 // We are either a top-level branch or sub-branch which is a pointer to an STL container.; 5417 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5418 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5419 Error(""SetAddress"",; 5420 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5421 GetName(), fStreamerType);; 5422 } else if (fStreamerType == -1) {; 5423 // -- We are a top-level branch, allocate.; 5424 SetBit(kDeleteObject);; 5425 fObject = (char*) proxy->New();; 5426 if (fObject) {; 5427 fAddress = (char*) &fObject;; 5428 } else {; 5429 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5430 // FIXME: Should we do this? Lots of other code wants; 5431 // fAddress to be zero if no fObject, but is; 5432 // that a good thing?; 5433 fAddress = nullptr;; 5434 ResetBit(kAddressSet);; 5435 }; 5436 } else {; 5437 // -- We are a sub-branch which is a pointer to an STL container.; 5438 Error(""SetAddress"", ""Embedded pointer to an STL container given a zero address for branch '%s'"", GetName());; 5439 }; 5440 }; 5441 }; 5442 } else if (fType == 41) {; 5443 // -- We are an STL container sub-branch.; 5444 // Initialize fCollProxy.; 5445 GetCollectionProxy();; 5446 // We are not at top-level branch.; 5447 fObject = fAddress;; 5448 } else if (fID < 0) {; 5449 // -- We are a top-level branch.; 5450 char** pp = (char**) fAddress;; 5451 if (pp && *pp) {; 5452 // -- Caller provided an i/o buffer for us to use.; 5453 fObject = *pp;; 5454 } else {; 5455 // -- Caller did not provide an i/o buffer for us to use, we must make one for ourselves.; 5456 if (clOfBranch) {; 5457 if (!pp) {; 5458 // -- Caller wants us to own the",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:203184,Energy Efficiency,allocate,allocate,203184,"pointer to an STL container.; 5438 Error(""SetAddress"", ""Embedded pointer to an STL container given a zero address for branch '%s'"", GetName());; 5439 }; 5440 }; 5441 }; 5442 } else if (fType == 41) {; 5443 // -- We are an STL container sub-branch.; 5444 // Initialize fCollProxy.; 5445 GetCollectionProxy();; 5446 // We are not at top-level branch.; 5447 fObject = fAddress;; 5448 } else if (fID < 0) {; 5449 // -- We are a top-level branch.; 5450 char** pp = (char**) fAddress;; 5451 if (pp && *pp) {; 5452 // -- Caller provided an i/o buffer for us to use.; 5453 fObject = *pp;; 5454 } else {; 5455 // -- Caller did not provide an i/o buffer for us to use, we must make one for ourselves.; 5456 if (clOfBranch) {; 5457 if (!pp) {; 5458 // -- Caller wants us to own the object.; 5459 SetBit(kDeleteObject);; 5460 }; 5461 fObject = (char*) clOfBranch->New();; 5462 if (pp) {; 5463 *pp = fObject;; 5464 } else {; 5465 fAddress = (char*) &fObject;; 5466 }; 5467 } else {; 5468 Error(""SetAddress"", ""I have no TClass for branch %s, so I cannot allocate an I/O buffer!"", GetName());; 5469 if (pp) {; 5470 fObject = nullptr;; 5471 *pp = nullptr;; 5472 }; 5473 }; 5474 }; 5475 } else {; 5476 // -- We are *not* a top-level branch.; 5477 fObject = fAddress;; 5478 }; 5479 ; 5480 if (!info) {; 5481 // FIXME: We need and error message here, no streamer info, so cannot set offsets.; 5482 return;; 5483 }; 5484 ; 5485 // We do this only once because it depends only on; 5486 // the type of our object, not on its address.; 5487 if (!fInitOffsets) {; 5488 InitializeOffsets();; 5489 }; 5490 ; 5491 // We are split, recurse down to our sub-branches.; 5492 //; 5493 // FIXME: This is a tail recursion, we burn stack.; 5494 Int_t nbranches = fBranches.GetEntriesFast();; 5495 for (Int_t i = 0; i < nbranches; ++i) {; 5496 TBranch *abranch = (TBranch*) fBranches.UncheckedAt(i);; 5497 // FIXME: This is a tail recursion!; 5498 if (fBranchOffset[i] != TStreamerInfo::kMissing && !(implied && abranch->TestBit(kAddress",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:223079,Energy Efficiency,allocate,allocate,223079,"SplitLevel >= TTree::kSplitCollectionOfPointers ); 5923 {; 5924 TBranchElement *parent = (TBranchElement *)GetMother()->GetSubBranch( this );; 5925 ; 5926 // Make sure the StreamerInfo is loaded and initialized.; 5927 GetInfoImp();; 5928 ; 5929 if( !parent->GetAddress() ); 5930 parent->SetAddress( nullptr );; 5931 return;; 5932 }; 5933 ; 5934 //--------------------------------------------------------------------------; 5935 // Any other case; 5936 /////////////////////////////////////////////////////////////////////////////; 5937 ; 5938 TBranchElement* mother = (TBranchElement*) GetMother();; 5939 if (!mother) {; 5940 return;; 5941 }; 5942 TClass* cl = TClass::GetClass(mother->GetClassName());; 5943 ; 5944 // Make sure the StreamerInfo is loaded and initialized.; 5945 GetInfoImp();; 5946 ; 5947 if (!cl) {; 5948 return;; 5949 }; 5950 ; 5951 if (!mother->GetAddress()) {; 5952 // -- Our top-level branch has no address.; 5953 bool motherStatus = mother->TestBit(kDoNotProcess);; 5954 mother->ResetBit(kDoNotProcess);; 5955 // Note: This will allocate an object.; 5956 mother->SetAddress(nullptr);; 5957 mother->SetBit(kDoNotProcess, motherStatus);; 5958 }; 5959}; 5960 ; 5961////////////////////////////////////////////////////////////////////////////////; 5962/// Stream an object of class TBranchElement.; 5963 ; 5964void TBranchElement::Streamer(TBuffer& R__b); 5965{; 5966 if (R__b.IsReading()) {; 5967 R__b.ReadClassBuffer(TBranchElement::Class(), this);; 5968 fParentClass.SetName(fParentName);; 5969 fBranchClass.SetName(fClassName);; 5970 fTargetClass.SetName(fClassName);; 5971 fClonesClass.SetName(fClonesName);; 5972 // The fAddress and fObject data members are not persistent,; 5973 // therefore we do not own anything.; 5974 // Also clear the bit possibly set by the schema evolution.; 5975 ResetBit(kDeleteObject|kCache|kOwnOnfileObj|kAddressSet|kDecomposedObj);; 5976 // Fixup a case where the TLeafElement was missing; 5977 if ((fType == 0) && (fLeaves.GetEntriesFast() == 0",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:255939,Energy Efficiency,allocate,allocated,255939,"actions to be executed to write the data to the basket.Definition TBranchElement.h:100; TBranchElement::Printvoid Print(Option_t *option="""") const overridePrint TBranch parameters.Definition TBranchElement.cxx:3836; TBranchElement::GetIDInt_t GetID() constDefinition TBranchElement.h:195; TBranchElement::GetClassNameconst char * GetClassName() const overrideReturn the name of the user class whose content is stored in this branch, if any.Definition TBranchElement.h:186; TBranchElement::GetInfoTStreamerInfo * GetInfo() constGet streamer info for the branch class.Definition TBranchElement.cxx:1024; TBranchElement::ReadLeavesCollectionvoid ReadLeavesCollection(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4267; TBranchElement::SetupAddressesvoid SetupAddresses() overrideIf the branch address is not set, we set all addresses starting with the top level parent branch.Definition TBranchElement.cxx:5892; TBranchElement::ResetAddressvoid ResetAddress() overrideSet branch address to zero and free all allocated memory.Definition TBranchElement.cxx:4780; TBranchElement::SetTypevirtual void SetType(Int_t btype)Definition TBranchElement.h:234; TBranchElement::FillLeavesMembervoid FillLeavesMember(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1734; TBranchElement::SetBranchCountvoid SetBranchCount(TBranchElement *bre)Set the branch counter for this branch.Definition TBranchElement.cxx:5529; TBranchElement::SwitchContainerstatic void SwitchContainer(TObjArray *)Modify the container type of the branches.Definition TBranchElement.cxx:85; TBranchElement::SetReadActionSequencevoid SetReadActionSequence()Set the sequence of actions needed to read the data out of the buffer.Definition TBranchElement.cxx:5663; TBranchElement::IsMissingCollectionbool IsMissingCollection() constDetect a collection written using a zero pointer in old versions of root.Definition TBranchElement.cxx:3776; TBranchElement::FillImplInt_",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:262559,Energy Efficiency,allocate,allocated,262559,ddress.Definition TBranchElement.cxx:1923; TBranchElement::FillLeavesMemberCountervoid FillLeavesMemberCounter(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1697; TBranchElement::SetBranchCount2void SetBranchCount2(TBranchElement *bre)Definition TBranchElement.h:124; TBranchElement::FillLeavesCollectionSplitPtrMembervoid FillLeavesCollectionSplitPtrMember(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1499; TBranchElement::SetAddressvoid SetAddress(void *addobj) overridePoint this branch at an object.Definition TBranchElement.cxx:4962; TBranchElement::GetInfoImpTStreamerInfo * GetInfoImp() constGet streamer info for the branch class.Definition TBranchElement.cxx:1011; TBranchElement::SetTargetClassvirtual void SetTargetClass(const char *name)Set the name of the class of the in-memory object into which the data will loaded.Definition TBranchElement.cxx:5855; TBranchElement::ResetDeleteObjectvirtual void ResetDeleteObject()Release ownership of any allocated objects.Definition TBranchElement.cxx:4814; TBranchElement::GetParentNamevirtual const char * GetParentName() constDefinition TBranchElement.h:200; TBranchElement::ValidateAddressvoid ValidateAddress() constDefinition TBranchElement.h:264; TBranchElement::GetOnfileObjectTVirtualArray * GetOnfileObject() constDefinition TBranchElement.h:199; TBranchElement::fWriteIteratorsTVirtualCollectionIterators * fWriteIterators! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers.Definition TBranchElement.h:102; TBranchElement::PrintValuevoid PrintValue(Int_t i) constPrints values of leaves.Definition TBranchElement.cxx:3928; TBranchElement::fOnfileObjectTVirtualArray * fOnfileObject! Place holder for the onfile representation of data members.Definition TBranchElement.h:87; TBranchElement::SetBasketSizevoid SetBasketSize(Int_t buffsize) overrideReset the basket size for all sub-branches of this branch e,MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:268127,Energy Efficiency,allocate,allocated,268127,"r this branch.Definition TBranchElement.cxx:1646; TBranchElement::GetClonesNamevirtual const char * GetClonesName() constDefinition TBranchElement.h:188; TBranchElement::GetClassvirtual TClass * GetClass() constDefinition TBranchElement.h:187; TBranchElement::fMaximumInt_t fMaximumMaximum entries for a TClonesArray or variable array.Definition TBranchElement.h:80; TBranchElement::ReadLeavesMemberCountervoid ReadLeavesMemberCounter(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4611; TBranchElement::fBranchIDInt_t fBranchID! ID number assigned by a TRefTable.Definition TBranchElement.h:97; TBranchElement::FindLeafTLeaf * FindLeaf(const char *name) overrideFind the leaf corresponding to the name 'searchname'.Definition TBranchElement.cxx:1872; TBranchElement::fIteratorsTVirtualCollectionIterators * fIterators! holds the iterators when the branch is of fType==4.Definition TBranchElement.h:101; TBranchElement::ReleaseObjectvoid ReleaseObject()Delete any object we may have allocated on a previous call to SetAddress.Definition TBranchElement.cxx:4672; TBranchElement::fTargetClassTClassRef fTargetClass! Reference to the target in-memory classDefinition TBranchElement.h:91; TBranchElement::Browsevoid Browse(TBrowser *b) overrideBrowse the branch content.Definition TBranchElement.cxx:1032; TBranchElement::FillLeavesMemberBranchCountvoid FillLeavesMemberBranchCount(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1676; TBranchElement::IsFolderbool IsFolder() const overrideReturn true if more than one leaf, false otherwise.Definition TBranchElement.cxx:3758; TBranchElement::SetMissingvirtual void SetMissing()Set offset of the object (to which the data member represented by this branch belongs) inside its con...Definition TBranchElement.cxx:5611; TBranchElement::fClonesNameTString fClonesNameName of class in TClonesArray (if any)Definition TBranchElement.h:62; TBranchElement::fBranchCountTBranchElement ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:281870,Energy Efficiency,allocate,allocated,281870," GetCheckSum(ECheckSum code=kCurrentCheckSum) constCall GetCheckSum with validity check.Definition TClass.cxx:6572; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2386; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4776; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2537; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataM",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:46688,Integrability,message,message,46688,"bject).; 1319 ; 1320void TBranchElement::FillLeavesMakeClass(TBuffer& b); 1321{; 1322 ValidateAddress();; 1323 ; 1324 //; 1325 // Silently do nothing if we have no user i/o buffer.; 1326 //; 1327 ; 1328 if (!fObject) {; 1329 return;; 1330 }; 1331 ; 1332 // -- TClonesArray top-level branch. Write out number of entries, sub-branch writes the entries themselves.; 1333 if(fType == 3) {; 1334 // fClonesClass can not be zero since we are of type 3, see TBranchElement::Init; 1335 TVirtualStreamerInfo* si = fClonesClass->GetStreamerInfo();; 1336 if (!si) {; 1337 Error(""FillLeaves"", ""Cannot get streamer info for branch '%s' class '%s'"", GetName(), fClonesClass->GetName());; 1338 return;; 1339 }; 1340 b.ForceWriteInfo(si,false);; 1341 Int_t* nptr = (Int_t*) fAddress;; 1342 b << *nptr;; 1343 } else if (fType == 31) {; 1344 // -- TClonesArray sub-branch. Write out the entries in the TClonesArray.; 1345 // -- A MakeClass() tree, we must use fAddress instead of fObject.; 1346 if (!fAddress) {; 1347 // FIXME: Enable this message.; 1348 //Error(""FillLeaves"", ""Branch address not set for branch '%s'!"", GetName());; 1349 return;; 1350 }; 1351 Int_t atype = fStreamerType;; 1352 if (atype > 54) {; 1353 // Note: We are not supporting kObjectp, kAny, kObjectp,; 1354 // kObjectP, kTString, kTObject, kTNamed, kAnyp,; 1355 // kAnyP, kSTLp, kSTL, kSTLstring, kStreamer,; 1356 // kStreamLoop here, nor pointers to varying length; 1357 // arrays of them either.; 1358 // Nor do we support pointers to varying length; 1359 // arrays of kBits, kLong64, kULong64, nor kBool.; 1360 return;; 1361 }; 1362 Int_t* nn = (Int_t*) fBranchCount->GetAddress();; 1363 if (!nn) {; 1364 Error(""FillLeaves"", ""The branch counter address was zero!"");; 1365 return;; 1366 }; 1367 Int_t n = *nn;; 1368 if (atype > 40) {; 1369 // Note: We are not supporting pointer to varying length array.; 1370 Error(""FillLeaves"", ""Clonesa: %s, n=%d, sorry not supported yet"", GetName(), n);; 1371 return;; 1372 }; 1373 if (atype > 20) {; 137",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:101929,Integrability,depend,depending,101929," (element) {; 2818 expectedClass = element->GetClassPointer();; 2819 if (!expectedClass) {; 2820 TDataType* data = gROOT->GetType(element->GetTypeNameBasic());; 2821 if (!data) {; 2822 Error(""GetExpectedType"", ""Did not find the type number for %s"", element->GetTypeNameBasic());; 2823 return 1;; 2824 } else {; 2825 expectedType = (EDataType) data->GetType();; 2826 }; 2827 }; 2828 } else {; 2829 Error(""GetExpectedType"", ""Did not find the type for %s"",GetName());; 2830 return 2;; 2831 }; 2832 }; 2833 return 0;; 2834}; 2835 ; 2836////////////////////////////////////////////////////////////////////////////////; 2837/// Return the 'full' name of the branch. In particular prefix the mother's name; 2838/// when it does not end in a trailing dot and thus is not part of the branch name; 2839TString TBranchElement::GetFullName() const; 2840{; 2841 TBranchElement* mother = static_cast<TBranchElement*>(GetMother());; 2842 if (!mother || mother==this || mother->GetType() == 3 || mother->GetType() == 4) {; 2843 // The parent's name is already included in the name for split TClonesArray and STL collections; 2844 return fName;; 2845 }; 2846 ; 2847 return TBranch::GetFullName();; 2848}; 2849 ; 2850////////////////////////////////////////////////////////////////////////////////; 2851/// Return icon name depending on type of branch element.; 2852 ; 2853const char* TBranchElement::GetIconName() const; 2854{; 2855 if (IsFolder()) {; 2856 return ""TBranchElement-folder"";; 2857 } else {; 2858 return ""TBranchElement-leaf"";; 2859 }; 2860}; 2861 ; 2862////////////////////////////////////////////////////////////////////////////////; 2863/// Return whether this branch is in a mode where the object are decomposed; 2864/// or not (Also known as MakeClass mode).; 2865 ; 2866bool TBranchElement::GetMakeClass() const; 2867{; 2868 return TestBit(kDecomposedObj); // Same as TestBit(kMakeClass); 2869}; 2870 ; 2871////////////////////////////////////////////////////////////////////////////////; 2872/// Re",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:122713,Integrability,rout,routine,122713," us, so; 3383 // that we may then do a by-name lookup in the; 3384 // dictionary meta info of our parent class to; 3385 // get our offset in our parent class.; 3386 //; 3387 ; 3388 // Get our name.; 3389 TString dataName(subBranch->GetName());; 3390 if (motherDotAtEnd) {; 3391 // -- Remove the top-level branch name from our name.; 3392 dataName.Remove(0, motherName.Length());; 3393 // stlParentNameUpdated is false the first time in this loop.; 3394 if (!stlParentNameUpdated && stlParentName.Length()) {; 3395 stlParentName.Remove(0, motherName.Length());; 3396 stlParentNameUpdated = true;; 3397 }; 3398 } else if (motherDot) {; 3399 // -- Remove the top-level branch name from our name, folder case.; 3400 //; 3401 // Note: We are in the case where our mother was created; 3402 // by the branch constructor which takes a folder; 3403 // as an argument. The mother branch has internal; 3404 // dots in its name to represent the folder hierarchy.; 3405 // The TTree::Bronch() routine has handled us as a; 3406 // special case, we must compensate.; 3407 if ((fID < 0) && (subBranchElement->IsA() == TStreamerBase::Class())) {; 3408 // -- Our name is the mother name, remove it.; 3409 // Note: The test is our parent is a top-level branch; 3410 // and our streamer is the base class streamer,; 3411 // this matches the exact test in TTree::Bronch().; 3412 if (dataName.Length() == motherName.Length()) {; 3413 dataName.Remove(0, motherName.Length());; 3414 // stlParentNameUpdated is false the first time in this loop.; 3415 if (!stlParentNameUpdated && stlParentName.Length()) {; 3416 stlParentName.Remove(0, motherName.Length());; 3417 }; 3418 }; 3419 } else {; 3420 // -- Remove the mother name and the dot.; 3421 if (dataName.Length() > motherName.Length()) {; 3422 dataName.Remove(0, motherName.Length() + 1);; 3423 if (!stlParentNameUpdated && stlParentName.Length()) {; 3424 stlParentName.Remove(0, motherName.Length());; 3425 }; 3426 }; 3427 }; 3428 }; 3429 stlParentNameUpdated = true;; 34",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:125168,Integrability,rout,routine,125168,"sub-branches, so we need to; 3438 // remove it.; 3439 dataName.Remove(dataName.Length() - pattern.Length());; 3440 }; 3441 }; 3442 // Remove any leading dot.; 3443 if (dataName.Length()) {; 3444 if (dataName[0] == '.') {; 3445 dataName.Remove(0, 1);; 3446 }; 3447 }; 3448 // Note: We intentionally leave any trailing dot; 3449 // in our modified name here.; 3450 }; 3451 ; 3452 // Get our parent branch's name.; 3453 TString parentName(GetName());; 3454 if (motherDotAtEnd) {; 3455 // -- Remove the top-level branch name from our parent's name.; 3456 parentName.Remove(0, motherName.Length());; 3457 } else if (motherDot) {; 3458 // -- Remove the top-level branch name from our parent's name, folder case.; 3459 //; 3460 // Note: We are in the case where our mother was created; 3461 // by the branch constructor which takes a folder; 3462 // as an argument. The mother branch has internal; 3463 // dots in its name to represent the folder hierarchy.; 3464 // The TTree::Bronch() routine has handled us as a; 3465 // special case, we must compensate.; 3466 if ((fID > -1) && (mother == mother->GetSubBranch(this)) && (branchElem->IsA() == TStreamerBase::Class())) {; 3467 // -- Our parent's name is the mother name, remove it.; 3468 // Note: The test is our parent's parent is a top-level branch; 3469 // and our parent's streamer is the base class streamer,; 3470 // this matches the exact test in TTree::Bronch().; 3471 if (parentName.Length() == motherName.Length()) {; 3472 parentName.Remove(0, motherName.Length());; 3473 }; 3474 } else {; 3475 // -- Remove the mother name and the dot.; 3476 if (parentName.Length() > motherName.Length()) {; 3477 parentName.Remove(0, motherName.Length() + 1);; 3478 }; 3479 }; 3480 }; 3481 // FIXME: Do we need to use the other tests for a base class here?; 3482 if (fType == 1) {; 3483 // -- Our parent is a base class sub-branch, remove the base class name suffix from its name.; 3484 if (mother != mother->GetSubBranch(this)) {; 3485 // -- My parent's paren",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:135283,Integrability,rout,routines,135283,"port to the developers]."",; 3660 dataName.Data(),GetName());; 3661 }; 3662 }; 3663 localOffset = TStreamerInfo::kMissing;; 3664 }; 3665 } else {; 3666 // -- We have no data member name, ok for a base class, not good otherwise.; 3667 if (isBaseSubBranch) {; 3668 // I am a direct base class of my parent class, my local offset is enough.; 3669 } else {; 3670 Warning(""InitializeOffsets"", ""Could not find the data member name for branch '%s' with parent branch '%s', assuming offset is zero!"", subBranch->GetName(), GetName());; 3671 }; 3672 }; 3673 ; 3674 //; 3675 // Ok, do final calculations for fOffset and fBranchOffset.; 3676 //; 3677 ; 3678 if (isContDataMember) {; 3679 // -- Container data members set fOffset instead of fBranchOffset.; 3680 // The fOffset is what should be added to the start of the entry; 3681 // in the collection (i.e., its current absolute address) to find; 3682 // the beginning of the data member described by the current branch.; 3683 //; 3684 // Compensate for the i/o routines adding our local offset later.; 3685 if (subBranch->fObject == nullptr && localOffset == TStreamerInfo::kMissing) {; 3686 subBranch->SetMissing();; 3687 // We stil need to set fBranchOffset in the case of a missing; 3688 // element so that SetAddress is (as expected) not called; 3689 // recursively in this case.; 3690 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3691 } else {; 3692 if (isBaseSubBranch) {; 3693 // The value of 'offset' for a base class does not include its; 3694 // 'localOffset'.; 3695 subBranch->SetOffset(offset);; 3696 } else {; 3697 // The value of 'offset' for a regular data member does include its; 3698 // 'localOffset', we need to remove it explicitly.; 3699 subBranch->SetOffset(offset - localOffset);; 3700 }; 3701 }; 3702 } else {; 3703 // -- Set fBranchOffset for sub-branch.; 3704 Int_t isSplit = 0 != subBranch->GetListOfBranches()->GetEntriesFast();; 3705 if (subBranch->fObject == nullptr && localOffset == TStreamerInfo::kMissing) {; 3706 /",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:136950,Integrability,rout,routines,136950,"/ The value of 'offset' for a regular data member does include its; 3698 // 'localOffset', we need to remove it explicitly.; 3699 subBranch->SetOffset(offset - localOffset);; 3700 }; 3701 }; 3702 } else {; 3703 // -- Set fBranchOffset for sub-branch.; 3704 Int_t isSplit = 0 != subBranch->GetListOfBranches()->GetEntriesFast();; 3705 if (subBranch->fObject == nullptr && localOffset == TStreamerInfo::kMissing) {; 3706 // The branch is missing; 3707 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3708 ; 3709 } else if (isSplit) {; 3710 if (isBaseSubBranch) {; 3711 // We are split, so we need to add in our local offset; 3712 // to get our absolute address for our children.; 3713 fBranchOffset[subBranchIdx] = offset + localOffset;; 3714 } else {; 3715 // We are split so our offset will never be; 3716 // used in an i/o, so we do not have to subtract; 3717 // off our local offset like below.; 3718 fBranchOffset[subBranchIdx] = offset;; 3719 }; 3720 } else {; 3721 if (isBaseSubBranch) {; 3722 // We are not split, so our local offset will be; 3723 // added later by the i/o routines.; 3724 fBranchOffset[subBranchIdx] = offset;; 3725 } else {; 3726 // Compensate for the fact that the i/o routines; 3727 // are going to add my local offset later.; 3728 fBranchOffset[subBranchIdx] = offset - localOffset;; 3729 }; 3730 }; 3731 }; 3732 }; 3733 }; 3734 else {; 3735 if (fID > -1) {; 3736 // Branch is *not* a top-level branch.; 3737 // Let's check if the target member is still present in memory; 3738 if (GetOffset() == TStreamerInfo::kMissing) {; 3739 fObject = nullptr;; 3740 }; 3741 }; 3742 }; 3743 const bool isSplitNode = (fType == 2 || fType == 1 || (fType == 0 && fID == -2)) && !fBranches.IsEmpty();; 3744 if (fReadActionSequence && isSplitNode) {; 3745 TBranchElement *parent = dynamic_cast<TBranchElement*>(GetMother()->GetSubBranch(this));; 3746 auto index = parent->fBranches.IndexOf(this);; 3747 if (index >= 0) {; 3748 fReadActionSequence->AddToOffset( - parent->fBranchOffs",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:137065,Integrability,rout,routines,137065,"0 }; 3701 }; 3702 } else {; 3703 // -- Set fBranchOffset for sub-branch.; 3704 Int_t isSplit = 0 != subBranch->GetListOfBranches()->GetEntriesFast();; 3705 if (subBranch->fObject == nullptr && localOffset == TStreamerInfo::kMissing) {; 3706 // The branch is missing; 3707 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3708 ; 3709 } else if (isSplit) {; 3710 if (isBaseSubBranch) {; 3711 // We are split, so we need to add in our local offset; 3712 // to get our absolute address for our children.; 3713 fBranchOffset[subBranchIdx] = offset + localOffset;; 3714 } else {; 3715 // We are split so our offset will never be; 3716 // used in an i/o, so we do not have to subtract; 3717 // off our local offset like below.; 3718 fBranchOffset[subBranchIdx] = offset;; 3719 }; 3720 } else {; 3721 if (isBaseSubBranch) {; 3722 // We are not split, so our local offset will be; 3723 // added later by the i/o routines.; 3724 fBranchOffset[subBranchIdx] = offset;; 3725 } else {; 3726 // Compensate for the fact that the i/o routines; 3727 // are going to add my local offset later.; 3728 fBranchOffset[subBranchIdx] = offset - localOffset;; 3729 }; 3730 }; 3731 }; 3732 }; 3733 }; 3734 else {; 3735 if (fID > -1) {; 3736 // Branch is *not* a top-level branch.; 3737 // Let's check if the target member is still present in memory; 3738 if (GetOffset() == TStreamerInfo::kMissing) {; 3739 fObject = nullptr;; 3740 }; 3741 }; 3742 }; 3743 const bool isSplitNode = (fType == 2 || fType == 1 || (fType == 0 && fID == -2)) && !fBranches.IsEmpty();; 3744 if (fReadActionSequence && isSplitNode) {; 3745 TBranchElement *parent = dynamic_cast<TBranchElement*>(GetMother()->GetSubBranch(this));; 3746 auto index = parent->fBranches.IndexOf(this);; 3747 if (index >= 0) {; 3748 fReadActionSequence->AddToOffset( - parent->fBranchOffset[index] );; 3749 }; 3750 }; 3751 ; 3752 fInitOffsets = true;; 3753}; 3754 ; 3755////////////////////////////////////////////////////////////////////////////////; 3756/// Return",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:159976,Integrability,message,message,159976,"300 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4301 TVirtualCollectionProxy::TPushPop helper(proxy, fObject);; 4302 void* alternate = proxy->Allocate(fNdata, true);; 4303 if(fSTLtype != ROOT::kSTLvector && proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ) {; 4304 fPtrIterators->CreateIterators(alternate, proxy);; 4305 } else {; 4306 fIterators->CreateIterators(alternate, proxy);; 4307 }; 4308 ; 4309 Int_t nbranches = fBranches.GetEntriesFast();; 4310 switch (fSTLtype) {; 4311 case ROOT::kSTLset:; 4312 case ROOT::kSTLunorderedset:; 4313 case ROOT::kSTLunorderedmultiset:; 4314 case ROOT::kSTLmultiset:; 4315 case ROOT::kSTLmap:; 4316 case ROOT::kSTLmultimap:; 4317 case ROOT::kSTLunorderedmap:; 4318 case ROOT::kSTLunorderedmultimap:; 4319 for (Int_t i = 0; i < nbranches; ++i) {; 4320 TBranch *branch = (TBranch*) fBranches[i];; 4321 Int_t nb = branch->GetEntry(GetReadEntry(), 1);; 4322 if (nb < 0) {; 4323 // Give up on i/o failure.; 4324 // FIXME: We need an error message here.; 4325 break;; 4326 }; 4327 }; 4328 break;; 4329 default:; 4330 break;; 4331 }; 4332 //------------------------------------------------------------------------; 4333 // We have split this stuff, so we need to create the pointers; 4334 /////////////////////////////////////////////////////////////////////////////; 4335 ; 4336 if( proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ); 4337 {; 4338 TClass *elClass = proxy->GetValueClass();; 4339 ; 4340 //--------------------------------------------------------------------; 4341 // The allocation is done in this strange way because ReadLeaves; 4342 // is being called many times by TTreeFormula!!!; 4343 //////////////////////////////////////////////////////////////////////////; 4344 ; 4345 Int_t i = 0;; 4346 // coverity[returned_null] the fNdata is check enough to prevent the use of null value of At(0); 4347 if( !fNdata || *(void**)proxy->At( 0 ) != nullptr ); 4348 i = fNdata;; 4349 ; 4350 for( ; i ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:178046,Integrability,interface,interface,178046," 4780void TBranchElement::ResetAddress(); 4781{; 4782 for (Int_t i = 0; i < fNleaves; ++i) {; 4783 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4784 //if (leaf) leaf->SetAddress(0);; 4785 leaf->SetAddress(nullptr);; 4786 }; 4787 ; 4788 // Note: We *must* do the sub-branches first, otherwise; 4789 // we may delete the object containing the sub-branches; 4790 // before giving them a chance to cleanup.; 4791 Int_t nbranches = fBranches.GetEntriesFast();; 4792 for (Int_t i = 0; i < nbranches; ++i) {; 4793 TBranch* br = (TBranch*) fBranches[i];; 4794 if (br) br->ResetAddress();; 4795 }; 4796 ; 4797 //; 4798 // SetAddress may have allocated an object.; 4799 //; 4800 ; 4801 ReleaseObject();; 4802 ; 4803 ResetBit(kAddressSet);; 4804 fAddress = nullptr;; 4805 fObject = nullptr;; 4806}; 4807 ; 4808////////////////////////////////////////////////////////////////////////////////; 4809/// Release ownership of any allocated objects.; 4810///; 4811/// Note: This interface was added so that clone trees could; 4812/// be told they do not own the allocated objects.; 4813 ; 4814void TBranchElement::ResetDeleteObject(); 4815{; 4816 ResetBit(kDeleteObject);; 4817 Int_t nb = fBranches.GetEntriesFast();; 4818 for (Int_t i = 0; i < nb; ++i) {; 4819 TBranch* br = (TBranch*) fBranches[i];; 4820 if (br->InheritsFrom(TBranchElement::Class())) {; 4821 ((TBranchElement*) br)->ResetDeleteObject();; 4822 }; 4823 }; 4824}; 4825 ; 4826////////////////////////////////////////////////////////////////////////////////; 4827/// \brief Reset offset and StreamerInfo information from this branch.; 4828/// \param[in] recurse When true call ResetInitInfo on all subbranches.; 4829///; 4830 ; 4831void TBranchElement::ResetInitInfo(bool recurse); 4832{; 4833 fInfo = nullptr;; 4834 fInit = false;; 4835 fInitOffsets = false;; 4836 fCurrentClass = nullptr;; 4837 delete fReadActionSequence;; 4838 fReadActionSequence = nullptr;; 4839 delete fFillActionSequence;; 4840 fFillActionSequence = nullptr;; 4841 ; 4842 if (",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:181210,Integrability,rout,routines,181210,"1/// If addr is not zero, but the pointer addr points at is; 4872/// zero, then we allocate a branch object and set the passed; 4873/// pointer to point at the allocated object. The caller; 4874/// owns the allocated object and is responsible for deleting; 4875/// it when it is no longer needed.; 4876///; 4877/// Example:; 4878/// ~~~ {.cpp}; 4879/// Event* event = 0;; 4880/// branch->SetAddress(&event);; 4881/// ... Do some work.; 4882/// delete event;; 4883/// event = 0;; 4884/// ~~~; 4885/// If addr is not zero and the pointer addr points at is; 4886/// also not zero, then the caller has allocated a branch; 4887/// object and is asking us to use it. The caller owns it; 4888/// and must delete it when it is no longer needed.; 4889///; 4890/// Example:; 4891/// ~~~ {.cpp}; 4892/// Event* event = new Event();; 4893/// branch->SetAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well because those routines call this one.; 4901///; 4902/// An example of a tree with branches with objects allocated; 4903/// and owned by us:; 4904/// ~~~ {.cpp}; 4905/// TFile* f1 = new TFile(""myfile_original.root"");; 4906/// TTree* t1 = (TTree*) f->Get(""MyTree"");; 4907/// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; 4908/// TTree* t2 = t1->Clone(0);; 4909/// for (Int_t i = 0; i < 10; ++i) {; 4910/// t1->GetEntry(i);; 4911/// t2->Fill();; 4912/// }; 4913/// t2->Write(); 4914/// delete f2;; 4915/// f2 = 0;; 4916/// delete f1;; 4917/// f1 = 0;; 4918/// ~~~; 4919/// An example of a branch with an object allocated by us,; 4920/// but owned by the caller:; 4921/// ~~~ {.cpp}; 4922/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4923/// TTree* t = new TTree(""t"", ""A test tree.""); 4924/// Event* event = 0;; 4925/// TBranchElement* br = t->Branch(""event."", &event);; 4926/// for (Int_t i = 0; i < 10; ++",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:185522,Integrability,message,message,185522,"OfBranch = fTargetClass;; 5014 }; 5015 ; 5016 //; 5017 // Try to build the streamer info.; 5018 //; 5019 ; 5020 TStreamerInfo *info = GetInfoImp();; 5021 ; 5022 // FIXME: Warn about failure to get the streamer info here?; 5023 ; 5024 //; 5025 // We may have allocated an object last time we were called.; 5026 //; 5027 ; 5028 if (fObject && TestBit(kDeleteObject)){; 5029 ReleaseObject();; 5030 }; 5031 ; 5032 //; 5033 // Remember the pointer to the pointer to our object.; 5034 //; 5035 ; 5036 fAddress = (char*) addr;; 5037 if (fAddress != (char*)(&fObject)) {; 5038 fObject = nullptr;; 5039 }; 5040 ResetBit(kDeleteObject);; 5041 SetBit(kAddressSet);; 5042 ; 5043 //; 5044 // Do special stuff if we got called from a MakeClass class.; 5045 // Allow sub-branches to have independently set addresses.; 5046 //; 5047 ; 5048 if (TestBit(kDecomposedObj)) {; 5049 if (fID > -1) {; 5050 // We are *not* a top-level branch.; 5051 if (!info) {; 5052 // No streamer info, give up.; 5053 // FIXME: We should have an error message here.; 5054 fObject = fAddress;; 5055 } else {; 5056 // Compensate for the fact that the i/o routines; 5057 // will add the streamer offset to the address.; 5058 fObject = fAddress - info->TStreamerInfo::GetElementOffset(fID);; 5059 }; 5060 return;; 5061 }; 5062 }; 5063 ; 5064 //; 5065 // Check whether the container type is still the same; 5066 // to support schema evolution; what is written on the file; 5067 // may no longer match the class code which is loaded.; 5068 //; 5069 ; 5070 if (fType == 3) {; 5071 // split TClonesArray, counter/master branch.; 5072 TClass* clm = fClonesClass;; 5073 if (clm) {; 5074 // In case clm derives from an abstract class.; 5075 clm->BuildRealData();; 5076 clm->GetStreamerInfo();; 5077 }; 5078 TClass* newType = GetCurrentClass();; 5079 if (newType && (newType != TClonesArray::Class())) {; 5080 // The data type of the container has changed.; 5081 //; 5082 // Let's check if it is a compatible type:; 5083 bool matched = false;; 5084 i",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:185623,Integrability,rout,routines,185623,"19 ; 5020 TStreamerInfo *info = GetInfoImp();; 5021 ; 5022 // FIXME: Warn about failure to get the streamer info here?; 5023 ; 5024 //; 5025 // We may have allocated an object last time we were called.; 5026 //; 5027 ; 5028 if (fObject && TestBit(kDeleteObject)){; 5029 ReleaseObject();; 5030 }; 5031 ; 5032 //; 5033 // Remember the pointer to the pointer to our object.; 5034 //; 5035 ; 5036 fAddress = (char*) addr;; 5037 if (fAddress != (char*)(&fObject)) {; 5038 fObject = nullptr;; 5039 }; 5040 ResetBit(kDeleteObject);; 5041 SetBit(kAddressSet);; 5042 ; 5043 //; 5044 // Do special stuff if we got called from a MakeClass class.; 5045 // Allow sub-branches to have independently set addresses.; 5046 //; 5047 ; 5048 if (TestBit(kDecomposedObj)) {; 5049 if (fID > -1) {; 5050 // We are *not* a top-level branch.; 5051 if (!info) {; 5052 // No streamer info, give up.; 5053 // FIXME: We should have an error message here.; 5054 fObject = fAddress;; 5055 } else {; 5056 // Compensate for the fact that the i/o routines; 5057 // will add the streamer offset to the address.; 5058 fObject = fAddress - info->TStreamerInfo::GetElementOffset(fID);; 5059 }; 5060 return;; 5061 }; 5062 }; 5063 ; 5064 //; 5065 // Check whether the container type is still the same; 5066 // to support schema evolution; what is written on the file; 5067 // may no longer match the class code which is loaded.; 5068 //; 5069 ; 5070 if (fType == 3) {; 5071 // split TClonesArray, counter/master branch.; 5072 TClass* clm = fClonesClass;; 5073 if (clm) {; 5074 // In case clm derives from an abstract class.; 5075 clm->BuildRealData();; 5076 clm->GetStreamerInfo();; 5077 }; 5078 TClass* newType = GetCurrentClass();; 5079 if (newType && (newType != TClonesArray::Class())) {; 5080 // The data type of the container has changed.; 5081 //; 5082 // Let's check if it is a compatible type:; 5083 bool matched = false;; 5084 if (newType->GetCollectionProxy()) {; 5085 TClass *content = newType->GetCollectionProxy()->GetValueCla",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:203462,Integrability,message,message,203462,"onProxy();; 5446 // We are not at top-level branch.; 5447 fObject = fAddress;; 5448 } else if (fID < 0) {; 5449 // -- We are a top-level branch.; 5450 char** pp = (char**) fAddress;; 5451 if (pp && *pp) {; 5452 // -- Caller provided an i/o buffer for us to use.; 5453 fObject = *pp;; 5454 } else {; 5455 // -- Caller did not provide an i/o buffer for us to use, we must make one for ourselves.; 5456 if (clOfBranch) {; 5457 if (!pp) {; 5458 // -- Caller wants us to own the object.; 5459 SetBit(kDeleteObject);; 5460 }; 5461 fObject = (char*) clOfBranch->New();; 5462 if (pp) {; 5463 *pp = fObject;; 5464 } else {; 5465 fAddress = (char*) &fObject;; 5466 }; 5467 } else {; 5468 Error(""SetAddress"", ""I have no TClass for branch %s, so I cannot allocate an I/O buffer!"", GetName());; 5469 if (pp) {; 5470 fObject = nullptr;; 5471 *pp = nullptr;; 5472 }; 5473 }; 5474 }; 5475 } else {; 5476 // -- We are *not* a top-level branch.; 5477 fObject = fAddress;; 5478 }; 5479 ; 5480 if (!info) {; 5481 // FIXME: We need and error message here, no streamer info, so cannot set offsets.; 5482 return;; 5483 }; 5484 ; 5485 // We do this only once because it depends only on; 5486 // the type of our object, not on its address.; 5487 if (!fInitOffsets) {; 5488 InitializeOffsets();; 5489 }; 5490 ; 5491 // We are split, recurse down to our sub-branches.; 5492 //; 5493 // FIXME: This is a tail recursion, we burn stack.; 5494 Int_t nbranches = fBranches.GetEntriesFast();; 5495 for (Int_t i = 0; i < nbranches; ++i) {; 5496 TBranch *abranch = (TBranch*) fBranches.UncheckedAt(i);; 5497 // FIXME: This is a tail recursion!; 5498 if (fBranchOffset[i] != TStreamerInfo::kMissing && !(implied && abranch->TestBit(kAddressSet))) {; 5499 abranch->SetAddressImpl(fObject + fBranchOffset[i], implied);; 5500 abranch->SetBit(kAddressSet);; 5501 if (TestBit(kDecomposedObj) != abranch->TestBit(kDecomposedObj)); 5502 abranch->SetMakeClass(TestBit(kDecomposedObj));; 5503 } else {; 5504 // When the member is missing, just le",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:203587,Integrability,depend,depends,203587,"; 5450 char** pp = (char**) fAddress;; 5451 if (pp && *pp) {; 5452 // -- Caller provided an i/o buffer for us to use.; 5453 fObject = *pp;; 5454 } else {; 5455 // -- Caller did not provide an i/o buffer for us to use, we must make one for ourselves.; 5456 if (clOfBranch) {; 5457 if (!pp) {; 5458 // -- Caller wants us to own the object.; 5459 SetBit(kDeleteObject);; 5460 }; 5461 fObject = (char*) clOfBranch->New();; 5462 if (pp) {; 5463 *pp = fObject;; 5464 } else {; 5465 fAddress = (char*) &fObject;; 5466 }; 5467 } else {; 5468 Error(""SetAddress"", ""I have no TClass for branch %s, so I cannot allocate an I/O buffer!"", GetName());; 5469 if (pp) {; 5470 fObject = nullptr;; 5471 *pp = nullptr;; 5472 }; 5473 }; 5474 }; 5475 } else {; 5476 // -- We are *not* a top-level branch.; 5477 fObject = fAddress;; 5478 }; 5479 ; 5480 if (!info) {; 5481 // FIXME: We need and error message here, no streamer info, so cannot set offsets.; 5482 return;; 5483 }; 5484 ; 5485 // We do this only once because it depends only on; 5486 // the type of our object, not on its address.; 5487 if (!fInitOffsets) {; 5488 InitializeOffsets();; 5489 }; 5490 ; 5491 // We are split, recurse down to our sub-branches.; 5492 //; 5493 // FIXME: This is a tail recursion, we burn stack.; 5494 Int_t nbranches = fBranches.GetEntriesFast();; 5495 for (Int_t i = 0; i < nbranches; ++i) {; 5496 TBranch *abranch = (TBranch*) fBranches.UncheckedAt(i);; 5497 // FIXME: This is a tail recursion!; 5498 if (fBranchOffset[i] != TStreamerInfo::kMissing && !(implied && abranch->TestBit(kAddressSet))) {; 5499 abranch->SetAddressImpl(fObject + fBranchOffset[i], implied);; 5500 abranch->SetBit(kAddressSet);; 5501 if (TestBit(kDecomposedObj) != abranch->TestBit(kDecomposedObj)); 5502 abranch->SetMakeClass(TestBit(kDecomposedObj));; 5503 } else {; 5504 // When the member is missing, just leave the address alone; 5505 // (since setting explicitly to 0 would trigger error/warning; 5506 // messages).; 5507 // abranch->SetAddress(0);; ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:204541,Integrability,message,messages,204541,"p = nullptr;; 5472 }; 5473 }; 5474 }; 5475 } else {; 5476 // -- We are *not* a top-level branch.; 5477 fObject = fAddress;; 5478 }; 5479 ; 5480 if (!info) {; 5481 // FIXME: We need and error message here, no streamer info, so cannot set offsets.; 5482 return;; 5483 }; 5484 ; 5485 // We do this only once because it depends only on; 5486 // the type of our object, not on its address.; 5487 if (!fInitOffsets) {; 5488 InitializeOffsets();; 5489 }; 5490 ; 5491 // We are split, recurse down to our sub-branches.; 5492 //; 5493 // FIXME: This is a tail recursion, we burn stack.; 5494 Int_t nbranches = fBranches.GetEntriesFast();; 5495 for (Int_t i = 0; i < nbranches; ++i) {; 5496 TBranch *abranch = (TBranch*) fBranches.UncheckedAt(i);; 5497 // FIXME: This is a tail recursion!; 5498 if (fBranchOffset[i] != TStreamerInfo::kMissing && !(implied && abranch->TestBit(kAddressSet))) {; 5499 abranch->SetAddressImpl(fObject + fBranchOffset[i], implied);; 5500 abranch->SetBit(kAddressSet);; 5501 if (TestBit(kDecomposedObj) != abranch->TestBit(kDecomposedObj)); 5502 abranch->SetMakeClass(TestBit(kDecomposedObj));; 5503 } else {; 5504 // When the member is missing, just leave the address alone; 5505 // (since setting explicitly to 0 would trigger error/warning; 5506 // messages).; 5507 // abranch->SetAddress(0);; 5508 abranch->SetBit(kAddressSet);; 5509 }; 5510 }; 5511}; 5512 ; 5513////////////////////////////////////////////////////////////////////////////////; 5514/// Reset the basket size for all sub-branches of this branch element.; 5515 ; 5516void TBranchElement::SetBasketSize(Int_t buffsize); 5517{; 5518 TBranch::SetBasketSize(buffsize);; 5519 Int_t nbranches = fBranches.GetEntriesFast();; 5520 for (Int_t i = 0; i < nbranches; ++i) {; 5521 TBranch* branch = (TBranch*) fBranches[i];; 5522 branch->SetBasketSize(fBasketSize);; 5523 }; 5524}; 5525 ; 5526////////////////////////////////////////////////////////////////////////////////; 5527/// Set the branch counter for this branch.; 55",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:270489,Integrability,depend,depending,270489,"rsionVersion number of class.Definition TBranchElement.h:65; TBranchElement::fPtrIteratorsTVirtualCollectionPtrIterators * fPtrIterators! holds the iterators when the branch is of fType==4 and it is a split collection of pointers.Definition TBranchElement.h:103; TBranchElement::FindBranchTBranch * FindBranch(const char *name) overrideFind the immediate sub-branch with passed name.Definition TBranchElement.cxx:1787; TBranchElement::Streamervoid Streamer(TBuffer &) overrideStream an object of class TBranchElement.Definition TBranchElement.cxx:5964; TBranchElement::InitInfovirtual void InitInfo()Init the streamer info for the branch class, try to compensate for class code unload/reload and schem...Definition TBranchElement.cxx:2209; TBranchElement::InitializeOffsetsvirtual void InitializeOffsets()Initialize the base class subobjects offsets of our sub-branches and set fOffset if we are a containe...Definition TBranchElement.cxx:3137; TBranchElement::GetIconNameconst char * GetIconName() const overrideReturn icon name depending on type of branch element.Definition TBranchElement.cxx:2853; TBranchElement::GetParentClassTClass * GetParentClass()Return a pointer to the parent class of the branch element.Definition TBranchElement.cxx:2894; TBranchElement::GetNdataInt_t GetNdata() constDefinition TBranchElement.h:202; TBranchElement::GetExpectedTypeInt_t GetExpectedType(TClass *&clptr, EDataType &type) overrideFill expectedClass and expectedType with information on the data type of the object/values contained ...Definition TBranchElement.cxx:2804; TBranchElement::fInitbool fInit! Initialization flag for branch assignmentDefinition TBranchElement.h:88; TBranchElement::fCollProxyTVirtualCollectionProxy * fCollProxy! collection interface (if any)Definition TBranchElement.h:63; TBranchElement::SetFillActionSequencevoid SetFillActionSequence()Set the sequence of actions needed to write the data out from the buffer.Definition TBranchElement.cxx:5763; TBranchElement::SetObjectvoid S",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:271205,Integrability,interface,interface,271205,"nt.cxx:2209; TBranchElement::InitializeOffsetsvirtual void InitializeOffsets()Initialize the base class subobjects offsets of our sub-branches and set fOffset if we are a containe...Definition TBranchElement.cxx:3137; TBranchElement::GetIconNameconst char * GetIconName() const overrideReturn icon name depending on type of branch element.Definition TBranchElement.cxx:2853; TBranchElement::GetParentClassTClass * GetParentClass()Return a pointer to the parent class of the branch element.Definition TBranchElement.cxx:2894; TBranchElement::GetNdataInt_t GetNdata() constDefinition TBranchElement.h:202; TBranchElement::GetExpectedTypeInt_t GetExpectedType(TClass *&clptr, EDataType &type) overrideFill expectedClass and expectedType with information on the data type of the object/values contained ...Definition TBranchElement.cxx:2804; TBranchElement::fInitbool fInit! Initialization flag for branch assignmentDefinition TBranchElement.h:88; TBranchElement::fCollProxyTVirtualCollectionProxy * fCollProxy! collection interface (if any)Definition TBranchElement.h:63; TBranchElement::SetFillActionSequencevoid SetFillActionSequence()Set the sequence of actions needed to write the data out from the buffer.Definition TBranchElement.cxx:5763; TBranchElement::SetObjectvoid SetObject(void *objadd) overrideSet object this branch is pointing to.Definition TBranchElement.cxx:5575; TBranchElement::fStreamerTypeInt_t fStreamerTypebranch streamer typeDefinition TBranchElement.h:79; TBranchElement::ReadLeavesCollectionSplitVectorPtrMembervoid ReadLeavesCollectionSplitVectorPtrMember(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4398; TBranchElement::GetMakeClassbool GetMakeClass() const overrideReturn whether this branch is in a mode where the object are decomposed or not (Also known as MakeCla...Definition TBranchElement.cxx:2866; TBranchElement::SetAddressImplvoid SetAddressImpl(void *addr, bool implied) overrideSee TBranchElement::SetAddress.Definition ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:290357,Integrability,message,message,290357,"rray.cxx:605; TObjArray::GetObjectRefTObject ** GetObjectRef() constDefinition TObjArray.h:63; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::IsEmptyBool_t IsEmpty() const overrideDefinition TObjArray.h:65; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TClonesArrayfriend class TClonesArrayDefinition TObject.h:240; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Inf",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:291034,Integrability,message,message,291034,"ay.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TClonesArrayfriend class TClonesArrayDefinition TObject.h:240; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TStreamerArtificial::Classstatic TClass * Class(); TStreamerBase::Classstatic TClass * Class(); TStreamerBasicPointerDefinition TStreamerElement.h:198; TStreamerBasicPointer::Classstatic TClass * Class(); TStreamerBasicPointer::GetCountNameconst char * GetCountName() constDefinition TStreamerElement.h:",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:291170,Integrability,message,message,291170,"h:240; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TStreamerArtificial::Classstatic TClass * Class(); TStreamerBase::Classstatic TClass * Class(); TStreamerBasicPointerDefinition TStreamerElement.h:198; TStreamerBasicPointer::Classstatic TClass * Class(); TStreamerBasicPointer::GetCountNameconst char * GetCountName() constDefinition TStreamerElement.h:218; TStreamerElementDefinition TStreamerElement.h:32; TStreamerElement::GetNewTypeInt_t GetNewType() constDefinition TStreamerElemen",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:291430,Integrability,message,message,291430,"ct * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TStreamerArtificial::Classstatic TClass * Class(); TStreamerBase::Classstatic TClass * Class(); TStreamerBasicPointerDefinition TStreamerElement.h:198; TStreamerBasicPointer::Classstatic TClass * Class(); TStreamerBasicPointer::GetCountNameconst char * GetCountName() constDefinition TStreamerElement.h:218; TStreamerElementDefinition TStreamerElement.h:32; TStreamerElement::GetNewTypeInt_t GetNewType() constDefinition TStreamerElement.h:116; TStreamerElement::GetTypeInt_t GetType() constDefinition TStreamerElement.h:118; TStreamerElement::GetFullNamevirtual const char * GetFullName() constReturn element name including dimensions, if any Note that this function stores the name into a stati...",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:304957,Integrability,interface,interface,304957,"bject and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualArray::GetObjectAtchar * GetObjectAt(UInt_t ind) constDefinition TVirtualArray.h:41; TVirtualArray::SetSizevoid SetSize(UInt_t size)Definition TVirtualArray.h:43; TVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators.Definition TVirtualCollectionIterators.h:26; TVirtualCollectionIterators::CreateIteratorsvoid CreateIterators(void *collection, TVirtualCollectionProxy *proxy)Definition TVirtualCollectionIterators.h:65; TVirtualCollectionIterators::fBeginvoid * fBeginDefinition TVirtualCollectionIterators.h:41; TVirtualCollectionIterators::fEndvoid * fEndDefinition TVirtualCollectionIterators.h:42; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::Destructorvirtual void Destructor(void *p, Bool_t dtorOnly=kFALSE) constExecute the container destructor.Definition TVirtualCollectionProxy.h:144; TVirtualCollectionProxy::GetTypevirtual EDataType GetType() const =0If the value type is a fundamental data type, return its type (see enumeration EDataType).; TVirtualCollectionProxy::kNeedDelete@ kNeedDeleteThe collection contains directly or indirectly (via other collection) some pointers that need explici...Definition TVirtualCollectionProxy.h:70; TVirtualCollectionProxy::kIsAssociative@ kIsAssociativeDefinition TVirtualCollectionProxy.h:66; TVirtualCollectionProxy::Clearvirtual void Clear(const char *opt="""")=0Clea",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:12706,Modifiability,inherit,inherits,12706,"ass()) {; 364 bool hasCustomStreamer = false;; 365 bool canSelfReference = CanSelfReference(fBranchClass);; 366 if (fBranchClass.GetClass()->IsTObject()) {; 367 if (canSelfReference) SetBit(kBranchObject);; 368 hasCustomStreamer = (!fBranchClass.GetClass()->GetCollectionProxy() && fBranchClass.GetClass()->HasCustomStreamerMember());; 369 } else {; 370 if (canSelfReference) SetBit(kBranchAny);; 371 hasCustomStreamer = !fBranchClass.GetClass()->GetCollectionProxy() && (fBranchClass.GetClass()->GetStreamer() != nullptr || fBranchClass.GetClass()->HasCustomStreamerMember());; 372 }; 373 if (hasCustomStreamer) {; 374 fType = -1;; 375 }; 376 }; 377 } else {; 378 // -- We are a sub-branch of a split object.; 379 TStreamerElement* element = sinfo->GetElement(id);; 380 if ((fStreamerType == TVirtualStreamerInfo::kObject) || (fStreamerType == TVirtualStreamerInfo::kBase) || (fStreamerType == TVirtualStreamerInfo::kTNamed) || (fStreamerType == TVirtualStreamerInfo::kTObject) || (fStreamerType == TVirtualStreamerInfo::kObjectp) || (fStreamerType == TVirtualStreamerInfo::kObjectP)) {; 381 // -- If we are an object data member which inherits from TObject,; 382 // flag it so that later during i/o we will register the object; 383 // with the buffer so that pointers are handled correctly.; 384 if (CanSelfReference(fBranchClass)) {; 385 if (fBranchClass.GetClass()->IsTObject()) {; 386 SetBit(kBranchObject);; 387 } else {; 388 SetBit(kBranchAny);; 389 }; 390 }; 391 }; 392 if (element->IsA() == TStreamerBasicPointer::Class()) {; 393 // -- Fixup title with counter if we are a varying length array data member.; 394 TStreamerBasicPointer *bp = (TStreamerBasicPointer *)element;; 395 TString countname;; 396 countname = bname;; 397 Ssiz_t dot = countname.Last('.');; 398 if (dot>=0) {; 399 countname.Remove(dot+1);; 400 } else {; 401 countname = """";; 402 }; 403 countname += bp->GetCountName();; 404 brOfCounter = (TBranchElement *)fTree->GetBranch(countname);; 405 countname.Form(""%s[%s]"",name.Da",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:20920,Modifiability,extend,extending,20920,";; 558 } else if (((fSTLtype >= ROOT::kSTLvector) && (fSTLtype < ROOT::kSTLend)) || ((fSTLtype > -ROOT::kSTLend) && (fSTLtype <= -ROOT::kSTLvector))) {; 559 // -- We are an STL container element.; 560 TClass* contCl = elementClass;; 561 fCollProxy = contCl->GetCollectionProxy()->Generate();; 562 TClass* valueClass = GetCollectionProxy()->GetValueClass();; 563 // Check to see if we can split the container.; 564 bool cansplit = true;; 565 if (!valueClass) {; 566 cansplit = false;; 567 } else if ((valueClass == TString::Class()) || (valueClass == TClass::GetClass(""string""))) {; 568 cansplit = false;; 569 } else if (GetCollectionProxy()->HasPointers() && !splitSTLP ) {; 570 cansplit = false;; 571 } else if (!valueClass->CanSplit() && !(GetCollectionProxy()->HasPointers() && splitSTLP)) {; 572 cansplit = false;; 573 } else if (valueClass->GetCollectionProxy()) {; 574 // -- A collection was stored in a collection, we choose not to split it.; 575 // Note: Splitting it would require extending TTreeFormula; 576 // to understand how to access it.; 577 cansplit = false;; 578 }; 579 if (cansplit) {; 580 // -- Do the splitting work if we are allowed to.; 581 fType = 4;; 582 // Create a leaf for the master branch (the counter).; 583 TLeaf *leaf = new TLeafElement(this, name, fID, fStreamerType);; 584 fNleaves = 1;; 585 fLeaves.Add(leaf);; 586 fTree->GetListOfLeaves()->Add(leaf);; 587 // Check that the contained objects class name is part of the element title.; 588 // This name is mandatory when reading the tree later on and; 589 // the parent class with the pointer to the STL container is not available.; 590 fClonesName = valueClass->GetName();; 591 fClonesClass = valueClass;; 592 TString aname;; 593 aname.Form("" (%s)"", valueClass->GetName());; 594 TString atitle = element->GetTitle();; 595 if (!atitle.Contains(aname)) {; 596 atitle += aname;; 597 element->SetTitle(atitle.Data());; 598 }; 599 TString branchname (name);; 600 if (branchname.EndsWith(""."")); 601 branchname.Remove(bra",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:43781,Modifiability,extend,extended,43781,"he function returns the number of bytes committed to the; 1223/// individual branches. If a write error occurs, the number of; 1224/// bytes returned is -1. If no data are written, because, e.g.,; 1225/// the branch is disabled, the number of bytes returned is 0.; 1226///; 1227/// Note: We not not use any member functions from TLeafElement!; 1228 ; 1229Int_t TBranchElement::FillImpl(ROOT::Internal::TBranchIMTHelper *imtHelper); 1230{; 1231 Int_t nbytes = 0;; 1232 Int_t nwrite = 0;; 1233 Int_t nerror = 0;; 1234 Int_t nbranches = fBranches.GetEntriesFast();; 1235 ; 1236 ValidateAddress();; 1237 ; 1238 //; 1239 // If we are a top-level branch, update addresses.; 1240 //; 1241 ; 1242 if (fID < 0) {; 1243 if (!fObject) {; 1244 Error(""Fill"", ""attempt to fill branch %s while address is not set"", GetName());; 1245 return 0;; 1246 }; 1247 }; 1248 ; 1249 //; 1250 // If the tree has a TRefTable, set the current branch if; 1251 // branch is not a basic type.; 1252 //; 1253 ; 1254 // FIXME: This test probably needs to be extended past 10.; 1255 if ((fType >= -1) && (fType < 10)) {; 1256 TBranchRef* bref = fTree->GetBranchRef();; 1257 if (bref) {; 1258 fBranchID = bref->SetParent(this, fBranchID);; 1259 }; 1260 }; 1261 ; 1262 if (!nbranches) {; 1263 // No sub-branches.; 1264 if (!TestBit(kDoNotProcess)) {; 1265 nwrite = TBranch::FillImpl(imtHelper);; 1266 if (nwrite < 0) {; 1267 Error(""Fill"", ""Failed filling branch:%s, nbytes=%d"", GetName(), nwrite);; 1268 ++nerror;; 1269 } else {; 1270 nbytes += nwrite;; 1271 }; 1272 }; 1273 } else {; 1274 // We have sub-branches.; 1275 if (fType == 3 || fType == 4) {; 1276 // TClonesArray or STL container counter; 1277 nwrite = TBranch::FillImpl(imtHelper);; 1278 if (nwrite < 0) {; 1279 Error(""Fill"", ""Failed filling branch:%s, nbytes=%d"", GetName(), nwrite);; 1280 ++nerror;; 1281 } else {; 1282 nbytes += nwrite;; 1283 }; 1284 } else {; 1285 ++fEntries;; 1286 }; 1287 for (Int_t i = 0; i < nbranches; ++i) {; 1288 TBranchElement* branch = (TBranchE",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:49982,Modifiability,variab,variable,49982," Double_t* xx = (Double_t*) fAddress;; 1393 for (Int_t ii = 0; ii < n; ++ii) {; 1394 b.WriteDouble32(&(xx[ii]),se);; 1395 }; 1396 break;; 1397 }; 1398 case TVirtualStreamerInfo::kFloat16 /* 19 */: {; 1399 TVirtualStreamerInfo* si = GetInfoImp();; 1400 // coverity[dereference] structurally si can not be null.; 1401 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 1402 Float_t* xx = (Float_t*) fAddress;; 1403 for (Int_t ii = 0; ii < n; ++ii) {; 1404 b.WriteFloat16(&(xx[ii]),se);; 1405 }; 1406 break;; 1407 }; 1408 // Note: Type 10 is unused for now.; 1409 case TVirtualStreamerInfo::kUChar /* 11 */: { b.WriteFastArray((UChar_t*) fAddress, n); break; }; 1410 case TVirtualStreamerInfo::kUShort /* 12 */: { b.WriteFastArray((UShort_t*) fAddress, n); break; }; 1411 case TVirtualStreamerInfo::kUInt /* 13 */: { b.WriteFastArray((UInt_t*) fAddress, n); break; }; 1412 case TVirtualStreamerInfo::kULong /* 14 */: { b.WriteFastArray((ULong_t*) fAddress, n); break; }; 1413 // FIXME: This is wrong!!! TVirtualStreamerInfo::kBits is a variable length type.; 1414 case TVirtualStreamerInfo::kBits /* 15 */: { b.WriteFastArray((UInt_t*) fAddress, n); break; }; 1415 case TVirtualStreamerInfo::kLong64 /* 16 */: { b.WriteFastArray((Long64_t*) fAddress, n); break; }; 1416 case TVirtualStreamerInfo::kULong64 /* 17 */: { b.WriteFastArray((ULong64_t*) fAddress, n); break; }; 1417 case TVirtualStreamerInfo::kBool /* 18 */: { b.WriteFastArray((bool*) fAddress, n); break; }; 1418 }; 1419 }; 1420}; 1421 ; 1422////////////////////////////////////////////////////////////////////////////////; 1423/// Write leaves into i/o buffers for this branch.; 1424/// Case of a collection (fType == 4).; 1425 ; 1426void TBranchElement::FillLeavesCollection(TBuffer& b); 1427{; 1428 // -- STL container top-level branch. Write out number of entries, sub-branch writes the entries themselves.; 1429 ValidateAddress();; 1430 ; 1431 //; 1432 // Silently do nothing if we have no user i/o buffer.; 1433 //; 1434",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:81526,Modifiability,variab,variable,81526,"250 Int_t nbranches = branches->GetEntriesFast();; 2251 TBranchElement *lastbranch = this;; 2252 ; 2253 TClass *currentClass = fBranchClass;; 2254 auto currentVersion = fClassVersion;; 2255 if (toplevel) {; 2256 // Note: Fragile/wrong when using conversion StreamerInfo?; 2257 currentClass = info->GetClass();; 2258 currentVersion = info->GetClassVersion();; 2259 }; 2260 ; 2261 // First find the first branch corresponding to the same class as 'this'; 2262 // branch; 2263 Int_t index = branches->IndexOf(this);; 2264 Int_t firstindex = 0;; 2265 Int_t lastindex = nbranches - 1;; 2266 if (index >= 0) {; 2267 TString fullname( GetFullName() );; 2268 Ssiz_t lastdot = fullname.Last('.');; 2269 if (lastdot == TString::kNPOS) {; 2270 // No prefix or index, thus this is a first level branch; 2271 TBranchElement* subbranch = (TBranchElement*)branches->At(0);; 2272 if (!subbranch->fInfo); 2273 subbranch->SetupInfo();; 2274 } else {; 2275 TString &thisprefix = fullname.Remove(lastdot + 1); // Mod fullname and 'rename' the variable.; 2276 for(Int_t i = index - 1; i >= 0; --i) {; 2277 TBranchElement* subbranch = (TBranchElement*)branches->At(i);; 2278 TString subbranch_name(subbranch->GetFullName());; 2279 if ( ! subbranch_name.BeginsWith(thisprefix)) {; 2280 // We moved to another data member (of the enclosing class); 2281 firstindex = i + 1;; 2282 break;; 2283 }; 2284 if (!subbranch->fInfo); 2285 subbranch->SetupInfo();; 2286 }; 2287 for(Int_t i = index; i < nbranches; ++i) {; 2288 TBranchElement* subbranch = (TBranchElement*)branches->At(i);; 2289 TString subbranch_name(subbranch->GetFullName());; 2290 if ( ! subbranch_name.BeginsWith(thisprefix)) {; 2291 lastindex = i - 1;; 2292 break;; 2293 }; 2294 }; 2295 }; 2296 } else {; 2297 // Case of a top level branch or 'empty node' (object marker for split sub-object); 2298 TString fullname( GetFullName() );; 2299 Ssiz_t lastdot = fullname.Last('.');; 2300 if (lastdot != TString::kNPOS) {; 2301 TString &thisprefix = fullname.Remove(last",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:82547,Modifiability,variab,variable,82547,e variable.; 2276 for(Int_t i = index - 1; i >= 0; --i) {; 2277 TBranchElement* subbranch = (TBranchElement*)branches->At(i);; 2278 TString subbranch_name(subbranch->GetFullName());; 2279 if ( ! subbranch_name.BeginsWith(thisprefix)) {; 2280 // We moved to another data member (of the enclosing class); 2281 firstindex = i + 1;; 2282 break;; 2283 }; 2284 if (!subbranch->fInfo); 2285 subbranch->SetupInfo();; 2286 }; 2287 for(Int_t i = index; i < nbranches; ++i) {; 2288 TBranchElement* subbranch = (TBranchElement*)branches->At(i);; 2289 TString subbranch_name(subbranch->GetFullName());; 2290 if ( ! subbranch_name.BeginsWith(thisprefix)) {; 2291 lastindex = i - 1;; 2292 break;; 2293 }; 2294 }; 2295 }; 2296 } else {; 2297 // Case of a top level branch or 'empty node' (object marker for split sub-object); 2298 TString fullname( GetFullName() );; 2299 Ssiz_t lastdot = fullname.Last('.');; 2300 if (lastdot != TString::kNPOS) {; 2301 TString &thisprefix = fullname.Remove(lastdot + 1); // Mod fullname and 'rename' the variable.; 2302 for(Int_t i = 0; i < nbranches; ++i) {; 2303 TBranchElement* subbranch = (TBranchElement*)branches->At(i);; 2304 TString subbranch_name(subbranch->GetFullName());; 2305 if ( ! subbranch_name.BeginsWith(thisprefix)) {; 2306 lastindex = i - 1;; 2307 break;; 2308 }; 2309 }; 2310 }; 2311 }; 2312 for (Int_t i = firstindex; i <= lastindex; ++i) {; 2313 TBranchElement* subbranch = (TBranchElement*)branches->At(i);; 2314 bool match = false;; 2315 if (this != subbranch) {; 2316 ; 2317 if (!subbranch->fInfo); 2318 subbranch->SetupInfo();; 2319 ; 2320 if (subbranch->fInfo == info); 2321 match = true;; 2322 else if (subbranch->fInfo == nullptr && subbranch->fBranchClass == currentClass) {; 2323 if (!toplevel) {; 2324 if (subbranch->fCheckSum == fCheckSum); 2325 match = true;; 2326 } else {; 2327 if (!subbranch->fBranchClass->IsForeign() && subbranch->fClassVersion == currentVersion); 2328 match = true;; 2329 else if (subbranch->fCheckSum == info->GetCheckSum(),MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:100411,Modifiability,variab,variable,100411," ; 2790 if (R__unlikely(fTree->Debug() > 0)) {; 2791 if ((entry >= fTree->GetDebugMin()) && (entry <= fTree->GetDebugMax())) {; 2792 Info(""GetEntry"", ""%lld, branch=%s, nbytes=%d"", entry, GetName(), nbytes);; 2793 }; 2794 }; 2795 return nbytes;; 2796}; 2797 ; 2798////////////////////////////////////////////////////////////////////////////////; 2799/// Fill expectedClass and expectedType with information on the data type of the; 2800/// object/values contained in this branch (and thus the type of pointers; 2801/// expected to be passed to Set[Branch]Address; 2802/// return 0 in case of success and > 0 in case of failure.; 2803 ; 2804Int_t TBranchElement::GetExpectedType(TClass *&expectedClass,EDataType &expectedType); 2805{; 2806 expectedClass = nullptr;; 2807 expectedType = kOther_t;; 2808 ; 2809 Int_t type = GetStreamerType();; 2810 if ((type == -1) || (fID == -1)) {; 2811 expectedClass = fBranchClass;; 2812 } else {; 2813 // Case of an object data member. Here we allow for the; 2814 // variable name to be omitted. Eg, for Event.root with split; 2815 // level 1 or above Draw(""GetXaxis"") is the same as Draw(""fH.GetXaxis()""); 2816 TStreamerElement* element = GetInfoImp()->GetElement(fID);; 2817 if (element) {; 2818 expectedClass = element->GetClassPointer();; 2819 if (!expectedClass) {; 2820 TDataType* data = gROOT->GetType(element->GetTypeNameBasic());; 2821 if (!data) {; 2822 Error(""GetExpectedType"", ""Did not find the type number for %s"", element->GetTypeNameBasic());; 2823 return 1;; 2824 } else {; 2825 expectedType = (EDataType) data->GetType();; 2826 }; 2827 }; 2828 } else {; 2829 Error(""GetExpectedType"", ""Did not find the type for %s"",GetName());; 2830 return 2;; 2831 }; 2832 }; 2833 return 0;; 2834}; 2835 ; 2836////////////////////////////////////////////////////////////////////////////////; 2837/// Return the 'full' name of the branch. In particular prefix the mother's name; 2838/// when it does not end in a trailing dot and thus is not part of the branch name",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:118818,Modifiability,config,config,118818,"ached item which is not a repeated but we might still; 3293 // have some Actions triggered by a rule that affect real; 3294 // data member(s).; 3295 if (subBranch->fReadActionSequence && subBranch->fReadActionSequence->fActions.size() > 1) {; 3296 typedef TStreamerInfoActions::ActionContainer_t::iterator iterator;; 3297 iterator end = subBranch->fReadActionSequence->fActions.end();; 3298 for(iterator iter = subBranch->fReadActionSequence->fActions.begin();; 3299 iter != end; ++iter) {; 3300 TStreamerInfoActions::TConfiguration *config = iter->fConfiguration;; 3301 UInt_t id = config->fElemId;; 3302 TStreamerElement *e = (TStreamerElement*)config->fInfo->GetElements()->At(id);; 3303 if (e && !e->TestBit(TStreamerElement::kCache)) {; 3304 subBranchElement = e;; 3305 alternateElement = true;; 3306 break;; 3307 }; 3308 }; 3309 }; 3310 }; 3311 ; 3312 localOffset = subBranchElement->GetOffset();; 3313 if (localOffset == TStreamerInfo::kMissing) {; 3314 subBranch->fObject = nullptr;; 3315 }; 3316 {; 3317 Int_t streamerType = subBranchElement->GetType();; 3318 if (streamerType > TStreamerInfo::kObject; 3319 && subBranch->GetListOfBranches()->GetEntriesFast()==0; 3320 && CanSelfReference(subBranchElement->GetClass())); 3321 {; 3322 subBranch->SetBit(kBranchAny);; 3323 } else {; 3324 subBranch->ResetBit(kBranchAny);; 3325 }; 3326 }; 3327 ; 3328 if (subBranchElement->GetNewType()<0) {; 3329 subBranch->ResetBit(kBranchAny);; 3330 subBranch->ResetBit(kBranchObject);; 3331 }; 3332 ; 3333 // Note: This call is expensive, do it only once.; 3334 TBranch* mother = GetMother();; 3335 if (!mother) {; 3336 Warning(""InitializeOffsets"", ""Branch '%s' has no mother!"", GetName());; 3337 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3338 continue;; 3339 }; 3340 TString motherName(mother->GetName());; 3341 bool motherDot = false;; 3342 if (motherName.Length() && strchr(motherName.Data(), '.')) {; 3343 motherDot = true;; 3344 }; 3345 bool motherDotAtEnd = false;; 3346 if (motherName.L",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:118867,Modifiability,config,config,118867,"ached item which is not a repeated but we might still; 3293 // have some Actions triggered by a rule that affect real; 3294 // data member(s).; 3295 if (subBranch->fReadActionSequence && subBranch->fReadActionSequence->fActions.size() > 1) {; 3296 typedef TStreamerInfoActions::ActionContainer_t::iterator iterator;; 3297 iterator end = subBranch->fReadActionSequence->fActions.end();; 3298 for(iterator iter = subBranch->fReadActionSequence->fActions.begin();; 3299 iter != end; ++iter) {; 3300 TStreamerInfoActions::TConfiguration *config = iter->fConfiguration;; 3301 UInt_t id = config->fElemId;; 3302 TStreamerElement *e = (TStreamerElement*)config->fInfo->GetElements()->At(id);; 3303 if (e && !e->TestBit(TStreamerElement::kCache)) {; 3304 subBranchElement = e;; 3305 alternateElement = true;; 3306 break;; 3307 }; 3308 }; 3309 }; 3310 }; 3311 ; 3312 localOffset = subBranchElement->GetOffset();; 3313 if (localOffset == TStreamerInfo::kMissing) {; 3314 subBranch->fObject = nullptr;; 3315 }; 3316 {; 3317 Int_t streamerType = subBranchElement->GetType();; 3318 if (streamerType > TStreamerInfo::kObject; 3319 && subBranch->GetListOfBranches()->GetEntriesFast()==0; 3320 && CanSelfReference(subBranchElement->GetClass())); 3321 {; 3322 subBranch->SetBit(kBranchAny);; 3323 } else {; 3324 subBranch->ResetBit(kBranchAny);; 3325 }; 3326 }; 3327 ; 3328 if (subBranchElement->GetNewType()<0) {; 3329 subBranch->ResetBit(kBranchAny);; 3330 subBranch->ResetBit(kBranchObject);; 3331 }; 3332 ; 3333 // Note: This call is expensive, do it only once.; 3334 TBranch* mother = GetMother();; 3335 if (!mother) {; 3336 Warning(""InitializeOffsets"", ""Branch '%s' has no mother!"", GetName());; 3337 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3338 continue;; 3339 }; 3340 TString motherName(mother->GetName());; 3341 bool motherDot = false;; 3342 if (motherName.Length() && strchr(motherName.Data(), '.')) {; 3343 motherDot = true;; 3344 }; 3345 bool motherDotAtEnd = false;; 3346 if (motherName.L",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:118931,Modifiability,config,config,118931,"ached item which is not a repeated but we might still; 3293 // have some Actions triggered by a rule that affect real; 3294 // data member(s).; 3295 if (subBranch->fReadActionSequence && subBranch->fReadActionSequence->fActions.size() > 1) {; 3296 typedef TStreamerInfoActions::ActionContainer_t::iterator iterator;; 3297 iterator end = subBranch->fReadActionSequence->fActions.end();; 3298 for(iterator iter = subBranch->fReadActionSequence->fActions.begin();; 3299 iter != end; ++iter) {; 3300 TStreamerInfoActions::TConfiguration *config = iter->fConfiguration;; 3301 UInt_t id = config->fElemId;; 3302 TStreamerElement *e = (TStreamerElement*)config->fInfo->GetElements()->At(id);; 3303 if (e && !e->TestBit(TStreamerElement::kCache)) {; 3304 subBranchElement = e;; 3305 alternateElement = true;; 3306 break;; 3307 }; 3308 }; 3309 }; 3310 }; 3311 ; 3312 localOffset = subBranchElement->GetOffset();; 3313 if (localOffset == TStreamerInfo::kMissing) {; 3314 subBranch->fObject = nullptr;; 3315 }; 3316 {; 3317 Int_t streamerType = subBranchElement->GetType();; 3318 if (streamerType > TStreamerInfo::kObject; 3319 && subBranch->GetListOfBranches()->GetEntriesFast()==0; 3320 && CanSelfReference(subBranchElement->GetClass())); 3321 {; 3322 subBranch->SetBit(kBranchAny);; 3323 } else {; 3324 subBranch->ResetBit(kBranchAny);; 3325 }; 3326 }; 3327 ; 3328 if (subBranchElement->GetNewType()<0) {; 3329 subBranch->ResetBit(kBranchAny);; 3330 subBranch->ResetBit(kBranchObject);; 3331 }; 3332 ; 3333 // Note: This call is expensive, do it only once.; 3334 TBranch* mother = GetMother();; 3335 if (!mother) {; 3336 Warning(""InitializeOffsets"", ""Branch '%s' has no mother!"", GetName());; 3337 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3338 continue;; 3339 }; 3340 TString motherName(mother->GetName());; 3341 bool motherDot = false;; 3342 if (motherName.Length() && strchr(motherName.Data(), '.')) {; 3343 motherDot = true;; 3344 }; 3345 bool motherDotAtEnd = false;; 3346 if (motherName.L",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:147722,Modifiability,config,configured,147722,"91 }; 3992 } else if (fType == 3) {; 3993 printf("" %-15s = %d\n"", GetName(), fNdata);; 3994 } else if (fType == 31) {; 3995 TClonesArray* clones = (TClonesArray*) object;; 3996 if (GetInfoImp()) {; 3997 GetInfoImp()->PrintValueClones(GetName(), clones, prID, fOffset, lenmax);; 3998 }; 3999 } else if (fType == 41) {; 4000 TVirtualCollectionProxy::TPushPop helper(((TBranchElement*) this)->GetCollectionProxy(), object);; 4001 if (GetInfoImp()) {; 4002 GetInfoImp()->PrintValueSTL(GetName(), ((TBranchElement*) this)->GetCollectionProxy(), prID, fOffset, lenmax);; 4003 }; 4004 } else {; 4005 if (GetInfoImp()) {; 4006 GetInfoImp()->PrintValue(GetName(), object, prID, -1, lenmax);; 4007 }; 4008 }; 4009}; 4010 ; 4011////////////////////////////////////////////////////////////////////////////////; 4012/// Unconfiguration Read Leave function.; 4013 ; 4014void TBranchElement::ReadLeavesImpl(TBuffer&); 4015{; 4016 Fatal(""ReadLeaves"",""The ReadLeaves function has not been configured for %s"",GetName());; 4017}; 4018 ; 4019////////////////////////////////////////////////////////////////////////////////; 4020/// Read leaves into i/o buffers for this branch.; 4021/// For the case where the branch is set in MakeClass mode (decomposed object).; 4022 ; 4023void TBranchElement::ReadLeavesMakeClass(TBuffer& b); 4024{; 4025 ValidateAddress();; 4026 ; 4027 if (fType == 3 || fType == 4) {; 4028 // Top level branch of a TClonesArray.; 4029 Int_t *n = (Int_t*) fAddress;; 4030 b >> n[0];; 4031 if ((n[0] < 0) || (n[0] > fMaximum)) {; 4032 if (IsMissingCollection()) {; 4033 n[0] = 0;; 4034 b.SetBufferOffset(b.Length() - sizeof(n));; 4035 } else {; 4036 Error(""ReadLeaves"", ""Incorrect size read for the container in %s\nThe size read is %d when the maximum is %d\nThe size is reset to 0 for this entry (%lld)"", GetName(), n[0], fMaximum, GetReadEntry());; 4037 n[0] = 0;; 4038 }; 4039 }; 4040 fNdata = n[0];; 4041 if (fType == 4) {; 4042 Int_t nbranches = fBranches.GetEntriesFast();; 4043 switch(fSTLtype",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:167317,Modifiability,config,configuring,167317,"leaves into i/o buffers for this branch.; 4497/// Case of a data member within a TClonesArray (fType == 31).; 4498 ; 4499void TBranchElement::ReadLeavesClonesMember(TBuffer& b); 4500{; 4501 // No need to validate the address here, if we are a member of a split ClonesArray,; 4502 // fID is positive; 4503 // ValidateAddress();; 4504 ; 4505 if (fObject == nullptr); 4506 {; 4507 // We have nowhere to copy the data (probably because the data member was; 4508 // 'dropped' from the current schema) so let's no copy it in a random place.; 4509 return;; 4510 }; 4511 ; 4512 // TClonesArray sub-branch (contains the elements).; 4513 fNdata = fBranchCount->GetNdata();; 4514 TClonesArray* clones = (TClonesArray*) fObject;; 4515 if (clones->IsZombie()) {; 4516 return;; 4517 }; 4518 TStreamerInfo *info = GetInfoImp();; 4519 if (info==nullptr) return;; 4520 // Since info is not null, fReadActionSequence is not null either.; 4521 ; 4522 // Note, we could (possibly) save some more, by configuring the action; 4523 // based on the value of fOnfileObject rather than pushing in on a stack.; 4524 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,fNdata);; 4525 ; 4526 char **arr = (char **)clones->GetObjectRef();; 4527 char **end = arr + fNdata;; 4528 b.ApplySequenceVecPtr(*fReadActionSequence,arr,end);; 4529}; 4530 ; 4531////////////////////////////////////////////////////////////////////////////////; 4532/// Read leaves into i/o buffers for this branch.; 4533/// For split-class branch, base class branch, data member branch, or top-level branch.; 4534/// which do not have a branch count and are not a counter.; 4535 ; 4536void TBranchElement::ReadLeavesMember(TBuffer& b); 4537{; 4538 R__ASSERT(fBranchCount==nullptr);; 4539 R__ASSERT(fStreamerType != TVirtualStreamerInfo::kCounter);; 4540 ; 4541 ValidateAddress();; 4542 if (fObject == nullptr); 4543 {; 4544 // We have nowhere to copy the data (probably because the data member was; 4545 // 'dropped' from the current schema) so let's no",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:168558,Modifiability,inherit,inherits,168558,"r = (char **)clones->GetObjectRef();; 4527 char **end = arr + fNdata;; 4528 b.ApplySequenceVecPtr(*fReadActionSequence,arr,end);; 4529}; 4530 ; 4531////////////////////////////////////////////////////////////////////////////////; 4532/// Read leaves into i/o buffers for this branch.; 4533/// For split-class branch, base class branch, data member branch, or top-level branch.; 4534/// which do not have a branch count and are not a counter.; 4535 ; 4536void TBranchElement::ReadLeavesMember(TBuffer& b); 4537{; 4538 R__ASSERT(fBranchCount==nullptr);; 4539 R__ASSERT(fStreamerType != TVirtualStreamerInfo::kCounter);; 4540 ; 4541 ValidateAddress();; 4542 if (fObject == nullptr); 4543 {; 4544 // We have nowhere to copy the data (probably because the data member was; 4545 // 'dropped' from the current schema) so let's no copy it in a random place.; 4546 return;; 4547 }; 4548 ; 4549 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,1);; 4550 // If not a TClonesArray or STL container master branch; 4551 // or sub-branch and branch inherits from tobject,; 4552 // then register with the buffer so that pointers are; 4553 // handled properly.; 4554 if (TestBit(kBranchObject)) {; 4555 b.MapObject((TObject*) fObject);; 4556 } else if (TestBit(kBranchAny)) {; 4557 b.MapObject(fObject, fBranchClass);; 4558 }; 4559 ; 4560 fNdata = 1;; 4561 TStreamerInfo *info = GetInfoImp();; 4562 if (!info) {; 4563 return;; 4564 }; 4565 // Since info is not null, fReadActionSequence is not null either.; 4566 b.ApplySequence(*fReadActionSequence, fObject);; 4567}; 4568 ; 4569////////////////////////////////////////////////////////////////////////////////; 4570/// Read leaves into i/o buffers for this branch.; 4571/// For split-class branch, base class branch, data member branch, or top-level branch.; 4572/// which do have a branch count and are not a counter.; 4573 ; 4574void TBranchElement::ReadLeavesMemberBranchCount(TBuffer& b); 4575{; 4576 R__ASSERT(fStreamerType != TVirtualStreamerInfo::kCou",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:169881,Modifiability,inherit,inherits,169881,"rInfo *info = GetInfoImp();; 4562 if (!info) {; 4563 return;; 4564 }; 4565 // Since info is not null, fReadActionSequence is not null either.; 4566 b.ApplySequence(*fReadActionSequence, fObject);; 4567}; 4568 ; 4569////////////////////////////////////////////////////////////////////////////////; 4570/// Read leaves into i/o buffers for this branch.; 4571/// For split-class branch, base class branch, data member branch, or top-level branch.; 4572/// which do have a branch count and are not a counter.; 4573 ; 4574void TBranchElement::ReadLeavesMemberBranchCount(TBuffer& b); 4575{; 4576 R__ASSERT(fStreamerType != TVirtualStreamerInfo::kCounter);; 4577 ; 4578 ValidateAddress();; 4579 if (fObject == nullptr); 4580 {; 4581 // We have nowhere to copy the data (probably because the data member was; 4582 // 'dropped' from the current schema) so let's no copy it in a random place.; 4583 return;; 4584 }; 4585 ; 4586 // If not a TClonesArray or STL container master branch; 4587 // or sub-branch and branch inherits from tobject,; 4588 // then register with the buffer so that pointers are; 4589 // handled properly.; 4590 if (TestBit(kBranchObject)) {; 4591 b.MapObject((TObject*) fObject);; 4592 } else if (TestBit(kBranchAny)) {; 4593 b.MapObject(fObject, fBranchClass);; 4594 }; 4595 ; 4596 fNdata = (Int_t) fBranchCount->GetValue(0, 0);; 4597 TStreamerInfo *info = GetInfoImp();; 4598 if (!info) {; 4599 return;; 4600 }; 4601 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,1); // Here we have a single object that contains a variable size C-style array.; 4602 // Since info is not null, fReadActionSequence is not null either.; 4603 b.ApplySequence(*fReadActionSequence, fObject);; 4604}; 4605 ; 4606////////////////////////////////////////////////////////////////////////////////; 4607/// Read leaves into i/o buffers for this branch.; 4608/// For split-class branch, base class branch, data member branch, or top-level branch.; 4609/// which do not have a branch count and are a co",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:170415,Modifiability,variab,variable,170415,"a member branch, or top-level branch.; 4572/// which do have a branch count and are not a counter.; 4573 ; 4574void TBranchElement::ReadLeavesMemberBranchCount(TBuffer& b); 4575{; 4576 R__ASSERT(fStreamerType != TVirtualStreamerInfo::kCounter);; 4577 ; 4578 ValidateAddress();; 4579 if (fObject == nullptr); 4580 {; 4581 // We have nowhere to copy the data (probably because the data member was; 4582 // 'dropped' from the current schema) so let's no copy it in a random place.; 4583 return;; 4584 }; 4585 ; 4586 // If not a TClonesArray or STL container master branch; 4587 // or sub-branch and branch inherits from tobject,; 4588 // then register with the buffer so that pointers are; 4589 // handled properly.; 4590 if (TestBit(kBranchObject)) {; 4591 b.MapObject((TObject*) fObject);; 4592 } else if (TestBit(kBranchAny)) {; 4593 b.MapObject(fObject, fBranchClass);; 4594 }; 4595 ; 4596 fNdata = (Int_t) fBranchCount->GetValue(0, 0);; 4597 TStreamerInfo *info = GetInfoImp();; 4598 if (!info) {; 4599 return;; 4600 }; 4601 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,1); // Here we have a single object that contains a variable size C-style array.; 4602 // Since info is not null, fReadActionSequence is not null either.; 4603 b.ApplySequence(*fReadActionSequence, fObject);; 4604}; 4605 ; 4606////////////////////////////////////////////////////////////////////////////////; 4607/// Read leaves into i/o buffers for this branch.; 4608/// For split-class branch, base class branch, data member branch, or top-level branch.; 4609/// which do not have a branch count and are a counter.; 4610 ; 4611void TBranchElement::ReadLeavesMemberCounter(TBuffer& b); 4612{; 4613 ValidateAddress();; 4614 if (fObject == nullptr); 4615 {; 4616 // We have nowhere to copy the data (probably because the data member was; 4617 // 'dropped' from the current schema) so let's no copy it in a random place.; 4618 return;; 4619 }; 4620 ; 4621 // If not a TClonesArray or STL container master branch; 4622 ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:171307,Modifiability,inherit,inherits,171307,"; 4601 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,1); // Here we have a single object that contains a variable size C-style array.; 4602 // Since info is not null, fReadActionSequence is not null either.; 4603 b.ApplySequence(*fReadActionSequence, fObject);; 4604}; 4605 ; 4606////////////////////////////////////////////////////////////////////////////////; 4607/// Read leaves into i/o buffers for this branch.; 4608/// For split-class branch, base class branch, data member branch, or top-level branch.; 4609/// which do not have a branch count and are a counter.; 4610 ; 4611void TBranchElement::ReadLeavesMemberCounter(TBuffer& b); 4612{; 4613 ValidateAddress();; 4614 if (fObject == nullptr); 4615 {; 4616 // We have nowhere to copy the data (probably because the data member was; 4617 // 'dropped' from the current schema) so let's no copy it in a random place.; 4618 return;; 4619 }; 4620 ; 4621 // If not a TClonesArray or STL container master branch; 4622 // or sub-branch and branch inherits from tobject,; 4623 // then register with the buffer so that pointers are; 4624 // handled properly.; 4625 if (TestBit(kBranchObject)) {; 4626 b.MapObject((TObject*) fObject);; 4627 } else if (TestBit(kBranchAny)) {; 4628 b.MapObject(fObject, fBranchClass);; 4629 }; 4630 ; 4631 TStreamerInfo *info = GetInfoImp();; 4632 if (!info) {; 4633 return;; 4634 }; 4635 ; 4636 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,1);; 4637 ; 4638 // Since info is not null, fReadActionSequence is not null either.; 4639 b.ApplySequence(*fReadActionSequence, fObject);; 4640 fNdata = (Int_t) GetValue(0, 0);; 4641}; 4642 ; 4643////////////////////////////////////////////////////////////////////////////////; 4644/// Read leaves into i/o buffers for this branch.; 4645/// Non TObject, Non collection classes with a custom streamer.; 4646 ; 4647void TBranchElement::ReadLeavesCustomStreamer(TBuffer& b); 4648{; 4649 ValidateAddress();; 4650 if (fObject == nullptr); 4651 {; 4652 // We hav",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:172859,Modifiability,config,configured,172859,"t) GetValue(0, 0);; 4641}; 4642 ; 4643////////////////////////////////////////////////////////////////////////////////; 4644/// Read leaves into i/o buffers for this branch.; 4645/// Non TObject, Non collection classes with a custom streamer.; 4646 ; 4647void TBranchElement::ReadLeavesCustomStreamer(TBuffer& b); 4648{; 4649 ValidateAddress();; 4650 if (fObject == nullptr); 4651 {; 4652 // We have nowhere to copy the data (probably because the data member was; 4653 // 'dropped' from the current schema) so let's no copy it in a random place.; 4654 return;; 4655 }; 4656 ; 4657 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,1);; 4658 fBranchClass->Streamer(fObject,b);; 4659}; 4660 ; 4661////////////////////////////////////////////////////////////////////////////////; 4662/// Unconfiguration Fill Leave function.; 4663 ; 4664void TBranchElement::FillLeavesImpl(TBuffer&); 4665{; 4666 Fatal(""FillLeaves"",""The FillLeaves function has not been configured for %s"",GetName());; 4667}; 4668 ; 4669////////////////////////////////////////////////////////////////////////////////; 4670/// Delete any object we may have allocated on a previous call to SetAddress.; 4671 ; 4672void TBranchElement::ReleaseObject(); 4673{; 4674 if (fObject && TestBit(kDeleteObject)) {; 4675 if (IsAutoDelete() && fAddress != (char*)&fObject) {; 4676 *((char**) fAddress) = nullptr;; 4677 }; 4678 ResetBit(kDeleteObject);; 4679 if (fType == 3) {; 4680 // -- We are a TClonesArray master branch.; 4681 TClonesArray::Class()->Destructor(fObject);; 4682 fObject = nullptr;; 4683 if ((fStreamerType == TVirtualStreamerInfo::kObjectp) ||; 4684 (fStreamerType == TVirtualStreamerInfo::kObjectP)) {; 4685 // -- We are a pointer to a TClonesArray.; 4686 // We must zero the pointer in the object.; 4687 *((char**) fAddress) = nullptr;; 4688 }; 4689 } else if (fType == 4) {; 4690 // -- We are an STL container master branch.; 4691 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4692 ; 4693 if (!proxy) {; 4694 ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:198722,Modifiability,inherit,inheriting,198722,"llocate.; 5338 SetBit(kDeleteObject);; 5339 fObject = (char*) new TClonesArray(fClonesClass);; 5340 fAddress = (char*) &fObject;; 5341 } else {; 5342 // -- We are a sub-branch which is a pointer to a TClonesArray.; 5343 Error(""SetAddress"", ""Embedded pointer to a TClonesArray given a zero address for branch '%s'"", GetName());; 5344 }; 5345 }; 5346 }; 5347 } else if (fType == 4) {; 5348 // -- We are an STL container master branch.; 5349 //; 5350 // Initialize fCollProxy.; 5351 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 5352 if (fAddress) {; 5353 // -- We have been given a non-zero address, allocate if necessary.; 5354 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5355 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5356 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5357 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5358 // Case of an embedded STL container.; 5359 // Note: We test for the kObject and kAny types to support; 5360 // the (unwise) choice of inheriting from an STL container.; 5361 fObject = fAddress;; 5362 } else {; 5363 // We are either a top-level branch or subbranch which is a pointer to an STL container.; 5364 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5365 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5366 Error(""SetAddress"",; 5367 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5368 GetName(), fStreamerType);; 5369 } else if (fStreamerType == -1) {; 5370 // -- We are a top-level branch.; 5371 void** pp = (void**) fAddress;; 5372 if (!*pp) {; 5373 // -- Caller wants us to allocate the STL container, but they will own it.; 5374 *pp = proxy->New();; 5375 if (!(*pp)) {; 5376 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5377 // FIXME: Should we do this? Lots of other code wants; 5378 // fAddress to be zero if no fObject, but is; 5379 // th",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:200996,Modifiability,inherit,inheriting,200996,"can be lazy.; 5389 void** pp = (void**) fAddress;; 5390 if (!*pp) {; 5391 // -- Caller wants us to allocate the STL container, but they will own it.; 5392 *pp = proxy->New();; 5393 if (!(*pp)) {; 5394 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5395 // FIXME: Should we do this? Lots of other code wants; 5396 // fAddress to be zero if no fObject, but is; 5397 // that a good thing?; 5398 fAddress = nullptr;; 5399 ResetBit(kAddressSet);; 5400 }; 5401 }; 5402 fObject = (char*) *pp;; 5403 }; 5404 }; 5405 } else {; 5406 // -- We have been given a zero address, allocate for top-level only.; 5407 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5408 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5409 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5410 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5411 // Case of an embedded STL container.; 5412 // Note: We test for the kObject and kAny types to support; 5413 // the (unwise) choice of inheriting from an STL container.; 5414 Error(""SetAddress"", ""Embedded STL container given a zero address for branch '%s'"", GetName());; 5415 } else {; 5416 // We are either a top-level branch or sub-branch which is a pointer to an STL container.; 5417 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5418 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5419 Error(""SetAddress"",; 5420 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5421 GetName(), fStreamerType);; 5422 } else if (fStreamerType == -1) {; 5423 // -- We are a top-level branch, allocate.; 5424 SetBit(kDeleteObject);; 5425 fObject = (char*) proxy->New();; 5426 if (fObject) {; 5427 fAddress = (char*) &fObject;; 5428 } else {; 5429 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5430 // FIXME: Should we do this? Lots of other code wants; 5431 // fAddress to",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:207455,Modifiability,config,configuration,207455,ss); 5558 else; 5559 ResetBit(kDecomposedObj);; 5560 ; 5561 Int_t nbranches = fBranches.GetEntriesFast();; 5562 for (Int_t i = 0; i < nbranches; ++i) {; 5563 TBranchElement* branch = (TBranchElement*) fBranches[i];; 5564 branch->SetMakeClass(decomposeObj);; 5565 }; 5566 SetReadLeavesPtr();; 5567 SetFillLeavesPtr();; 5568 ; 5569 return true;; 5570}; 5571 ; 5572////////////////////////////////////////////////////////////////////////////////; 5573/// Set object this branch is pointing to.; 5574 ; 5575void TBranchElement::SetObject(void* obj); 5576{; 5577 if (TestBit(kDoNotProcess)) {; 5578 return;; 5579 }; 5580 fObject = (char*)obj;; 5581 SetAddress( &fObject );; 5582}; 5583 ; 5584////////////////////////////////////////////////////////////////////////////////; 5585/// Set offset of the object (to which the data member represented by this; 5586/// branch belongs) inside its containing object (if any).; 5587 ; 5588void TBranchElement::SetOffset(Int_t offset); 5589{; 5590 // We need to make sure that the Read and Write action's configuration; 5591 // properly reflect this value.; 5592 ; 5593 if (offset == TVirtualStreamerInfo::kMissing) {; 5594 SetMissing();; 5595 return;; 5596 }; 5597 ; 5598 if (fReadActionSequence) {; 5599 fReadActionSequence->AddToOffset(offset - fOffset);; 5600 }; 5601 if (fFillActionSequence) {; 5602 fFillActionSequence->AddToOffset(offset - fOffset);; 5603 }; 5604 fOffset = offset;; 5605}; 5606 ; 5607////////////////////////////////////////////////////////////////////////////////; 5608/// Set offset of the object (to which the data member represented by this; 5609/// branch belongs) inside its containing object (if any) to mark it as missing.; 5610 ; 5611void TBranchElement::SetMissing(); 5612{; 5613 // We need to make sure that the Read and Write action's configuration; 5614 // properly reflect this value.; 5615 ; 5616 if (fReadActionSequence) {; 5617 fReadActionSequence->SetMissing();; 5618 }; 5619 if (fFillActionSequence) {; 5620 fFillActionSeque,MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:208221,Modifiability,config,configuration,208221,"5/// Set offset of the object (to which the data member represented by this; 5586/// branch belongs) inside its containing object (if any).; 5587 ; 5588void TBranchElement::SetOffset(Int_t offset); 5589{; 5590 // We need to make sure that the Read and Write action's configuration; 5591 // properly reflect this value.; 5592 ; 5593 if (offset == TVirtualStreamerInfo::kMissing) {; 5594 SetMissing();; 5595 return;; 5596 }; 5597 ; 5598 if (fReadActionSequence) {; 5599 fReadActionSequence->AddToOffset(offset - fOffset);; 5600 }; 5601 if (fFillActionSequence) {; 5602 fFillActionSequence->AddToOffset(offset - fOffset);; 5603 }; 5604 fOffset = offset;; 5605}; 5606 ; 5607////////////////////////////////////////////////////////////////////////////////; 5608/// Set offset of the object (to which the data member represented by this; 5609/// branch belongs) inside its containing object (if any) to mark it as missing.; 5610 ; 5611void TBranchElement::SetMissing(); 5612{; 5613 // We need to make sure that the Read and Write action's configuration; 5614 // properly reflect this value.; 5615 ; 5616 if (fReadActionSequence) {; 5617 fReadActionSequence->SetMissing();; 5618 }; 5619 if (fFillActionSequence) {; 5620 fFillActionSequence->SetMissing();; 5621 }; 5622 fOffset = TVirtualStreamerInfo::kMissing;; 5623}; 5624 ; 5625 ; 5626////////////////////////////////////////////////////////////////////////////////; 5627/// Set the sequence of actions needed to read the data out of the buffer.; 5628void TBranchElement::SetActionSequence(TClass *originalClass, TStreamerInfo *localInfo, TStreamerInfoActions::TActionSequence::SequenceGetter_t create, TStreamerInfoActions::TActionSequence *&actionSequence); 5629{; 5630 // A 'split' node does not store data itself (it has not associated baskets); 5631 const bool isSplitNode = (fType == 3 || fType == 4 || fType == 2 || fType == 1 || (fType == 0 && fID == -2)) && !fBranches.IsEmpty();; 5632 ; 5633 if (!isSplitNode) {; 5634 fNewIDs.insert(fNewIDs.begi",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:237185,Modifiability,inherit,inherited,237185,"lass()) {; 6283 unroll = Unroll(name, clParent, clOfBase, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6284 }; 6285 if (unroll < 0) {; 6286 // FIXME: We could not split because we are abstract, should we be doing this?; 6287 if (namelen) {; 6288 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6289 } else {; 6290 branchname.Form(""%s"", elem->GetFullName());; 6291 }; 6292 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, nullptr, basketsize, 0, btype);; 6293 branch->SetParentClass(clParent);; 6294 fBranches.Add(branch);; 6295 }; 6296 } else if (clOfBase->GetListOfRealData()->GetSize()) {; 6297 // -- Create a branch for a non-empty base class.; 6298 if (namelen) {; 6299 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6300 // Elide the base class name when creating the sub-branches.; 6301 // Note: The branch names for sub-branches of a base class branch; 6302 // do not represent the full class hierarchy because we do; 6303 // this, however it does keep the branch names for the; 6304 // inherited data members simple.; 6305 TBranchElement* branch = new TBranchElement(this, name, sinfo, elemID, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6306 // Then reset it to the proper name.; 6307 branch->SetName(branchname);; 6308 branch->SetTitle(branchname);; 6309 branch->SetParentClass(clParent);; 6310 fBranches.Add(branch);; 6311 } else {; 6312 branchname.Form(""%s"", elem->GetFullName());; 6313 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6314 branch->SetParentClass(clParent);; 6315 fBranches.Add(branch);; 6316 }; 6317 }; 6318 } else {; 6319 // -- This is a data member of cl.; 6320 if (namelen) {; 6321 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6322 } else {; 6323 branchname.Form(""%s"", elem->GetFullName());; 6324 }; 6325 if ((splitlevel > 1) && ((elem->IsA() =",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:238229,Modifiability,inherit,inherit,238229,"p the branch names for the; 6304 // inherited data members simple.; 6305 TBranchElement* branch = new TBranchElement(this, name, sinfo, elemID, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6306 // Then reset it to the proper name.; 6307 branch->SetName(branchname);; 6308 branch->SetTitle(branchname);; 6309 branch->SetParentClass(clParent);; 6310 fBranches.Add(branch);; 6311 } else {; 6312 branchname.Form(""%s"", elem->GetFullName());; 6313 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6314 branch->SetParentClass(clParent);; 6315 fBranches.Add(branch);; 6316 }; 6317 }; 6318 } else {; 6319 // -- This is a data member of cl.; 6320 if (namelen) {; 6321 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6322 } else {; 6323 branchname.Form(""%s"", elem->GetFullName());; 6324 }; 6325 if ((splitlevel > 1) && ((elem->IsA() == TStreamerObject::Class()) || (elem->IsA() == TStreamerObjectAny::Class()))) {; 6326 // -- We are splitting a non-TClonesArray (may inherit from TClonesArray though), non-STL container object.; 6327 //; 6328 // Ignore an abstract class.; 6329 // FIXME: How could an abstract class get here?; 6330 // Partial answer: It is a base class. But this is a data member!; 6331 TClass* elemClass = elem->GetClassPointer();; 6332 if (!elemClass || elemClass->Property() & kIsAbstract) {; 6333 return -1;; 6334 }; 6335 if (elem->CannotSplit()) {; 6336 // We are not splitting.; 6337 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, ptr + offset, basketsize, 0, btype);; 6338 branch->SetParentClass(clParent);; 6339 fBranches.Add(branch);; 6340 } else if (elemClass->InheritsFrom(TClonesArray::Class())) {; 6341 // Splitting something derived from TClonesArray.; 6342 Int_t subSplitlevel = splitlevel-1;; 6343 if (btype == 31 || btype == 41 || elem->CannotSplit()) {; 6344 // -- We split the sub-branches of a TClonesArray or an STL cont",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:267425,Modifiability,variab,variable,267425,etInitInfo(bool recurse)Reset offset and StreamerInfo information from this branch.Definition TBranchElement.cxx:4831; TBranchElement::TLeafElementfriend class TLeafElementDefinition TBranchElement.h:43; TBranchElement::GetFullNameTString GetFullName() const overrideReturn the 'full' name of the branch.Definition TBranchElement.cxx:2839; TBranchElement::ReadLeavesMakeClassvoid ReadLeavesMakeClass(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4023; TBranchElement::TBranchElementTBranchElement()Default and I/O constructor.Definition TBranchElement.cxx:133; TBranchElement::FillLeavesCustomStreamervoid FillLeavesCustomStreamer(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1646; TBranchElement::GetClonesNamevirtual const char * GetClonesName() constDefinition TBranchElement.h:188; TBranchElement::GetClassvirtual TClass * GetClass() constDefinition TBranchElement.h:187; TBranchElement::fMaximumInt_t fMaximumMaximum entries for a TClonesArray or variable array.Definition TBranchElement.h:80; TBranchElement::ReadLeavesMemberCountervoid ReadLeavesMemberCounter(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4611; TBranchElement::fBranchIDInt_t fBranchID! ID number assigned by a TRefTable.Definition TBranchElement.h:97; TBranchElement::FindLeafTLeaf * FindLeaf(const char *name) overrideFind the leaf corresponding to the name 'searchname'.Definition TBranchElement.cxx:1872; TBranchElement::fIteratorsTVirtualCollectionIterators * fIterators! holds the iterators when the branch is of fType==4.Definition TBranchElement.h:101; TBranchElement::ReleaseObjectvoid ReleaseObject()Delete any object we may have allocated on a previous call to SetAddress.Definition TBranchElement.cxx:4672; TBranchElement::fTargetClassTClassRef fTargetClass! Reference to the target in-memory classDefinition TBranchElement.h:91; TBranchElement::Browsevoid Browse(TBrowser *b) overrideBrowse ,MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:274443,Modifiability,variab,variable,274443,"anch::fEntryOffsetLenInt_t fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers.Definition TBranch.h:119; TBranch::fMaxBasketsInt_t fMaxBasketsMaximum number of Baskets so far.Definition TBranch.h:125; TBranch::GetTreeTTree * GetTree() constDefinition TBranch.h:252; TBranch::fFillLeavesFillLeaves_t fFillLeaves! Pointer to the FillLeaves implementation to use.Definition TBranch.h:163; TBranch::GetFullNamevirtual TString GetFullName() constReturn the 'full' name of the branch.Definition TBranch.cxx:2031; TBranch::ReadLeaves_tvoid(TBranch::* ReadLeaves_t)(TBuffer &b)Definition TBranch.h:160; TBranch::kBranchAny@ kBranchAnyBranch is an object*.Definition TBranch.h:108; TBranch::kBranchObject@ kBranchObjectBranch is a TObject*.Definition TBranch.h:107; TBranch::kDoNotProcess@ kDoNotProcessActive bit for branches.Definition TBranch.h:105; TBranch::fLeavesTObjArray fLeaves-> List of leaves of this branchDefinition TBranch.h:139; TBranch::fAddresschar * fAddress! Address of 1st leaf (variable or object)Definition TBranch.h:147; TBranch::GetListOfBranchesTObjArray * GetListOfBranches()Definition TBranch.h:246; TBranch::GetBrowsablesvirtual TList * GetBrowsables()Returns (and, if 0, creates) browsable objects for this branch See TVirtualBranchBrowsable::FillListO...Definition TBranch.cxx:1312; TBranch::fOffsetInt_t fOffsetOffset of this branch.Definition TBranch.h:124; TBranch::fBasketEntryLong64_t * fBasketEntry[fMaxBaskets] Table of first entry in each basketDefinition TBranch.h:142; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; TBranch::GetFileNameconst char * GetFileName() constDefinition TBranch.h:234; TBranch::GetIOFeaturesTIOFeatures GetIOFeatures() constReturns the IO settings currently in use for this branch.Definition TBranch.cxx:2255; TBranch::IsATClass * IsA() const overrideDefinition TBranch.h:295; TBranch::fReadEntryLong64_t",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:283507,Modifiability,inherit,inherits,283507," the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetStreamerInfosconst TObjArray * GetStreamerInfos() constDefinition TClass.h:492; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:6014; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * G",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:284040,Modifiability,inherit,inherits,284040,"tStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetStreamerInfosconst TObjArray * GetStreamerInfos() constDefinition TClass.h:492; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:6014; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::IsVersionedBool_t IsVersioned() constDefinitio",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:290880,Modifiability,inherit,inherits,290880,"* FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TClonesArrayfriend class TClonesArrayDefinition TObject.h:240; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TStreamerArtificial::Classstatic TClass * Class(); TStreamerBase::Classstatic TClass * Class(); TStreamerBasicPoint",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:35331,Performance,optimiz,optimizer,35331,"etTitle(), fID, fStreamerType);; 964 leaf->SetTitle(GetTitle());; 965 fNleaves = 1;; 966 fLeaves.Add(leaf);; 967 fTree->GetListOfLeaves()->Add(leaf);; 968 SetReadLeavesPtr();; 969 SetFillLeavesPtr();; 970}; 971 ; 972////////////////////////////////////////////////////////////////////////////////; 973/// Destructor.; 974 ; 975TBranchElement::~TBranchElement(); 976{; 977 // Release any allocated I/O buffers.; 978 if (fOnfileObject && TestBit(kOwnOnfileObj)) {; 979 delete fOnfileObject;; 980 fOnfileObject = nullptr;; 981 }; 982 ResetAddress();; 983 ; 984 delete[] fBranchOffset;; 985 fBranchOffset = nullptr;; 986 ; 987 fInfo = nullptr;; 988 fBranchCount2 = nullptr;; 989 fBranchCount = nullptr;; 990 ; 991 if (fType == 4 || fType == 0) {; 992 // Only the top level TBranchElement containing an STL container,; 993 // owns the collectionproxy.; 994 delete fCollProxy;; 995 }; 996 fCollProxy = nullptr;; 997 ; 998 delete fReadActionSequence;; 999 delete fFillActionSequence;; 1000 delete fIterators;; 1001 delete fWriteIterators;; 1002 delete fPtrIterators;; 1003}; 1004 ; 1005//; 1006// This function is located here to allow inlining by the optimizer.; 1007//; 1008////////////////////////////////////////////////////////////////////////////////; 1009/// Get streamer info for the branch class.; 1010 ; 1011inline TStreamerInfo* TBranchElement::GetInfoImp() const; 1012{; 1013 // Note: we need to find a way to reduce the complexity of; 1014 // this often executed condition.; 1015 if (!fInfo || (fInfo && (!fInit || !fInfo->IsCompiled()))) {; 1016 const_cast<TBranchElement*>(this)->InitInfo();; 1017 }; 1018 return fInfo;; 1019}; 1020 ; 1021////////////////////////////////////////////////////////////////////////////////; 1022/// Get streamer info for the branch class.; 1023 ; 1024TStreamerInfo* TBranchElement::GetInfo() const; 1025{; 1026 return GetInfoImp();; 1027}; 1028 ; 1029////////////////////////////////////////////////////////////////////////////////; 1030/// Browse the branch cont",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:75967,Performance,load,loaded,75967,"ds.pop_back();; 2106 }; 2107 }; 2108};; 2109} // Anonymous namespace.; 2110 ; 2111 ; 2112////////////////////////////////////////////////////////////////////////////////; 2113/// Set the value of fInfo. This is part one of InitInfo.; 2114/// To be used as:; 2115/// if (!fInfo); 2116/// SetupInfo();; 2117/// It would only be used within InitInfo (and its callees); 2118 ; 2119void TBranchElement::SetupInfo(); 2120{; 2121 // We did not already have streamer info, so now we must find it.; 2122 TClass* cl = fBranchClass.GetClass();; 2123 ; 2124 //------------------------------------------------------------------------; 2125 // Check if we're dealing with the name change; 2126 //////////////////////////////////////////////////////////////////////////; 2127 ; 2128 TClass* targetClass = nullptr;; 2129 if( fTargetClass.GetClassName()[0] ) {; 2130 targetClass = fTargetClass;; 2131 if (!targetClass && GetCollectionProxy()) {; 2132 // We are in the case where the branch holds a custom collection; 2133 // proxy but the dictionary is not loaded, calling; 2134 // GetCollectionProxy had the side effect of creating the TClass; 2135 // corresponding to this emulated collection.; 2136 targetClass = fTargetClass;; 2137 }; 2138 if ( !targetClass ) {; 2139 Error(""InitInfo"", ""Branch '%s': missing dictionary for target class '%s'!"",; 2140 GetFullName().Data(), fTargetClass.GetClassName());; 2141 return;; 2142 }; 2143 } else {; 2144 targetClass = cl;; 2145 }; 2146 if (cl) {; 2147 //---------------------------------------------------------------------; 2148 // Get the streamer info for given version; 2149 ///////////////////////////////////////////////////////////////////////; 2150 ; 2151 {; 2152 if ( (cl->Property() & kIsAbstract) && cl == targetClass) {; 2153 TBranchElement *parent = (TBranchElement*)GetMother()->GetSubBranch(this);; 2154 if (parent && parent != this && !parent->GetClass()->IsLoaded() ) {; 2155 // Our parent's class is emulated and we represent an abstract class.; 2156 // ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:79182,Performance,cache,cached,79182,"amerInfo*)targetClass->FindConversionStreamerInfo( cl, fCheckSum );; 2186 else {; 2187 info = (TStreamerInfo*)cl->FindStreamerInfo( fCheckSum );; 2188 if (info) {; 2189 // Now that we found it, we need to make sure it is initialize (Find does not initialize the StreamerInfo).; 2190 info = (TStreamerInfo*)cl->GetStreamerInfo(info->GetClassVersion());; 2191 }; 2192 }; 2193 if( info ) {; 2194 fInfo = info;; 2195 // We no longer reset the class version so that in case the user is passing us later; 2196 // the address of a class that require (another) Conversion we can find the proper; 2197 // StreamerInfo.; 2198 // fClassVersion = fInfo->GetClassVersion();; 2199 }; 2200 }; 2201 }; 2202}; 2203 ; 2204 ; 2205////////////////////////////////////////////////////////////////////////////////; 2206/// Init the streamer info for the branch class, try to compensate for class; 2207/// code unload/reload and schema evolution.; 2208 ; 2209void TBranchElement::InitInfo(); 2210{; 2211 if (!fInfo); 2212 SetupInfo();; 2213 ; 2214 //; 2215 // Fixup cached streamer info if necessary.; 2216 //; 2217 // FIXME: What if the class code was unloaded/reloaded since we were cached?; 2218 ; 2219 if (fInfo) {; 2220 ; 2221 if (!fInfo->IsCompiled()) {; 2222 // Streamer info has not yet been compiled.; 2223 ; 2224 Error(""InitInfo"",""StreamerInfo is not compiled."");; 2225 }; 2226 // return immediately if we are called recursively.; 2227 if (fInInitInfo); 2228 return;; 2229 fInInitInfo = true;; 2230 if (!fInit) {; 2231 // We were read in from a file, figure out what our fID should be,; 2232 // schema evolution must be considered.; 2233 //; 2234 // Force our fID to be the id of the first streamer element that matches our name.; 2235 //; 2236 auto SetOnfileObject = [this](TStreamerInfo *info) {; 2237 Int_t arrlen = 1;; 2238 if (fType==31 || fType==41) {; 2239 TLeaf *leaf = (TLeaf*)fLeaves.At(0);; 2240 if (leaf) {; 2241 arrlen = leaf->GetMaximum();; 2242 }; 2243 }; 2244 bool toplevel = (fType == 3 || fType ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:79301,Performance,cache,cached,79301,"we found it, we need to make sure it is initialize (Find does not initialize the StreamerInfo).; 2190 info = (TStreamerInfo*)cl->GetStreamerInfo(info->GetClassVersion());; 2191 }; 2192 }; 2193 if( info ) {; 2194 fInfo = info;; 2195 // We no longer reset the class version so that in case the user is passing us later; 2196 // the address of a class that require (another) Conversion we can find the proper; 2197 // StreamerInfo.; 2198 // fClassVersion = fInfo->GetClassVersion();; 2199 }; 2200 }; 2201 }; 2202}; 2203 ; 2204 ; 2205////////////////////////////////////////////////////////////////////////////////; 2206/// Init the streamer info for the branch class, try to compensate for class; 2207/// code unload/reload and schema evolution.; 2208 ; 2209void TBranchElement::InitInfo(); 2210{; 2211 if (!fInfo); 2212 SetupInfo();; 2213 ; 2214 //; 2215 // Fixup cached streamer info if necessary.; 2216 //; 2217 // FIXME: What if the class code was unloaded/reloaded since we were cached?; 2218 ; 2219 if (fInfo) {; 2220 ; 2221 if (!fInfo->IsCompiled()) {; 2222 // Streamer info has not yet been compiled.; 2223 ; 2224 Error(""InitInfo"",""StreamerInfo is not compiled."");; 2225 }; 2226 // return immediately if we are called recursively.; 2227 if (fInInitInfo); 2228 return;; 2229 fInInitInfo = true;; 2230 if (!fInit) {; 2231 // We were read in from a file, figure out what our fID should be,; 2232 // schema evolution must be considered.; 2233 //; 2234 // Force our fID to be the id of the first streamer element that matches our name.; 2235 //; 2236 auto SetOnfileObject = [this](TStreamerInfo *info) {; 2237 Int_t arrlen = 1;; 2238 if (fType==31 || fType==41) {; 2239 TLeaf *leaf = (TLeaf*)fLeaves.At(0);; 2240 if (leaf) {; 2241 arrlen = leaf->GetMaximum();; 2242 }; 2243 }; 2244 bool toplevel = (fType == 3 || fType == 4 || (fType == 0 && fID == -2));; 2245 bool seenExisting = false;; 2246 ; 2247 fOnfileObject = new TVirtualArray( info->GetElement(0)->GetClassPointer(), arrlen );; 2248 // Propag",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:85146,Performance,cache,cache,85146,"2344 }; 2345 }; 2346 subbranch->fOnfileObject = fOnfileObject;; 2347 lastbranch = subbranch;; 2348 }; 2349 }; 2350 if (toplevel) {; 2351 SetBit(kOwnOnfileObj);; 2352 if (lastbranch != this); 2353 lastbranch->ResetBit(kOwnOnfileObj);; 2354 } else {; 2355 lastbranch->SetBit(kOwnOnfileObj);; 2356 }; 2357 };; 2358 if (GetID() > -1) {; 2359 // We are *not* a top-level branch.; 2360 std::string s(GetName());; 2361 size_t pos = s.rfind('.');; 2362 if (pos != std::string::npos) {; 2363 s = s.substr(pos+1);; 2364 }; 2365 while ((pos = s.rfind('[')) != std::string::npos) {; 2366 s = s.substr(0, pos);; 2367 }; 2368 int offset = 0;; 2369 TStreamerElement* elt = fInfo->GetStreamerElement(s.c_str(), offset);; 2370 if (elt && offset!=TStreamerInfo::kMissing) {; 2371 size_t ndata = fInfo->GetNelement();; 2372 fNewIDs.clear();; 2373 for (size_t i = 0; i < ndata; ++i) {; 2374 if (fInfo->GetElement(i) == elt) {; 2375 if (elt->TestBit (TStreamerElement::kCache); 2376 && (i+1) < ndata; 2377 && s == fInfo->GetElement(i)->GetName()); 2378 {; 2379 // If the TStreamerElement we found is storing the information in the; 2380 // cache and is a repeater, we need to use the real one (the next one).; 2381 // (At least until the cache/repeat mechanism is properly handle by; 2382 // ReadLeaves).; 2383 // fID = i+1;; 2384 fID = i;; 2385 if (fType != 2) {; 2386 if (elt->TestBit(TStreamerElement::kRepeat)) {; 2387 fNewIDs.push_back(fID+1);; 2388 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2389 fNewIDs.back().fInfo = fInfo;; 2390 } else if (fInfo->GetElement(i+1)->TestBit(TStreamerElement::kWrite)) {; 2391 fNewIDs.push_back(fID+1);; 2392 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2393 fNewIDs.back().fInfo = fInfo;; 2394 }; 2395 }; 2396 } else {; 2397 fID = i;; 2398 }; 2399 if (elt->TestBit (TStreamerElement::kCache)) {; 2400 SetBit(TBranchElement::kCache);; 2401 }; 2402 break;; 2403 }; 2404 }; 2405 for (size_t i = fID+1+(fNewIDs.size()); i < ndata; ++i) {; 2406 TStreamerElement *nextel =",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:85244,Performance,cache,cache,85244,"354 } else {; 2355 lastbranch->SetBit(kOwnOnfileObj);; 2356 }; 2357 };; 2358 if (GetID() > -1) {; 2359 // We are *not* a top-level branch.; 2360 std::string s(GetName());; 2361 size_t pos = s.rfind('.');; 2362 if (pos != std::string::npos) {; 2363 s = s.substr(pos+1);; 2364 }; 2365 while ((pos = s.rfind('[')) != std::string::npos) {; 2366 s = s.substr(0, pos);; 2367 }; 2368 int offset = 0;; 2369 TStreamerElement* elt = fInfo->GetStreamerElement(s.c_str(), offset);; 2370 if (elt && offset!=TStreamerInfo::kMissing) {; 2371 size_t ndata = fInfo->GetNelement();; 2372 fNewIDs.clear();; 2373 for (size_t i = 0; i < ndata; ++i) {; 2374 if (fInfo->GetElement(i) == elt) {; 2375 if (elt->TestBit (TStreamerElement::kCache); 2376 && (i+1) < ndata; 2377 && s == fInfo->GetElement(i)->GetName()); 2378 {; 2379 // If the TStreamerElement we found is storing the information in the; 2380 // cache and is a repeater, we need to use the real one (the next one).; 2381 // (At least until the cache/repeat mechanism is properly handle by; 2382 // ReadLeaves).; 2383 // fID = i+1;; 2384 fID = i;; 2385 if (fType != 2) {; 2386 if (elt->TestBit(TStreamerElement::kRepeat)) {; 2387 fNewIDs.push_back(fID+1);; 2388 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2389 fNewIDs.back().fInfo = fInfo;; 2390 } else if (fInfo->GetElement(i+1)->TestBit(TStreamerElement::kWrite)) {; 2391 fNewIDs.push_back(fID+1);; 2392 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2393 fNewIDs.back().fInfo = fInfo;; 2394 }; 2395 }; 2396 } else {; 2397 fID = i;; 2398 }; 2399 if (elt->TestBit (TStreamerElement::kCache)) {; 2400 SetBit(TBranchElement::kCache);; 2401 }; 2402 break;; 2403 }; 2404 }; 2405 for (size_t i = fID+1+(fNewIDs.size()); i < ndata; ++i) {; 2406 TStreamerElement *nextel = fInfo->GetElement(i);; 2407 ; 2408 std::string ename = nextel->GetName();; 2409 if (ename[0] == '*'); 2410 ename = ename.substr(1);; 2411 ; 2412 while ((pos = ename.rfind('[')) != std::string::npos) {; 2413 ename = ename.substr(0, pos",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:93901,Performance,load,loaded,93901, = fBranchCount->GetCollectionProxy();; 2593 }; 2594 return fCollProxy;; 2595}; 2596 ; 2597////////////////////////////////////////////////////////////////////////////////; 2598/// Return a pointer to the current type of the data member corresponding to branch element.; 2599 ; 2600TClass* TBranchElement::GetCurrentClass(); 2601{; 2602 TClass* cl = fCurrentClass;; 2603 if (cl) {; 2604 return cl;; 2605 }; 2606 ; 2607 TStreamerInfo* brInfo = (TStreamerInfo*)GetInfoImp();; 2608 if (!brInfo) {; 2609 cl = TClass::GetClass(GetClassName());; 2610 R__ASSERT(cl && cl->GetCollectionProxy());; 2611 fCurrentClass = cl;; 2612 return cl;; 2613 }; 2614 TClass* motherCl = brInfo->GetClass();; 2615 if (motherCl->GetCollectionProxy()) {; 2616 cl = motherCl->GetCollectionProxy()->GetCollectionClass();; 2617 if (cl) {; 2618 fCurrentClass = cl;; 2619 }; 2620 return cl;; 2621 }; 2622 if (GetID() < 0 || GetID()>=brInfo->GetNelement()) {; 2623 return nullptr;; 2624 }; 2625 TStreamerElement* currentStreamerElement = brInfo->GetElement(GetID());; 2626 TDataMember* dm = (TDataMember*) motherCl->GetListOfDataMembers()->FindObject(currentStreamerElement->GetName());; 2627 ; 2628 TString newType;; 2629 if (!dm) {; 2630 // Either the class is not loaded or the data member is gone; 2631 if (!motherCl->IsLoaded()) {; 2632 TVirtualStreamerInfo* newInfo = motherCl->GetStreamerInfo();; 2633 if (newInfo != brInfo) {; 2634 TStreamerElement* newElems = (TStreamerElement*) newInfo->GetElements()->FindObject(currentStreamerElement->GetName());; 2635 if (newElems) {; 2636 if (newElems->GetClassPointer()); 2637 newType = newElems->GetClassPointer()->GetName();; 2638 else; 2639 newType = newElems->GetTypeName();; 2640 }; 2641 }; 2642 if (newType.Length()==0) {; 2643 if (currentStreamerElement->GetClassPointer()); 2644 newType = currentStreamerElement->GetClassPointer()->GetName();; 2645 else; 2646 newType = currentStreamerElement->GetTypeName();; 2647 }; 2648 }; 2649 } else {; 2650 newType = dm->GetTypeName();,MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:105732,Performance,load,load,105732,"/////////////; 2946 ; 2947template Double_t TBranchElement::GetTypedValue(Int_t j, Int_t len, bool subarr) const;; 2948template Long64_t TBranchElement::GetTypedValue(Int_t j, Int_t len, bool subarr) const;; 2949template LongDouble_t TBranchElement::GetTypedValue(Int_t j, Int_t len, bool subarr) const;; 2950 ; 2951template <typename T>; 2952T TBranchElement::GetTypedValue(Int_t j, Int_t len, bool subarr) const; 2953{; 2954 // -- Returns the branch value.; 2955 //; 2956 // If the leaf is an array, j is the index in the array.; 2957 //; 2958 // If leaf is an array inside a TClonesArray, len should be the length; 2959 // of the array.; 2960 //; 2961 // If subarr is true, then len is actually the index within the sub-array.; 2962 //; 2963 ; 2964 ValidateAddress();; 2965 ; 2966 Int_t prID = fID;; 2967 char *object = fObject;; 2968 if (TestBit(kCache)) {; 2969 if (GetInfoImp()->GetElements()->At(fID)->TestBit(TStreamerElement::kRepeat)) {; 2970 prID = fID+1;; 2971 } else if (fOnfileObject) {; 2972 object = fOnfileObject->GetObjectAt(0);; 2973 }; 2974 }; 2975 ; 2976 if (!j && fBranchCount) {; 2977 Long64_t entry = fTree->GetReadEntry();; 2978 // Since reloading the index, will reset the ClonesArray, let's; 2979 // skip the load if we already read this entry.; 2980 if (entry != fBranchCount->GetReadEntry()) {; 2981 fBranchCount->TBranch::GetEntry(entry);; 2982 }; 2983 if (fBranchCount2 && entry != fBranchCount2->GetReadEntry()) {; 2984 fBranchCount2->TBranch::GetEntry(entry);; 2985 }; 2986 }; 2987 ; 2988 if (TestBit(kDecomposedObj)) {; 2989 if (!fAddress) {; 2990 return 0;; 2991 }; 2992 if ((fType == 3) || (fType == 4)) {; 2993 // Top-level branch of a TClonesArray.; 2994 return fNdata;; 2995 } else if ((fType == 31) || (fType == 41)) {; 2996 // sub branch of a TClonesArray; 2997 Int_t atype = fStreamerType;; 2998 if (atype < 20) {; 2999 atype += 20;; 3000 }; 3001 return GetInfoImp()->GetTypedValue<T>(fAddress, atype, j, 1);; 3002 } else if (fType <= 2) {; 3003 // branch in",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:118283,Performance,cache,cached,118283,"TVirtualStreamerInfo* sinfo = subBranch->GetInfoImp();; 3269 if (!sinfo) {; 3270 Warning(""InitializeOffsets"", ""No streamer info for branch: %s subbranch: %s"", GetName(), subBranch->GetName());; 3271 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3272 continue;; 3273 }; 3274 if (!sinfo->IsCompiled()) {; 3275 Warning(""InitializeOffsets"", ""No elements array for branch: %s subbranch: %s"", GetName(), subBranch->GetName());; 3276 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3277 continue;; 3278 }; 3279 // FIXME: Make sure subBranch->fID is in range.; 3280 TStreamerElement* subBranchElement = sinfo->GetElement(subBranch->fID);; 3281 if (!subBranchElement) {; 3282 Warning(""InitializeOffsets"", ""No streamer element for branch: %s subbranch: %s"", GetName(), subBranch->GetName());; 3283 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3284 continue;; 3285 } else if (subBranchElement->TestBit(TStreamerElement::kRepeat)) {; 3286 // If we have a repeating streamerElement, use the next; 3287 // one as it actually hold the 'real' data member('s offset); 3288 if (sinfo->GetElement(subBranch->fID+1)) {; 3289 subBranchElement = sinfo->GetElement(subBranch->fID+1);; 3290 }; 3291 } else if (subBranchElement->TestBit(TStreamerElement::kCache)) {; 3292 // We have a cached item which is not a repeated but we might still; 3293 // have some Actions triggered by a rule that affect real; 3294 // data member(s).; 3295 if (subBranch->fReadActionSequence && subBranch->fReadActionSequence->fActions.size() > 1) {; 3296 typedef TStreamerInfoActions::ActionContainer_t::iterator iterator;; 3297 iterator end = subBranch->fReadActionSequence->fActions.end();; 3298 for(iterator iter = subBranch->fReadActionSequence->fActions.begin();; 3299 iter != end; ++iter) {; 3300 TStreamerInfoActions::TConfiguration *config = iter->fConfiguration;; 3301 UInt_t id = config->fElemId;; 3302 TStreamerElement *e = (TStreamerElement*)config->fInfo->GetElements()->At(id);; 3303 if (e && !e->TestBit",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:128244,Performance,cache,cache,128244," parentName);; 3508 }; 3509 ; 3510 // Remove any leading dot.; 3511 if (dataName.Length()) {; 3512 if (dataName[0] == '.') {; 3513 dataName.Remove(0, 1);; 3514 }; 3515 }; 3516 ; 3517 // Remove any trailing dot.; 3518 if (dataName.Length()) {; 3519 if (dataName[dataName.Length()-1] == '.') {; 3520 dataName.Remove(dataName.Length() - 1, 1);; 3521 }; 3522 }; 3523 ; 3524 //; 3525 // Now that we have our data member name, find our offset; 3526 // in our parent class.; 3527 //; 3528 // Note: Our data member name can have many dots in it; 3529 // if branches were elided between our parent branch; 3530 // and us by Unroll().; 3531 //; 3532 // FIXME: This may not work if our member name is ambiguous.; 3533 //; 3534 ; 3535 Int_t offset = 0;; 3536 if (dataName.Length()) {; 3537 // -- We have our data member name, do a lookup in the dictionary meta info of our parent class.; 3538 // Get our parent class.; 3539 TClass* pClass = nullptr;; 3540 // First check whether this sub-branch is part of the 'cache' (because the data member it; 3541 // represents is no longer in the current class layout.; 3542 TStreamerInfo *subInfo = subBranch->GetInfoImp();; 3543 //if (subInfo && subBranch->TestBit(kCache)) { // subInfo->GetElements()->At(subBranch->GetID())->TestBit(TStreamerElement::kCache)) {; 3544 if (subBranchElement->TestBit(TStreamerElement::kCache)) {; 3545 pClass = ((TStreamerElement*)subInfo->GetElements()->At(0))->GetClassPointer();; 3546 }; 3547 // FIXME: Do we need the other base class tests here?; 3548 if (!pClass) {; 3549 if (fType == 1) {; 3550 // -- Parent branch is a base class branch.; 3551 // FIXME: Is using branchElem here the right thing?; 3552 pClass = branchElem->GetClassPointer();; 3553 if (pClass->Property() & kIsAbstract) {; 3554 // the class is abstract, let see if the; 3555 ; 3556 TBranchElement *parent = (TBranchElement*)GetMother()->GetSubBranch(this);; 3557 if (parent && parent != this && !parent->GetClass()->IsLoaded() ) {; 3558 // Our parent's class is emu",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:185990,Performance,load,loaded,185990,"ject && TestBit(kDeleteObject)){; 5029 ReleaseObject();; 5030 }; 5031 ; 5032 //; 5033 // Remember the pointer to the pointer to our object.; 5034 //; 5035 ; 5036 fAddress = (char*) addr;; 5037 if (fAddress != (char*)(&fObject)) {; 5038 fObject = nullptr;; 5039 }; 5040 ResetBit(kDeleteObject);; 5041 SetBit(kAddressSet);; 5042 ; 5043 //; 5044 // Do special stuff if we got called from a MakeClass class.; 5045 // Allow sub-branches to have independently set addresses.; 5046 //; 5047 ; 5048 if (TestBit(kDecomposedObj)) {; 5049 if (fID > -1) {; 5050 // We are *not* a top-level branch.; 5051 if (!info) {; 5052 // No streamer info, give up.; 5053 // FIXME: We should have an error message here.; 5054 fObject = fAddress;; 5055 } else {; 5056 // Compensate for the fact that the i/o routines; 5057 // will add the streamer offset to the address.; 5058 fObject = fAddress - info->TStreamerInfo::GetElementOffset(fID);; 5059 }; 5060 return;; 5061 }; 5062 }; 5063 ; 5064 //; 5065 // Check whether the container type is still the same; 5066 // to support schema evolution; what is written on the file; 5067 // may no longer match the class code which is loaded.; 5068 //; 5069 ; 5070 if (fType == 3) {; 5071 // split TClonesArray, counter/master branch.; 5072 TClass* clm = fClonesClass;; 5073 if (clm) {; 5074 // In case clm derives from an abstract class.; 5075 clm->BuildRealData();; 5076 clm->GetStreamerInfo();; 5077 }; 5078 TClass* newType = GetCurrentClass();; 5079 if (newType && (newType != TClonesArray::Class())) {; 5080 // The data type of the container has changed.; 5081 //; 5082 // Let's check if it is a compatible type:; 5083 bool matched = false;; 5084 if (newType->GetCollectionProxy()) {; 5085 TClass *content = newType->GetCollectionProxy()->GetValueClass();; 5086 if (clm == content) {; 5087 matched = true;; 5088 } else {; 5089 Warning(""SetAddress"", ""The type of %s was changed from TClonesArray to %s but the content do not match (was %s)!"", GetName(), newType->GetName(), GetClone",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:211874,Performance,optimiz,optimized,211874," = fInfo;; 5673 if (fType == 41) {; 5674 if( fSplitLevel >= TTree::kSplitCollectionOfPointers && fBranchCount->fSTLtype == ROOT::kSTLvector) {; 5675 create = TStreamerInfoActions::TActionSequence::ReadMemberWiseActionsCollectionGetter;; 5676 } else {; 5677 TVirtualStreamerInfo *info = GetInfoImp();; 5678 if (GetParentClass() == info->GetClass()) {; 5679 if( fTargetClass.GetClassName()[0] && fBranchClass != fTargetClass ) {; 5680 originalClass = fBranchClass;; 5681 create = TStreamerInfoActions::TActionSequence::ConversionReadMemberWiseActionsViaProxyGetter;; 5682 } else {; 5683 create = TStreamerInfoActions::TActionSequence::ReadMemberWiseActionsViaProxyGetter;; 5684 }; 5685 } else if (GetCollectionProxy()) {; 5686 // Base class and embedded objects.; 5687 create = TStreamerInfoActions::TActionSequence::ReadMemberWiseActionsCollectionCreator;; 5688 }; 5689 }; 5690 } else if (fType == 31) {; 5691 create = TStreamerInfoActions::TActionSequence::ReadMemberWiseActionsCollectionGetter;; 5692 } else if (0<=fType && fType<=2) {; 5693 // Note: this still requires the ObjectWise sequence to not be optimized!; 5694 create = TStreamerInfoActions::TActionSequence::ReadMemberWiseActionsGetter;; 5695 } else if ( fType == 4 && !fNewIDs.empty()) {; 5696 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 5697 create = TStreamerInfoActions::TActionSequence::ReadMemberWiseActionsCollectionCreator;; 5698 } else if ( fType == 3 && !fNewIDs.empty()) {; 5699 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 5700 create = TStreamerInfoActions::TActionSequence::ReadMemberWiseActionsCollectionGetter;; 5701 }; 5702 ; 5703 if (create) {; 5704 SetActionSequence(originalClass, localInfo, create, fReadActionSequence);; 5705 }; 5706}; 5707 ; 5708////////////////////////////////////////////////////////////////////////////////; 5709/// Set the ReadLeaves pointer to execute the expected operations.; 5710 ; 5711void TBranchElement::SetReadLeavesPtr(); 5712{; 5713 if (TestBit(kDecomposedObj)) {; ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:216619,Performance,optimiz,optimized,216619,"fType == 41) {; 5774 if( fSplitLevel >= TTree::kSplitCollectionOfPointers && fBranchCount->fSTLtype == ROOT::kSTLvector) {; 5775 create = TStreamerInfoActions::TActionSequence::WriteMemberWiseActionsCollectionGetter;; 5776 } else {; 5777 TVirtualStreamerInfo *info = GetInfoImp();; 5778 if (GetParentClass() == info->GetClass()) {; 5779 // if( fTargetClass.GetClassName()[0] && fBranchClass != fTargetClass ) {; 5780 // originalClass = fBranchClass;; 5781 // create = TStreamerInfoActions::TActionSequence::ConversionWriteMemberWiseActionsViaProxyGetter;; 5782 // } else {; 5783 create = TStreamerInfoActions::TActionSequence::WriteMemberWiseActionsViaProxyGetter;; 5784 // }; 5785 } else if (GetCollectionProxy()) {; 5786 // Base class and embedded objects.; 5787 create = TStreamerInfoActions::TActionSequence::WriteMemberWiseActionsCollectionCreator;; 5788 }; 5789 }; 5790 } else if (fType == 31) {; 5791 create = TStreamerInfoActions::TActionSequence::WriteMemberWiseActionsCollectionGetter;; 5792 } else if (0<=fType && fType<=2) {; 5793 // Note: this still requires the ObjectWise sequence to not be optimized!; 5794 create = TStreamerInfoActions::TActionSequence::WriteMemberWiseActionsGetter;; 5795 } else if ( fType == 4 && !fNewIDs.empty()) {; 5796 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 5797 create = TStreamerInfoActions::TActionSequence::WriteMemberWiseActionsCollectionCreator;; 5798 } else if ( fType == 3 && !fNewIDs.empty()) {; 5799 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 5800 create = TStreamerInfoActions::TActionSequence::WriteMemberWiseActionsCollectionGetter;; 5801 }; 5802 ; 5803 if (create) {; 5804 SetActionSequence(originalClass, localInfo, create, fFillActionSequence);; 5805 }; 5806}; 5807 ; 5808////////////////////////////////////////////////////////////////////////////////; 5809/// Set the FillLeaves pointer to execute the expected operations.; 5810 ; 5811void TBranchElement::SetFillLeavesPtr(); 5812{; 5813 if (TestBit(kDecomposedObj) ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:219478,Performance,load,loaded,219478,"ollectionProxy::kIsAssociative) {; 5825 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesAssociativeCollectionMember;; 5826 } else {; 5827 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesCollectionMember;; 5828 }; 5829 } else if (fType == 3) {; 5830 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesClones;; 5831 } else if (fType == 31) {; 5832 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesClonesMember;; 5833 } else if (fType < 0) {; 5834 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesCustomStreamer;; 5835 } else if (fType <=2) {; 5836 //split-class branch, base class branch, data member branch, or top-level branch.; 5837 if (fBranchCount) {; 5838 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesMemberBranchCount;; 5839 } else if (fStreamerType == TVirtualStreamerInfo::kCounter) {; 5840 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesMemberCounter;; 5841 } else {; 5842 fFillLeaves = (FillLeaves_t)&TBranchElement::FillLeavesMember;; 5843 }; 5844 } else {; 5845 Fatal(""SetFillLeavePtr"",""Unexpected branch type %d for %s"",fType,GetName());; 5846 }; 5847 ; 5848 SetFillActionSequence();; 5849}; 5850 ; 5851////////////////////////////////////////////////////////////////////////////////; 5852/// Set the name of the class of the in-memory object into which the data will; 5853/// loaded.; 5854 ; 5855void TBranchElement::SetTargetClass(const char *name); 5856{; 5857 if (name == nullptr) return;; 5858 ; 5859 if (strcmp(fTargetClass.GetClassName(),name) != 0 ); 5860 {; 5861 // We are changing target class, let's reset the meta information and; 5862 // the sub-branches.; 5863 ; 5864 ResetInitInfo(/*recurse=*/ false);; 5865 ; 5866 Int_t nbranches = fBranches.GetEntriesFast();; 5867 for (Int_t i = 0; i < nbranches; ++i) {; 5868 TBranchElement *sub = (TBranchElement*) fBranches[i];; 5869 ; 5870 if (sub->fTargetClass == fTargetClass ) {; 5871 sub->SetTargetClass(name);; 5872 } else {; 5873 // Since the top level changes, the StreamerInfo (",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:222215,Performance,load,loaded,222215,"7 if (fAddress || TestBit(kDecomposedObj)) {; 5898 // -- Do nothing if already setup or if we are a MakeClass branch.; 5899 return;; 5900 }; 5901 SetupAddressesImpl();; 5902}; 5903 ; 5904////////////////////////////////////////////////////////////////////////////////; 5905/// If the branch address is not set, we set all addresses starting with; 5906/// the top level parent branch. This is required to be done in order for; 5907/// GetOffset to be correct and for GetEntry to run.; 5908 ; 5909void TBranchElement::SetupAddressesImpl(); 5910{; 5911 if (TestBit((long)kDoNotProcess|(long)kAddressSet)) {; 5912 // -- Do nothing if we have been told not to.; 5913 // Or the data member in this branch is not longer part of the; 5914 // parent's layout.; 5915 return;; 5916 }; 5917 ; 5918 //--------------------------------------------------------------------------; 5919 // Check if we are splited STL collection of pointers; 5920 /////////////////////////////////////////////////////////////////////////////; 5921 ; 5922 if( fType == 41 && fSplitLevel >= TTree::kSplitCollectionOfPointers ); 5923 {; 5924 TBranchElement *parent = (TBranchElement *)GetMother()->GetSubBranch( this );; 5925 ; 5926 // Make sure the StreamerInfo is loaded and initialized.; 5927 GetInfoImp();; 5928 ; 5929 if( !parent->GetAddress() ); 5930 parent->SetAddress( nullptr );; 5931 return;; 5932 }; 5933 ; 5934 //--------------------------------------------------------------------------; 5935 // Any other case; 5936 /////////////////////////////////////////////////////////////////////////////; 5937 ; 5938 TBranchElement* mother = (TBranchElement*) GetMother();; 5939 if (!mother) {; 5940 return;; 5941 }; 5942 TClass* cl = TClass::GetClass(mother->GetClassName());; 5943 ; 5944 // Make sure the StreamerInfo is loaded and initialized.; 5945 GetInfoImp();; 5946 ; 5947 if (!cl) {; 5948 return;; 5949 }; 5950 ; 5951 if (!mother->GetAddress()) {; 5952 // -- Our top-level branch has no address.; 5953 bool motherStatus = mothe",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:222776,Performance,load,loaded,222776,"mpl(); 5910{; 5911 if (TestBit((long)kDoNotProcess|(long)kAddressSet)) {; 5912 // -- Do nothing if we have been told not to.; 5913 // Or the data member in this branch is not longer part of the; 5914 // parent's layout.; 5915 return;; 5916 }; 5917 ; 5918 //--------------------------------------------------------------------------; 5919 // Check if we are splited STL collection of pointers; 5920 /////////////////////////////////////////////////////////////////////////////; 5921 ; 5922 if( fType == 41 && fSplitLevel >= TTree::kSplitCollectionOfPointers ); 5923 {; 5924 TBranchElement *parent = (TBranchElement *)GetMother()->GetSubBranch( this );; 5925 ; 5926 // Make sure the StreamerInfo is loaded and initialized.; 5927 GetInfoImp();; 5928 ; 5929 if( !parent->GetAddress() ); 5930 parent->SetAddress( nullptr );; 5931 return;; 5932 }; 5933 ; 5934 //--------------------------------------------------------------------------; 5935 // Any other case; 5936 /////////////////////////////////////////////////////////////////////////////; 5937 ; 5938 TBranchElement* mother = (TBranchElement*) GetMother();; 5939 if (!mother) {; 5940 return;; 5941 }; 5942 TClass* cl = TClass::GetClass(mother->GetClassName());; 5943 ; 5944 // Make sure the StreamerInfo is loaded and initialized.; 5945 GetInfoImp();; 5946 ; 5947 if (!cl) {; 5948 return;; 5949 }; 5950 ; 5951 if (!mother->GetAddress()) {; 5952 // -- Our top-level branch has no address.; 5953 bool motherStatus = mother->TestBit(kDoNotProcess);; 5954 mother->ResetBit(kDoNotProcess);; 5955 // Note: This will allocate an object.; 5956 mother->SetAddress(nullptr);; 5957 mother->SetBit(kDoNotProcess, motherStatus);; 5958 }; 5959}; 5960 ; 5961////////////////////////////////////////////////////////////////////////////////; 5962/// Stream an object of class TBranchElement.; 5963 ; 5964void TBranchElement::Streamer(TBuffer& R__b); 5965{; 5966 if (R__b.IsReading()) {; 5967 R__b.ReadClassBuffer(TBranchElement::Class(), this);; 5968 fParentClass.Set",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:228981,Performance,optimiz,optimized,228981,"sses and create branches for each one.; 6095 TObjArray* blist = this->GetListOfBranches();; 6096 TIter next(sinfo->GetElements());; 6097 TStreamerElement* element = nullptr;; 6098 TString bname;; 6099 for (Int_t id = 0; (element = (TStreamerElement*) next()); ++id) {; 6100 if (element->IsA() == TStreamerArtificial::Class()) {; 6101 continue;; 6102 }; 6103 if (element->TestBit(TStreamerElement::kRepeat)) {; 6104 continue;; 6105 }; 6106 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 6107 continue;; 6108 }; 6109 char* pointer = (char*) (objptr + element->GetOffset());; 6110 // FIXME: This is not good enough, an STL container can be; 6111 // a base, and the test will fail.; 6112 // See TBranchElement::InitializeOffsets() for the; 6113 // correct test.; 6114 bool isBase = (element->IsA() == TStreamerBase::Class());; 6115 if (isBase) {; 6116 TClass* clbase = element->GetClassPointer();; 6117 if ((clbase == TObject::Class()) && cl->CanIgnoreTObjectStreamer()) {; 6118 // Note: TStreamerInfo::Compile() leaves this element; 6119 // out of the optimized info, although it does; 6120 // exists in the non-compiled and non-optimized info.; 6121 // FIXME: The test that TStreamerInfo::Compile() uses; 6122 // is element->GetType() < 0, so that is what; 6123 // we should do as well.; 6124 continue;; 6125 }; 6126 if (clbase->GetListOfRealData()->GetSize() == 0) {; 6127 // Do not create a branch for empty bases.; 6128 continue;; 6129 }; 6130 }; 6131 if (dot) {; 6132 if (dotlast) {; 6133 bname.Form(""%s%s"", name, element->GetFullName());; 6134 } else {; 6135 // FIXME: We are in the case where we have a top-level; 6136 // branch name that was created by the branch; 6137 // constructor which takes a folder as input.; 6138 // The internal dots in the name are in place of; 6139 // of the original slashes and represent the; 6140 // folder hierarchy.; 6141 if (isBase) {; 6142 // FIXME: This is very strange, this is the only case where; 6143 // ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:229058,Performance,optimiz,optimized,229058,"sses and create branches for each one.; 6095 TObjArray* blist = this->GetListOfBranches();; 6096 TIter next(sinfo->GetElements());; 6097 TStreamerElement* element = nullptr;; 6098 TString bname;; 6099 for (Int_t id = 0; (element = (TStreamerElement*) next()); ++id) {; 6100 if (element->IsA() == TStreamerArtificial::Class()) {; 6101 continue;; 6102 }; 6103 if (element->TestBit(TStreamerElement::kRepeat)) {; 6104 continue;; 6105 }; 6106 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 6107 continue;; 6108 }; 6109 char* pointer = (char*) (objptr + element->GetOffset());; 6110 // FIXME: This is not good enough, an STL container can be; 6111 // a base, and the test will fail.; 6112 // See TBranchElement::InitializeOffsets() for the; 6113 // correct test.; 6114 bool isBase = (element->IsA() == TStreamerBase::Class());; 6115 if (isBase) {; 6116 TClass* clbase = element->GetClassPointer();; 6117 if ((clbase == TObject::Class()) && cl->CanIgnoreTObjectStreamer()) {; 6118 // Note: TStreamerInfo::Compile() leaves this element; 6119 // out of the optimized info, although it does; 6120 // exists in the non-compiled and non-optimized info.; 6121 // FIXME: The test that TStreamerInfo::Compile() uses; 6122 // is element->GetType() < 0, so that is what; 6123 // we should do as well.; 6124 continue;; 6125 }; 6126 if (clbase->GetListOfRealData()->GetSize() == 0) {; 6127 // Do not create a branch for empty bases.; 6128 continue;; 6129 }; 6130 }; 6131 if (dot) {; 6132 if (dotlast) {; 6133 bname.Form(""%s%s"", name, element->GetFullName());; 6134 } else {; 6135 // FIXME: We are in the case where we have a top-level; 6136 // branch name that was created by the branch; 6137 // constructor which takes a folder as input.; 6138 // The internal dots in the name are in place of; 6139 // of the original slashes and represent the; 6140 // folder hierarchy.; 6141 if (isBase) {; 6142 // FIXME: This is very strange, this is the only case where; 6143 // ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:262426,Performance,load,loaded,262426,6; TBranchElement::fIDInt_t fIDelement serial number in fInfoDefinition TBranchElement.h:66; TBranchElement::GetAddresschar * GetAddress() const overrideGet the branch address.Definition TBranchElement.cxx:1923; TBranchElement::FillLeavesMemberCountervoid FillLeavesMemberCounter(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1697; TBranchElement::SetBranchCount2void SetBranchCount2(TBranchElement *bre)Definition TBranchElement.h:124; TBranchElement::FillLeavesCollectionSplitPtrMembervoid FillLeavesCollectionSplitPtrMember(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1499; TBranchElement::SetAddressvoid SetAddress(void *addobj) overridePoint this branch at an object.Definition TBranchElement.cxx:4962; TBranchElement::GetInfoImpTStreamerInfo * GetInfoImp() constGet streamer info for the branch class.Definition TBranchElement.cxx:1011; TBranchElement::SetTargetClassvirtual void SetTargetClass(const char *name)Set the name of the class of the in-memory object into which the data will loaded.Definition TBranchElement.cxx:5855; TBranchElement::ResetDeleteObjectvirtual void ResetDeleteObject()Release ownership of any allocated objects.Definition TBranchElement.cxx:4814; TBranchElement::GetParentNamevirtual const char * GetParentName() constDefinition TBranchElement.h:200; TBranchElement::ValidateAddressvoid ValidateAddress() constDefinition TBranchElement.h:264; TBranchElement::GetOnfileObjectTVirtualArray * GetOnfileObject() constDefinition TBranchElement.h:199; TBranchElement::fWriteIteratorsTVirtualCollectionIterators * fWriteIterators! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers.Definition TBranchElement.h:102; TBranchElement::PrintValuevoid PrintValue(Int_t i) constPrints values of leaves.Definition TBranchElement.cxx:3928; TBranchElement::fOnfileObjectTVirtualArray * fOnfileObject! Place holder for the onfile representation of data mem,MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:272951,Performance,queue,queues,272951,"ether this branch is in a mode where the object are decomposed or not (Also known as MakeCla...Definition TBranchElement.cxx:2866; TBranchElement::SetAddressImplvoid SetAddressImpl(void *addr, bool implied) overrideSee TBranchElement::SetAddress.Definition TBranchElement.cxx:4970; TBranchElement::SetFillLeavesPtrvoid SetFillLeavesPtr()Set the FillLeaves pointer to execute the expected operations.Definition TBranchElement.cxx:5811; TBranchElement::ReadLeavesCollectionMembervoid ReadLeavesCollectionMember(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4429; TBranchRefA branch containing and managing a TRefTable for TRef autoloading.Definition TBranchRef.h:34; TBranchRef::SetRequestedEntryvirtual void SetRequestedEntry(Long64_t entry)Definition TBranchRef.h:55; TBranchRef::SetParentvirtual Int_t SetParent(const TObject *obj, Int_t branchID)Set the current parent branch.Definition TBranchRef.cxx:212; TBranchSTLA Branch handling STL collection of pointers (vectors, lists, queues, sets and multisets) while stori...Definition TBranchSTL.h:22; TBranchSTL::SetAddressvoid SetAddress(void *addr) overrideSet Address.Definition TBranchSTL.cxx:661; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::ResetAddressvirtual void ResetAddress()Reset the address of the branch.Definition TBranch.cxx:2651; TBranch::fFileNameTString fFileNameName of file where buffers are stored ("""" if in same file as Tree header)Definition TBranch.h:149; TBranch::fEntryOffsetLenInt_t fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers.Definition TBranch.h:119; TBranch::fMaxBasketsInt_t fMaxBasketsMaximum number of Baskets so far.Definition TBranch.h:125; TBranch::GetTreeTTree * GetTree() constDefinition TBranch.h:252; TBranch::fFillLeavesFillLeaves_t fFillLeaves! Pointer to the FillLeaves implementation to use.Definition TBranch.h:163; TBranch::GetFullNamevirtual TString GetFullName() constReturn the 'full' name of the branch.",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:282781,Performance,load,load,282781,"* New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2537; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetStreamerInfosconst TObjArray * GetStreamerInfos() constDefinition TClass.h:492; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:6014; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:285526,Performance,load,load,285526,"t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::ExpandCreateFastvirtual void ExpandCreateFast(Int_t n)Expand or shrink the array to n elements and create the clone objects by calling their default ctor.Definition TClonesArray.cxx:558; TClonesArray::GetClassTClass * GetClass() constDefinition TClonesArray.h:53; TClonesArray::Classstatic TClass * Class(); TCollection::Classstatic TClass * Class(); TCollection::GetNameconst char * GetName() const overrideReturn name of this collection.Definition TCollection.cxx:351; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TC",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:15892,Safety,detect,detection,15892,"ement.; 439 fType = 1;; 440 TClass* clOfElement = element->GetClassPointer();; 441 Int_t nbranches = fBranches.GetEntriesFast();; 442 // Note: The following code results in base class branches; 443 // having two different cases for what their parent; 444 // class will be, this is very annoying. It is also; 445 // very annoying that the naming conventions for the; 446 // sub-branch names are different as well.; 447 if (!strcmp(name, clOfElement->GetName())) {; 448 // -- If the branch's name is the same as the base class name,; 449 // which happens when we are a child branch of a top-level; 450 // branch whose name does not end in a dot and also has no; 451 // internal dots, elide the branch name, and keep the branch; 452 // hierarchy rooted at the ultimate parent, this keeps the base; 453 // class part of the branch name from propagating downwards.; 454 // FIXME: We are eliding the base class here, creating a break in the branch hierarchy.; 455 // Note: We can use parent class (cltop) != branch class (elemClass) to detection elision.; 456 Unroll("""", fBranchClass.GetClass(), clOfElement, pointer, basketsize, splitlevel+splitSTLP, 0);; 457 SetReadLeavesPtr();; 458 SetFillLeavesPtr();; 459 return;; 460 }; 461 // If the branch's name is not the same as the base class name,; 462 // keep the branch name as a prefix (i.e., continue the branch; 463 // hierarchy), but start a new class hierarchy at the base class.; 464 //; 465 // Note: If the parent branch was created by the branch constructor; 466 // which takes a folder as a parameter, then this case will; 467 // be used, because the branch name will be the same as the; 468 // parent branch name.; 469 // Note: This means that the sub-branches of a base class branch; 470 // created by TTree::Bronch() have the base class name as; 471 // as part of the branch name, while those created by; 472 // Unroll() do not, ouch!!!; 473 //; 474 Unroll(name, clOfElement, clOfElement, pointer, basketsize, splitlevel+splitSTLP, 0);; 475 if (",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:51764,Safety,avoid,avoid,51764,"tries, sub-branch writes the entries themselves.; 1429 ValidateAddress();; 1430 ; 1431 //; 1432 // Silently do nothing if we have no user i/o buffer.; 1433 //; 1434 ; 1435 if (!fObject) {; 1436 return;; 1437 }; 1438 ; 1439 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 1440 Int_t n = 0;; 1441 // We are in a block so the helper pops as soon as possible.; 1442 TVirtualCollectionProxy::TPushPop helper(proxy, fObject);; 1443 n = proxy->Size();; 1444 ; 1445 if (n > fMaximum) {; 1446 fMaximum = n;; 1447 }; 1448 b << n;; 1449 ; 1450 if(fSTLtype != ROOT::kSTLvector && proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ) {; 1451 fPtrIterators->CreateIterators(fObject, proxy);; 1452 } else {; 1453 //NOTE: this does not work for not vectors since the CreateIterators expects a TGenCollectionProxy::TStaging as its argument!; 1454 //NOTE: and those not work in general yet, since the TStaging object is neither created nor passed.; 1455 // We need to review how to avoid the need for a TStaging during the writing.; 1456 if (proxy->GetProperties() & TVirtualCollectionProxy::kIsAssociative) {; 1457 fWriteIterators->CreateIterators(fObject, proxy);; 1458 } else {; 1459 fIterators->CreateIterators(fObject, proxy);; 1460 }; 1461 }; 1462 ; 1463}; 1464 ; 1465////////////////////////////////////////////////////////////////////////////////; 1466/// Write leaves into i/o buffers for this branch.; 1467/// Case of a data member within a collection (fType == 41).; 1468 ; 1469void TBranchElement::FillLeavesCollectionSplitVectorPtrMember(TBuffer& b); 1470{; 1471 ValidateAddress();; 1472 ; 1473 //; 1474 // Silently do nothing if we have no user i/o buffer.; 1475 //; 1476 ; 1477 if (!fObject) {; 1478 return;; 1479 }; 1480 ; 1481 // FIXME: This wont work if a pointer to vector is split!; 1482 TVirtualCollectionProxy::TPushPop helper(GetCollectionProxy(), fObject);; 1483 // Note: We cannot pop the proxy here because we need it for the i/o.; 1484 TStreamerInfo* si = (TStre",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:116178,Safety,avoid,avoid,116178,"= nullptr;; 3221 } else {; 3222 renamed = branchClass && branchElem->GetNewClass() && (branchClass != branchElem->GetNewClass());; 3223 }; 3224 } else {; 3225 renamed = fTargetClass != fBranchClass;; 3226 }; 3227 if (!branchClass) {; 3228 Error(""InitializeOffsets"", ""Could not find class for branch: %s"", GetName());; 3229 fInitOffsets = true;; 3230 return;; 3231 }; 3232 ; 3233 //------------------------------------------------------------------------; 3234 // Extract the name of the STL branch in case it has been split.; 3235 //////////////////////////////////////////////////////////////////////////; 3236 ; 3237 TString stlParentName;; 3238 bool stlParentNameUpdated = false;; 3239 if( fType == 4 ); 3240 {; 3241 TBranch *br = GetMother()->GetSubBranch( this );; 3242 stlParentName = br->GetName();; 3243 stlParentName = stlParentName.Strip( TString::kTrailing, '.' );; 3244 ; 3245 // We may ourself contain the 'Mother' branch name.; 3246 // To avoid code duplication, we delegate the removal; 3247 // of the mother's name to the first sub-branch loop.; 3248 }; 3249 ; 3250 // Loop over our sub-branches and compute their offsets.; 3251 for (Int_t subBranchIdx = 0; subBranchIdx < nbranches; ++subBranchIdx) {; 3252 bool alternateElement = false;; 3253 ; 3254 fBranchOffset[subBranchIdx] = 0;; 3255 TBranchElement* subBranch = dynamic_cast<TBranchElement*> (fBranches[subBranchIdx]);; 3256 if (subBranch == nullptr) {; 3257 // -- Skip sub-branches that are not TBranchElements.; 3258 continue;; 3259 }; 3260 ; 3261 if (renamed) {; 3262 if (subBranch->fBranchClass == branchClass) {; 3263 if (branchElem) subBranch->SetTargetClass(branchElem->GetNewClass()->GetName());; 3264 else subBranch->SetTargetClass(fTargetClass->GetName());; 3265 }; 3266 }; 3267 ; 3268 TVirtualStreamerInfo* sinfo = subBranch->GetInfoImp();; 3269 if (!sinfo) {; 3270 Warning(""InitializeOffsets"", ""No streamer info for branch: %s subbranch: %s"", GetName(), subBranch->GetName());; 3271 fBranchOffset[subBranchIdx] = TS",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:138790,Safety,detect,detect,138790,"f (index >= 0) {; 3748 fReadActionSequence->AddToOffset( - parent->fBranchOffset[index] );; 3749 }; 3750 }; 3751 ; 3752 fInitOffsets = true;; 3753}; 3754 ; 3755////////////////////////////////////////////////////////////////////////////////; 3756/// Return true if more than one leaf, false otherwise.; 3757 ; 3758bool TBranchElement::IsFolder() const; 3759{; 3760 Int_t nbranches = fBranches.GetEntriesFast();; 3761 if (nbranches >= 1) {; 3762 return true;; 3763 }; 3764 TList* browsables = const_cast<TBranchElement*>(this)->GetBrowsables();; 3765 return browsables && browsables->GetSize();; 3766}; 3767 ; 3768////////////////////////////////////////////////////////////////////////////////; 3769/// Detect a collection written using a zero pointer in old versions of root.; 3770/// In versions of ROOT older than 4.00/03, if a collection (TClonesArray; 3771/// or STL container) was split but the pointer to the collection was zeroed; 3772/// out, nothing was saved. Hence there is no __easy__ way to detect the; 3773/// case. In newer versions, a zero is written so that a 'missing' collection; 3774/// appears to be an empty collection.; 3775 ; 3776bool TBranchElement::IsMissingCollection() const; 3777{; 3778 bool ismissing = false;; 3779 TBasket* basket = (TBasket*) fBaskets.UncheckedAt(fReadBasket);; 3780 if (basket && fTree) {; 3781 Long64_t entry = fTree->GetReadEntry();; 3782 Long64_t first = fBasketEntry[fReadBasket];; 3783 Long64_t last;; 3784 if (fReadBasket == fWriteBasket) {; 3785 last = fEntryNumber - 1;; 3786 } else {; 3787 last = fBasketEntry[fReadBasket+1] - 1;; 3788 }; 3789 Int_t* entryOffset = basket->GetEntryOffset();; 3790 Int_t bufbegin;; 3791 Int_t bufnext;; 3792 if (entryOffset) {; 3793 bufbegin = entryOffset[entry-first];; 3794 ; 3795 if (entry < last) {; 3796 bufnext = entryOffset[entry+1-first];; 3797 } else {; 3798 bufnext = basket->GetLast();; 3799 }; 3800 if (bufnext == bufbegin) {; 3801 ismissing = true;; 3802 } else {; 3803 // fixed length buffer so",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:154555,Safety,recover,recover,154555,"k;}; 4143 case 17: {b.ReadFastArray((ULong64_t*)fAddress, n); break;}; 4144 case 18: {b.ReadFastArray((bool*) fAddress, n); break;}; 4145 case 9: {; 4146 TVirtualStreamerInfo* si = GetInfoImp();; 4147 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 4148 Double_t *xx = (Double_t*) fAddress;; 4149 for (Int_t ii=0;ii<n;ii++) {; 4150 b.ReadDouble32(&(xx[ii]),se);; 4151 }; 4152 break;; 4153 }; 4154 case 19: {; 4155 TVirtualStreamerInfo* si = GetInfoImp();; 4156 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 4157 Float_t *xx = (Float_t*) fAddress;; 4158 for (Int_t ii=0;ii<n;ii++) {; 4159 b.ReadFloat16(&(xx[ii]),se);; 4160 }; 4161 break;; 4162 }; 4163 }; 4164 return;; 4165 } else if (fType <= 2) { // branch in split mode; 4166 // FIXME: This should probably be < 60 instead.; 4167 if (fStreamerType > 40 && fStreamerType < 55) {; 4168 Int_t atype = fStreamerType - 40;; 4169 Int_t n;; 4170 if (fBranchCount==nullptr) {; 4171 // Missing fBranchCount. let's attempts to recover.; 4172 ; 4173 TString countname( GetName() );; 4174 Ssiz_t dot = countname.Last('.');; 4175 if (dot>=0) {; 4176 countname.Remove(dot+1);; 4177 } else {; 4178 countname = """";; 4179 }; 4180 TString counter( GetTitle() );; 4181 Ssiz_t loc = counter.Last('[');; 4182 if (loc>=0) {; 4183 counter.Remove(0,loc+1);; 4184 }; 4185 loc = counter.Last(']');; 4186 if (loc>=0) {; 4187 counter.Remove(loc);; 4188 }; 4189 countname += counter;; 4190 SetBranchCount((TBranchElement *)fTree->GetBranch(countname));; 4191 }; 4192 if (fBranchCount) {; 4193 n = (Int_t)fBranchCount->GetValue(0,0);; 4194 } else {; 4195 Warning(""ReadLeaves"",""Missing fBranchCount for %s. Data will not be read correctly by the MakeClass mode."",GetName());; 4196 n = 0;; 4197 }; 4198 fNdata = n;; 4199 Char_t isArray;; 4200 b >> isArray;; 4201 switch (atype) {; 4202 case 1: {b.ReadFastArray((Char_t*) fAddress, n); break;}; 4203 case 2: {b.ReadFastArray((Short_t*) fAddress, n); break;}; 4204 case 3: {b.ReadFastArray((Int_t",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:158942,Safety,safe,safety,158942,") || (n > fMaximum)) {; 4281 if (IsMissingCollection()) {; 4282 n = 0;; 4283 b.SetBufferOffset(b.Length()-sizeof(n));; 4284 } else {; 4285 Error(""ReadLeaves"", ""Incorrect size read for the container in %s\n\tThe size read is %d while the maximum is %d\n\tThe size is reset to 0 for this entry (%lld)"", GetName(), n, fMaximum, GetReadEntry());; 4286 n = 0;; 4287 }; 4288 }; 4289 fNdata = n;; 4290 ; 4291 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,1);; 4292 ; 4293 // Note: Proxy-helper needs to ""embrace"" the entire; 4294 // streaming of this STL container if the container; 4295 // is a set/multiset/map/multimap (what we do not; 4296 // know here).; 4297 // For vector/list/deque Allocate == Resize; 4298 // and Commit == noop.; 4299 // TODO: Exception safety a la TPushPop; 4300 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4301 TVirtualCollectionProxy::TPushPop helper(proxy, fObject);; 4302 void* alternate = proxy->Allocate(fNdata, true);; 4303 if(fSTLtype != ROOT::kSTLvector && proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ) {; 4304 fPtrIterators->CreateIterators(alternate, proxy);; 4305 } else {; 4306 fIterators->CreateIterators(alternate, proxy);; 4307 }; 4308 ; 4309 Int_t nbranches = fBranches.GetEntriesFast();; 4310 switch (fSTLtype) {; 4311 case ROOT::kSTLset:; 4312 case ROOT::kSTLunorderedset:; 4313 case ROOT::kSTLunorderedmultiset:; 4314 case ROOT::kSTLmultiset:; 4315 case ROOT::kSTLmap:; 4316 case ROOT::kSTLmultimap:; 4317 case ROOT::kSTLunorderedmap:; 4318 case ROOT::kSTLunorderedmultimap:; 4319 for (Int_t i = 0; i < nbranches; ++i) {; 4320 TBranch *branch = (TBranch*) fBranches[i];; 4321 Int_t nb = branch->GetEntry(GetReadEntry(), 1);; 4322 if (nb < 0) {; 4323 // Give up on i/o failure.; 4324 // FIXME: We need an error message here.; 4325 break;; 4326 }; 4327 }; 4328 break;; 4329 default:; 4330 break;; 4331 }; 4332 //------------------------------------------------------------------------; 4333 // We have split thi",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:224368,Safety,avoid,avoid,224368," Stream an object of class TBranchElement.; 5963 ; 5964void TBranchElement::Streamer(TBuffer& R__b); 5965{; 5966 if (R__b.IsReading()) {; 5967 R__b.ReadClassBuffer(TBranchElement::Class(), this);; 5968 fParentClass.SetName(fParentName);; 5969 fBranchClass.SetName(fClassName);; 5970 fTargetClass.SetName(fClassName);; 5971 fClonesClass.SetName(fClonesName);; 5972 // The fAddress and fObject data members are not persistent,; 5973 // therefore we do not own anything.; 5974 // Also clear the bit possibly set by the schema evolution.; 5975 ResetBit(kDeleteObject|kCache|kOwnOnfileObj|kAddressSet|kDecomposedObj);; 5976 // Fixup a case where the TLeafElement was missing; 5977 if ((fType == 0) && (fLeaves.GetEntriesFast() == 0)) {; 5978 TLeaf* leaf = new TLeafElement(this, GetTitle(), fID, fStreamerType);; 5979 leaf->SetTitle(GetTitle());; 5980 fNleaves = 1;; 5981 fLeaves.Add(leaf);; 5982 fTree->GetListOfLeaves()->Add(leaf);; 5983 }; 5984 ; 5985 // SetReadLeavesPtr();; 5986 }; 5987 else {; 5988 TDirectory* dirsav = fDirectory;; 5989 fDirectory = nullptr; // to avoid recursive calls; 5990 {; 5991 // Save class version.; 5992 Int_t classVersion = fClassVersion;; 5993 // Record only positive 'version number'; 5994 if (fClassVersion < 0) {; 5995 fClassVersion = -fClassVersion;; 5996 }; 5997 // TODO: Should we clear the kDeleteObject bit before writing?; 5998 // If we did we would have to remember the old value and; 5999 // put it back, we wouldn't want to forget that we owned; 6000 // something just because we got written to disk.; 6001 R__b.WriteClassBuffer(TBranchElement::Class(), this);; 6002 // Restore class version.; 6003 fClassVersion = classVersion;; 6004 }; 6005 //; 6006 // Mark all streamer infos used by this branch element; 6007 // to be written to our output file.; 6008 //; 6009 {; 6010 R__b.ForceWriteInfo(GetInfoImp(), true);; 6011 }; 6012 //; 6013 // If we are a clones array master branch, or an; 6014 // STL container master branch, we must also mark; 6015 // the str",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:235996,Safety,detect,detection,235996,"base class gets TStreamerSTL as its class, so this test is not enough.; 6263 // See InitializeOffsets() for the proper test.; 6264 if (elem->IsA() == TStreamerBase::Class()) {; 6265 // -- This is a base class of cl.; 6266 TClass* clOfBase = elem->GetClassPointer();; 6267 if (!clOfBase || ((clOfBase->Property() & kIsAbstract) && cl->InheritsFrom(TCollection::Class()))) {; 6268 // -- Do nothing if we are one of the abstract collection (we know they have no data).; 6269 return -1;; 6270 }; 6271 if ((btype == 31) || (btype == 41)) {; 6272 // -- Elide the base-class sub-branches of a split TClonesArray or STL container.; 6273 //; 6274 // Note: We are eliding the base class here, that is, we never; 6275 // create a branch for it, so the branch hierarchy is not; 6276 // complete.; 6277 // Note: The clParent parameter is the value class of the; 6278 // container which we are splitting. It does not; 6279 // appear in the branch hierarchy either.; 6280 // Note: We can use parent class (clParent) != branch class (elemClass) to detection elision.; 6281 Int_t unroll = -1;; 6282 if (!elem->CannotSplit() || clOfBase == TObject::Class()) {; 6283 unroll = Unroll(name, clParent, clOfBase, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6284 }; 6285 if (unroll < 0) {; 6286 // FIXME: We could not split because we are abstract, should we be doing this?; 6287 if (namelen) {; 6288 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6289 } else {; 6290 branchname.Form(""%s"", elem->GetFullName());; 6291 }; 6292 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, nullptr, basketsize, 0, btype);; 6293 branch->SetParentClass(clParent);; 6294 fBranches.Add(branch);; 6295 }; 6296 } else if (clOfBase->GetListOfRealData()->GetSize()) {; 6297 // -- Create a branch for a non-empty base class.; 6298 if (namelen) {; 6299 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6300 // Elide the base class name when creating the ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:239831,Safety,detect,detection,239831,"tParentClass(clParent);; 6339 fBranches.Add(branch);; 6340 } else if (elemClass->InheritsFrom(TClonesArray::Class())) {; 6341 // Splitting something derived from TClonesArray.; 6342 Int_t subSplitlevel = splitlevel-1;; 6343 if (btype == 31 || btype == 41 || elem->CannotSplit()) {; 6344 // -- We split the sub-branches of a TClonesArray or an STL container only once.; 6345 subSplitlevel = 0;; 6346 }; 6347 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, ptr + offset, basketsize, subSplitlevel, btype);; 6348 branch->SetParentClass(clParent);; 6349 fBranches.Add(branch);; 6350 } else {; 6351 // Splitting a normal class.; 6352 // FIXME: We are eliding the class we are splitting here,; 6353 // i.e., we do not create a branch for it, so the; 6354 // branch hierarchy does not match the class hierarchy.; 6355 // Note: clParent is the class which contains a data member of; 6356 // the class type which we are splitting.; 6357 // Note: We can use parent class (clParent) != branch class (elemClass) to detection elision.; 6358 Int_t unroll = Unroll(branchname, clParent, elemClass, ptr + offset, basketsize, splitlevel-1+splitSTLP, btype);; 6359 if (unroll < 0) {; 6360 // FIXME: We could not split because we are abstract, should we be doing this?; 6361 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, ptr + offset, basketsize, 0, btype);; 6362 branch->SetParentClass(clParent);; 6363 fBranches.Add(branch);; 6364 }; 6365 }; 6366 }; 6367 else if( elem->GetClassPointer() &&; 6368 elem->GetClassPointer()->GetCollectionProxy() &&; 6369 elem->GetClassPointer()->GetCollectionProxy()->HasPointers() &&; 6370 splitSTLP && fType != 4 ); 6371 {; 6372 ; 6373 TBranchSTL* branch = new TBranchSTL( this, branchname,; 6374 elem->GetClassPointer()->GetCollectionProxy(),; 6375 basketsize, splitlevel - 1+splitSTLP, sinfo, elemID );; 6376 branch->SetAddress( ptr+offset );; 6377 fBranches.Add( branch );; 6378 }; 6379 else if ((elem->IsA() == TStreamer",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:20972,Security,access,access,20972,";; 558 } else if (((fSTLtype >= ROOT::kSTLvector) && (fSTLtype < ROOT::kSTLend)) || ((fSTLtype > -ROOT::kSTLend) && (fSTLtype <= -ROOT::kSTLvector))) {; 559 // -- We are an STL container element.; 560 TClass* contCl = elementClass;; 561 fCollProxy = contCl->GetCollectionProxy()->Generate();; 562 TClass* valueClass = GetCollectionProxy()->GetValueClass();; 563 // Check to see if we can split the container.; 564 bool cansplit = true;; 565 if (!valueClass) {; 566 cansplit = false;; 567 } else if ((valueClass == TString::Class()) || (valueClass == TClass::GetClass(""string""))) {; 568 cansplit = false;; 569 } else if (GetCollectionProxy()->HasPointers() && !splitSTLP ) {; 570 cansplit = false;; 571 } else if (!valueClass->CanSplit() && !(GetCollectionProxy()->HasPointers() && splitSTLP)) {; 572 cansplit = false;; 573 } else if (valueClass->GetCollectionProxy()) {; 574 // -- A collection was stored in a collection, we choose not to split it.; 575 // Note: Splitting it would require extending TTreeFormula; 576 // to understand how to access it.; 577 cansplit = false;; 578 }; 579 if (cansplit) {; 580 // -- Do the splitting work if we are allowed to.; 581 fType = 4;; 582 // Create a leaf for the master branch (the counter).; 583 TLeaf *leaf = new TLeafElement(this, name, fID, fStreamerType);; 584 fNleaves = 1;; 585 fLeaves.Add(leaf);; 586 fTree->GetListOfLeaves()->Add(leaf);; 587 // Check that the contained objects class name is part of the element title.; 588 // This name is mandatory when reading the tree later on and; 589 // the parent class with the pointer to the STL container is not available.; 590 fClonesName = valueClass->GetName();; 591 fClonesClass = valueClass;; 592 TString aname;; 593 aname.Form("" (%s)"", valueClass->GetName());; 594 TString atitle = element->GetTitle();; 595 if (!atitle.Contains(aname)) {; 596 atitle += aname;; 597 element->SetTitle(atitle.Data());; 598 }; 599 TString branchname (name);; 600 if (branchname.EndsWith(""."")); 601 branchname.Remove(bra",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:77509,Security,checksum,checksum,77509,"e());; 2141 return;; 2142 }; 2143 } else {; 2144 targetClass = cl;; 2145 }; 2146 if (cl) {; 2147 //---------------------------------------------------------------------; 2148 // Get the streamer info for given version; 2149 ///////////////////////////////////////////////////////////////////////; 2150 ; 2151 {; 2152 if ( (cl->Property() & kIsAbstract) && cl == targetClass) {; 2153 TBranchElement *parent = (TBranchElement*)GetMother()->GetSubBranch(this);; 2154 if (parent && parent != this && !parent->GetClass()->IsLoaded() ) {; 2155 // Our parent's class is emulated and we represent an abstract class.; 2156 // and the target class has not been set explicitly.; 2157 TString target = cl->GetName();; 2158 target += ""@@emulated"";; 2159 fTargetClass.SetName(target);; 2160 ; 2161 if (!fTargetClass) {; 2162 cl->GetStreamerInfoAbstractEmulated(fClassVersion);; 2163 }; 2164 targetClass = fTargetClass;; 2165 }; 2166 }; 2167 if( targetClass != cl ) {; 2168 fInfo = (TStreamerInfo*)targetClass->GetConversionStreamerInfo( cl, fClassVersion );; 2169 } else {; 2170 fInfo = (TStreamerInfo*)cl->GetStreamerInfo(fClassVersion);; 2171 }; 2172 }; 2173 ; 2174 // FIXME: Check that the found streamer info checksum matches our branch class checksum here.; 2175 // Check to see if the class code was unloaded/reloaded; 2176 // since we were created.; 2177 R__LOCKGUARD(gInterpreterMutex);; 2178 if (fCheckSum && (cl->IsForeign() || (!cl->IsLoaded() && (fClassVersion == 1) && cl->GetStreamerInfos()->At(1) && (fCheckSum != ((TVirtualStreamerInfo*) cl->GetStreamerInfos()->At(1))->GetCheckSum())))) {; 2179 // Try to compensate for a class that got unloaded on us.; 2180 // Search through the streamer infos by checksum; 2181 // and take the first match.; 2182 ; 2183 TStreamerInfo* info;; 2184 if( targetClass != cl ); 2185 info = (TStreamerInfo*)targetClass->FindConversionStreamerInfo( cl, fCheckSum );; 2186 else {; 2187 info = (TStreamerInfo*)cl->FindStreamerInfo( fCheckSum );; 2188 if (info) {; 2189 // ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:77543,Security,checksum,checksum,77543,"e());; 2141 return;; 2142 }; 2143 } else {; 2144 targetClass = cl;; 2145 }; 2146 if (cl) {; 2147 //---------------------------------------------------------------------; 2148 // Get the streamer info for given version; 2149 ///////////////////////////////////////////////////////////////////////; 2150 ; 2151 {; 2152 if ( (cl->Property() & kIsAbstract) && cl == targetClass) {; 2153 TBranchElement *parent = (TBranchElement*)GetMother()->GetSubBranch(this);; 2154 if (parent && parent != this && !parent->GetClass()->IsLoaded() ) {; 2155 // Our parent's class is emulated and we represent an abstract class.; 2156 // and the target class has not been set explicitly.; 2157 TString target = cl->GetName();; 2158 target += ""@@emulated"";; 2159 fTargetClass.SetName(target);; 2160 ; 2161 if (!fTargetClass) {; 2162 cl->GetStreamerInfoAbstractEmulated(fClassVersion);; 2163 }; 2164 targetClass = fTargetClass;; 2165 }; 2166 }; 2167 if( targetClass != cl ) {; 2168 fInfo = (TStreamerInfo*)targetClass->GetConversionStreamerInfo( cl, fClassVersion );; 2169 } else {; 2170 fInfo = (TStreamerInfo*)cl->GetStreamerInfo(fClassVersion);; 2171 }; 2172 }; 2173 ; 2174 // FIXME: Check that the found streamer info checksum matches our branch class checksum here.; 2175 // Check to see if the class code was unloaded/reloaded; 2176 // since we were created.; 2177 R__LOCKGUARD(gInterpreterMutex);; 2178 if (fCheckSum && (cl->IsForeign() || (!cl->IsLoaded() && (fClassVersion == 1) && cl->GetStreamerInfos()->At(1) && (fCheckSum != ((TVirtualStreamerInfo*) cl->GetStreamerInfos()->At(1))->GetCheckSum())))) {; 2179 // Try to compensate for a class that got unloaded on us.; 2180 // Search through the streamer infos by checksum; 2181 // and take the first match.; 2182 ; 2183 TStreamerInfo* info;; 2184 if( targetClass != cl ); 2185 info = (TStreamerInfo*)targetClass->FindConversionStreamerInfo( cl, fCheckSum );; 2186 else {; 2187 info = (TStreamerInfo*)cl->FindStreamerInfo( fCheckSum );; 2188 if (info) {; 2189 // ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:78012,Security,checksum,checksum,78012,"e();; 2158 target += ""@@emulated"";; 2159 fTargetClass.SetName(target);; 2160 ; 2161 if (!fTargetClass) {; 2162 cl->GetStreamerInfoAbstractEmulated(fClassVersion);; 2163 }; 2164 targetClass = fTargetClass;; 2165 }; 2166 }; 2167 if( targetClass != cl ) {; 2168 fInfo = (TStreamerInfo*)targetClass->GetConversionStreamerInfo( cl, fClassVersion );; 2169 } else {; 2170 fInfo = (TStreamerInfo*)cl->GetStreamerInfo(fClassVersion);; 2171 }; 2172 }; 2173 ; 2174 // FIXME: Check that the found streamer info checksum matches our branch class checksum here.; 2175 // Check to see if the class code was unloaded/reloaded; 2176 // since we were created.; 2177 R__LOCKGUARD(gInterpreterMutex);; 2178 if (fCheckSum && (cl->IsForeign() || (!cl->IsLoaded() && (fClassVersion == 1) && cl->GetStreamerInfos()->At(1) && (fCheckSum != ((TVirtualStreamerInfo*) cl->GetStreamerInfos()->At(1))->GetCheckSum())))) {; 2179 // Try to compensate for a class that got unloaded on us.; 2180 // Search through the streamer infos by checksum; 2181 // and take the first match.; 2182 ; 2183 TStreamerInfo* info;; 2184 if( targetClass != cl ); 2185 info = (TStreamerInfo*)targetClass->FindConversionStreamerInfo( cl, fCheckSum );; 2186 else {; 2187 info = (TStreamerInfo*)cl->FindStreamerInfo( fCheckSum );; 2188 if (info) {; 2189 // Now that we found it, we need to make sure it is initialize (Find does not initialize the StreamerInfo).; 2190 info = (TStreamerInfo*)cl->GetStreamerInfo(info->GetClassVersion());; 2191 }; 2192 }; 2193 if( info ) {; 2194 fInfo = info;; 2195 // We no longer reset the class version so that in case the user is passing us later; 2196 // the address of a class that require (another) Conversion we can find the proper; 2197 // StreamerInfo.; 2198 // fClassVersion = fInfo->GetClassVersion();; 2199 }; 2200 }; 2201 }; 2202}; 2203 ; 2204 ; 2205////////////////////////////////////////////////////////////////////////////////; 2206/// Init the streamer info for the branch class, try to compensate for cla",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:97249,Security,validat,validation,97249,"this, fBranchID);; 2685 bref->SetRequestedEntry(entry);; 2686 }; 2687 ; 2688 Int_t nbytes = 0;; 2689 ; 2690 if (R__unlikely(IsAutoDelete())) {; 2691 SetBit(kDeleteObject);; 2692 SetAddress(fAddress);; 2693 } else {; 2694 if (R__unlikely(!fAddress && !TestBit(kDecomposedObj))) {; 2695 R__LOCKGUARD_IMT(gROOTMutex); // Lock for parallel TTree I/O; 2696 SetupAddressesImpl();; 2697 }; 2698 }; 2699 ; 2700 Int_t nbranches = fBranches.GetEntriesFast();; 2701 if (nbranches) {; 2702 // -- Branch has daughters.; 2703 // One must always read the branch counter.; 2704 // In the case when one reads consecutively twice the same entry,; 2705 // the user may have cleared the TClonesArray between the GetEntry calls.; 2706 if ((fType == 3) || (fType == 4)) {; 2707 Int_t nb = TBranch::GetEntry(entry, getall);; 2708 if (nb < 0) {; 2709 return nb;; 2710 }; 2711 nbytes += nb;; 2712 }; 2713 switch(fSTLtype) {; 2714 case ROOT::kSTLset:; 2715 case ROOT::kSTLmultiset:; 2716 case ROOT::kSTLunorderedset:; 2717 case ROOT::kSTLunorderedmultiset:; 2718 case ROOT::kSTLmap:; 2719 case ROOT::kSTLmultimap:; 2720 case ROOT::kSTLunorderedmap:; 2721 case ROOT::kSTLunorderedmultimap:; 2722 break;; 2723 default:; 2724 ValidateAddress(); // There is no ReadLeave for this node, so we need to do the validation here.; 2725 for (Int_t i = 0; i < nbranches; ++i) {; 2726 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 2727 Int_t nb = branch->GetEntry(entry, getall);; 2728 if (nb < 0) {; 2729 return nb;; 2730 }; 2731 nbytes += nb;; 2732 }; 2733 break;; 2734 }; 2735 if (!TestBit(kDecomposedObj) && fReadActionSequence && !fReadActionSequence->fActions.empty()) {; 2736 if (fType == 3) {; 2737 // Apply the unattached rules; by definition they do not need any; 2738 // input from a buffer.; 2739 TBufferFile b(TBufferFile::kRead, 1);; 2740 ; 2741 auto ndata = GetNdata();; 2742 ; 2743 TClonesArray* clones = (TClonesArray*) fObject;; 2744 if (clones->IsZombie()) {; 2745 return -1;; 2746 }; 2747 R__PushCache onfileO",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:166541,Security,validat,validate,166541,"read for the container in %s\n\tThe size read is %d while the maximum is %d\n\tThe size is reset to 0 for this entry (%lld)"", GetName(), n, fMaximum, GetReadEntry());; 4481 n = 0;; 4482 }; 4483 }; 4484 fNdata = n;; 4485 TClonesArray* clones = (TClonesArray*) fObject;; 4486 if (clones->IsZombie()) {; 4487 return;; 4488 }; 4489 // The salient part of Clear is now 'duplicated in ExpandCreateFast (i.e. the; 4490 // setting to zero of the unused slots), so we no longer need to call Clear explicitly; 4491 // clones->Clear();; 4492 clones->ExpandCreateFast(fNdata);; 4493}; 4494 ; 4495////////////////////////////////////////////////////////////////////////////////; 4496/// Read leaves into i/o buffers for this branch.; 4497/// Case of a data member within a TClonesArray (fType == 31).; 4498 ; 4499void TBranchElement::ReadLeavesClonesMember(TBuffer& b); 4500{; 4501 // No need to validate the address here, if we are a member of a split ClonesArray,; 4502 // fID is positive; 4503 // ValidateAddress();; 4504 ; 4505 if (fObject == nullptr); 4506 {; 4507 // We have nowhere to copy the data (probably because the data member was; 4508 // 'dropped' from the current schema) so let's no copy it in a random place.; 4509 return;; 4510 }; 4511 ; 4512 // TClonesArray sub-branch (contains the elements).; 4513 fNdata = fBranchCount->GetNdata();; 4514 TClonesArray* clones = (TClonesArray*) fObject;; 4515 if (clones->IsZombie()) {; 4516 return;; 4517 }; 4518 TStreamerInfo *info = GetInfoImp();; 4519 if (info==nullptr) return;; 4520 // Since info is not null, fReadActionSequence is not null either.; 4521 ; 4522 // Note, we could (possibly) save some more, by configuring the action; 4523 // based on the value of fOnfileObject rather than pushing in on a stack.; 4524 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,fNdata);; 4525 ; 4526 char **arr = (char **)clones->GetObjectRef();; 4527 char **end = arr + fNdata;; 4528 b.ApplySequenceVecPtr(*fReadActionSequence,arr,end);; 4529}; 4530 ;",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:284808,Security,checksum,checksum,284808,"ent=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::ExpandCreateFastvirtual void ExpandCreateFast(Int_",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:284914,Security,checksum,checksum,284914,"ent=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::ExpandCreateFastvirtual void ExpandCreateFast(Int_",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:285112,Security,checksum,checksum,285112," TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::ExpandCreateFastvirtual void ExpandCreateFast(Int_t n)Expand or shrink the array to n elements and create the clone objects by calling their default ctor.Definition TClonesArray.cxx:558; TClonesArray::GetClassTClass * GetClass() constDefinition TClonesArray.h:53; TClonesArray::Classstatic TClass * Class(); TCollection::Classstatic TClass * Class(); TCollecti",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:285195,Security,checksum,checksum,285195," TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::ExpandCreateFastvirtual void ExpandCreateFast(Int_t n)Expand or shrink the array to n elements and create the clone objects by calling their default ctor.Definition TClonesArray.cxx:558; TClonesArray::GetClassTClass * GetClass() constDefinition TClonesArray.h:53; TClonesArray::Classstatic TClass * Class(); TCollection::Classstatic TClass * Class(); TCollecti",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:304001,Security,access,access,304001,"reamerInfo for class cl.Definition TTree.cxx:2652; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::GetDefaultEntryOffsetLenInt_t GetDefaultEntryOffsetLen() constDefinition TTree.h:459; TTree::GetListOfLeavesvirtual TObjArray * GetListOfLeaves()Definition TTree.h:529; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::DebugInt_t Debug() constDefinition TTree.h:429; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetDebugMinLong64_t GetDebugMin() constDefinition TTree.h:461; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualArray::GetObjectAtchar * GetObjectAt(UInt_t ind) constDefinition TVirtualArray.h:41; TVirtualArray::SetSizevoid SetSize(UInt_t size)Definition TVirtualArray.h:43; TVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators.Definition TVirtualCollectionIterators.h:26; TVirtualCollectionIterators::CreateIteratorsvoid CreateIterators(void *collection, TVirtualCollectionProxy *proxy)Definition TVirtualCollectionIterators.h:65; TVirtualCollectionIterators::fBeginvoid * fBeginDefinition TVirtualCollectionIterators.h:41; TVirtualCollectionIterators::fEndvoid * fEndDefinition TVirtualCollectionIterators.h:42; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:43755,Testability,test,test,43755,"he function returns the number of bytes committed to the; 1223/// individual branches. If a write error occurs, the number of; 1224/// bytes returned is -1. If no data are written, because, e.g.,; 1225/// the branch is disabled, the number of bytes returned is 0.; 1226///; 1227/// Note: We not not use any member functions from TLeafElement!; 1228 ; 1229Int_t TBranchElement::FillImpl(ROOT::Internal::TBranchIMTHelper *imtHelper); 1230{; 1231 Int_t nbytes = 0;; 1232 Int_t nwrite = 0;; 1233 Int_t nerror = 0;; 1234 Int_t nbranches = fBranches.GetEntriesFast();; 1235 ; 1236 ValidateAddress();; 1237 ; 1238 //; 1239 // If we are a top-level branch, update addresses.; 1240 //; 1241 ; 1242 if (fID < 0) {; 1243 if (!fObject) {; 1244 Error(""Fill"", ""attempt to fill branch %s while address is not set"", GetName());; 1245 return 0;; 1246 }; 1247 }; 1248 ; 1249 //; 1250 // If the tree has a TRefTable, set the current branch if; 1251 // branch is not a basic type.; 1252 //; 1253 ; 1254 // FIXME: This test probably needs to be extended past 10.; 1255 if ((fType >= -1) && (fType < 10)) {; 1256 TBranchRef* bref = fTree->GetBranchRef();; 1257 if (bref) {; 1258 fBranchID = bref->SetParent(this, fBranchID);; 1259 }; 1260 }; 1261 ; 1262 if (!nbranches) {; 1263 // No sub-branches.; 1264 if (!TestBit(kDoNotProcess)) {; 1265 nwrite = TBranch::FillImpl(imtHelper);; 1266 if (nwrite < 0) {; 1267 Error(""Fill"", ""Failed filling branch:%s, nbytes=%d"", GetName(), nwrite);; 1268 ++nerror;; 1269 } else {; 1270 nbytes += nwrite;; 1271 }; 1272 }; 1273 } else {; 1274 // We have sub-branches.; 1275 if (fType == 3 || fType == 4) {; 1276 // TClonesArray or STL container counter; 1277 nwrite = TBranch::FillImpl(imtHelper);; 1278 if (nwrite < 0) {; 1279 Error(""Fill"", ""Failed filling branch:%s, nbytes=%d"", GetName(), nwrite);; 1280 ++nerror;; 1281 } else {; 1282 nbytes += nwrite;; 1283 }; 1284 } else {; 1285 ++fEntries;; 1286 }; 1287 for (Int_t i = 0; i < nbranches; ++i) {; 1288 TBranchElement* branch = (TBranchE",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:111908,Testability,test,test,111908,"ta members so that when; 3124/// SetAddress recursively sets their address, they will get the; 3125/// same address as their containing class because i/o is based; 3126/// on streamer info offsets from the address of the containing; 3127/// class.; 3128///; 3129/// Offsets are non-zero for base-class sub-branches that are; 3130/// not the leftmost direct base class. They are laid out in; 3131/// memory sequentially and only the leftmost direct base class; 3132/// has the same address as the derived class. The streamer; 3133/// offsets need to be added to the address of the base class; 3134/// subobject which is not the same as the address of the; 3135/// derived class for the non-leftmost direct base classes.; 3136 ; 3137void TBranchElement::InitializeOffsets(); 3138{; 3139 Int_t nbranches = fBranches.GetEntriesFast();; 3140 ; 3141 // See https://sft.its.cern.ch/jira/browse/ROOT-8742; 3142 // and https://sft.its.cern.ch/jira/browse/ROOT-9253; 3143 // As of commit e21b4f1a3b, removing this lock lead to a failure; 3144 // in the test testSetAddress[Loop].; 3145 // As of commit 4f8b237849, removing this lock does not lead to; 3146 // a visible failure in test. This might be due to the underlying; 3147 // problem (missing lock or ?) being solved somewhere else or some; 3148 // other perturbation reducing the failure rate.; 3149 // Having the lock here is not too costly as InitializeOffsets is; 3150 // one called once in the lifetime of the TBranch.; 3151 R__LOCKGUARD(gInterpreterMutex);; 3152 ; 3153 if (fID < 0) {; 3154 // -- We are a top-level branch. Let's mark whether we need to use MapObject.; 3155 if (CanSelfReference(fBranchClass)) {; 3156 if (fBranchClass.GetClass()->IsTObject()) {; 3157 SetBit(kBranchObject);; 3158 } else {; 3159 SetBit(kBranchAny);; 3160 }; 3161 }; 3162 }; 3163 if (nbranches) {; 3164 // Allocate space for the new sub-branch offsets.; 3165 delete[] fBranchOffset;; 3166 fBranchOffset = nullptr;; 3167 fBranchOffset = new Int_t[nbranches];; 3168 //",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:111913,Testability,test,testSetAddress,111913,"ta members so that when; 3124/// SetAddress recursively sets their address, they will get the; 3125/// same address as their containing class because i/o is based; 3126/// on streamer info offsets from the address of the containing; 3127/// class.; 3128///; 3129/// Offsets are non-zero for base-class sub-branches that are; 3130/// not the leftmost direct base class. They are laid out in; 3131/// memory sequentially and only the leftmost direct base class; 3132/// has the same address as the derived class. The streamer; 3133/// offsets need to be added to the address of the base class; 3134/// subobject which is not the same as the address of the; 3135/// derived class for the non-leftmost direct base classes.; 3136 ; 3137void TBranchElement::InitializeOffsets(); 3138{; 3139 Int_t nbranches = fBranches.GetEntriesFast();; 3140 ; 3141 // See https://sft.its.cern.ch/jira/browse/ROOT-8742; 3142 // and https://sft.its.cern.ch/jira/browse/ROOT-9253; 3143 // As of commit e21b4f1a3b, removing this lock lead to a failure; 3144 // in the test testSetAddress[Loop].; 3145 // As of commit 4f8b237849, removing this lock does not lead to; 3146 // a visible failure in test. This might be due to the underlying; 3147 // problem (missing lock or ?) being solved somewhere else or some; 3148 // other perturbation reducing the failure rate.; 3149 // Having the lock here is not too costly as InitializeOffsets is; 3150 // one called once in the lifetime of the TBranch.; 3151 R__LOCKGUARD(gInterpreterMutex);; 3152 ; 3153 if (fID < 0) {; 3154 // -- We are a top-level branch. Let's mark whether we need to use MapObject.; 3155 if (CanSelfReference(fBranchClass)) {; 3156 if (fBranchClass.GetClass()->IsTObject()) {; 3157 SetBit(kBranchObject);; 3158 } else {; 3159 SetBit(kBranchAny);; 3160 }; 3161 }; 3162 }; 3163 if (nbranches) {; 3164 // Allocate space for the new sub-branch offsets.; 3165 delete[] fBranchOffset;; 3166 fBranchOffset = nullptr;; 3167 fBranchOffset = new Int_t[nbranches];; 3168 //",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:112035,Testability,test,test,112035,"ir containing class because i/o is based; 3126/// on streamer info offsets from the address of the containing; 3127/// class.; 3128///; 3129/// Offsets are non-zero for base-class sub-branches that are; 3130/// not the leftmost direct base class. They are laid out in; 3131/// memory sequentially and only the leftmost direct base class; 3132/// has the same address as the derived class. The streamer; 3133/// offsets need to be added to the address of the base class; 3134/// subobject which is not the same as the address of the; 3135/// derived class for the non-leftmost direct base classes.; 3136 ; 3137void TBranchElement::InitializeOffsets(); 3138{; 3139 Int_t nbranches = fBranches.GetEntriesFast();; 3140 ; 3141 // See https://sft.its.cern.ch/jira/browse/ROOT-8742; 3142 // and https://sft.its.cern.ch/jira/browse/ROOT-9253; 3143 // As of commit e21b4f1a3b, removing this lock lead to a failure; 3144 // in the test testSetAddress[Loop].; 3145 // As of commit 4f8b237849, removing this lock does not lead to; 3146 // a visible failure in test. This might be due to the underlying; 3147 // problem (missing lock or ?) being solved somewhere else or some; 3148 // other perturbation reducing the failure rate.; 3149 // Having the lock here is not too costly as InitializeOffsets is; 3150 // one called once in the lifetime of the TBranch.; 3151 R__LOCKGUARD(gInterpreterMutex);; 3152 ; 3153 if (fID < 0) {; 3154 // -- We are a top-level branch. Let's mark whether we need to use MapObject.; 3155 if (CanSelfReference(fBranchClass)) {; 3156 if (fBranchClass.GetClass()->IsTObject()) {; 3157 SetBit(kBranchObject);; 3158 } else {; 3159 SetBit(kBranchAny);; 3160 }; 3161 }; 3162 }; 3163 if (nbranches) {; 3164 // Allocate space for the new sub-branch offsets.; 3165 delete[] fBranchOffset;; 3166 fBranchOffset = nullptr;; 3167 fBranchOffset = new Int_t[nbranches];; 3168 // Make sure we can instantiate our class meta info.; 3169 if (!fBranchClass.GetClass()) {; 3170 Warning(""InitializeOffsets""",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:114284,Testability,test,tested,114284,"fBranchClass.GetClass()->GetName());; 3177 fInitOffsets = true;; 3178 return;; 3179 }; 3180 ; 3181 // Get the class we are a member of now (which is the; 3182 // type of our containing subobject) and get our offset; 3183 // inside of our containing subobject (our local offset).; 3184 // Note: branchElem stays zero if we are a top-level branch,; 3185 // we have to be careful about this later.; 3186 TStreamerElement* branchElem = nullptr;; 3187 Int_t localOffset = 0;; 3188 TClass* branchClass = fBranchClass.GetClass();; 3189 bool renamed = false;; 3190 if (fID > -1) {; 3191 // -- Branch is *not* a top-level branch.; 3192 // Instead of the streamer info class, we want the class of our; 3193 // specific element in the streamer info. We could be a data; 3194 // member of a base class or a split class, in which case our; 3195 // streamer info will be for our containing sub-object, while; 3196 // we are actually a different type.; 3197 TVirtualStreamerInfo* si = GetInfoImp();; 3198 // Note: We tested to make sure the streamer info was available previously.; 3199 if (!si->IsCompiled()) {; 3200 Warning(""InitializeOffsets"", ""Streamer info for branch: %s has no elements array!"", GetName());; 3201 fInitOffsets = true;; 3202 return;; 3203 }; 3204 // FIXME: Check that fID is in range.; 3205 branchElem = si->GetElement(fID);; 3206 if (!branchElem) {; 3207 Warning(""InitializeOffsets"", ""Cannot get streamer element for branch: %s!"", GetName());; 3208 fInitOffsets = true;; 3209 return;; 3210 } else if (branchElem->TestBit(TStreamerElement::kRepeat)) {; 3211 // If we have a repeating streamerElement, use the next; 3212 // one as it actually hold the 'real' data member('s offset); 3213 if (si->GetElement(fID+1)) {; 3214 branchElem = si->GetElement(fID+1);; 3215 }; 3216 }; 3217 localOffset = branchElem->GetOffset();; 3218 branchClass = branchElem->GetClassPointer();; 3219 if (localOffset == TStreamerInfo::kMissing) {; 3220 fObject = nullptr;; 3221 } else {; 3222 renamed = branchClass && b",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:122933,Testability,test,test,122933,"End) {; 3391 // -- Remove the top-level branch name from our name.; 3392 dataName.Remove(0, motherName.Length());; 3393 // stlParentNameUpdated is false the first time in this loop.; 3394 if (!stlParentNameUpdated && stlParentName.Length()) {; 3395 stlParentName.Remove(0, motherName.Length());; 3396 stlParentNameUpdated = true;; 3397 }; 3398 } else if (motherDot) {; 3399 // -- Remove the top-level branch name from our name, folder case.; 3400 //; 3401 // Note: We are in the case where our mother was created; 3402 // by the branch constructor which takes a folder; 3403 // as an argument. The mother branch has internal; 3404 // dots in its name to represent the folder hierarchy.; 3405 // The TTree::Bronch() routine has handled us as a; 3406 // special case, we must compensate.; 3407 if ((fID < 0) && (subBranchElement->IsA() == TStreamerBase::Class())) {; 3408 // -- Our name is the mother name, remove it.; 3409 // Note: The test is our parent is a top-level branch; 3410 // and our streamer is the base class streamer,; 3411 // this matches the exact test in TTree::Bronch().; 3412 if (dataName.Length() == motherName.Length()) {; 3413 dataName.Remove(0, motherName.Length());; 3414 // stlParentNameUpdated is false the first time in this loop.; 3415 if (!stlParentNameUpdated && stlParentName.Length()) {; 3416 stlParentName.Remove(0, motherName.Length());; 3417 }; 3418 }; 3419 } else {; 3420 // -- Remove the mother name and the dot.; 3421 if (dataName.Length() > motherName.Length()) {; 3422 dataName.Remove(0, motherName.Length() + 1);; 3423 if (!stlParentNameUpdated && stlParentName.Length()) {; 3424 stlParentName.Remove(0, motherName.Length());; 3425 }; 3426 }; 3427 }; 3428 }; 3429 stlParentNameUpdated = true;; 3430 if (isBaseSubBranch) {; 3431 // -- Remove the base class name suffix from our name.; 3432 // Note: The pattern is the name of the base class.; 3433 TString pattern(subBranchElement->GetName());; 3434 if (pattern.Length() <= dataName.Length()) {; 3435 if (!strcmp(",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:123060,Testability,test,test,123060,"End) {; 3391 // -- Remove the top-level branch name from our name.; 3392 dataName.Remove(0, motherName.Length());; 3393 // stlParentNameUpdated is false the first time in this loop.; 3394 if (!stlParentNameUpdated && stlParentName.Length()) {; 3395 stlParentName.Remove(0, motherName.Length());; 3396 stlParentNameUpdated = true;; 3397 }; 3398 } else if (motherDot) {; 3399 // -- Remove the top-level branch name from our name, folder case.; 3400 //; 3401 // Note: We are in the case where our mother was created; 3402 // by the branch constructor which takes a folder; 3403 // as an argument. The mother branch has internal; 3404 // dots in its name to represent the folder hierarchy.; 3405 // The TTree::Bronch() routine has handled us as a; 3406 // special case, we must compensate.; 3407 if ((fID < 0) && (subBranchElement->IsA() == TStreamerBase::Class())) {; 3408 // -- Our name is the mother name, remove it.; 3409 // Note: The test is our parent is a top-level branch; 3410 // and our streamer is the base class streamer,; 3411 // this matches the exact test in TTree::Bronch().; 3412 if (dataName.Length() == motherName.Length()) {; 3413 dataName.Remove(0, motherName.Length());; 3414 // stlParentNameUpdated is false the first time in this loop.; 3415 if (!stlParentNameUpdated && stlParentName.Length()) {; 3416 stlParentName.Remove(0, motherName.Length());; 3417 }; 3418 }; 3419 } else {; 3420 // -- Remove the mother name and the dot.; 3421 if (dataName.Length() > motherName.Length()) {; 3422 dataName.Remove(0, motherName.Length() + 1);; 3423 if (!stlParentNameUpdated && stlParentName.Length()) {; 3424 stlParentName.Remove(0, motherName.Length());; 3425 }; 3426 }; 3427 }; 3428 }; 3429 stlParentNameUpdated = true;; 3430 if (isBaseSubBranch) {; 3431 // -- Remove the base class name suffix from our name.; 3432 // Note: The pattern is the name of the base class.; 3433 TString pattern(subBranchElement->GetName());; 3434 if (pattern.Length() <= dataName.Length()) {; 3435 if (!strcmp(",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:125434,Testability,test,test,125434,"; 3449 // in our modified name here.; 3450 }; 3451 ; 3452 // Get our parent branch's name.; 3453 TString parentName(GetName());; 3454 if (motherDotAtEnd) {; 3455 // -- Remove the top-level branch name from our parent's name.; 3456 parentName.Remove(0, motherName.Length());; 3457 } else if (motherDot) {; 3458 // -- Remove the top-level branch name from our parent's name, folder case.; 3459 //; 3460 // Note: We are in the case where our mother was created; 3461 // by the branch constructor which takes a folder; 3462 // as an argument. The mother branch has internal; 3463 // dots in its name to represent the folder hierarchy.; 3464 // The TTree::Bronch() routine has handled us as a; 3465 // special case, we must compensate.; 3466 if ((fID > -1) && (mother == mother->GetSubBranch(this)) && (branchElem->IsA() == TStreamerBase::Class())) {; 3467 // -- Our parent's name is the mother name, remove it.; 3468 // Note: The test is our parent's parent is a top-level branch; 3469 // and our parent's streamer is the base class streamer,; 3470 // this matches the exact test in TTree::Bronch().; 3471 if (parentName.Length() == motherName.Length()) {; 3472 parentName.Remove(0, motherName.Length());; 3473 }; 3474 } else {; 3475 // -- Remove the mother name and the dot.; 3476 if (parentName.Length() > motherName.Length()) {; 3477 parentName.Remove(0, motherName.Length() + 1);; 3478 }; 3479 }; 3480 }; 3481 // FIXME: Do we need to use the other tests for a base class here?; 3482 if (fType == 1) {; 3483 // -- Our parent is a base class sub-branch, remove the base class name suffix from its name.; 3484 if (mother != mother->GetSubBranch(this)) {; 3485 // -- My parent's parent is not a top-level branch.; 3486 // Remove the base class name suffix from the parent name.; 3487 // Note: The pattern is the name of the base class.; 3488 // coverity[var_deref_model] branchElem is non zero here since fType==1 and thus fID > -1; 3489 TString pattern(branchElem->GetName());; 3490 if (pattern.Length() ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:125579,Testability,test,test,125579,"; 3449 // in our modified name here.; 3450 }; 3451 ; 3452 // Get our parent branch's name.; 3453 TString parentName(GetName());; 3454 if (motherDotAtEnd) {; 3455 // -- Remove the top-level branch name from our parent's name.; 3456 parentName.Remove(0, motherName.Length());; 3457 } else if (motherDot) {; 3458 // -- Remove the top-level branch name from our parent's name, folder case.; 3459 //; 3460 // Note: We are in the case where our mother was created; 3461 // by the branch constructor which takes a folder; 3462 // as an argument. The mother branch has internal; 3463 // dots in its name to represent the folder hierarchy.; 3464 // The TTree::Bronch() routine has handled us as a; 3465 // special case, we must compensate.; 3466 if ((fID > -1) && (mother == mother->GetSubBranch(this)) && (branchElem->IsA() == TStreamerBase::Class())) {; 3467 // -- Our parent's name is the mother name, remove it.; 3468 // Note: The test is our parent's parent is a top-level branch; 3469 // and our parent's streamer is the base class streamer,; 3470 // this matches the exact test in TTree::Bronch().; 3471 if (parentName.Length() == motherName.Length()) {; 3472 parentName.Remove(0, motherName.Length());; 3473 }; 3474 } else {; 3475 // -- Remove the mother name and the dot.; 3476 if (parentName.Length() > motherName.Length()) {; 3477 parentName.Remove(0, motherName.Length() + 1);; 3478 }; 3479 }; 3480 }; 3481 // FIXME: Do we need to use the other tests for a base class here?; 3482 if (fType == 1) {; 3483 // -- Our parent is a base class sub-branch, remove the base class name suffix from its name.; 3484 if (mother != mother->GetSubBranch(this)) {; 3485 // -- My parent's parent is not a top-level branch.; 3486 // Remove the base class name suffix from the parent name.; 3487 // Note: The pattern is the name of the base class.; 3488 // coverity[var_deref_model] branchElem is non zero here since fType==1 and thus fID > -1; 3489 TString pattern(branchElem->GetName());; 3490 if (pattern.Length() ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:125956,Testability,test,tests,125956,"onstructor which takes a folder; 3462 // as an argument. The mother branch has internal; 3463 // dots in its name to represent the folder hierarchy.; 3464 // The TTree::Bronch() routine has handled us as a; 3465 // special case, we must compensate.; 3466 if ((fID > -1) && (mother == mother->GetSubBranch(this)) && (branchElem->IsA() == TStreamerBase::Class())) {; 3467 // -- Our parent's name is the mother name, remove it.; 3468 // Note: The test is our parent's parent is a top-level branch; 3469 // and our parent's streamer is the base class streamer,; 3470 // this matches the exact test in TTree::Bronch().; 3471 if (parentName.Length() == motherName.Length()) {; 3472 parentName.Remove(0, motherName.Length());; 3473 }; 3474 } else {; 3475 // -- Remove the mother name and the dot.; 3476 if (parentName.Length() > motherName.Length()) {; 3477 parentName.Remove(0, motherName.Length() + 1);; 3478 }; 3479 }; 3480 }; 3481 // FIXME: Do we need to use the other tests for a base class here?; 3482 if (fType == 1) {; 3483 // -- Our parent is a base class sub-branch, remove the base class name suffix from its name.; 3484 if (mother != mother->GetSubBranch(this)) {; 3485 // -- My parent's parent is not a top-level branch.; 3486 // Remove the base class name suffix from the parent name.; 3487 // Note: The pattern is the name of the base class.; 3488 // coverity[var_deref_model] branchElem is non zero here since fType==1 and thus fID > -1; 3489 TString pattern(branchElem->GetName());; 3490 if (pattern.Length() <= parentName.Length()) {; 3491 if (!strcmp(parentName.Data() + (parentName.Length() - pattern.Length()), pattern.Data())) {; 3492 // The branch name contains the name of the base class in it.; 3493 // This name is not reproduced in the sub-branches, so we need to; 3494 // remove it.; 3495 parentName.Remove(parentName.Length() - pattern.Length());; 3496 }; 3497 }; 3498 }; 3499 // Note: We intentionally leave any trailing dots; 3500 // in the modified parent name here.; 3501 }; ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:128745,Testability,test,tests,128745,"3522 }; 3523 ; 3524 //; 3525 // Now that we have our data member name, find our offset; 3526 // in our parent class.; 3527 //; 3528 // Note: Our data member name can have many dots in it; 3529 // if branches were elided between our parent branch; 3530 // and us by Unroll().; 3531 //; 3532 // FIXME: This may not work if our member name is ambiguous.; 3533 //; 3534 ; 3535 Int_t offset = 0;; 3536 if (dataName.Length()) {; 3537 // -- We have our data member name, do a lookup in the dictionary meta info of our parent class.; 3538 // Get our parent class.; 3539 TClass* pClass = nullptr;; 3540 // First check whether this sub-branch is part of the 'cache' (because the data member it; 3541 // represents is no longer in the current class layout.; 3542 TStreamerInfo *subInfo = subBranch->GetInfoImp();; 3543 //if (subInfo && subBranch->TestBit(kCache)) { // subInfo->GetElements()->At(subBranch->GetID())->TestBit(TStreamerElement::kCache)) {; 3544 if (subBranchElement->TestBit(TStreamerElement::kCache)) {; 3545 pClass = ((TStreamerElement*)subInfo->GetElements()->At(0))->GetClassPointer();; 3546 }; 3547 // FIXME: Do we need the other base class tests here?; 3548 if (!pClass) {; 3549 if (fType == 1) {; 3550 // -- Parent branch is a base class branch.; 3551 // FIXME: Is using branchElem here the right thing?; 3552 pClass = branchElem->GetClassPointer();; 3553 if (pClass->Property() & kIsAbstract) {; 3554 // the class is abstract, let see if the; 3555 ; 3556 TBranchElement *parent = (TBranchElement*)GetMother()->GetSubBranch(this);; 3557 if (parent && parent != this && !parent->GetClass()->IsLoaded() ) {; 3558 // Our parent's class is emulated and we represent an abstract class.; 3559 // and the target class has not been set explicitly.; 3560 TString target = pClass->GetName();; 3561 target += ""@@emulated"";; 3562 ; 3563 pClass = TClass::GetClass(target);; 3564 }; 3565 }; 3566 } else {; 3567 // -- Parent branch is *not* a base class branch.; 3568 // FIXME: This sometimes returns a nu",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:145767,Testability,log,logic,145767,"D = fID+1;; 3938 } else if (fOnfileObject) {; 3939 object = fOnfileObject->GetObjectAt(0);; 3940 }; 3941 }; 3942 ; 3943 if (TestBit(kDecomposedObj)) {; 3944 if (!fAddress) {; 3945 return;; 3946 }; 3947 if (fType == 3 || fType == 4) {; 3948 // TClonesArray or STL container top-level branch.; 3949 printf("" %-15s = %d\n"", GetName(), fNdata);; 3950 return;; 3951 } else if (fType == 31 || fType == 41) {; 3952 // TClonesArray or STL container sub-branch.; 3953 Int_t n = TMath::Min(10, fNdata);; 3954 Int_t atype = fStreamerType + TVirtualStreamerInfo::kOffsetL;; 3955 if (fStreamerType == TVirtualStreamerInfo::kChar) {; 3956 // TVirtualStreamerInfo::kOffsetL + TVirtualStreamerInfo::kChar is; 3957 // printed as a string and could print weird characters.; 3958 // So we print an unsigned char instead (not perfect, but better).; 3959 atype = TVirtualStreamerInfo::kOffsetL + TVirtualStreamerInfo::kUChar;; 3960 }; 3961 if (atype > 54) {; 3962 // FIXME: More logic required here (like in ReadLeaves); 3963 printf("" %-15s = %d\n"", GetName(), fNdata);; 3964 return;; 3965 }; 3966 if (fStreamerType > 20) {; 3967 atype -= 20;; 3968 TLeafElement* leaf = (TLeafElement*) fLeaves.UncheckedAt(0);; 3969 n = n * leaf->GetLenStatic();; 3970 }; 3971 if (GetInfoImp()) {; 3972 GetInfoImp()->PrintValue(GetName(), fAddress, atype, n, lenmax);; 3973 }; 3974 return;; 3975 } else if (fType <= 2) {; 3976 // Branch in split mode.; 3977 // FIXME: This should probably be < 60 instead.; 3978 if ((fStreamerType > 40) && (fStreamerType < 55)) {; 3979 Int_t atype = fStreamerType - 20;; 3980 TBranchElement* counterElement = (TBranchElement*) fBranchCount;; 3981 Int_t n = (Int_t) counterElement->GetValue(0, 0);; 3982 if (GetInfoImp()) {; 3983 GetInfoImp()->PrintValue(GetName(), fAddress, atype, n, lenmax);; 3984 }; 3985 } else {; 3986 if (GetInfoImp()) {; 3987 GetInfoImp()->PrintValue(GetName(), object, prID, -1, lenmax);; 3988 }; 3989 }; 3990 return;; 3991 }; 3992 } else if (fType == 3) {; 3993 printf("" %-15s = ",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:181981,Testability,test,test,181981,"tAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well because those routines call this one.; 4901///; 4902/// An example of a tree with branches with objects allocated; 4903/// and owned by us:; 4904/// ~~~ {.cpp}; 4905/// TFile* f1 = new TFile(""myfile_original.root"");; 4906/// TTree* t1 = (TTree*) f->Get(""MyTree"");; 4907/// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; 4908/// TTree* t2 = t1->Clone(0);; 4909/// for (Int_t i = 0; i < 10; ++i) {; 4910/// t1->GetEntry(i);; 4911/// t2->Fill();; 4912/// }; 4913/// t2->Write(); 4914/// delete f2;; 4915/// f2 = 0;; 4916/// delete f1;; 4917/// f1 = 0;; 4918/// ~~~; 4919/// An example of a branch with an object allocated by us,; 4920/// but owned by the caller:; 4921/// ~~~ {.cpp}; 4922/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4923/// TTree* t = new TTree(""t"", ""A test tree.""); 4924/// Event* event = 0;; 4925/// TBranchElement* br = t->Branch(""event."", &event);; 4926/// for (Int_t i = 0; i < 10; ++i) {; 4927/// ... Fill event with meaningful data in some way.; 4928/// t->Fill();; 4929/// }; 4930/// t->Write();; 4931/// delete event;; 4932/// event = 0;; 4933/// delete f;; 4934/// f = 0;; 4935/// ~~~; 4936/// Notice that the only difference between this example; 4937/// and the following example is that the event pointer; 4938/// is zero when the branch is created.; 4939///; 4940/// An example of a branch with an object allocated and; 4941/// owned by the caller:; 4942/// ~~~ {.cpp}; 4943/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4944/// TTree* t = new TTree(""t"", ""A test tree.""); 4945/// Event* event = new Event();; 4946/// TBranchElement* br = t->Branch(""event."", &event);; 4947/// for (Int_t i = 0; i < 10; ++i) {; 4948/// ... Fill event with meaningful data in some way.; 4949/// t->Fill();; 4950/// }; 4951/// t",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:182707,Testability,test,test,182707,"14/// delete f2;; 4915/// f2 = 0;; 4916/// delete f1;; 4917/// f1 = 0;; 4918/// ~~~; 4919/// An example of a branch with an object allocated by us,; 4920/// but owned by the caller:; 4921/// ~~~ {.cpp}; 4922/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4923/// TTree* t = new TTree(""t"", ""A test tree.""); 4924/// Event* event = 0;; 4925/// TBranchElement* br = t->Branch(""event."", &event);; 4926/// for (Int_t i = 0; i < 10; ++i) {; 4927/// ... Fill event with meaningful data in some way.; 4928/// t->Fill();; 4929/// }; 4930/// t->Write();; 4931/// delete event;; 4932/// event = 0;; 4933/// delete f;; 4934/// f = 0;; 4935/// ~~~; 4936/// Notice that the only difference between this example; 4937/// and the following example is that the event pointer; 4938/// is zero when the branch is created.; 4939///; 4940/// An example of a branch with an object allocated and; 4941/// owned by the caller:; 4942/// ~~~ {.cpp}; 4943/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4944/// TTree* t = new TTree(""t"", ""A test tree.""); 4945/// Event* event = new Event();; 4946/// TBranchElement* br = t->Branch(""event."", &event);; 4947/// for (Int_t i = 0; i < 10; ++i) {; 4948/// ... Fill event with meaningful data in some way.; 4949/// t->Fill();; 4950/// }; 4951/// t->Write();; 4952/// delete event;; 4953/// event = 0;; 4954/// delete f;; 4955/// f = 0;; 4956/// ~~~; 4957/// If AutoDelete is on (see TBranch::SetAutoDelete),; 4958/// the top level objet will be deleted and recreate; 4959/// each time an entry is read, whether or not the; 4960/// TTree owns the object.; 4961 ; 4962void TBranchElement::SetAddress(void* addr); 4963{; 4964 SetAddressImpl(addr, (addr == nullptr));; 4965}; 4966 ; 4967/// See TBranchElement::SetAddress.; 4968/// If implied is true, we do not over-ride existing address for; 4969/// sub-branches.; 4970void TBranchElement::SetAddressImpl(void* addr, bool implied); 4971{; 4972 //; 4973 // Don't bother if we are disabled.; 4974 //; 4975 ; 4976 if (TestBit(kD",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:198643,Testability,test,test,198643,"llocate.; 5338 SetBit(kDeleteObject);; 5339 fObject = (char*) new TClonesArray(fClonesClass);; 5340 fAddress = (char*) &fObject;; 5341 } else {; 5342 // -- We are a sub-branch which is a pointer to a TClonesArray.; 5343 Error(""SetAddress"", ""Embedded pointer to a TClonesArray given a zero address for branch '%s'"", GetName());; 5344 }; 5345 }; 5346 }; 5347 } else if (fType == 4) {; 5348 // -- We are an STL container master branch.; 5349 //; 5350 // Initialize fCollProxy.; 5351 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 5352 if (fAddress) {; 5353 // -- We have been given a non-zero address, allocate if necessary.; 5354 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5355 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5356 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5357 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5358 // Case of an embedded STL container.; 5359 // Note: We test for the kObject and kAny types to support; 5360 // the (unwise) choice of inheriting from an STL container.; 5361 fObject = fAddress;; 5362 } else {; 5363 // We are either a top-level branch or subbranch which is a pointer to an STL container.; 5364 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5365 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5366 Error(""SetAddress"",; 5367 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5368 GetName(), fStreamerType);; 5369 } else if (fStreamerType == -1) {; 5370 // -- We are a top-level branch.; 5371 void** pp = (void**) fAddress;; 5372 if (!*pp) {; 5373 // -- Caller wants us to allocate the STL container, but they will own it.; 5374 *pp = proxy->New();; 5375 if (!(*pp)) {; 5376 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5377 // FIXME: Should we do this? Lots of other code wants; 5378 // fAddress to be zero if no fObject, but is; 5379 // th",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:200917,Testability,test,test,200917,"can be lazy.; 5389 void** pp = (void**) fAddress;; 5390 if (!*pp) {; 5391 // -- Caller wants us to allocate the STL container, but they will own it.; 5392 *pp = proxy->New();; 5393 if (!(*pp)) {; 5394 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5395 // FIXME: Should we do this? Lots of other code wants; 5396 // fAddress to be zero if no fObject, but is; 5397 // that a good thing?; 5398 fAddress = nullptr;; 5399 ResetBit(kAddressSet);; 5400 }; 5401 }; 5402 fObject = (char*) *pp;; 5403 }; 5404 }; 5405 } else {; 5406 // -- We have been given a zero address, allocate for top-level only.; 5407 if ((fStreamerType == TVirtualStreamerInfo::kObject) ||; 5408 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5409 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5410 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5411 // Case of an embedded STL container.; 5412 // Note: We test for the kObject and kAny types to support; 5413 // the (unwise) choice of inheriting from an STL container.; 5414 Error(""SetAddress"", ""Embedded STL container given a zero address for branch '%s'"", GetName());; 5415 } else {; 5416 // We are either a top-level branch or sub-branch which is a pointer to an STL container.; 5417 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5418 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5419 Error(""SetAddress"",; 5420 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5421 GetName(), fStreamerType);; 5422 } else if (fStreamerType == -1) {; 5423 // -- We are a top-level branch, allocate.; 5424 SetBit(kDeleteObject);; 5425 fObject = (char*) proxy->New();; 5426 if (fObject) {; 5427 fAddress = (char*) &fObject;; 5428 } else {; 5429 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5430 // FIXME: Should we do this? Lots of other code wants; 5431 // fAddress to",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:228594,Testability,test,test,228594,"nchElement::Unroll(const char *name, TClass *cl, TStreamerInfo *sinfo, char* objptr, Int_t bufsize, Int_t splitlevel); 6079{; 6080 //; 6081 // Do we have a final dot in our name?; 6082 //; 6083 ; 6084 // Note: The branch constructor which takes a folder as input; 6085 // creates top-level branch names with dots in them to; 6086 // indicate the folder hierarchy.; 6087 char* dot = (char*) strchr(name, '.');; 6088 Int_t nch = strlen(name);; 6089 bool dotlast = false;; 6090 if (nch && (name[nch-1] == '.')) {; 6091 dotlast = true;; 6092 }; 6093 ; 6094 // Loop on all public data members of the class and its base classes and create branches for each one.; 6095 TObjArray* blist = this->GetListOfBranches();; 6096 TIter next(sinfo->GetElements());; 6097 TStreamerElement* element = nullptr;; 6098 TString bname;; 6099 for (Int_t id = 0; (element = (TStreamerElement*) next()); ++id) {; 6100 if (element->IsA() == TStreamerArtificial::Class()) {; 6101 continue;; 6102 }; 6103 if (element->TestBit(TStreamerElement::kRepeat)) {; 6104 continue;; 6105 }; 6106 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 6107 continue;; 6108 }; 6109 char* pointer = (char*) (objptr + element->GetOffset());; 6110 // FIXME: This is not good enough, an STL container can be; 6111 // a base, and the test will fail.; 6112 // See TBranchElement::InitializeOffsets() for the; 6113 // correct test.; 6114 bool isBase = (element->IsA() == TStreamerBase::Class());; 6115 if (isBase) {; 6116 TClass* clbase = element->GetClassPointer();; 6117 if ((clbase == TObject::Class()) && cl->CanIgnoreTObjectStreamer()) {; 6118 // Note: TStreamerInfo::Compile() leaves this element; 6119 // out of the optimized info, although it does; 6120 // exists in the non-compiled and non-optimized info.; 6121 // FIXME: The test that TStreamerInfo::Compile() uses; 6122 // is element->GetType() < 0, so that is what; 6123 // we should do as well.; 6124 continue;; 6125 }; 6126 if (clbase->GetLi",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:228684,Testability,test,test,228684,"ar*) strchr(name, '.');; 6088 Int_t nch = strlen(name);; 6089 bool dotlast = false;; 6090 if (nch && (name[nch-1] == '.')) {; 6091 dotlast = true;; 6092 }; 6093 ; 6094 // Loop on all public data members of the class and its base classes and create branches for each one.; 6095 TObjArray* blist = this->GetListOfBranches();; 6096 TIter next(sinfo->GetElements());; 6097 TStreamerElement* element = nullptr;; 6098 TString bname;; 6099 for (Int_t id = 0; (element = (TStreamerElement*) next()); ++id) {; 6100 if (element->IsA() == TStreamerArtificial::Class()) {; 6101 continue;; 6102 }; 6103 if (element->TestBit(TStreamerElement::kRepeat)) {; 6104 continue;; 6105 }; 6106 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 6107 continue;; 6108 }; 6109 char* pointer = (char*) (objptr + element->GetOffset());; 6110 // FIXME: This is not good enough, an STL container can be; 6111 // a base, and the test will fail.; 6112 // See TBranchElement::InitializeOffsets() for the; 6113 // correct test.; 6114 bool isBase = (element->IsA() == TStreamerBase::Class());; 6115 if (isBase) {; 6116 TClass* clbase = element->GetClassPointer();; 6117 if ((clbase == TObject::Class()) && cl->CanIgnoreTObjectStreamer()) {; 6118 // Note: TStreamerInfo::Compile() leaves this element; 6119 // out of the optimized info, although it does; 6120 // exists in the non-compiled and non-optimized info.; 6121 // FIXME: The test that TStreamerInfo::Compile() uses; 6122 // is element->GetType() < 0, so that is what; 6123 // we should do as well.; 6124 continue;; 6125 }; 6126 if (clbase->GetListOfRealData()->GetSize() == 0) {; 6127 // Do not create a branch for empty bases.; 6128 continue;; 6129 }; 6130 }; 6131 if (dot) {; 6132 if (dotlast) {; 6133 bname.Form(""%s%s"", name, element->GetFullName());; 6134 } else {; 6135 // FIXME: We are in the case where we have a top-level; 6136 // branch name that was created by the branch; 6137 // constructor which takes a folder as inp",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:229094,Testability,test,test,229094,"d) {; 6100 if (element->IsA() == TStreamerArtificial::Class()) {; 6101 continue;; 6102 }; 6103 if (element->TestBit(TStreamerElement::kRepeat)) {; 6104 continue;; 6105 }; 6106 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 6107 continue;; 6108 }; 6109 char* pointer = (char*) (objptr + element->GetOffset());; 6110 // FIXME: This is not good enough, an STL container can be; 6111 // a base, and the test will fail.; 6112 // See TBranchElement::InitializeOffsets() for the; 6113 // correct test.; 6114 bool isBase = (element->IsA() == TStreamerBase::Class());; 6115 if (isBase) {; 6116 TClass* clbase = element->GetClassPointer();; 6117 if ((clbase == TObject::Class()) && cl->CanIgnoreTObjectStreamer()) {; 6118 // Note: TStreamerInfo::Compile() leaves this element; 6119 // out of the optimized info, although it does; 6120 // exists in the non-compiled and non-optimized info.; 6121 // FIXME: The test that TStreamerInfo::Compile() uses; 6122 // is element->GetType() < 0, so that is what; 6123 // we should do as well.; 6124 continue;; 6125 }; 6126 if (clbase->GetListOfRealData()->GetSize() == 0) {; 6127 // Do not create a branch for empty bases.; 6128 continue;; 6129 }; 6130 }; 6131 if (dot) {; 6132 if (dotlast) {; 6133 bname.Form(""%s%s"", name, element->GetFullName());; 6134 } else {; 6135 // FIXME: We are in the case where we have a top-level; 6136 // branch name that was created by the branch; 6137 // constructor which takes a folder as input.; 6138 // The internal dots in the name are in place of; 6139 // of the original slashes and represent the; 6140 // folder hierarchy.; 6141 if (isBase) {; 6142 // FIXME: This is very strange, this is the only case where; 6143 // we create a branch for a base class that does; 6144 // not have the base class name in the branch name.; 6145 // FIXME: This is also quite bad since classes with two; 6146 // or more base classes end up with sub-branches; 6147 // that have the same name.; 6148 bna",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:235015,Testability,test,test,235015,"uild the streamer info for cl.; 6231 //; 6232 ; 6233 if (!sinfo) {; 6234 return 0;; 6235 }; 6236 ; 6237 const auto namelen = strlen(name);; 6238 bool dotlast = (namelen && (name[namelen-1] == '.'));; 6239 ; 6240 Int_t ndata = sinfo->GetNelement();; 6241 ; 6242 if ((ndata == 1) && cl->GetCollectionProxy() && !strcmp(sinfo->GetElement(0)->GetName(), ""This"")) {; 6243 // -- Class cl is an STL collection, refuse to split it.; 6244 // Question: Why? We certainly could by switching to the value class.; 6245 // Partial Answer: Only the branch element constructor can split STL containers.; 6246 return 1;; 6247 }; 6248 ; 6249 for (Int_t elemID = 0; elemID < ndata; ++elemID) {; 6250 // -- Loop over all the streamer elements and create sub-branches as needed.; 6251 TStreamerElement* elem = sinfo->GetElement(elemID);; 6252 if (elem->IsA() == TStreamerArtificial::Class()) {; 6253 continue;; 6254 }; 6255 if (elem->TestBit(TStreamerElement::kRepeat)) {; 6256 continue;; 6257 }; 6258 if (elem->TestBit(TStreamerElement::kCache) && !elem->TestBit(TStreamerElement::kWrite)) {; 6259 continue;; 6260 }; 6261 Int_t offset = elem->GetOffset();; 6262 // FIXME: An STL container as a base class gets TStreamerSTL as its class, so this test is not enough.; 6263 // See InitializeOffsets() for the proper test.; 6264 if (elem->IsA() == TStreamerBase::Class()) {; 6265 // -- This is a base class of cl.; 6266 TClass* clOfBase = elem->GetClassPointer();; 6267 if (!clOfBase || ((clOfBase->Property() & kIsAbstract) && cl->InheritsFrom(TCollection::Class()))) {; 6268 // -- Do nothing if we are one of the abstract collection (we know they have no data).; 6269 return -1;; 6270 }; 6271 if ((btype == 31) || (btype == 41)) {; 6272 // -- Elide the base-class sub-branches of a split TClonesArray or STL container.; 6273 //; 6274 // Note: We are eliding the base class here, that is, we never; 6275 // create a branch for it, so the branch hierarchy is not; 6276 // complete.; 6277 // Note: The clParent parameter is th",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:235083,Testability,test,test,235083," == 1) && cl->GetCollectionProxy() && !strcmp(sinfo->GetElement(0)->GetName(), ""This"")) {; 6243 // -- Class cl is an STL collection, refuse to split it.; 6244 // Question: Why? We certainly could by switching to the value class.; 6245 // Partial Answer: Only the branch element constructor can split STL containers.; 6246 return 1;; 6247 }; 6248 ; 6249 for (Int_t elemID = 0; elemID < ndata; ++elemID) {; 6250 // -- Loop over all the streamer elements and create sub-branches as needed.; 6251 TStreamerElement* elem = sinfo->GetElement(elemID);; 6252 if (elem->IsA() == TStreamerArtificial::Class()) {; 6253 continue;; 6254 }; 6255 if (elem->TestBit(TStreamerElement::kRepeat)) {; 6256 continue;; 6257 }; 6258 if (elem->TestBit(TStreamerElement::kCache) && !elem->TestBit(TStreamerElement::kWrite)) {; 6259 continue;; 6260 }; 6261 Int_t offset = elem->GetOffset();; 6262 // FIXME: An STL container as a base class gets TStreamerSTL as its class, so this test is not enough.; 6263 // See InitializeOffsets() for the proper test.; 6264 if (elem->IsA() == TStreamerBase::Class()) {; 6265 // -- This is a base class of cl.; 6266 TClass* clOfBase = elem->GetClassPointer();; 6267 if (!clOfBase || ((clOfBase->Property() & kIsAbstract) && cl->InheritsFrom(TCollection::Class()))) {; 6268 // -- Do nothing if we are one of the abstract collection (we know they have no data).; 6269 return -1;; 6270 }; 6271 if ((btype == 31) || (btype == 41)) {; 6272 // -- Elide the base-class sub-branches of a split TClonesArray or STL container.; 6273 //; 6274 // Note: We are eliding the base class here, that is, we never; 6275 // create a branch for it, so the branch hierarchy is not; 6276 // complete.; 6277 // Note: The clParent parameter is the value class of the; 6278 // container which we are splitting. It does not; 6279 // appear in the branch hierarchy either.; 6280 // Note: We can use parent class (clParent) != branch class (elemClass) to detection elision.; 6281 Int_t unroll = -1;; 6282 if (!elem->Cann",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:84840,Usability,clear,clear,84840,"2344 }; 2345 }; 2346 subbranch->fOnfileObject = fOnfileObject;; 2347 lastbranch = subbranch;; 2348 }; 2349 }; 2350 if (toplevel) {; 2351 SetBit(kOwnOnfileObj);; 2352 if (lastbranch != this); 2353 lastbranch->ResetBit(kOwnOnfileObj);; 2354 } else {; 2355 lastbranch->SetBit(kOwnOnfileObj);; 2356 }; 2357 };; 2358 if (GetID() > -1) {; 2359 // We are *not* a top-level branch.; 2360 std::string s(GetName());; 2361 size_t pos = s.rfind('.');; 2362 if (pos != std::string::npos) {; 2363 s = s.substr(pos+1);; 2364 }; 2365 while ((pos = s.rfind('[')) != std::string::npos) {; 2366 s = s.substr(0, pos);; 2367 }; 2368 int offset = 0;; 2369 TStreamerElement* elt = fInfo->GetStreamerElement(s.c_str(), offset);; 2370 if (elt && offset!=TStreamerInfo::kMissing) {; 2371 size_t ndata = fInfo->GetNelement();; 2372 fNewIDs.clear();; 2373 for (size_t i = 0; i < ndata; ++i) {; 2374 if (fInfo->GetElement(i) == elt) {; 2375 if (elt->TestBit (TStreamerElement::kCache); 2376 && (i+1) < ndata; 2377 && s == fInfo->GetElement(i)->GetName()); 2378 {; 2379 // If the TStreamerElement we found is storing the information in the; 2380 // cache and is a repeater, we need to use the real one (the next one).; 2381 // (At least until the cache/repeat mechanism is properly handle by; 2382 // ReadLeaves).; 2383 // fID = i+1;; 2384 fID = i;; 2385 if (fType != 2) {; 2386 if (elt->TestBit(TStreamerElement::kRepeat)) {; 2387 fNewIDs.push_back(fID+1);; 2388 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2389 fNewIDs.back().fInfo = fInfo;; 2390 } else if (fInfo->GetElement(i+1)->TestBit(TStreamerElement::kWrite)) {; 2391 fNewIDs.push_back(fID+1);; 2392 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2393 fNewIDs.back().fInfo = fInfo;; 2394 }; 2395 }; 2396 } else {; 2397 fID = i;; 2398 }; 2399 if (elt->TestBit (TStreamerElement::kCache)) {; 2400 SetBit(TBranchElement::kCache);; 2401 }; 2402 break;; 2403 }; 2404 }; 2405 for (size_t i = fID+1+(fNewIDs.size()); i < ndata; ++i) {; 2406 TStreamerElement *nextel =",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:87723,Usability,clear,clear,87723,"l->GetClassPointer()->CanSplit()); 2428 {; 2429 continue;; 2430 }; 2431 }; 2432 if (nextel->GetOffset() == TStreamerInfo::kMissing) {; 2433 // This element will be 'skipped', it's TBranchElement's fObject will null; 2434 // and thus can not be used to execute the artificial StreamerElements; 2435 continue;; 2436 }; 2437 if (nextel->IsA() != TStreamerArtificial::Class(); 2438 || nextel->GetType() == TStreamerInfo::kCacheDelete ) {; 2439 continue;; 2440 }; 2441 // NOTE: We should verify that the rule's source are 'before'; 2442 // or 'at' this branch.; 2443 // fprintf(stderr,""%s/%d[%zu] pushd %zu %s\n"",GetName(),fID,fIDs.size(),i,nextel->GetName());; 2444 fNewIDs.push_back(i);; 2445 fNewIDs.back().fElement = nextel;; 2446 fNewIDs.back().fInfo = fInfo;; 2447 }; 2448 } else if (elt && offset==TStreamerInfo::kMissing) {; 2449 // Still re-assign fID properly.; 2450 fNewIDs.clear();; 2451 size_t ndata = fInfo->GetNelement();; 2452 for (size_t i = 0; i < ndata; ++i) {; 2453 if (fInfo->GetElement(i) == elt) {; 2454 fID = i;; 2455 break;; 2456 }; 2457 }; 2458 } else {; 2459 // We have not even found the element .. this is strange :(; 2460 // fNewIDs.clear();; 2461 // fID = -3;; 2462 // SetBit(kDoNotProcess);; 2463 }; 2464 if (fOnfileObject==nullptr && (fType==31 || fType==41 || (0 <= fType && fType <=2) ) && fInfo->GetNelement(); 2465 && fInfo->GetElement(0)->GetType() == TStreamerInfo::kCacheNew); 2466 {; 2467 SetOnfileObject(fInfo);; 2468 }; 2469 }; 2470 if (fType == 3 || fType == 4 || (fType == 0 && fID == -2) || fType == 2) {; 2471 // Need to add the rule targeting transient members.; 2472 TStreamerInfo *localInfo = fInfo;; 2473 if (fType == 3 || fType == 4) {; 2474 // Don't we have real version information?; 2475 // Not unless there is a subbranch with a non-split element of the class.; 2476 // Search for the correct version.; 2477 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 2478 }; 2479 ; 2480 TString prefix(GetFullName());; 2481 if (fType == 2 && fID >= 0) {;",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:88001,Usability,clear,clear,88001,"nextel->GetType() == TStreamerInfo::kCacheDelete ) {; 2439 continue;; 2440 }; 2441 // NOTE: We should verify that the rule's source are 'before'; 2442 // or 'at' this branch.; 2443 // fprintf(stderr,""%s/%d[%zu] pushd %zu %s\n"",GetName(),fID,fIDs.size(),i,nextel->GetName());; 2444 fNewIDs.push_back(i);; 2445 fNewIDs.back().fElement = nextel;; 2446 fNewIDs.back().fInfo = fInfo;; 2447 }; 2448 } else if (elt && offset==TStreamerInfo::kMissing) {; 2449 // Still re-assign fID properly.; 2450 fNewIDs.clear();; 2451 size_t ndata = fInfo->GetNelement();; 2452 for (size_t i = 0; i < ndata; ++i) {; 2453 if (fInfo->GetElement(i) == elt) {; 2454 fID = i;; 2455 break;; 2456 }; 2457 }; 2458 } else {; 2459 // We have not even found the element .. this is strange :(; 2460 // fNewIDs.clear();; 2461 // fID = -3;; 2462 // SetBit(kDoNotProcess);; 2463 }; 2464 if (fOnfileObject==nullptr && (fType==31 || fType==41 || (0 <= fType && fType <=2) ) && fInfo->GetNelement(); 2465 && fInfo->GetElement(0)->GetType() == TStreamerInfo::kCacheNew); 2466 {; 2467 SetOnfileObject(fInfo);; 2468 }; 2469 }; 2470 if (fType == 3 || fType == 4 || (fType == 0 && fID == -2) || fType == 2) {; 2471 // Need to add the rule targeting transient members.; 2472 TStreamerInfo *localInfo = fInfo;; 2473 if (fType == 3 || fType == 4) {; 2474 // Don't we have real version information?; 2475 // Not unless there is a subbranch with a non-split element of the class.; 2476 // Search for the correct version.; 2477 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 2478 }; 2479 ; 2480 TString prefix(GetFullName());; 2481 if (fType == 2 && fID >= 0) {; 2482 auto start = prefix.Length();; 2483 if (prefix[start - 1] == '.'); 2484 --start;; 2485 std::string_view view(prefix.Data(), start);; 2486 auto cutoff = view.find_last_of('.');; 2487 if (cutoff != std::string::npos) {; 2488 prefix.Remove(cutoff + 1);; 2489 }; 2490 }; 2491 if (prefix[prefix.Length()-1] != '.') {; 2492 if (fType == 3 || fType == 4 || prefix.Index('.') != TStr",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:89323,Usability,clear,clear,89323,"== 2) {; 2471 // Need to add the rule targeting transient members.; 2472 TStreamerInfo *localInfo = fInfo;; 2473 if (fType == 3 || fType == 4) {; 2474 // Don't we have real version information?; 2475 // Not unless there is a subbranch with a non-split element of the class.; 2476 // Search for the correct version.; 2477 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 2478 }; 2479 ; 2480 TString prefix(GetFullName());; 2481 if (fType == 2 && fID >= 0) {; 2482 auto start = prefix.Length();; 2483 if (prefix[start - 1] == '.'); 2484 --start;; 2485 std::string_view view(prefix.Data(), start);; 2486 auto cutoff = view.find_last_of('.');; 2487 if (cutoff != std::string::npos) {; 2488 prefix.Remove(cutoff + 1);; 2489 }; 2490 }; 2491 if (prefix[prefix.Length()-1] != '.') {; 2492 if (fType == 3 || fType == 4 || prefix.Index('.') != TString::kNPOS) {; 2493 prefix += ""."";; 2494 } else {; 2495 prefix = """";; 2496 }; 2497 }; 2498 fNewIDs.clear();; 2499 ; 2500 GatherArtificialElements(fBranches, fNewIDs, prefix, localInfo, 0);; 2501 ; 2502 if (!fNewIDs.empty() && fOnfileObject == nullptr && localInfo->GetElement(0)->GetType() == TStreamerInfo::kCacheNew); 2503 {; 2504 SetOnfileObject(localInfo);; 2505 }; 2506 ; 2507 }; 2508 fInit = true;; 2509 ; 2510 // Get the action sequence we need to copy for reading.; 2511 SetReadActionSequence();; 2512 SetFillActionSequence();; 2513 } else if (!fReadActionSequence) {; 2514 // Get the action sequence we need to copy for reading.; 2515 SetReadActionSequence();; 2516 SetFillActionSequence();; 2517 }; 2518 SetReadLeavesPtr();; 2519 SetFillLeavesPtr();; 2520 fInInitInfo = false;; 2521 }; 2522}; 2523 ; 2524////////////////////////////////////////////////////////////////////////////////; 2525/// Return the collection proxy describing the branch content, if any.; 2526 ; 2527TVirtualCollectionProxy* TBranchElement::GetCollectionProxy(); 2528{; 2529 if (fCollProxy) {; 2530 return fCollProxy;; 2531 }; 2532 TBranchElement* thiscast = const_cast<TBra",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:96627,Usability,clear,cleared,96627,") call done during; 2678 // the following I/O operation, for example in a custom streamer,; 2679 // to search for the referenced object in the proper element of the; 2680 // proper branch.; 2681 TBranchRef* bref = fTree->GetBranchRef();; 2682 if (R__unlikely(bref)) {; 2683 R__LOCKGUARD_IMT(gROOTMutex); // Lock for parallel TTree I/O; 2684 fBranchID = bref->SetParent(this, fBranchID);; 2685 bref->SetRequestedEntry(entry);; 2686 }; 2687 ; 2688 Int_t nbytes = 0;; 2689 ; 2690 if (R__unlikely(IsAutoDelete())) {; 2691 SetBit(kDeleteObject);; 2692 SetAddress(fAddress);; 2693 } else {; 2694 if (R__unlikely(!fAddress && !TestBit(kDecomposedObj))) {; 2695 R__LOCKGUARD_IMT(gROOTMutex); // Lock for parallel TTree I/O; 2696 SetupAddressesImpl();; 2697 }; 2698 }; 2699 ; 2700 Int_t nbranches = fBranches.GetEntriesFast();; 2701 if (nbranches) {; 2702 // -- Branch has daughters.; 2703 // One must always read the branch counter.; 2704 // In the case when one reads consecutively twice the same entry,; 2705 // the user may have cleared the TClonesArray between the GetEntry calls.; 2706 if ((fType == 3) || (fType == 4)) {; 2707 Int_t nb = TBranch::GetEntry(entry, getall);; 2708 if (nb < 0) {; 2709 return nb;; 2710 }; 2711 nbytes += nb;; 2712 }; 2713 switch(fSTLtype) {; 2714 case ROOT::kSTLset:; 2715 case ROOT::kSTLmultiset:; 2716 case ROOT::kSTLunorderedset:; 2717 case ROOT::kSTLunorderedmultiset:; 2718 case ROOT::kSTLmap:; 2719 case ROOT::kSTLmultimap:; 2720 case ROOT::kSTLunorderedmap:; 2721 case ROOT::kSTLunorderedmultimap:; 2722 break;; 2723 default:; 2724 ValidateAddress(); // There is no ReadLeave for this node, so we need to do the validation here.; 2725 for (Int_t i = 0; i < nbranches; ++i) {; 2726 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 2727 Int_t nb = branch->GetEntry(entry, getall);; 2728 if (nb < 0) {; 2729 return nb;; 2730 }; 2731 nbytes += nb;; 2732 }; 2733 break;; 2734 }; 2735 if (!TestBit(kDecomposedObj) && fReadActionSequence && !fReadActionSequence->fAc",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:223783,Usability,clear,clear,223783,"5945 GetInfoImp();; 5946 ; 5947 if (!cl) {; 5948 return;; 5949 }; 5950 ; 5951 if (!mother->GetAddress()) {; 5952 // -- Our top-level branch has no address.; 5953 bool motherStatus = mother->TestBit(kDoNotProcess);; 5954 mother->ResetBit(kDoNotProcess);; 5955 // Note: This will allocate an object.; 5956 mother->SetAddress(nullptr);; 5957 mother->SetBit(kDoNotProcess, motherStatus);; 5958 }; 5959}; 5960 ; 5961////////////////////////////////////////////////////////////////////////////////; 5962/// Stream an object of class TBranchElement.; 5963 ; 5964void TBranchElement::Streamer(TBuffer& R__b); 5965{; 5966 if (R__b.IsReading()) {; 5967 R__b.ReadClassBuffer(TBranchElement::Class(), this);; 5968 fParentClass.SetName(fParentName);; 5969 fBranchClass.SetName(fClassName);; 5970 fTargetClass.SetName(fClassName);; 5971 fClonesClass.SetName(fClonesName);; 5972 // The fAddress and fObject data members are not persistent,; 5973 // therefore we do not own anything.; 5974 // Also clear the bit possibly set by the schema evolution.; 5975 ResetBit(kDeleteObject|kCache|kOwnOnfileObj|kAddressSet|kDecomposedObj);; 5976 // Fixup a case where the TLeafElement was missing; 5977 if ((fType == 0) && (fLeaves.GetEntriesFast() == 0)) {; 5978 TLeaf* leaf = new TLeafElement(this, GetTitle(), fID, fStreamerType);; 5979 leaf->SetTitle(GetTitle());; 5980 fNleaves = 1;; 5981 fLeaves.Add(leaf);; 5982 fTree->GetListOfLeaves()->Add(leaf);; 5983 }; 5984 ; 5985 // SetReadLeavesPtr();; 5986 }; 5987 else {; 5988 TDirectory* dirsav = fDirectory;; 5989 fDirectory = nullptr; // to avoid recursive calls; 5990 {; 5991 // Save class version.; 5992 Int_t classVersion = fClassVersion;; 5993 // Record only positive 'version number'; 5994 if (fClassVersion < 0) {; 5995 fClassVersion = -fClassVersion;; 5996 }; 5997 // TODO: Should we clear the kDeleteObject bit before writing?; 5998 // If we did we would have to remember the old value and; 5999 // put it back, we wouldn't want to forget that we owned; 6000 // some",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:224618,Usability,clear,clear,224618,"ss.SetName(fClonesName);; 5972 // The fAddress and fObject data members are not persistent,; 5973 // therefore we do not own anything.; 5974 // Also clear the bit possibly set by the schema evolution.; 5975 ResetBit(kDeleteObject|kCache|kOwnOnfileObj|kAddressSet|kDecomposedObj);; 5976 // Fixup a case where the TLeafElement was missing; 5977 if ((fType == 0) && (fLeaves.GetEntriesFast() == 0)) {; 5978 TLeaf* leaf = new TLeafElement(this, GetTitle(), fID, fStreamerType);; 5979 leaf->SetTitle(GetTitle());; 5980 fNleaves = 1;; 5981 fLeaves.Add(leaf);; 5982 fTree->GetListOfLeaves()->Add(leaf);; 5983 }; 5984 ; 5985 // SetReadLeavesPtr();; 5986 }; 5987 else {; 5988 TDirectory* dirsav = fDirectory;; 5989 fDirectory = nullptr; // to avoid recursive calls; 5990 {; 5991 // Save class version.; 5992 Int_t classVersion = fClassVersion;; 5993 // Record only positive 'version number'; 5994 if (fClassVersion < 0) {; 5995 fClassVersion = -fClassVersion;; 5996 }; 5997 // TODO: Should we clear the kDeleteObject bit before writing?; 5998 // If we did we would have to remember the old value and; 5999 // put it back, we wouldn't want to forget that we owned; 6000 // something just because we got written to disk.; 6001 R__b.WriteClassBuffer(TBranchElement::Class(), this);; 6002 // Restore class version.; 6003 fClassVersion = classVersion;; 6004 }; 6005 //; 6006 // Mark all streamer infos used by this branch element; 6007 // to be written to our output file.; 6008 //; 6009 {; 6010 R__b.ForceWriteInfo(GetInfoImp(), true);; 6011 }; 6012 //; 6013 // If we are a clones array master branch, or an; 6014 // STL container master branch, we must also mark; 6015 // the streamer infos used by the value class to; 6016 // be written to our output file.; 6017 //; 6018 if (fType == 3) {; 6019 // -- TClonesArray, counter/master branch; 6020 //; 6021 // We must mark the streamer info for the; 6022 // value class to be written to the file.; 6023 //; 6024 TClass* cl = fClonesClass;; 6025 if (cl) {; 6026 R__b.",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8cxx_source.html:237208,Usability,simpl,simple,237208,"lass()) {; 6283 unroll = Unroll(name, clParent, clOfBase, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6284 }; 6285 if (unroll < 0) {; 6286 // FIXME: We could not split because we are abstract, should we be doing this?; 6287 if (namelen) {; 6288 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6289 } else {; 6290 branchname.Form(""%s"", elem->GetFullName());; 6291 }; 6292 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, nullptr, basketsize, 0, btype);; 6293 branch->SetParentClass(clParent);; 6294 fBranches.Add(branch);; 6295 }; 6296 } else if (clOfBase->GetListOfRealData()->GetSize()) {; 6297 // -- Create a branch for a non-empty base class.; 6298 if (namelen) {; 6299 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6300 // Elide the base class name when creating the sub-branches.; 6301 // Note: The branch names for sub-branches of a base class branch; 6302 // do not represent the full class hierarchy because we do; 6303 // this, however it does keep the branch names for the; 6304 // inherited data members simple.; 6305 TBranchElement* branch = new TBranchElement(this, name, sinfo, elemID, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6306 // Then reset it to the proper name.; 6307 branch->SetName(branchname);; 6308 branch->SetTitle(branchname);; 6309 branch->SetParentClass(clParent);; 6310 fBranches.Add(branch);; 6311 } else {; 6312 branchname.Form(""%s"", elem->GetFullName());; 6313 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6314 branch->SetParentClass(clParent);; 6315 fBranches.Add(branch);; 6316 }; 6317 }; 6318 } else {; 6319 // -- This is a data member of cl.; 6320 if (namelen) {; 6321 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6322 } else {; 6323 branchname.Form(""%s"", elem->GetFullName());; 6324 }; 6325 if ((splitlevel > 1) && ((elem->IsA() =",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:41261,Availability,error,error,41261,"T type system.Definition TClass.h:81; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TLeafElementA TLeaf for the general case when using the branches created via a TStreamerInfo (i....Definition TLeafElement.h:32; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSequence::SequenceGetter_tSequencePtr(*)(TStreamerInfo *info, TVirtualCollectionProxy *collectionProxy, TClass *originalClass) SequenceGetter_tDefinition TStreamerInfoActions.h:185; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetMakeClassInt_t GetMakeClass() constDefinition TTree.h:535; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollection",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:42317,Deployability,release,release,42317,"id SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSequence::SequenceGetter_tSequencePtr(*)(TStreamerInfo *info, TVirtualCollectionProxy *collectionProxy, TClass *originalClass) SequenceGetter_tDefinition TStreamerInfoActions.h:185; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetMakeClassInt_t GetMakeClass() constDefinition TTree.h:535; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators.Definition TVirtualCollectionIterators.h:26; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionPtrIteratorsDefinition TVirtualCollectionIterators.h:195; double; int; unsigned int; TStreamerInfoActions::TIDsstd::vector< TIDNode > TIDsDefinition TStreamerInfoActions.h:138; ROOT::RCompressionSetting::EAlgorithm::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:91. treetreeincTBranchElement.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:21499,Energy Efficiency,allocate,allocated,21499,"Element::Printvoid Print(Option_t *option="""") const overridePrint TBranch parameters.Definition TBranchElement.cxx:3836; TBranchElement::GetIDInt_t GetID() constDefinition TBranchElement.h:195; TBranchElement::GetBranchOffsetInt_t * GetBranchOffset() constDefinition TBranchElement.h:184; TBranchElement::GetClassNameconst char * GetClassName() const overrideReturn the name of the user class whose content is stored in this branch, if any.Definition TBranchElement.h:186; TBranchElement::GetInfoTStreamerInfo * GetInfo() constGet streamer info for the branch class.Definition TBranchElement.cxx:1024; TBranchElement::ReadLeavesCollectionvoid ReadLeavesCollection(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4267; TBranchElement::SetupAddressesvoid SetupAddresses() overrideIf the branch address is not set, we set all addresses starting with the top level parent branch.Definition TBranchElement.cxx:5892; TBranchElement::ResetAddressvoid ResetAddress() overrideSet branch address to zero and free all allocated memory.Definition TBranchElement.cxx:4780; TBranchElement::SetTypevirtual void SetType(Int_t btype)Definition TBranchElement.h:234; TBranchElement::FillLeavesMembervoid FillLeavesMember(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1734; TBranchElement::SetBranchCountvoid SetBranchCount(TBranchElement *bre)Set the branch counter for this branch.Definition TBranchElement.cxx:5529; TBranchElement::SwitchContainerstatic void SwitchContainer(TObjArray *)Modify the container type of the branches.Definition TBranchElement.cxx:85; TBranchElement::SetReadActionSequencevoid SetReadActionSequence()Set the sequence of actions needed to read the data out of the buffer.Definition TBranchElement.cxx:5663; TBranchElement::IsMissingCollectionbool IsMissingCollection() constDetect a collection written using a zero pointer in old versions of root.Definition TBranchElement.cxx:3776; TBranchElement::FillImplInt_",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:28503,Energy Efficiency,allocate,allocated,28503,ddress.Definition TBranchElement.cxx:1923; TBranchElement::FillLeavesMemberCountervoid FillLeavesMemberCounter(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1697; TBranchElement::SetBranchCount2void SetBranchCount2(TBranchElement *bre)Definition TBranchElement.h:124; TBranchElement::FillLeavesCollectionSplitPtrMembervoid FillLeavesCollectionSplitPtrMember(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1499; TBranchElement::SetAddressvoid SetAddress(void *addobj) overridePoint this branch at an object.Definition TBranchElement.cxx:4962; TBranchElement::GetInfoImpTStreamerInfo * GetInfoImp() constGet streamer info for the branch class.Definition TBranchElement.cxx:1011; TBranchElement::SetTargetClassvirtual void SetTargetClass(const char *name)Set the name of the class of the in-memory object into which the data will loaded.Definition TBranchElement.cxx:5855; TBranchElement::ResetDeleteObjectvirtual void ResetDeleteObject()Release ownership of any allocated objects.Definition TBranchElement.cxx:4814; TBranchElement::GetParentNamevirtual const char * GetParentName() constDefinition TBranchElement.h:200; TBranchElement::ValidateAddressvoid ValidateAddress() constDefinition TBranchElement.h:264; TBranchElement::GetOnfileObjectTVirtualArray * GetOnfileObject() constDefinition TBranchElement.h:199; TBranchElement::fWriteIteratorsTVirtualCollectionIterators * fWriteIterators! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers.Definition TBranchElement.h:102; TBranchElement::PrintValuevoid PrintValue(Int_t i) constPrints values of leaves.Definition TBranchElement.cxx:3928; TBranchElement::fOnfileObjectTVirtualArray * fOnfileObject! Place holder for the onfile representation of data members.Definition TBranchElement.h:87; TBranchElement::SetBasketSizevoid SetBasketSize(Int_t buffsize) overrideReset the basket size for all sub-branches of this branch e,MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:34186,Energy Efficiency,allocate,allocated,34186,r this branch.Definition TBranchElement.cxx:1646; TBranchElement::GetClonesNamevirtual const char * GetClonesName() constDefinition TBranchElement.h:188; TBranchElement::GetClassvirtual TClass * GetClass() constDefinition TBranchElement.h:187; TBranchElement::fMaximumInt_t fMaximumMaximum entries for a TClonesArray or variable array.Definition TBranchElement.h:80; TBranchElement::ReadLeavesMemberCountervoid ReadLeavesMemberCounter(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4611; TBranchElement::fBranchIDInt_t fBranchID! ID number assigned by a TRefTable.Definition TBranchElement.h:97; TBranchElement::FindLeafTLeaf * FindLeaf(const char *name) overrideFind the leaf corresponding to the name 'searchname'.Definition TBranchElement.cxx:1872; TBranchElement::fIteratorsTVirtualCollectionIterators * fIterators! holds the iterators when the branch is of fType==4.Definition TBranchElement.h:101; TBranchElement::ReleaseObjectvoid ReleaseObject()Delete any object we may have allocated on a previous call to SetAddress.Definition TBranchElement.cxx:4672; TBranchElement::fTargetClassTClassRef fTargetClass! Reference to the target in-memory classDefinition TBranchElement.h:91; TBranchElement::Browsevoid Browse(TBrowser *b) overrideBrowse the branch content.Definition TBranchElement.cxx:1032; TBranchElement::FillLeavesMemberBranchCountvoid FillLeavesMemberBranchCount(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1676; TBranchElement::EBranchElementTypeEBranchElementTypeDefinition TBranchElement.h:238; TBranchElement::kClonesNode@ kClonesNodeDefinition TBranchElement.h:246; TBranchElement::kClonesMemberNode@ kClonesMemberNodeDefinition TBranchElement.h:248; TBranchElement::kObjectNode@ kObjectNodeDefinition TBranchElement.h:245; TBranchElement::kSTLNode@ kSTLNodeDefinition TBranchElement.h:247; TBranchElement::kLeafNode@ kLeafNodeDefinition TBranchElement.h:239; TBranchElement::kSTLMemberNode@ kSTLMem,MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:2196,Integrability,interface,interface,2196,"ranch {; 40 ; 41// Friends; 42 friend class TTreeCloner;; 43 friend class TLeafElement;; 44 ; 45/// Types; 46protected:; 47 enum EStatusBits {; 48 kBranchFolder = BIT(14),; 49 kDeleteObject = BIT(16), ///< We are the owner of fObject.; 50 kCache = BIT(18), ///< Need to pushd/pop fOnfileObject.; 51 kOwnOnfileObj = BIT(19), ///< We are the owner of fOnfileObject.; 52 kAddressSet = BIT(20), ///< The addressing set have been called for this branch; 53 kMakeClass = BIT(21), ///< This branch has been switched to using the MakeClass Mode; 54 kDecomposedObj = BIT(21) ///< More explicit alias for kMakeClass.; 55 };; 56 ; 57 ; 58// Data Members; 59protected:; 60 TString fClassName; ///< Class name of referenced object; 61 TString fParentName; ///< Name of parent class; 62 TString fClonesName; ///< Name of class in TClonesArray (if any); 63 TVirtualCollectionProxy *fCollProxy; ///<! collection interface (if any); 64 UInt_t fCheckSum; ///< CheckSum of class; 65 Version_t fClassVersion; ///< Version number of class; 66 Int_t fID; ///< element serial number in fInfo; 67 Int_t fType; ///< Branch type; 68 ///<; 69 ///< Note on fType values:; 70 ///< * -1 unsplit object with custom streamer at time of writing; 71 ///< * 0 unsplit object with default streamer at time of writing; 72 ///< OR simple data member of split object (fID==-1 for the former); 73 ///< * 1 base class of a split object.; 74 ///< * 2 class typed data member of a split object; 75 ///< * 3 branch count of a split TClonesArray; 76 ///< * 31 data member of the content of a split TClonesArray; 77 ///< * 4 branch count of a split STL Collection.; 78 ///< * 41 data member of the content of a split STL collection; 79 Int_t fStreamerType; ///< branch streamer type; 80 Int_t fMaximum; ///< Maximum entries for a TClonesArray or variable array; 81 Int_t fSTLtype; ///<! STL container type; 82 Int_t fNdata; ///<! Number of data in this branch; 83 TBranchElement *fBranchCount; ///< pointer to primary branchcount branch; 84 TBranc",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:14286,Integrability,interface,interface,14286," 246 kClonesNode = 3,; 247 kSTLNode = 4,; 248 kClonesMemberNode = 31,; 249 kSTLMemberNode = 41; 250 };; 251 ; 252private:; 253 Int_t FillImpl(ROOT::Internal::TBranchIMTHelper *) override;; 254 ; 255 ClassDefOverride(TBranchElement,10) // Branch in case of an object; 256};; 257 ; 258inline void TBranchElement::SetParentClass(TClass* clparent); 259{; 260 fParentClass = clparent;; 261 fParentName = clparent ? clparent->GetName() : """";; 262}; 263 ; 264inline void TBranchElement::ValidateAddress() const; 265{; 266 // Check to see if the user changed the object pointer without telling us.; 267 ; 268 if (fID < 0) {; 269 // We are a top-level branch.; 270 if (!fTree->GetMakeClass() && fAddress && (*((char**) fAddress) != fObject)) {; 271 // The semantics of fAddress and fObject are violated.; 272 // Assume the user changed the pointer on us.; 273 // Note: The cast is here because we want to be able to; 274 // be called from the constant get functions.; 275 ; 276 // FIXME: Disable the check/warning TTree until we add a missing interface.; 277 if (TestBit(kDeleteObject)) {; 278 // This should never happen!; 279 Error(""ValidateAddress"", ""We owned an object whose address changed! our ptr: %p new ptr: %p"",; 280 (void*)fObject, (void*)*((char**) fAddress));; 281 const_cast<TBranchElement*>(this)->ResetBit(kDeleteObject);; 282 }; 283 const_cast<TBranchElement*>(this)->SetAddress(fAddress);; 284 }; 285 }; 286}; 287 ; 288#endif // ROOT_TBranchElement; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TBranch.h; TClassRef.h; EDataTypeEDataTypeDefinition TDataType.h:28; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; offsetOption_t Option_t TPoint TPoint const",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:37460,Integrability,depend,depending,37460,"is a split collection of pointers.Definition TBranchElement.h:103; TBranchElement::TBranchElementTBranchElement(const TBranchElement &)=delete; TBranchElement::FindBranchTBranch * FindBranch(const char *name) overrideFind the immediate sub-branch with passed name.Definition TBranchElement.cxx:1787; TBranchElement::GetCheckSumUInt_t GetCheckSum()Definition TBranchElement.h:185; TBranchElement::Notifybool Notify() overrideThis method must be overridden to handle object notification (the base implementation is no-op).Definition TBranchElement.h:214; TBranchElement::InitInfovirtual void InitInfo()Init the streamer info for the branch class, try to compensate for class code unload/reload and schem...Definition TBranchElement.cxx:2209; TBranchElement::InitializeOffsetsvirtual void InitializeOffsets()Initialize the base class subobjects offsets of our sub-branches and set fOffset if we are a containe...Definition TBranchElement.cxx:3137; TBranchElement::GetIconNameconst char * GetIconName() const overrideReturn icon name depending on type of branch element.Definition TBranchElement.cxx:2853; TBranchElement::operator=TBranchElement & operator=(const TBranchElement &)=delete; TBranchElement::GetParentClassTClass * GetParentClass()Return a pointer to the parent class of the branch element.Definition TBranchElement.cxx:2894; TBranchElement::GetNdataInt_t GetNdata() constDefinition TBranchElement.h:202; TBranchElement::GetExpectedTypeInt_t GetExpectedType(TClass *&clptr, EDataType &type) overrideFill expectedClass and expectedType with information on the data type of the object/values contained ...Definition TBranchElement.cxx:2804; TBranchElement::fInitbool fInit! Initialization flag for branch assignmentDefinition TBranchElement.h:88; TBranchElement::fCollProxyTVirtualCollectionProxy * fCollProxy! collection interface (if any)Definition TBranchElement.h:63; TBranchElement::IsBranchFolderbool IsBranchFolder() constDefinition TBranchElement.h:211; TBranchElement::SetFillActionSe",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:38260,Integrability,interface,interface,38260,"lize the base class subobjects offsets of our sub-branches and set fOffset if we are a containe...Definition TBranchElement.cxx:3137; TBranchElement::GetIconNameconst char * GetIconName() const overrideReturn icon name depending on type of branch element.Definition TBranchElement.cxx:2853; TBranchElement::operator=TBranchElement & operator=(const TBranchElement &)=delete; TBranchElement::GetParentClassTClass * GetParentClass()Return a pointer to the parent class of the branch element.Definition TBranchElement.cxx:2894; TBranchElement::GetNdataInt_t GetNdata() constDefinition TBranchElement.h:202; TBranchElement::GetExpectedTypeInt_t GetExpectedType(TClass *&clptr, EDataType &type) overrideFill expectedClass and expectedType with information on the data type of the object/values contained ...Definition TBranchElement.cxx:2804; TBranchElement::fInitbool fInit! Initialization flag for branch assignmentDefinition TBranchElement.h:88; TBranchElement::fCollProxyTVirtualCollectionProxy * fCollProxy! collection interface (if any)Definition TBranchElement.h:63; TBranchElement::IsBranchFolderbool IsBranchFolder() constDefinition TBranchElement.h:211; TBranchElement::SetFillActionSequencevoid SetFillActionSequence()Set the sequence of actions needed to write the data out from the buffer.Definition TBranchElement.cxx:5763; TBranchElement::SetObjectvoid SetObject(void *objadd) overrideSet object this branch is pointing to.Definition TBranchElement.cxx:5575; TBranchElement::fStreamerTypeInt_t fStreamerTypebranch streamer typeDefinition TBranchElement.h:79; TBranchElement::ReadLeavesCollectionSplitVectorPtrMembervoid ReadLeavesCollectionSplitVectorPtrMember(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4398; TBranchElement::GetMakeClassbool GetMakeClass() const overrideReturn whether this branch is in a mode where the object are decomposed or not (Also known as MakeCla...Definition TBranchElement.cxx:2866; TBranchElement::SetAddressImplvoid S",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:40496,Integrability,interface,interface,40496,"finition TBranchElement.cxx:5811; TBranchElement::ReadLeavesCollectionMembervoid ReadLeavesCollectionMember(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4429; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::fAddresschar * fAddress! Address of 1st leaf (variable or object)Definition TBranch.h:147; TBranch::fTreeTTree * fTree! Pointer to Tree headerDefinition TBranch.h:144; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TLeafElementA TLeaf for the general case when using the branches created via a TStreamerInfo (i....Definition TLeafElement.h:32; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSeq",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:41267,Integrability,message,message,41267,"T type system.Definition TClass.h:81; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TLeafElementA TLeaf for the general case when using the branches created via a TStreamerInfo (i....Definition TLeafElement.h:32; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSequence::SequenceGetter_tSequencePtr(*)(TStreamerInfo *info, TVirtualCollectionProxy *collectionProxy, TClass *originalClass) SequenceGetter_tDefinition TStreamerInfoActions.h:185; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetMakeClassInt_t GetMakeClass() constDefinition TTree.h:535; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollection",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:42420,Integrability,interface,interface,42420,"id SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSequence::SequenceGetter_tSequencePtr(*)(TStreamerInfo *info, TVirtualCollectionProxy *collectionProxy, TClass *originalClass) SequenceGetter_tDefinition TStreamerInfoActions.h:185; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetMakeClassInt_t GetMakeClass() constDefinition TTree.h:535; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators.Definition TVirtualCollectionIterators.h:26; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionPtrIteratorsDefinition TVirtualCollectionIterators.h:195; double; int; unsigned int; TStreamerInfoActions::TIDsstd::vector< TIDNode > TIDsDefinition TStreamerInfoActions.h:138; ROOT::RCompressionSetting::EAlgorithm::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:91. treetreeincTBranchElement.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:3100,Modifiability,variab,variable,3100, of class; 65 Version_t fClassVersion; ///< Version number of class; 66 Int_t fID; ///< element serial number in fInfo; 67 Int_t fType; ///< Branch type; 68 ///<; 69 ///< Note on fType values:; 70 ///< * -1 unsplit object with custom streamer at time of writing; 71 ///< * 0 unsplit object with default streamer at time of writing; 72 ///< OR simple data member of split object (fID==-1 for the former); 73 ///< * 1 base class of a split object.; 74 ///< * 2 class typed data member of a split object; 75 ///< * 3 branch count of a split TClonesArray; 76 ///< * 31 data member of the content of a split TClonesArray; 77 ///< * 4 branch count of a split STL Collection.; 78 ///< * 41 data member of the content of a split STL collection; 79 Int_t fStreamerType; ///< branch streamer type; 80 Int_t fMaximum; ///< Maximum entries for a TClonesArray or variable array; 81 Int_t fSTLtype; ///<! STL container type; 82 Int_t fNdata; ///<! Number of data in this branch; 83 TBranchElement *fBranchCount; ///< pointer to primary branchcount branch; 84 TBranchElement *fBranchCount2; ///< pointer to secondary branchcount branch; 85 TStreamerInfo *fInfo; ///<! Pointer to StreamerInfo; 86 char *fObject; ///<! Pointer to object at *fAddress; 87 TVirtualArray *fOnfileObject; ///<! Place holder for the onfile representation of data members.; 88 bool fInit : 1; ///<! Initialization flag for branch assignment; 89 bool fInInitInfo : 1;///<! True during the 2nd part of InitInfo (cut recursion).; 90 bool fInitOffsets: 1;///<! Initialization flag to not endlessly recalculate offsets; 91 TClassRef fTargetClass; ///<! Reference to the target in-memory class; 92 TClassRef fCurrentClass; ///<! Reference to current (transient) class definition; 93 TClassRef fParentClass; ///<! Reference to class definition in fParentName; 94 TClassRef fBranchClass; ///<! Reference to class definition in fClassName; 95 TClassRef fClonesClass; ///<! Reference to class definition in fClonesName; 96 Int_t *fBranchOffset; ///<!,MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:33484,Modifiability,variab,variable,33484,ch type.Definition TBranchElement.h:67; TBranchElement::ResetInitInfovirtual void ResetInitInfo(bool recurse)Reset offset and StreamerInfo information from this branch.Definition TBranchElement.cxx:4831; TBranchElement::GetFullNameTString GetFullName() const overrideReturn the 'full' name of the branch.Definition TBranchElement.cxx:2839; TBranchElement::ReadLeavesMakeClassvoid ReadLeavesMakeClass(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4023; TBranchElement::TBranchElementTBranchElement()Default and I/O constructor.Definition TBranchElement.cxx:133; TBranchElement::FillLeavesCustomStreamervoid FillLeavesCustomStreamer(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1646; TBranchElement::GetClonesNamevirtual const char * GetClonesName() constDefinition TBranchElement.h:188; TBranchElement::GetClassvirtual TClass * GetClass() constDefinition TBranchElement.h:187; TBranchElement::fMaximumInt_t fMaximumMaximum entries for a TClonesArray or variable array.Definition TBranchElement.h:80; TBranchElement::ReadLeavesMemberCountervoid ReadLeavesMemberCounter(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4611; TBranchElement::fBranchIDInt_t fBranchID! ID number assigned by a TRefTable.Definition TBranchElement.h:97; TBranchElement::FindLeafTLeaf * FindLeaf(const char *name) overrideFind the leaf corresponding to the name 'searchname'.Definition TBranchElement.cxx:1872; TBranchElement::fIteratorsTVirtualCollectionIterators * fIterators! holds the iterators when the branch is of fType==4.Definition TBranchElement.h:101; TBranchElement::ReleaseObjectvoid ReleaseObject()Delete any object we may have allocated on a previous call to SetAddress.Definition TBranchElement.cxx:4672; TBranchElement::fTargetClassTClassRef fTargetClass! Reference to the target in-memory classDefinition TBranchElement.h:91; TBranchElement::Browsevoid Browse(TBrowser *b) overrideBrowse ,MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:39794,Modifiability,variab,variable,39794,"nition TBranchElement.h:79; TBranchElement::ReadLeavesCollectionSplitVectorPtrMembervoid ReadLeavesCollectionSplitVectorPtrMember(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4398; TBranchElement::GetMakeClassbool GetMakeClass() const overrideReturn whether this branch is in a mode where the object are decomposed or not (Also known as MakeCla...Definition TBranchElement.cxx:2866; TBranchElement::SetAddressImplvoid SetAddressImpl(void *addr, bool implied) overrideSee TBranchElement::SetAddress.Definition TBranchElement.cxx:4970; TBranchElement::SetFillLeavesPtrvoid SetFillLeavesPtr()Set the FillLeaves pointer to execute the expected operations.Definition TBranchElement.cxx:5811; TBranchElement::ReadLeavesCollectionMembervoid ReadLeavesCollectionMember(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4429; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::fAddresschar * fAddress! Address of 1st leaf (variable or object)Definition TBranch.h:147; TBranch::fTreeTTree * fTree! Pointer to Tree headerDefinition TBranch.h:144; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TLeafElementA TLeaf for the general case when using the branches created via a TStreamerInfo (i....Definition TLeafElement.h:32; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Defini",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:42875,Modifiability,inherit,inherited,42875,"id SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSequence::SequenceGetter_tSequencePtr(*)(TStreamerInfo *info, TVirtualCollectionProxy *collectionProxy, TClass *originalClass) SequenceGetter_tDefinition TStreamerInfoActions.h:185; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetMakeClassInt_t GetMakeClass() constDefinition TTree.h:535; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators.Definition TVirtualCollectionIterators.h:26; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionPtrIteratorsDefinition TVirtualCollectionIterators.h:195; double; int; unsigned int; TStreamerInfoActions::TIDsstd::vector< TIDNode > TIDsDefinition TStreamerInfoActions.h:138; ROOT::RCompressionSetting::EAlgorithm::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:91. treetreeincTBranchElement.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:28370,Performance,load,loaded,28370,6; TBranchElement::fIDInt_t fIDelement serial number in fInfoDefinition TBranchElement.h:66; TBranchElement::GetAddresschar * GetAddress() const overrideGet the branch address.Definition TBranchElement.cxx:1923; TBranchElement::FillLeavesMemberCountervoid FillLeavesMemberCounter(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1697; TBranchElement::SetBranchCount2void SetBranchCount2(TBranchElement *bre)Definition TBranchElement.h:124; TBranchElement::FillLeavesCollectionSplitPtrMembervoid FillLeavesCollectionSplitPtrMember(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1499; TBranchElement::SetAddressvoid SetAddress(void *addobj) overridePoint this branch at an object.Definition TBranchElement.cxx:4962; TBranchElement::GetInfoImpTStreamerInfo * GetInfoImp() constGet streamer info for the branch class.Definition TBranchElement.cxx:1011; TBranchElement::SetTargetClassvirtual void SetTargetClass(const char *name)Set the name of the class of the in-memory object into which the data will loaded.Definition TBranchElement.cxx:5855; TBranchElement::ResetDeleteObjectvirtual void ResetDeleteObject()Release ownership of any allocated objects.Definition TBranchElement.cxx:4814; TBranchElement::GetParentNamevirtual const char * GetParentName() constDefinition TBranchElement.h:200; TBranchElement::ValidateAddressvoid ValidateAddress() constDefinition TBranchElement.h:264; TBranchElement::GetOnfileObjectTVirtualArray * GetOnfileObject() constDefinition TBranchElement.h:199; TBranchElement::fWriteIteratorsTVirtualCollectionIterators * fWriteIterators! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers.Definition TBranchElement.h:102; TBranchElement::PrintValuevoid PrintValue(Int_t i) constPrints values of leaves.Definition TBranchElement.cxx:3928; TBranchElement::fOnfileObjectTVirtualArray * fOnfileObject! Place holder for the onfile representation of data mem,MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:42154,Security,access,access,42154,"id SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSequence::SequenceGetter_tSequencePtr(*)(TStreamerInfo *info, TVirtualCollectionProxy *collectionProxy, TClass *originalClass) SequenceGetter_tDefinition TStreamerInfoActions.h:185; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetMakeClassInt_t GetMakeClass() constDefinition TTree.h:535; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators.Definition TVirtualCollectionIterators.h:26; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionPtrIteratorsDefinition TVirtualCollectionIterators.h:195; double; int; unsigned int; TStreamerInfoActions::TIDsstd::vector< TIDNode > TIDsDefinition TStreamerInfoActions.h:138; ROOT::RCompressionSetting::EAlgorithm::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:91. treetreeincTBranchElement.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranchElement_8h_source.html:2593,Usability,simpl,simple,2593,"ranch {; 40 ; 41// Friends; 42 friend class TTreeCloner;; 43 friend class TLeafElement;; 44 ; 45/// Types; 46protected:; 47 enum EStatusBits {; 48 kBranchFolder = BIT(14),; 49 kDeleteObject = BIT(16), ///< We are the owner of fObject.; 50 kCache = BIT(18), ///< Need to pushd/pop fOnfileObject.; 51 kOwnOnfileObj = BIT(19), ///< We are the owner of fOnfileObject.; 52 kAddressSet = BIT(20), ///< The addressing set have been called for this branch; 53 kMakeClass = BIT(21), ///< This branch has been switched to using the MakeClass Mode; 54 kDecomposedObj = BIT(21) ///< More explicit alias for kMakeClass.; 55 };; 56 ; 57 ; 58// Data Members; 59protected:; 60 TString fClassName; ///< Class name of referenced object; 61 TString fParentName; ///< Name of parent class; 62 TString fClonesName; ///< Name of class in TClonesArray (if any); 63 TVirtualCollectionProxy *fCollProxy; ///<! collection interface (if any); 64 UInt_t fCheckSum; ///< CheckSum of class; 65 Version_t fClassVersion; ///< Version number of class; 66 Int_t fID; ///< element serial number in fInfo; 67 Int_t fType; ///< Branch type; 68 ///<; 69 ///< Note on fType values:; 70 ///< * -1 unsplit object with custom streamer at time of writing; 71 ///< * 0 unsplit object with default streamer at time of writing; 72 ///< OR simple data member of split object (fID==-1 for the former); 73 ///< * 1 base class of a split object.; 74 ///< * 2 class typed data member of a split object; 75 ///< * 3 branch count of a split TClonesArray; 76 ///< * 31 data member of the content of a split TClonesArray; 77 ///< * 4 branch count of a split STL Collection.; 78 ///< * 41 data member of the content of a split STL collection; 79 Int_t fStreamerType; ///< branch streamer type; 80 Int_t fMaximum; ///< Maximum entries for a TClonesArray or variable array; 81 Int_t fSTLtype; ///<! STL container type; 82 Int_t fNdata; ///<! Number of data in this branch; 83 TBranchElement *fBranchCount; ///< pointer to primary branchcount branch; 84 TBranc",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:14924,Availability,avail,available,14924,"ype);; 384 } else if (*leaftype == 'f') {; 385 leaf = new TLeafF16(this, leafname, leaftype);; 386 } else if (*leaftype == 'L') {; 387 leaf = new TLeafL(this, leafname, leaftype);; 388 } else if (*leaftype == 'l') {; 389 leaf = new TLeafL(this, leafname, leaftype);; 390 leaf->SetUnsigned();; 391 } else if (*leaftype == 'D') {; 392 leaf = new TLeafD(this, leafname, leaftype);; 393 } else if (*leaftype == 'd') {; 394 leaf = new TLeafD32(this, leafname, leaftype);; 395 } else if (*leaftype == 'G') {; 396 leaf = new TLeafG(this, leafname, leaftype);; 397 } else if (*leaftype == 'g') {; 398 leaf = new TLeafG(this, leafname, leaftype);; 399 leaf->SetUnsigned();; 400 }; 401 if (!leaf) {; 402 Error(""TLeaf"", ""Illegal data type for %s/%s"", name, leaflist);; 403 delete[] leaftype;; 404 delete [] leafname;; 405 MakeZombie();; 406 return;; 407 }; 408 if (leaf->IsZombie()) {; 409 delete leaf;; 410 leaf = nullptr;; 411 auto msg = ""Illegal leaf: %s/%s. If this is a variable size C array it's possible that the branch holding the size is not available."";; 412 Error(""TBranch"", msg, name, leaflist);; 413 delete [] leafname;; 414 delete[] leaftype;; 415 MakeZombie();; 416 return;; 417 }; 418 leaf->SetBranch(this);; 419 leaf->SetAddress((char*) (fAddress + offset));; 420 leaf->SetOffset(offset);; 421 if (leaf->GetLeafCount()) {; 422 // -- Leaf is a varying length array, we need an offset array.; 423 fEntryOffsetLen = 1000;; 424 }; 425 if (leaf->InheritsFrom(TLeafC::Class())) {; 426 // -- Leaf is a character string, we need an offset array.; 427 fEntryOffsetLen = 1000;; 428 }; 429 ++fNleaves;; 430 fLeaves.Add(leaf);; 431 fTree->GetListOfLeaves()->Add(leaf);; 432 if (*pos == 0) {; 433 // -- We reached the end of the leaf specification.; 434 break;; 435 }; 436 nameBegin = pos + 1;; 437 offset += leaf->GetLenType() * leaf->GetLen();; 438 }; 439 }; 440 delete[] leafname;; 441 leafname = nullptr;; 442 delete[] leaftype;; 443 leaftype = nullptr;; 444 ; 445}; 446 ; 447///////////////////////////",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:18830,Availability,down,down,18830,"505 file->Close();; 506 delete file;; 507 file = nullptr;; 508 }; 509 }; 510 ; 511 fTree = nullptr;; 512 fDirectory = nullptr;; 513 ; 514 if (fTransientBuffer) {; 515 delete fTransientBuffer;; 516 fTransientBuffer = nullptr;; 517 }; 518}; 519 ; 520////////////////////////////////////////////////////////////////////////////////; 521/// Returns the transient buffer currently used by this TBranch for reading/writing baskets.; 522 ; 523TBuffer* TBranch::GetTransientBuffer(Int_t size); 524{; 525 if (fTransientBuffer) {; 526 if (fTransientBuffer->BufferSize() < size) {; 527 fTransientBuffer->Expand(size);; 528 }; 529 return fTransientBuffer;; 530 }; 531 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 532 return fTransientBuffer;; 533}; 534 ; 535////////////////////////////////////////////////////////////////////////////////; 536/// Add the basket to this branch.; 537///; 538/// Warning: if the basket are not 'flushed/copied' in the same; 539/// order as they were created, this will induce a slow down in; 540/// the insert (since we'll need to move all the record that are; 541/// entere 'too early').; 542/// Warning we also assume that the __current__ write basket is; 543/// not present (aka has been removed) or is empty (no entries).; 544 ; 545void TBranch::AddBasket(TBasket& b, bool ondisk, Long64_t startEntry); 546{; 547 TBasket *basket = &b;; 548 ; 549 basket->SetBranch(this);; 550 ; 551 if (fWriteBasket >= fMaxBaskets) {; 552 ExpandBasketArrays();; 553 }; 554 Int_t where = fWriteBasket;; 555 ; 556 if (where && startEntry < fBasketEntry[where-1]) {; 557 // Need to find the right location and move the possible baskets; 558 ; 559 if (!ondisk) {; 560 Warning(""AddBasket"",""The assumption that out-of-order basket only comes from disk based ntuple is false."");; 561 }; 562 ; 563 if (startEntry < fBasketEntry[0]) {; 564 where = 0;; 565 } else {; 566 for(Int_t i=fWriteBasket-1; i>=0; --i) {; 567 if (fBasketEntry[i] < startEntry) {; 568 where = i+1;; 569 break;; 570 } ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:22816,Availability,error,error,22816,"t have the highest entry number (%s/%lld/%d)."",GetName(),startEntry,fWriteBasket);; 629 ; 630 }; 631 // The first basket (should) always start at zero. If we are asked to update; 632 // it, this likely to be from merging 'empty' branches (base class node and the likes); 633 if (where) {; 634 fBasketEntry[where] = startEntry;; 635 fBaskets.AddAtAndExpand(nullptr,fWriteBasket);; 636 }; 637}; 638 ; 639////////////////////////////////////////////////////////////////////////////////; 640/// Loop on all leaves of this branch to back fill Basket buffer.; 641///; 642/// Use this routine instead of TBranch::Fill when filling a branch individually; 643/// to catch up with the number of entries already in the TTree.; 644///; 645/// First it calls TBranch::Fill and then if the number of entries of the branch; 646/// reach one of TTree cluster's boundary, the basket is flushed.; 647///; 648/// The function returns the number of bytes committed to the memory basket.; 649/// If a write error occurs, the number of bytes returned is -1.; 650/// If no data are written, because e.g. the branch is disabled,; 651/// the number of bytes returned is 0.; 652///; 653/// To insure that the baskets of each cluster are located close by in the; 654/// file, when back-filling multiple branches make sure to call BackFill; 655/// for the same entry for all the branches consecutively; 656/// ~~~ {.cpp}; 657/// for( auto e = 0; e < tree->GetEntries(); ++e ) { // loop over entries.; 658/// for( auto branch : branchCollection) {; 659/// ... Make change to the data associated with the branch ...; 660/// branch->BackFill();; 661/// }; 662/// }; 663/// // Since we loop over all the branches for each new entry; 664/// // all the baskets for a cluster are consecutive in the file.; 665/// ~~~; 666/// rather than doing all the entries of one branch at a time.; 667/// ~~~ {.cpp}; 668/// // Do NOT do things in the following order, it will lead to; 669/// // poorly clustered files.; 670/// for(auto branch : bran",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:29851,Availability,error,error,29851,"size = TMath::Max(10,Int_t(1.5*fMaxBaskets));; 828 fBasketBytes = TStorage::ReAllocInt(fBasketBytes, newsize, fMaxBaskets);; 829 fBasketEntry = (Long64_t*)TStorage::ReAlloc(fBasketEntry,; 830 newsize*sizeof(Long64_t),fMaxBaskets*sizeof(Long64_t));; 831 fBasketSeek = (Long64_t*)TStorage::ReAlloc(fBasketSeek,; 832 newsize*sizeof(Long64_t),fMaxBaskets*sizeof(Long64_t));; 833 ; 834 fMaxBaskets = newsize;; 835 ; 836 fBaskets.Expand(newsize);; 837 ; 838 for (Int_t i=fWriteBasket;i<fMaxBaskets;i++) {; 839 fBasketBytes[i] = 0;; 840 fBasketEntry[i] = 0;; 841 fBasketSeek[i] = 0;; 842 }; 843}; 844 ; 845////////////////////////////////////////////////////////////////////////////////; 846/// Loop on all leaves of this branch to fill Basket buffer.; 847///; 848/// If TBranchIMTHelper is non-null and it is time to WriteBasket, then we will; 849/// use TBB to compress in parallel.; 850///; 851/// The function returns the number of bytes committed to the memory basket.; 852/// If a write error occurs, the number of bytes returned is -1.; 853/// If no data are written, because e.g. the branch is disabled,; 854/// the number of bytes returned is 0.; 855 ; 856Int_t TBranch::FillImpl(ROOT::Internal::TBranchIMTHelper *imtHelper); 857{; 858 if (TestBit(kDoNotProcess)) {; 859 return 0;; 860 }; 861 ; 862 TBasket* basket = (TBasket*)fBaskets.UncheckedAt(fWriteBasket);; 863 if (!basket) {; 864 basket = fTree->CreateBasket(this); // create a new basket; 865 if (!basket) return 0;; 866 ++fNBaskets;; 867 fBaskets.AddAtAndExpand(basket,fWriteBasket);; 868 }; 869 TBuffer* buf = basket->GetBufferRef();; 870 ; 871 // Fill basket buffer.; 872 ; 873 Int_t nsize = 0;; 874 ; 875 if (buf->IsReading()) {; 876 basket->SetWriteMode();; 877 }; 878 ; 879 if (!TestBit(kDoNotUseBufferMap)) {; 880 buf->ResetMap();; 881 }; 882 ; 883 Int_t lnew = 0;; 884 Int_t nbytes = 0;; 885 ; 886 if (fEntryBuffer) {; 887 nbytes = FillEntryBuffer(basket,buf,lnew);; 888 } else {; 889 Int_t lold = buf->Length();; 890 basket->Update",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:39970,Availability,error,error,39970,"n leaf;; 1111 ; 1112 // The leaf element contains the branch name in its name.; 1113 longname.Form(""%s.%s"",branch->GetName(),searchname);; 1114 if (longname==leafname) return leaf;; 1115 ; 1116 longtitle.Form(""%s.%s"",branch->GetName(),leaftitle.Data());; 1117 dim = longtitle.First('[');; 1118 if (dim>=0) longtitle.Remove(dim);; 1119 if (longtitle == searchname) return leaf;; 1120 ; 1121 // The following is for the case where the branch is only; 1122 // a sub-branch. Since we do not see it through; 1123 // TTree::GetListOfBranches, we need to see it indirectly.; 1124 // This is the less sturdy part of this search ... it may; 1125 // need refining ...; 1126 if (strstr(searchname, ""."") && !strcmp(searchname, branch->GetName())) return leaf;; 1127 }; 1128 }; 1129 return nullptr;; 1130}; 1131 ; 1132////////////////////////////////////////////////////////////////////////////////; 1133/// Flush to disk all the baskets of this branch and any of subbranches.; 1134/// Return the number of bytes written or -1 in case of write error.; 1135 ; 1136Int_t TBranch::FlushBaskets(); 1137{; 1138 UInt_t nerror = 0;; 1139 Int_t nbytes = 0;; 1140 ; 1141 Int_t maxbasket = fWriteBasket + 1;; 1142 // The following protection is not necessary since we should always; 1143 // have fWriteBasket < fBasket.GetSize(); 1144 //if (fBaskets.GetSize() < maxbasket) {; 1145 // maxbasket = fBaskets.GetSize();; 1146 //}; 1147 for(Int_t i=0; i != maxbasket; ++i) {; 1148 if (fBaskets.UncheckedAt(i)) {; 1149 Int_t nwrite = FlushOneBasket(i);; 1150 if (nwrite<0) {; 1151 ++nerror;; 1152 } else {; 1153 nbytes += nwrite;; 1154 }; 1155 }; 1156 }; 1157 Int_t len = fBranches.GetEntriesFast();; 1158 for (Int_t i = 0; i < len; ++i) {; 1159 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 1160 if (!branch) {; 1161 continue;; 1162 }; 1163 Int_t nwrite = branch->FlushBaskets();; 1164 if (nwrite<0) {; 1165 ++nerror;; 1166 } else {; 1167 nbytes += nwrite;; 1168 }; 1169 }; 1170 if (nerror) {; 1171 return -1;; 1172 } ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:42805,Availability,error,errors,42805,") {; 1195 basket->SetWriteMode();; 1196 }; 1197 nbytes = WriteBasket(basket,ibasket);; 1198 ; 1199 } else {; 1200 // If the basket is empty or has already been written.; 1201 if ((Int_t)ibasket==fWriteBasket) {; 1202 // Nothing to do.; 1203 } else {; 1204 basket->DropBuffers();; 1205 if (basket == fCurrentBasket) {; 1206 fCurrentBasket = nullptr;; 1207 fFirstBasketEntry = -1;; 1208 fNextBasketEntry = -1;; 1209 }; 1210 delete basket;; 1211 --fNBaskets;; 1212 fBaskets[ibasket] = nullptr;; 1213 }; 1214 }; 1215 }; 1216 }; 1217 return nbytes;; 1218}; 1219 ; 1220////////////////////////////////////////////////////////////////////////////////; 1221/// Return pointer to basket basketnumber in this Branch; 1222///; 1223/// If a new buffer must be created and the user_buffer argument is non-null,; 1224/// then the memory in the user_buffer will be shared with the returned TBasket.; 1225 ; 1226TBasket* TBranch::GetBasketImpl(Int_t basketnumber, TBuffer *user_buffer); 1227{; 1228 // This counter in the sequential case collects errors coming also from; 1229 // different files (suppose to have a program reading f1.root, f2.root ...); 1230 // In the mt case, it is made atomic: it safely collects errors from; 1231 // different files processed simultaneously.; 1232 static std::atomic<Int_t> nerrors(0);; 1233 ; 1234 // reference to an existing basket in memory ?; 1235 if (basketnumber <0 || basketnumber > fWriteBasket) return nullptr;; 1236 TBasket *basket = (TBasket*)fBaskets.UncheckedAt(basketnumber);; 1237 if (basket) return basket;; 1238 if (basketnumber == fWriteBasket) return nullptr;; 1239 ; 1240 // create/decode basket parameters from buffer; 1241 TFile *file = GetFile(0);; 1242 if (file == nullptr) {; 1243 return nullptr;; 1244 }; 1245 // if cluster pre-fetching or retaining is on, do not re-use existing baskets; 1246 // unless a new cluster is used.; 1247 if (fTree->GetMaxVirtualSize() < 0 || fTree->GetClusterPrefetch()); 1248 basket = GetFreshCluster(user_buffer);; 1249 els",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:42974,Availability,error,errors,42974,"iteBasket) {; 1202 // Nothing to do.; 1203 } else {; 1204 basket->DropBuffers();; 1205 if (basket == fCurrentBasket) {; 1206 fCurrentBasket = nullptr;; 1207 fFirstBasketEntry = -1;; 1208 fNextBasketEntry = -1;; 1209 }; 1210 delete basket;; 1211 --fNBaskets;; 1212 fBaskets[ibasket] = nullptr;; 1213 }; 1214 }; 1215 }; 1216 }; 1217 return nbytes;; 1218}; 1219 ; 1220////////////////////////////////////////////////////////////////////////////////; 1221/// Return pointer to basket basketnumber in this Branch; 1222///; 1223/// If a new buffer must be created and the user_buffer argument is non-null,; 1224/// then the memory in the user_buffer will be shared with the returned TBasket.; 1225 ; 1226TBasket* TBranch::GetBasketImpl(Int_t basketnumber, TBuffer *user_buffer); 1227{; 1228 // This counter in the sequential case collects errors coming also from; 1229 // different files (suppose to have a program reading f1.root, f2.root ...); 1230 // In the mt case, it is made atomic: it safely collects errors from; 1231 // different files processed simultaneously.; 1232 static std::atomic<Int_t> nerrors(0);; 1233 ; 1234 // reference to an existing basket in memory ?; 1235 if (basketnumber <0 || basketnumber > fWriteBasket) return nullptr;; 1236 TBasket *basket = (TBasket*)fBaskets.UncheckedAt(basketnumber);; 1237 if (basket) return basket;; 1238 if (basketnumber == fWriteBasket) return nullptr;; 1239 ; 1240 // create/decode basket parameters from buffer; 1241 TFile *file = GetFile(0);; 1242 if (file == nullptr) {; 1243 return nullptr;; 1244 }; 1245 // if cluster pre-fetching or retaining is on, do not re-use existing baskets; 1246 // unless a new cluster is used.; 1247 if (fTree->GetMaxVirtualSize() < 0 || fTree->GetClusterPrefetch()); 1248 basket = GetFreshCluster(user_buffer);; 1249 else; 1250 basket = GetFreshBasket(basketnumber, user_buffer);; 1251 ; 1252 // fSkipZip is old stuff still maintained for CDF; 1253 if (fSkipZip) basket->SetBit(TBufferFile::kNotDecompressed);; 1254 if",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:44796,Availability,error,error,44796," }; 1245 // if cluster pre-fetching or retaining is on, do not re-use existing baskets; 1246 // unless a new cluster is used.; 1247 if (fTree->GetMaxVirtualSize() < 0 || fTree->GetClusterPrefetch()); 1248 basket = GetFreshCluster(user_buffer);; 1249 else; 1250 basket = GetFreshBasket(basketnumber, user_buffer);; 1251 ; 1252 // fSkipZip is old stuff still maintained for CDF; 1253 if (fSkipZip) basket->SetBit(TBufferFile::kNotDecompressed);; 1254 if (fBasketBytes[basketnumber] == 0) {; 1255 fBasketBytes[basketnumber] = basket->ReadBasketBytes(fBasketSeek[basketnumber],file);; 1256 }; 1257 //add branch to cache (if any); 1258 {; 1259 R__LOCKGUARD_IMT(gROOTMutex); // Lock for parallel TTree I/O; 1260 TFileCacheRead *pf = fTree->GetReadCache(file);; 1261 if (pf){; 1262 if (pf->IsLearning()) pf->LearnBranch(this, false);; 1263 if (fSkipZip) pf->SetSkipZip();; 1264 }; 1265 }; 1266 ; 1267 //now read basket; 1268 Int_t badread = basket->ReadBasketBuffers(fBasketSeek[basketnumber],fBasketBytes[basketnumber],file);; 1269 if (R__unlikely(badread || basket->GetSeekKey() != fBasketSeek[basketnumber] || basket->IsZombie())) {; 1270 nerrors++;; 1271 if (nerrors > 10) return nullptr;; 1272 if (nerrors == 10) {; 1273 printf("" file probably overwritten: stopping reporting error messages\n"");; 1274 if (fBasketSeek[basketnumber] > 2000000000) {; 1275 printf(""===>File is more than 2 Gigabytes\n"");; 1276 return nullptr;; 1277 }; 1278 if (fBasketSeek[basketnumber] > 1000000000) {; 1279 printf(""===>Your file is may be bigger than the maximum file size allowed on your system\n"");; 1280 printf("" Check your AFS maximum file size limit for example\n"");; 1281 return nullptr;; 1282 }; 1283 }; 1284 Error(""GetBasket"",""File: %s at byte:%lld, branch:%s, entry:%lld, badread=%d, nerrors=%d, basketnumber=%d"",file->GetName(),basket->GetSeekKey(),GetName(),fReadEntry,badread,nerrors.load(),basketnumber);; 1285 return nullptr;; 1286 }; 1287 ; 1288 ++fNBaskets;; 1289 ; 1290 fCacheInfo.SetUsed(basketnumber);;",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:47843,Availability,error,error,47843,"h::GetClassName() const; 1325{; 1326 return """";; 1327}; 1328 ; 1329////////////////////////////////////////////////////////////////////////////////; 1330/// Return icon name depending on type of branch.; 1331 ; 1332const char* TBranch::GetIconName() const; 1333{; 1334 if (IsFolder()); 1335 return ""TBranchElement-folder"";; 1336 else; 1337 return ""TBranchElement-leaf"";; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// A helper function to locate the correct basket - and its first entry.; 1342/// Extracted to a common private function because it is needed by both GetEntry; 1343/// and GetBulkEntries. It should not be called directly.; 1344///; 1345/// If a new basket must be constructed and the user_buffer is provided, then; 1346/// the user_buffer will back the memory of the newly-constructed basket.; 1347///; 1348/// Assumes that this branch is enabled.; 1349///; 1350/// Returns -1 if the entry does not exist; 1351/// Returns -2 in case of error; 1352/// Returns the index of the basket in case of success.; 1353Int_t TBranch::GetBasketAndFirst(TBasket *&basket, Long64_t &first,; 1354 TBuffer *user_buffer); 1355{; 1356 Long64_t updatedNext = fNextBasketEntry;; 1357 Long64_t entry = fReadEntry;; 1358 if (R__likely(fCurrentBasket && fFirstBasketEntry <= entry && entry < fNextBasketEntry)) {; 1359 // We have found the basket containing this entry.; 1360 // make sure basket buffers are in memory.; 1361 basket = fCurrentBasket;; 1362 first = fFirstBasketEntry;; 1363 return fReadBasket;; 1364 } else {; 1365 if ((entry < fFirstEntry) || (entry >= fEntryNumber)) {; 1366 return -1;; 1367 }; 1368 first = fFirstBasketEntry;; 1369 Long64_t last = fNextBasketEntry - 1;; 1370 // Are we still in the same ReadBasket?; 1371 if ((entry < first) || (entry > last)) {; 1372 fReadBasket = TMath::BinarySearch(fWriteBasket + 1, fBasketEntry, entry);; 1373 if (fReadBasket < 0) {; 1374 fNextBasketEntry = -1;; 1375 Error(""GetBasketAndFirs",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:51542,Availability,failure,failure,51542,"ket = basket;; 1420 }; 1421 return fReadBasket;; 1422 }; 1423}; 1424 ; 1425////////////////////////////////////////////////////////////////////////////////; 1426/// Returns true if this branch supports bulk IO, false otherwise.; 1427///; 1428/// This will return true if all the various preconditions necessary hold true; 1429/// to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may; 1430/// still fail, depending on the contents of the individual TBaskets loaded.; 1431bool TBranch::SupportsBulkRead() const {; 1432 return (fNleaves == 1) &&; 1433 (static_cast<TLeaf*>(fLeaves.UncheckedAt(0))->GetDeserializeType() != TLeaf::DeserializeType::kExternal);; 1434}; 1435 ; 1436////////////////////////////////////////////////////////////////////////////////; 1437/// \brief Read a basket of events into the given buffer with byte swapping.; 1438///; 1439/// \return On success, the number of events of the type held by this branch; 1440/// that have been read into the buffer. -1 on failure.; 1441///; 1442/// On success, the caller should be able to access the contents of buf as they; 1443/// are with:; 1444///; 1445/// ~~~{.cpp}; 1446/// static_cast<T*>(buf.GetCurrent()); 1447/// ~~~; 1448///; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1452/// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; 1453/// from the branchCount. After deserialization those value can be used to calculate; 1454/// the number of elements corresponding to each entries.; 1455///; 1456/// For each entry the number of elements is the multiplication of; 1457/// ; 1458/// ~~~{.cpp}; 1459/// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1460/// auto len = leaf->GetLen();; 1461/// ~~~; 1462///; 1463/// and the value in the BranchCount corresponding to that entry (can be obtained; 1464/// from `branch->GetBranchCount()`).; 1465///; 1466/// \not",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:56035,Availability,failure,failure,56035,";; 1530 user_buf.SetBufferOffset(bufbegin);; 1531 ; 1532 Int_t N = ((fNextBasketEntry < 0) ? fEntryNumber : fNextBasketEntry) - first;; 1533 //printf(""Requesting %d events; fNextBasketEntry=%lld; first=%lld.\n"", N, fNextBasketEntry, first);; 1534 if (R__unlikely(!leaf->ReadBasketFast(user_buf, N))) {; 1535 Error(""GetBulkEntries"", ""Leaf failed to read.\n"");; 1536 return -1;; 1537 }; 1538 user_buf.SetBufferOffset(bufbegin);; 1539 ; 1540 if (fCurrentBasket == nullptr) {; 1541 R__ASSERT(fExtraBasket == nullptr && ""fExtraBasket should have been set to nullptr by GetFreshBasket"");; 1542 fExtraBasket = basket;; 1543 basket->DisownBuffer();; 1544 }; 1545 ; 1546 return N;; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// \brief Read a basket of events into the given buffer without byte swapping.; 1551///; 1552/// \return On success, the number of events of the type held by this branch; 1553/// that have been read into the buffer. -1 on failure.; 1554///; 1555/// On success, the caller still need to deserialize the content. For example for; 1556/// a scalar branch and `N` the return value (i.e. number of entries); 1557///; 1558/// ~~~{.cpp}; 1559/// rawdata = static_cast<char*>(buf.GetCurrent());; 1560/// for (std::size_t i = 0u; i < N; ++i, ++target); 1561/// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; 1562/// ~~~; 1563///; 1564/// where target is a pointer or array to the type stored on this branch.; 1565///; 1566/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1567/// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; 1568/// from the branchCount. After deserialization those value can be used to calculate; 1569/// the number of elements corresponding to each entries.; 1570///; 1571/// For each entry the number of elements is the multiplication of; 1572///; 1573/// ~~~{.cpp}; 1574/// TLeaf *leaf = dynamic_cast<TLeaf*>(bran",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:62201,Availability,error,error,62201,"offset);; 1675 }; 1676 }; 1677 ; 1678 if (fCurrentBasket == nullptr) {; 1679 R__ASSERT(fExtraBasket == nullptr && ""fExtraBasket should have been set to nullptr by GetFreshBasket"");; 1680 fExtraBasket = basket;; 1681 basket->DisownBuffer();; 1682 }; 1683 ; 1684 return N;; 1685}; 1686 ; 1687////////////////////////////////////////////////////////////////////////////////; 1688/// Read all leaves of entry and return total number of bytes read.; 1689///; 1690/// The input argument ""entry"" is the entry number in the current tree.; 1691/// In case of a TChain, the entry number in the current Tree must be found; 1692/// before calling this function. For example:; 1693///; 1694///~~~ {.cpp}; 1695/// TChain* chain = ...;; 1696/// Long64_t localEntry = chain->LoadTree(entry);; 1697/// branch->GetEntry(localEntry);; 1698///~~~; 1699///; 1700/// The function returns the number of bytes read from the input buffer.; 1701/// If entry does not exist, the function returns 0.; 1702/// If an I/O error occurs, the function returns -1.; 1703///; 1704/// See IMPORTANT REMARKS in TTree::GetEntry.; 1705 ; 1706Int_t TBranch::GetEntry(Long64_t entry, Int_t getall); 1707{; 1708 // Remember which entry we are reading.; 1709 fReadEntry = entry;; 1710 ; 1711 if (R__unlikely(TestBit(kDoNotProcess) && !getall)) { return 0; }; 1712 ; 1713 TBasket *basket; // will be initialized in the if/then clauses.; 1714 Long64_t first;; 1715 ; 1716 Int_t result = GetBasketAndFirst(basket, first, nullptr);; 1717 if (R__unlikely(result < 0)) { return result + 1; }; 1718 ; 1719 basket->PrepareBasket(entry);; 1720 TBuffer* buf = basket->GetBufferRef();; 1721 ; 1722 // This test necessary to read very old Root files (NvE).; 1723 if (R__unlikely(!buf)) {; 1724 TFile* file = GetFile(0);; 1725 if (!file) return -1;; 1726 basket->ReadBasketBuffers(fBasketSeek[fReadBasket], fBasketBytes[fReadBasket], file);; 1727 buf = basket->GetBufferRef();; 1728 }; 1729 ; 1730 // Set entry offset in buffer.; 1731 if (!TestBit(kDoNotUse",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:66820,Availability,failure,failure,66820,"2 // Set entry offset in buffer and read data from all leaves.; 1803 if (!TestBit(kDoNotUseBufferMap)) {; 1804 buf->ResetMap();; 1805 }; 1806 if (R__unlikely(!buf->IsReading())) {; 1807 basket->SetReadMode();; 1808 }; 1809 Int_t* entryOffset = basket->GetEntryOffset();; 1810 Int_t bufbegin = 0;; 1811 if (entryOffset) {; 1812 bufbegin = entryOffset[entry-first];; 1813 buf->SetBufferOffset(bufbegin);; 1814 Int_t* displacement = basket->GetDisplacement();; 1815 if (R__unlikely(displacement)) {; 1816 buf->SetBufferDisplacement(displacement[entry-first]);; 1817 }; 1818 } else {; 1819 bufbegin = basket->GetKeylen() + ((entry-first) * basket->GetNevBufSize());; 1820 buf->SetBufferOffset(bufbegin);; 1821 }; 1822 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(0);; 1823 leaf->ReadBasketExport(*buf, li, nentries);; 1824 nbytes = buf->Length() - bufbegin;; 1825 return nbytes;; 1826}; 1827 ; 1828////////////////////////////////////////////////////////////////////////////////; 1829/// Fill expectedClass and expectedType with information on the data type of the; 1830/// object/values contained in this branch (and thus the type of pointers; 1831/// expected to be passed to Set[Branch]Address; 1832/// return 0 in case of success and > 0 in case of failure.; 1833 ; 1834Int_t TBranch::GetExpectedType(TClass *&expectedClass,EDataType &expectedType); 1835{; 1836 expectedClass = nullptr;; 1837 expectedType = kOther_t;; 1838 TLeaf* l = (TLeaf*) GetListOfLeaves()->At(0);; 1839 if (l) {; 1840 expectedType = (EDataType) gROOT->GetType(l->GetTypeName())->GetType();; 1841 return 0;; 1842 } else {; 1843 Error(""GetExpectedType"", ""Did not find any leaves in %s"",GetName());; 1844 return 1;; 1845 }; 1846}; 1847 ; 1848////////////////////////////////////////////////////////////////////////////////; 1849/// Return pointer to the file where branch buffers reside, returns 0; 1850/// in case branch buffers reside in the same file as tree header.; 1851/// If mode is 1 the branch buffer file is recreated.; 18",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:78450,Availability,error,error,78450,"e the 'mutable' keyword; 2136 return fMother;; 2137 }; 2138 if (!parent->fParent) {; 2139 // This is the top node; 2140 const_cast<TBranch*>(this)->fMother = parent; // We can not yet use the 'mutable' keyword; 2141 return fMother;; 2142 }; 2143 parent = parent->fParent;; 2144 }; 2145 }; 2146 ; 2147 const TObjArray* array = fTree->GetListOfBranches();; 2148 Int_t n = array->GetEntriesFast();; 2149 for (Int_t i = 0; i < n; ++i) {; 2150 TBranch* branch = (TBranch*) array->UncheckedAt(i);; 2151 TBranch* parent = branch->GetSubBranch(this);; 2152 if (parent) {; 2153 const_cast<TBranch*>(this)->fMother = branch; // We can not yet use the 'mutable' keyword; 2154 return branch;; 2155 }; 2156 }; 2157 return nullptr;; 2158}; 2159 ; 2160////////////////////////////////////////////////////////////////////////////////; 2161/// Find the parent branch of child.; 2162/// Return 0 if child is not in this branch hierarchy.; 2163 ; 2164TBranch* TBranch::GetSubBranch(const TBranch* child) const; 2165{; 2166 // Handle error condition, if the parameter is us, we cannot find the parent.; 2167 if (this == child) {; 2168 // Note: We cast away any const-ness of ""this"".; 2169 return (TBranch*) this;; 2170 }; 2171 ; 2172 if (child->fParent) {; 2173 return child->fParent;; 2174 }; 2175 ; 2176 Int_t len = fBranches.GetEntriesFast();; 2177 for (Int_t i = 0; i < len; ++i) {; 2178 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 2179 if (!branch) {; 2180 continue;; 2181 }; 2182 if (branch == child) {; 2183 // We are the direct parent of child.; 2184 // Note: We cast away any const-ness of ""this"".; 2185 const_cast<TBranch*>(child)->fParent = (TBranch*)this; // We can not yet use the 'mutable' keyword; 2186 return (TBranch*) this;; 2187 }; 2188 // FIXME: This is a tail-recursion!; 2189 TBranch* parent = branch->GetSubBranch(child);; 2190 if (parent) {; 2191 return parent;; 2192 }; 2193 }; 2194 // We failed to find the parent.; 2195 return nullptr;; 2196}; 2197 ; 2198//////////////////////////",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:119011,Availability,error,error,119011,:586; b#define b(i)Definition RSha256.hxx:100; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Char_tchar Char_tDefinition RtypesCore.h:37; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBasket.h; TBranchBrowsable.h; TBranchCacheInfo.h; TBranchIMTHelper.h; TBranch.h; TBrowser.h; kNewClassTagconst UInt_t kNewClassTagDefinition TBufferFile.cxx:50; kByteCountMaskconst UInt_t kByteCountMaskDefinition TBufferFile.cxx:52; TBufferFile.h; TBuffer.h; TClass.h; TClonesArray.h; EDataTypeEDataTypeDefinition TDataType.h:28; kOther_t@ kOther_tDefinition TDataType.h:32; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; TFile.h; N#define N; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLi,MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:153591,Availability,error,error,153591," array.Definition TObjArray.cxx:577; TObjArray::LowerBoundInt_t LowerBound() constDefinition TObjArray.h:91; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStorage::ReAllocIntstatic Int_t * ReAllocInt(Int_t *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:258; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Clearvoid Clear()Clear string without changing its capacity.Definition TString.cxx:1235; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() cons",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:153727,Availability,error,error,153727,"Object *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStorage::ReAllocIntstatic Int_t * ReAllocInt(Int_t *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:258; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Clearvoid Clear()Clear string without changing its capacity.Definition TString.cxx:1235; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::PrependTString & Prepend(const char *cs)Definition TString.h:673; TString::RemoveTString & Remove",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:22001,Deployability,update,update,22001,"7 if (ondisk) {; 608 fTotBytes += basket->GetObjlen() + basket->GetKeylen() ;; 609 fZipBytes += basket->GetNbytes();; 610 fTree->AddTotBytes(basket->GetObjlen() + basket->GetKeylen());; 611 fTree->AddZipBytes(basket->GetNbytes());; 612 }; 613}; 614 ; 615////////////////////////////////////////////////////////////////////////////////; 616/// Add the start entry of the write basket (not yet created); 617 ; 618void TBranch::AddLastBasket(Long64_t startEntry); 619{; 620 if (fWriteBasket >= fMaxBaskets) {; 621 ExpandBasketArrays();; 622 }; 623 Int_t where = fWriteBasket;; 624 ; 625 if (where && startEntry < fBasketEntry[where-1]) {; 626 // Need to find the right location and move the possible baskets; 627 ; 628 Fatal(""AddBasket"",""The last basket must have the highest entry number (%s/%lld/%d)."",GetName(),startEntry,fWriteBasket);; 629 ; 630 }; 631 // The first basket (should) always start at zero. If we are asked to update; 632 // it, this likely to be from merging 'empty' branches (base class node and the likes); 633 if (where) {; 634 fBasketEntry[where] = startEntry;; 635 fBaskets.AddAtAndExpand(nullptr,fWriteBasket);; 636 }; 637}; 638 ; 639////////////////////////////////////////////////////////////////////////////////; 640/// Loop on all leaves of this branch to back fill Basket buffer.; 641///; 642/// Use this routine instead of TBranch::Fill when filling a branch individually; 643/// to catch up with the number of entries already in the TTree.; 644///; 645/// First it calls TBranch::Fill and then if the number of entries of the branch; 646/// reach one of TTree cluster's boundary, the basket is flushed.; 647///; 648/// The function returns the number of bytes committed to the memory basket.; 649/// If a write error occurs, the number of bytes returned is -1.; 650/// If no data are written, because e.g. the branch is disabled,; 651/// the number of bytes returned is 0.; 652///; 653/// To insure that the baskets of each cluster are located close by in the; 654/// fil",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:48033,Deployability,update,updatedNext,48033,"const; 1333{; 1334 if (IsFolder()); 1335 return ""TBranchElement-folder"";; 1336 else; 1337 return ""TBranchElement-leaf"";; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// A helper function to locate the correct basket - and its first entry.; 1342/// Extracted to a common private function because it is needed by both GetEntry; 1343/// and GetBulkEntries. It should not be called directly.; 1344///; 1345/// If a new basket must be constructed and the user_buffer is provided, then; 1346/// the user_buffer will back the memory of the newly-constructed basket.; 1347///; 1348/// Assumes that this branch is enabled.; 1349///; 1350/// Returns -1 if the entry does not exist; 1351/// Returns -2 in case of error; 1352/// Returns the index of the basket in case of success.; 1353Int_t TBranch::GetBasketAndFirst(TBasket *&basket, Long64_t &first,; 1354 TBuffer *user_buffer); 1355{; 1356 Long64_t updatedNext = fNextBasketEntry;; 1357 Long64_t entry = fReadEntry;; 1358 if (R__likely(fCurrentBasket && fFirstBasketEntry <= entry && entry < fNextBasketEntry)) {; 1359 // We have found the basket containing this entry.; 1360 // make sure basket buffers are in memory.; 1361 basket = fCurrentBasket;; 1362 first = fFirstBasketEntry;; 1363 return fReadBasket;; 1364 } else {; 1365 if ((entry < fFirstEntry) || (entry >= fEntryNumber)) {; 1366 return -1;; 1367 }; 1368 first = fFirstBasketEntry;; 1369 Long64_t last = fNextBasketEntry - 1;; 1370 // Are we still in the same ReadBasket?; 1371 if ((entry < first) || (entry > last)) {; 1372 fReadBasket = TMath::BinarySearch(fWriteBasket + 1, fBasketEntry, entry);; 1373 if (fReadBasket < 0) {; 1374 fNextBasketEntry = -1;; 1375 Error(""GetBasketAndFirst"", ""In the branch %s, no basket contains the entry %lld\n"", GetName(), entry);; 1376 return -2;; 1377 }; 1378 if (fReadBasket == fWriteBasket) {; 1379 fNextBasketEntry = fEntryNumber;; 1380 } else {; 1381 fNextBasketEntry = fBasketEntry[fReadBasket",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:49100,Deployability,update,updatedNext,49100,"s -1 if the entry does not exist; 1351/// Returns -2 in case of error; 1352/// Returns the index of the basket in case of success.; 1353Int_t TBranch::GetBasketAndFirst(TBasket *&basket, Long64_t &first,; 1354 TBuffer *user_buffer); 1355{; 1356 Long64_t updatedNext = fNextBasketEntry;; 1357 Long64_t entry = fReadEntry;; 1358 if (R__likely(fCurrentBasket && fFirstBasketEntry <= entry && entry < fNextBasketEntry)) {; 1359 // We have found the basket containing this entry.; 1360 // make sure basket buffers are in memory.; 1361 basket = fCurrentBasket;; 1362 first = fFirstBasketEntry;; 1363 return fReadBasket;; 1364 } else {; 1365 if ((entry < fFirstEntry) || (entry >= fEntryNumber)) {; 1366 return -1;; 1367 }; 1368 first = fFirstBasketEntry;; 1369 Long64_t last = fNextBasketEntry - 1;; 1370 // Are we still in the same ReadBasket?; 1371 if ((entry < first) || (entry > last)) {; 1372 fReadBasket = TMath::BinarySearch(fWriteBasket + 1, fBasketEntry, entry);; 1373 if (fReadBasket < 0) {; 1374 fNextBasketEntry = -1;; 1375 Error(""GetBasketAndFirst"", ""In the branch %s, no basket contains the entry %lld\n"", GetName(), entry);; 1376 return -2;; 1377 }; 1378 if (fReadBasket == fWriteBasket) {; 1379 fNextBasketEntry = fEntryNumber;; 1380 } else {; 1381 fNextBasketEntry = fBasketEntry[fReadBasket+1];; 1382 }; 1383 updatedNext = fNextBasketEntry;; 1384 first = fFirstBasketEntry = fBasketEntry[fReadBasket];; 1385 }; 1386 // We have found the basket containing this entry.; 1387 // make sure basket buffers are in memory.; 1388 basket = (TBasket*) fBaskets.UncheckedAt(fReadBasket);; 1389 if (!basket) {; 1390 basket = GetBasketImpl(fReadBasket, user_buffer);; 1391 if (!basket) {; 1392 fCurrentBasket = nullptr;; 1393 fFirstBasketEntry = -1;; 1394 fNextBasketEntry = -1;; 1395 return -2;; 1396 }; 1397 if (fTree->GetClusterPrefetch()) {; 1398 TTree::TClusterIterator clusterIterator = fTree->GetClusterIterator(entry);; 1399 clusterIterator.Next();; 1400 Int_t nextClusterEntry = clusterIterato",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:50127,Deployability,update,updatedNext,50127,"tEntry[fReadBasket];; 1385 }; 1386 // We have found the basket containing this entry.; 1387 // make sure basket buffers are in memory.; 1388 basket = (TBasket*) fBaskets.UncheckedAt(fReadBasket);; 1389 if (!basket) {; 1390 basket = GetBasketImpl(fReadBasket, user_buffer);; 1391 if (!basket) {; 1392 fCurrentBasket = nullptr;; 1393 fFirstBasketEntry = -1;; 1394 fNextBasketEntry = -1;; 1395 return -2;; 1396 }; 1397 if (fTree->GetClusterPrefetch()) {; 1398 TTree::TClusterIterator clusterIterator = fTree->GetClusterIterator(entry);; 1399 clusterIterator.Next();; 1400 Int_t nextClusterEntry = clusterIterator.GetNextEntry();; 1401 for (Int_t i = fReadBasket + 1; i < fMaxBaskets && fBasketEntry[i] < nextClusterEntry; i++) {; 1402 GetBasket(i);; 1403 }; 1404 }; 1405 // Getting the next basket might reset the current one and; 1406 // cause a reset of the first / next basket entries back to -1.; 1407 fFirstBasketEntry = first;; 1408 fNextBasketEntry = updatedNext;; 1409 if (user_buffer) {; 1410 // Disassociate basket from memory buffer for bulk IO; 1411 // When the user provides a memory buffer (i.e., for bulk IO), we should; 1412 // make sure to drop all references to that buffer in the TTree afterward.; 1413 fCurrentBasket = nullptr;; 1414 fBaskets[fReadBasket] = nullptr;; 1415 } else {; 1416 fCurrentBasket = basket;; 1417 }; 1418 } else {; 1419 fCurrentBasket = basket;; 1420 }; 1421 return fReadBasket;; 1422 }; 1423}; 1424 ; 1425////////////////////////////////////////////////////////////////////////////////; 1426/// Returns true if this branch supports bulk IO, false otherwise.; 1427///; 1428/// This will return true if all the various preconditions necessary hold true; 1429/// to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may; 1430/// still fail, depending on the contents of the individual TBaskets loaded.; 1431bool TBranch::SupportsBulkRead() const {; 1432 return (fNleaves == 1) &&; 1433 (static_cast<TLeaf*>(fLeaves.UncheckedAt(0))->GetDeserializeT",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:100257,Deployability,update,updateExisting,100257,"2787 if (fCompress < 0) {; 2788 fCompress = level;; 2789 } else {; 2790 int algorithm = fCompress / 100;; 2791 if (algorithm >= ROOT::RCompressionSetting::EAlgorithm::kUndefined) algorithm = 0;; 2792 fCompress = 100 * algorithm + level;; 2793 }; 2794 ; 2795 Int_t nb = fBranches.GetEntriesFast();; 2796 for (Int_t i=0;i<nb;i++) {; 2797 TBranch *branch = (TBranch*)fBranches.UncheckedAt(i);; 2798 branch->SetCompressionLevel(level);; 2799 }; 2800}; 2801 ; 2802////////////////////////////////////////////////////////////////////////////////; 2803/// Set compression settings.; 2804 ; 2805void TBranch::SetCompressionSettings(Int_t settings); 2806{; 2807 fCompress = settings;; 2808 ; 2809 Int_t nb = fBranches.GetEntriesFast();; 2810 for (Int_t i=0;i<nb;i++) {; 2811 TBranch *branch = (TBranch*)fBranches.UncheckedAt(i);; 2812 branch->SetCompressionSettings(settings);; 2813 }; 2814}; 2815 ; 2816////////////////////////////////////////////////////////////////////////////////; 2817/// Update the default value for the branch's fEntryOffsetLen if and only if; 2818/// it was already non zero (and the new value is not zero); 2819/// If updateExisting is true, also update all the existing branches.; 2820 ; 2821void TBranch::SetEntryOffsetLen(Int_t newdefault, bool updateExisting); 2822{; 2823 if (fEntryOffsetLen && newdefault) {; 2824 fEntryOffsetLen = newdefault;; 2825 }; 2826 if (updateExisting) {; 2827 TIter next( GetListOfBranches() );; 2828 TBranch *b;; 2829 while ( ( b = (TBranch*)next() ) ) {; 2830 b->SetEntryOffsetLen( newdefault, true );; 2831 }; 2832 }; 2833}; 2834 ; 2835////////////////////////////////////////////////////////////////////////////////; 2836/// Set the number of entries in this branch.; 2837 ; 2838void TBranch::SetEntries(Long64_t entries); 2839{; 2840 fEntries = entries;; 2841 fEntryNumber = entries;; 2842}; 2843 ; 2844////////////////////////////////////////////////////////////////////////////////; 2845/// Set file where this branch writes/reads its buffers.; ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:100286,Deployability,update,update,100286,"2787 if (fCompress < 0) {; 2788 fCompress = level;; 2789 } else {; 2790 int algorithm = fCompress / 100;; 2791 if (algorithm >= ROOT::RCompressionSetting::EAlgorithm::kUndefined) algorithm = 0;; 2792 fCompress = 100 * algorithm + level;; 2793 }; 2794 ; 2795 Int_t nb = fBranches.GetEntriesFast();; 2796 for (Int_t i=0;i<nb;i++) {; 2797 TBranch *branch = (TBranch*)fBranches.UncheckedAt(i);; 2798 branch->SetCompressionLevel(level);; 2799 }; 2800}; 2801 ; 2802////////////////////////////////////////////////////////////////////////////////; 2803/// Set compression settings.; 2804 ; 2805void TBranch::SetCompressionSettings(Int_t settings); 2806{; 2807 fCompress = settings;; 2808 ; 2809 Int_t nb = fBranches.GetEntriesFast();; 2810 for (Int_t i=0;i<nb;i++) {; 2811 TBranch *branch = (TBranch*)fBranches.UncheckedAt(i);; 2812 branch->SetCompressionSettings(settings);; 2813 }; 2814}; 2815 ; 2816////////////////////////////////////////////////////////////////////////////////; 2817/// Update the default value for the branch's fEntryOffsetLen if and only if; 2818/// it was already non zero (and the new value is not zero); 2819/// If updateExisting is true, also update all the existing branches.; 2820 ; 2821void TBranch::SetEntryOffsetLen(Int_t newdefault, bool updateExisting); 2822{; 2823 if (fEntryOffsetLen && newdefault) {; 2824 fEntryOffsetLen = newdefault;; 2825 }; 2826 if (updateExisting) {; 2827 TIter next( GetListOfBranches() );; 2828 TBranch *b;; 2829 while ( ( b = (TBranch*)next() ) ) {; 2830 b->SetEntryOffsetLen( newdefault, true );; 2831 }; 2832 }; 2833}; 2834 ; 2835////////////////////////////////////////////////////////////////////////////////; 2836/// Set the number of entries in this branch.; 2837 ; 2838void TBranch::SetEntries(Long64_t entries); 2839{; 2840 fEntries = entries;; 2841 fEntryNumber = entries;; 2842}; 2843 ; 2844////////////////////////////////////////////////////////////////////////////////; 2845/// Set file where this branch writes/reads its buffers.; ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:100387,Deployability,update,updateExisting,100387,"2////////////////////////////////////////////////////////////////////////////////; 2803/// Set compression settings.; 2804 ; 2805void TBranch::SetCompressionSettings(Int_t settings); 2806{; 2807 fCompress = settings;; 2808 ; 2809 Int_t nb = fBranches.GetEntriesFast();; 2810 for (Int_t i=0;i<nb;i++) {; 2811 TBranch *branch = (TBranch*)fBranches.UncheckedAt(i);; 2812 branch->SetCompressionSettings(settings);; 2813 }; 2814}; 2815 ; 2816////////////////////////////////////////////////////////////////////////////////; 2817/// Update the default value for the branch's fEntryOffsetLen if and only if; 2818/// it was already non zero (and the new value is not zero); 2819/// If updateExisting is true, also update all the existing branches.; 2820 ; 2821void TBranch::SetEntryOffsetLen(Int_t newdefault, bool updateExisting); 2822{; 2823 if (fEntryOffsetLen && newdefault) {; 2824 fEntryOffsetLen = newdefault;; 2825 }; 2826 if (updateExisting) {; 2827 TIter next( GetListOfBranches() );; 2828 TBranch *b;; 2829 while ( ( b = (TBranch*)next() ) ) {; 2830 b->SetEntryOffsetLen( newdefault, true );; 2831 }; 2832 }; 2833}; 2834 ; 2835////////////////////////////////////////////////////////////////////////////////; 2836/// Set the number of entries in this branch.; 2837 ; 2838void TBranch::SetEntries(Long64_t entries); 2839{; 2840 fEntries = entries;; 2841 fEntryNumber = entries;; 2842}; 2843 ; 2844////////////////////////////////////////////////////////////////////////////////; 2845/// Set file where this branch writes/reads its buffers.; 2846/// By default the branch buffers reside in the file where the; 2847/// Tree was created.; 2848/// If the file name where the tree was created is an absolute; 2849/// path name or an URL (e.g. or root://host/...); 2850/// and if the fname is not an absolute path name or an URL then; 2851/// the path of the tree file is prepended to fname to make the; 2852/// branch file relative to the tree file. In this case one can; 2853/// move the tree + all bra",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:100507,Deployability,update,updateExisting,100507,"2////////////////////////////////////////////////////////////////////////////////; 2803/// Set compression settings.; 2804 ; 2805void TBranch::SetCompressionSettings(Int_t settings); 2806{; 2807 fCompress = settings;; 2808 ; 2809 Int_t nb = fBranches.GetEntriesFast();; 2810 for (Int_t i=0;i<nb;i++) {; 2811 TBranch *branch = (TBranch*)fBranches.UncheckedAt(i);; 2812 branch->SetCompressionSettings(settings);; 2813 }; 2814}; 2815 ; 2816////////////////////////////////////////////////////////////////////////////////; 2817/// Update the default value for the branch's fEntryOffsetLen if and only if; 2818/// it was already non zero (and the new value is not zero); 2819/// If updateExisting is true, also update all the existing branches.; 2820 ; 2821void TBranch::SetEntryOffsetLen(Int_t newdefault, bool updateExisting); 2822{; 2823 if (fEntryOffsetLen && newdefault) {; 2824 fEntryOffsetLen = newdefault;; 2825 }; 2826 if (updateExisting) {; 2827 TIter next( GetListOfBranches() );; 2828 TBranch *b;; 2829 while ( ( b = (TBranch*)next() ) ) {; 2830 b->SetEntryOffsetLen( newdefault, true );; 2831 }; 2832 }; 2833}; 2834 ; 2835////////////////////////////////////////////////////////////////////////////////; 2836/// Set the number of entries in this branch.; 2837 ; 2838void TBranch::SetEntries(Long64_t entries); 2839{; 2840 fEntries = entries;; 2841 fEntryNumber = entries;; 2842}; 2843 ; 2844////////////////////////////////////////////////////////////////////////////////; 2845/// Set file where this branch writes/reads its buffers.; 2846/// By default the branch buffers reside in the file where the; 2847/// Tree was created.; 2848/// If the file name where the tree was created is an absolute; 2849/// path name or an URL (e.g. or root://host/...); 2850/// and if the fname is not an absolute path name or an URL then; 2851/// the path of the tree file is prepended to fname to make the; 2852/// branch file relative to the tree file. In this case one can; 2853/// move the tree + all bra",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:102004,Deployability,update,update,102004,"///////////////////////; 2845/// Set file where this branch writes/reads its buffers.; 2846/// By default the branch buffers reside in the file where the; 2847/// Tree was created.; 2848/// If the file name where the tree was created is an absolute; 2849/// path name or an URL (e.g. or root://host/...); 2850/// and if the fname is not an absolute path name or an URL then; 2851/// the path of the tree file is prepended to fname to make the; 2852/// branch file relative to the tree file. In this case one can; 2853/// move the tree + all branch files to a different location in; 2854/// the file system and still access the branch files.; 2855/// The ROOT file will be connected only when necessary.; 2856/// If called by TBranch::Fill (via TBasket::WriteFile), the file; 2857/// will be created with the option ""recreate"".; 2858/// If called by TBranch::GetEntry (via TBranch::GetBasket), the file; 2859/// will be opened in read mode.; 2860/// To open a file in ""update"" mode or with a certain compression; 2861/// level, use TBranch::SetFile(TFile *file).; 2862 ; 2863void TBranch::SetFile(TFile* file); 2864{; 2865 if (file == nullptr) file = fTree->GetCurrentFile();; 2866 fDirectory = (TDirectory*)file;; 2867 if (file == fTree->GetCurrentFile()) fFileName = """";; 2868 else fFileName = file->GetName();; 2869 ; 2870 if (file && fCompress == -1) {; 2871 fCompress = file->GetCompressionLevel();; 2872 }; 2873 ; 2874 // Apply to all existing baskets.; 2875 TIter nextb(GetListOfBaskets());; 2876 TBasket *basket;; 2877 while ((basket = (TBasket*)nextb())) {; 2878 basket->SetParent(file);; 2879 }; 2880 ; 2881 // Apply to sub-branches as well.; 2882 TIter next(GetListOfBranches());; 2883 TBranch *branch;; 2884 while ((branch = (TBranch*)next())) {; 2885 branch->SetFile(file);; 2886 }; 2887}; 2888 ; 2889////////////////////////////////////////////////////////////////////////////////; 2890/// Set file where this branch writes/reads its buffers.; 2891/// By default the branch buffers resid",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:103871,Deployability,update,update,103871,"//////////////////////////; 2890/// Set file where this branch writes/reads its buffers.; 2891/// By default the branch buffers reside in the file where the; 2892/// Tree was created.; 2893/// If the file name where the tree was created is an absolute; 2894/// path name or an URL (e.g. root://host/...); 2895/// and if the fname is not an absolute path name or an URL then; 2896/// the path of the tree file is prepended to fname to make the; 2897/// branch file relative to the tree file. In this case one can; 2898/// move the tree + all branch files to a different location in; 2899/// the file system and still access the branch files.; 2900/// The ROOT file will be connected only when necessary.; 2901/// If called by TBranch::Fill (via TBasket::WriteFile), the file; 2902/// will be created with the option ""recreate"".; 2903/// If called by TBranch::GetEntry (via TBranch::GetBasket), the file; 2904/// will be opened in read mode.; 2905/// To open a file in ""update"" mode or with a certain compression; 2906/// level, use TBranch::SetFile(TFile *file).; 2907 ; 2908void TBranch::SetFile(const char* fname); 2909{; 2910 fFileName = fname;; 2911 fDirectory = nullptr;; 2912 ; 2913 //apply to sub-branches as well; 2914 TIter next(GetListOfBranches());; 2915 TBranch *branch;; 2916 while ((branch = (TBranch*)next())) {; 2917 branch->SetFile(fname);; 2918 }; 2919}; 2920 ; 2921////////////////////////////////////////////////////////////////////////////////; 2922/// Set the branch in a mode where the object are decomposed; 2923/// (Also known as MakeClass mode).; 2924/// Return whether the setting was possible (it is not possible for; 2925/// TBranch and TBranchObject).; 2926 ; 2927bool TBranch::SetMakeClass(bool /* decomposeObj */); 2928{; 2929 // Regular TBranch and TBrancObject can not be in makeClass mode; 2930 return false;; 2931}; 2932 ; 2933////////////////////////////////////////////////////////////////////////////////; 2934/// Set object this branch is pointing to.; 2935 ; 2",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:117206,Deployability,update,update,117206,"anchSTL); 3278 ; 3279void TBranch::SetFirstEntry(Long64_t entry); 3280{; 3281 fFirstEntry = entry;; 3282 fEntries = 0;; 3283 fEntryNumber = entry;; 3284 if( fBasketEntry ); 3285 fBasketEntry[0] = entry;; 3286 for( Int_t i = 0; i < fBranches.GetEntriesFast(); ++i ); 3287 ((TBranch*)fBranches[i])->SetFirstEntry( entry );; 3288}; 3289 ; 3290////////////////////////////////////////////////////////////////////////////////; 3291/// If the branch address is not set, we set all addresses starting with; 3292/// the top level parent branch.; 3293 ; 3294void TBranch::SetupAddresses(); 3295{; 3296 SetAddress(nullptr); // in some cases, this triggers setting of the address; 3297}; 3298 ; 3299////////////////////////////////////////////////////////////////////////////////; 3300/// Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); 3301/// with the current value of fTree->GetCurrentFile unless this branch has been; 3302/// redirected to a different file. Also update the sub-branches.; 3303 ; 3304void TBranch::UpdateFile(); 3305{; 3306 TFile *file = fTree->GetCurrentFile();; 3307 if (fFileName.Length() == 0) {; 3308 fDirectory = file;; 3309 ; 3310 // Apply to all existing baskets.; 3311 TIter nextb(GetListOfBaskets());; 3312 TBasket *basket;; 3313 while ((basket = (TBasket*)nextb())) {; 3314 basket->SetParent(file);; 3315 }; 3316 }; 3317 ; 3318 // Apply to sub-branches as well.; 3319 TIter next(GetListOfBranches());; 3320 TBranch *branch;; 3321 while ((branch = (TBranch*)next())) {; 3322 branch->UpdateFile();; 3323 }; 3324}; Bytes.h; tobufvoid tobuf(char *&buf, Bool_t x)Definition Bytes.h:55; Compression.h; R__likely#define R__likely(expr)Definition RConfig.hxx:587; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; b#define b(i)Definition RSha256.hxx:100; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Char_tchar Cha",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:134569,Deployability,update,updateSubBranches,134569,"ch writes/reads its buffers.Definition TBranch.cxx:2863; TBranch::GetEntryExportvirtual Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray *list, Int_t n)Read all leaves of an entry and export buffers to real objects in a TClonesArray list.Definition TBranch.cxx:1762; TBranch::SetAutoDeletevirtual void SetAutoDelete(bool autodel=true)Set the automatic delete bit.Definition TBranch.cxx:2716; TBranch::fZipBytesLong64_t fZipBytesTotal number of bytes in all leaves after compression.Definition TBranch.h:137; TBranch::fIOFeaturesTIOFeatures fIOFeaturesIO features for newly-created baskets.Definition TBranch.h:123; TBranch::Browsevoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, R",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:5188,Integrability,depend,dependent,5188,"ariable type must be 1 character. (Characters; 142/// after the first are legal and will be appended to the visible; 143/// name of the leaf, but have no effect.) If no type is given, the; 144/// type of the variable is assumed to be the same as the previous; 145/// variable. If the first variable does not have a type, it is; 146/// assumed of type F by default. The list of currently supported; 147/// types is given below:; 148/// - `C` : a character string terminated by the 0 character; 149/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 150/// - `b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Float_t`); 156/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 157/// - `D` : a 64 bit floating point (`Double_t`); 158/// - `d` : a 24 bit truncated floating point (`Double32_t`); 159/// - `L` : a 64 bit signed integer (`Long64_t`); 160/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 161/// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 162/// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned integer but held in memory usually as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 163/// - `O` : [the letter `o`, not a zero] a boolean (`bool`); 164///; 165/// Arrays of values are supported with the following syntax:; 166/// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; 167///",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:5469,Integrability,depend,dependent,5469,"`b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Float_t`); 156/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 157/// - `D` : a 64 bit floating point (`Double_t`); 158/// - `d` : a 24 bit truncated floating point (`Double32_t`); 159/// - `L` : a 64 bit signed integer (`Long64_t`); 160/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 161/// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 162/// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned integer but held in memory usually as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 163/// - `O` : [the letter `o`, not a zero] a boolean (`bool`); 164///; 165/// Arrays of values are supported with the following syntax:; 166/// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; 167/// if nelem is a leaf name, it is used as the variable size of the array,; 168/// otherwise return 0.; 169/// The leaf referred to by nelem **MUST** be an int (/I),; 170/// - If leaf name has the form var[nelem], where nelem is a non-negative integers, then; 171/// it is used as the fixed size of the array.; 172/// - If leaf name has the form of a multi dimension array (e.g. var[nelem][nelem2]); 173/// where nelem and nelem2 are non-negative integers) then; 174/// it is used as a 2 dimensional array of fixed size.; 175/// - In case of the truncated floating point types (Float16_t and Doubl",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:10770,Integrability,rout,routine,10770," fTransientBuffer(nullptr); 237, fBrowsables(nullptr); 238, fBulk(*this); 239, fSkipZip(false); 240, fReadLeaves(&TBranch::ReadLeavesImpl); 241, fFillLeaves(&TBranch::FillLeavesImpl); 242{; 243 Init(name,leaflist,compress);; 244}; 245 ; 246////////////////////////////////////////////////////////////////////////////////; 247/// Create a Branch as a child of another Branch; 248///; 249/// See documentation for; 250/// TBranch::TBranch(TTree *, const char *, void *, const char *, Int_t, Int_t); 251 ; 252TBranch::TBranch(TBranch *parent, const char *name, void *address, const char *leaflist, Int_t basketsize,; 253 Int_t compress); 254: TNamed(name, leaflist); 255, TAttFill(0, 1001); 256, fCompress(compress); 257, fBasketSize((basketsize < 100) ? 100 : basketsize); 258, fEntryOffsetLen(0); 259, fWriteBasket(0); 260, fEntryNumber(0); 261, fExtraBasket(nullptr); 262, fIOFeatures(parent->fIOFeatures); 263, fOffset(0); 264, fMaxBaskets(10); 265, fNBaskets(0); 266, fSplitLevel(0); 267, fNleaves(0); 268, fReadBasket(0); 269, fReadEntry(-1); 270, fFirstBasketEntry(-1); 271, fNextBasketEntry(-1); 272, fCurrentBasket(nullptr); 273, fEntries(0); 274, fFirstEntry(0); 275, fTotBytes(0); 276, fZipBytes(0); 277, fBranches(); 278, fLeaves(); 279, fBaskets(fMaxBaskets); 280, fBasketBytes(nullptr); 281, fBasketEntry(nullptr); 282, fBasketSeek(nullptr); 283, fTree(parent ? parent->GetTree() : nullptr); 284, fMother(parent ? parent->GetMother() : nullptr); 285, fParent(parent); 286, fAddress((char *)address); 287, fDirectory(fTree ? fTree->GetDirectory() : nullptr); 288, fFileName(""""); 289, fEntryBuffer(nullptr); 290, fTransientBuffer(nullptr); 291, fBrowsables(nullptr); 292, fBulk(*this); 293, fSkipZip(false); 294, fReadLeaves(&TBranch::ReadLeavesImpl); 295, fFillLeaves(&TBranch::FillLeavesImpl); 296{; 297 Init(name,leaflist,compress);; 298}; 299 ; 300void TBranch::Init(const char* name, const char* leaflist, Int_t compress); 301{; 302 // Initialization routine called from the constructor.",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:22408,Integrability,rout,routine,22408," yet created); 617 ; 618void TBranch::AddLastBasket(Long64_t startEntry); 619{; 620 if (fWriteBasket >= fMaxBaskets) {; 621 ExpandBasketArrays();; 622 }; 623 Int_t where = fWriteBasket;; 624 ; 625 if (where && startEntry < fBasketEntry[where-1]) {; 626 // Need to find the right location and move the possible baskets; 627 ; 628 Fatal(""AddBasket"",""The last basket must have the highest entry number (%s/%lld/%d)."",GetName(),startEntry,fWriteBasket);; 629 ; 630 }; 631 // The first basket (should) always start at zero. If we are asked to update; 632 // it, this likely to be from merging 'empty' branches (base class node and the likes); 633 if (where) {; 634 fBasketEntry[where] = startEntry;; 635 fBaskets.AddAtAndExpand(nullptr,fWriteBasket);; 636 }; 637}; 638 ; 639////////////////////////////////////////////////////////////////////////////////; 640/// Loop on all leaves of this branch to back fill Basket buffer.; 641///; 642/// Use this routine instead of TBranch::Fill when filling a branch individually; 643/// to catch up with the number of entries already in the TTree.; 644///; 645/// First it calls TBranch::Fill and then if the number of entries of the branch; 646/// reach one of TTree cluster's boundary, the basket is flushed.; 647///; 648/// The function returns the number of bytes committed to the memory basket.; 649/// If a write error occurs, the number of bytes returned is -1.; 650/// If no data are written, because e.g. the branch is disabled,; 651/// the number of bytes returned is 0.; 652///; 653/// To insure that the baskets of each cluster are located close by in the; 654/// file, when back-filling multiple branches make sure to call BackFill; 655/// for the same entry for all the branches consecutively; 656/// ~~~ {.cpp}; 657/// for( auto e = 0; e < tree->GetEntries(); ++e ) { // loop over entries.; 658/// for( auto branch : branchCollection) {; 659/// ... Make change to the data associated with the branch ...; 660/// branch->BackFill();; 661/// }; 662/// }",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:24662,Integrability,interface,interface,24662,"ntry; 664/// // all the baskets for a cluster are consecutive in the file.; 665/// ~~~; 666/// rather than doing all the entries of one branch at a time.; 667/// ~~~ {.cpp}; 668/// // Do NOT do things in the following order, it will lead to; 669/// // poorly clustered files.; 670/// for(auto branch : branchCollection) {; 671/// for( auto e = 0; e < tree->GetEntries(); ++e ) { // loop over entries.; 672/// ... Make change to the data associated with the branch ...; 673/// branch->BackFill();; 674/// }; 675/// }; 676/// // Since we loop over all the entries for one branch; 677/// // all the baskets for that branch are consecutive.; 678/// ~~~; 679 ; 680Int_t TBranch::BackFill() {; 681 ; 682 // Get the end of the next cluster.; 683 auto cluster = GetTree()->GetClusterIterator( GetEntries() );; 684 cluster.Next();; 685 auto endCluster = cluster.GetNextEntry();; 686 ; 687 auto result = FillImpl(nullptr);; 688 ; 689 if ( result && GetEntries() >= endCluster ) {; 690 FlushBaskets();; 691 }; 692 ; 693 return result;; 694}; 695 ; 696////////////////////////////////////////////////////////////////////////////////; 697/// Browser interface.; 698 ; 699void TBranch::Browse(TBrowser* b); 700{; 701 if (fNleaves > 1) {; 702 fLeaves.Browse(b);; 703 } else {; 704 // Get the name and strip any extra brackets; 705 // in order to get the full arrays.; 706 TString name = GetName();; 707 Int_t pos = name.First('[');; 708 if (pos!=kNPOS) name.Remove(pos);; 709 ; 710 GetTree()->Draw(name, """", b ? b->GetDrawOption() : """");; 711 if (gPad) gPad->Update();; 712 }; 713}; 714 ; 715 ///////////////////////////////////////////////////////////////////////////////; 716 /// Loop on all branch baskets. If the file where branch buffers reside is; 717 /// writable, free the disk space associated to the baskets of the branch,; 718 /// then call Reset(). If the option contains ""all"", delete also the baskets; 719 /// for the subbranches.; 720 /// The branch is reset.; 721 ///; 722 /// NOTE that this functio",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:44802,Integrability,message,messages,44802," }; 1245 // if cluster pre-fetching or retaining is on, do not re-use existing baskets; 1246 // unless a new cluster is used.; 1247 if (fTree->GetMaxVirtualSize() < 0 || fTree->GetClusterPrefetch()); 1248 basket = GetFreshCluster(user_buffer);; 1249 else; 1250 basket = GetFreshBasket(basketnumber, user_buffer);; 1251 ; 1252 // fSkipZip is old stuff still maintained for CDF; 1253 if (fSkipZip) basket->SetBit(TBufferFile::kNotDecompressed);; 1254 if (fBasketBytes[basketnumber] == 0) {; 1255 fBasketBytes[basketnumber] = basket->ReadBasketBytes(fBasketSeek[basketnumber],file);; 1256 }; 1257 //add branch to cache (if any); 1258 {; 1259 R__LOCKGUARD_IMT(gROOTMutex); // Lock for parallel TTree I/O; 1260 TFileCacheRead *pf = fTree->GetReadCache(file);; 1261 if (pf){; 1262 if (pf->IsLearning()) pf->LearnBranch(this, false);; 1263 if (fSkipZip) pf->SetSkipZip();; 1264 }; 1265 }; 1266 ; 1267 //now read basket; 1268 Int_t badread = basket->ReadBasketBuffers(fBasketSeek[basketnumber],fBasketBytes[basketnumber],file);; 1269 if (R__unlikely(badread || basket->GetSeekKey() != fBasketSeek[basketnumber] || basket->IsZombie())) {; 1270 nerrors++;; 1271 if (nerrors > 10) return nullptr;; 1272 if (nerrors == 10) {; 1273 printf("" file probably overwritten: stopping reporting error messages\n"");; 1274 if (fBasketSeek[basketnumber] > 2000000000) {; 1275 printf(""===>File is more than 2 Gigabytes\n"");; 1276 return nullptr;; 1277 }; 1278 if (fBasketSeek[basketnumber] > 1000000000) {; 1279 printf(""===>Your file is may be bigger than the maximum file size allowed on your system\n"");; 1280 printf("" Check your AFS maximum file size limit for example\n"");; 1281 return nullptr;; 1282 }; 1283 }; 1284 Error(""GetBasket"",""File: %s at byte:%lld, branch:%s, entry:%lld, badread=%d, nerrors=%d, basketnumber=%d"",file->GetName(),basket->GetSeekKey(),GetName(),fReadEntry,badread,nerrors.load(),basketnumber);; 1285 return nullptr;; 1286 }; 1287 ; 1288 ++fNBaskets;; 1289 ; 1290 fCacheInfo.SetUsed(basketnumber);;",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:47005,Integrability,depend,depending,47005,"ber) const; 1303{; 1304 if (basketnumber <0 || basketnumber > fWriteBasket) return 0;; 1305 return fBasketSeek[basketnumber];; 1306}; 1307 ; 1308////////////////////////////////////////////////////////////////////////////////; 1309/// Returns (and, if 0, creates) browsable objects for this branch; 1310/// See TVirtualBranchBrowsable::FillListOfBrowsables.; 1311 ; 1312TList* TBranch::GetBrowsables() {; 1313 if (fBrowsables) return fBrowsables;; 1314 fBrowsables=new TList();; 1315 TVirtualBranchBrowsable::FillListOfBrowsables(*fBrowsables, this);; 1316 return fBrowsables;; 1317}; 1318 ; 1319////////////////////////////////////////////////////////////////////////////////; 1320/// Return the name of the user class whose content is stored in this branch,; 1321/// if any. If this branch was created using the 'leaflist' technique, this; 1322/// function returns an empty string.; 1323 ; 1324const char * TBranch::GetClassName() const; 1325{; 1326 return """";; 1327}; 1328 ; 1329////////////////////////////////////////////////////////////////////////////////; 1330/// Return icon name depending on type of branch.; 1331 ; 1332const char* TBranch::GetIconName() const; 1333{; 1334 if (IsFolder()); 1335 return ""TBranchElement-folder"";; 1336 else; 1337 return ""TBranchElement-leaf"";; 1338}; 1339 ; 1340////////////////////////////////////////////////////////////////////////////////; 1341/// A helper function to locate the correct basket - and its first entry.; 1342/// Extracted to a common private function because it is needed by both GetEntry; 1343/// and GetBulkEntries. It should not be called directly.; 1344///; 1345/// If a new basket must be constructed and the user_buffer is provided, then; 1346/// the user_buffer will back the memory of the newly-constructed basket.; 1347///; 1348/// Assumes that this branch is enabled.; 1349///; 1350/// Returns -1 if the entry does not exist; 1351/// Returns -2 in case of error; 1352/// Returns the index of the basket in case of success.; 1353I",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:50966,Integrability,depend,depending,50966,"; 1402 GetBasket(i);; 1403 }; 1404 }; 1405 // Getting the next basket might reset the current one and; 1406 // cause a reset of the first / next basket entries back to -1.; 1407 fFirstBasketEntry = first;; 1408 fNextBasketEntry = updatedNext;; 1409 if (user_buffer) {; 1410 // Disassociate basket from memory buffer for bulk IO; 1411 // When the user provides a memory buffer (i.e., for bulk IO), we should; 1412 // make sure to drop all references to that buffer in the TTree afterward.; 1413 fCurrentBasket = nullptr;; 1414 fBaskets[fReadBasket] = nullptr;; 1415 } else {; 1416 fCurrentBasket = basket;; 1417 }; 1418 } else {; 1419 fCurrentBasket = basket;; 1420 }; 1421 return fReadBasket;; 1422 }; 1423}; 1424 ; 1425////////////////////////////////////////////////////////////////////////////////; 1426/// Returns true if this branch supports bulk IO, false otherwise.; 1427///; 1428/// This will return true if all the various preconditions necessary hold true; 1429/// to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may; 1430/// still fail, depending on the contents of the individual TBaskets loaded.; 1431bool TBranch::SupportsBulkRead() const {; 1432 return (fNleaves == 1) &&; 1433 (static_cast<TLeaf*>(fLeaves.UncheckedAt(0))->GetDeserializeType() != TLeaf::DeserializeType::kExternal);; 1434}; 1435 ; 1436////////////////////////////////////////////////////////////////////////////////; 1437/// \brief Read a basket of events into the given buffer with byte swapping.; 1438///; 1439/// \return On success, the number of events of the type held by this branch; 1440/// that have been read into the buffer. -1 on failure.; 1441///; 1442/// On success, the caller should be able to access the contents of buf as they; 1443/// are with:; 1444///; 1445/// ~~~{.cpp}; 1446/// static_cast<T*>(buf.GetCurrent()); 1447/// ~~~; 1448///; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:52550,Integrability,interface,interface,52550,"ould be able to access the contents of buf as they; 1443/// are with:; 1444///; 1445/// ~~~{.cpp}; 1446/// static_cast<T*>(buf.GetCurrent()); 1447/// ~~~; 1448///; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1452/// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; 1453/// from the branchCount. After deserialization those value can be used to calculate; 1454/// the number of elements corresponding to each entries.; 1455///; 1456/// For each entry the number of elements is the multiplication of; 1457/// ; 1458/// ~~~{.cpp}; 1459/// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1460/// auto len = leaf->GetLen();; 1461/// ~~~; 1462///; 1463/// and the value in the BranchCount corresponding to that entry (can be obtained; 1464/// from `branch->GetBranchCount()`).; 1465///; 1466/// \note This interface is not meant to be exposed to end users, but rather it should; 1467/// be wrapped by higher-level interfaces.; 1468///; 1469/// \note See TBranch::GetEntriesSerialized() for an alternative that does not; 1470/// perform byte swapping (useful to save one pass over data in some cases).; 1471///; 1472Int_t TBranch::GetBulkEntries(Long64_t entry, TBuffer &user_buf); 1473{; 1474 // TODO: eventually support multiple leaves.; 1475 if (R__unlikely(fNleaves != 1)) return -1;; 1476 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1477 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kExternal)) {; 1478 return -1;; 1479 }; 1480 ; 1481 // Remember which entry we are reading.; 1482 fReadEntry = entry;; 1483 ; 1484 bool enabled = !TestBit(kDoNotProcess);; 1485 if (R__unlikely(!enabled)) return -1;; 1486 TBasket *basket = nullptr;; 1487 Long64_t first;; 1488 Int_t result = GetBasketAndFirst(basket, first, &user_buf);; 1489 if (R__unlikely(result < 0)) return -1;; 1490 // Only support reading from full c",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:52634,Integrability,wrap,wrapped,52634,"ould be able to access the contents of buf as they; 1443/// are with:; 1444///; 1445/// ~~~{.cpp}; 1446/// static_cast<T*>(buf.GetCurrent()); 1447/// ~~~; 1448///; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1452/// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; 1453/// from the branchCount. After deserialization those value can be used to calculate; 1454/// the number of elements corresponding to each entries.; 1455///; 1456/// For each entry the number of elements is the multiplication of; 1457/// ; 1458/// ~~~{.cpp}; 1459/// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1460/// auto len = leaf->GetLen();; 1461/// ~~~; 1462///; 1463/// and the value in the BranchCount corresponding to that entry (can be obtained; 1464/// from `branch->GetBranchCount()`).; 1465///; 1466/// \note This interface is not meant to be exposed to end users, but rather it should; 1467/// be wrapped by higher-level interfaces.; 1468///; 1469/// \note See TBranch::GetEntriesSerialized() for an alternative that does not; 1470/// perform byte swapping (useful to save one pass over data in some cases).; 1471///; 1472Int_t TBranch::GetBulkEntries(Long64_t entry, TBuffer &user_buf); 1473{; 1474 // TODO: eventually support multiple leaves.; 1475 if (R__unlikely(fNleaves != 1)) return -1;; 1476 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1477 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kExternal)) {; 1478 return -1;; 1479 }; 1480 ; 1481 // Remember which entry we are reading.; 1482 fReadEntry = entry;; 1483 ; 1484 bool enabled = !TestBit(kDoNotProcess);; 1485 if (R__unlikely(!enabled)) return -1;; 1486 TBasket *basket = nullptr;; 1487 Long64_t first;; 1488 Int_t result = GetBasketAndFirst(basket, first, &user_buf);; 1489 if (R__unlikely(result < 0)) return -1;; 1490 // Only support reading from full c",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:52658,Integrability,interface,interfaces,52658,"ould be able to access the contents of buf as they; 1443/// are with:; 1444///; 1445/// ~~~{.cpp}; 1446/// static_cast<T*>(buf.GetCurrent()); 1447/// ~~~; 1448///; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1452/// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; 1453/// from the branchCount. After deserialization those value can be used to calculate; 1454/// the number of elements corresponding to each entries.; 1455///; 1456/// For each entry the number of elements is the multiplication of; 1457/// ; 1458/// ~~~{.cpp}; 1459/// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1460/// auto len = leaf->GetLen();; 1461/// ~~~; 1462///; 1463/// and the value in the BranchCount corresponding to that entry (can be obtained; 1464/// from `branch->GetBranchCount()`).; 1465///; 1466/// \note This interface is not meant to be exposed to end users, but rather it should; 1467/// be wrapped by higher-level interfaces.; 1468///; 1469/// \note See TBranch::GetEntriesSerialized() for an alternative that does not; 1470/// perform byte swapping (useful to save one pass over data in some cases).; 1471///; 1472Int_t TBranch::GetBulkEntries(Long64_t entry, TBuffer &user_buf); 1473{; 1474 // TODO: eventually support multiple leaves.; 1475 if (R__unlikely(fNleaves != 1)) return -1;; 1476 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1477 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kExternal)) {; 1478 return -1;; 1479 }; 1480 ; 1481 // Remember which entry we are reading.; 1482 fReadEntry = entry;; 1483 ; 1484 bool enabled = !TestBit(kDoNotProcess);; 1485 if (R__unlikely(!enabled)) return -1;; 1486 TBasket *basket = nullptr;; 1487 Long64_t first;; 1488 Int_t result = GetBasketAndFirst(basket, first, &user_buf);; 1489 if (R__unlikely(result < 0)) return -1;; 1490 // Only support reading from full c",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:57284,Integrability,interface,interface,57284,"= 0u; i < N; ++i, ++target); 1561/// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; 1562/// ~~~; 1563///; 1564/// where target is a pointer or array to the type stored on this branch.; 1565///; 1566/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1567/// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; 1568/// from the branchCount. After deserialization those value can be used to calculate; 1569/// the number of elements corresponding to each entries.; 1570///; 1571/// For each entry the number of elements is the multiplication of; 1572///; 1573/// ~~~{.cpp}; 1574/// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1575/// auto len = leaf->GetLen();; 1576/// ~~~; 1577///; 1578/// and the value in the BranchCount corresponding to that entry (can be obtained; 1579/// from `branch->GetBranchCount()`).; 1580///; 1581/// \note This interface is not meant to be exposed to end users, but rather it should; 1582/// be wrapped by higher-level interfaces.; 1583///; 1584/// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; 1585///; 1586Int_t TBranch::GetEntriesSerialized(Long64_t entry, TBuffer &user_buf, TBuffer *count_buf); 1587{; 1588 // TODO: Template this and TBranch::GetBulkEntries; only difference is the TLeaf function (ReadBasketFast vs; 1589 // ReadBasketSerialized; 1590 ; 1591 // TODO: eventually support multiple leaves.; 1592 if (R__unlikely(fNleaves != 1)) { return -1; }; 1593 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1594 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kDestructive)) {; 1595 Error(""GetEntriesSerialized"", ""Encountered a branch with destructive deserialization; failing."");; 1596 return -1;; 1597 }; 1598 ; 1599 // Remember which entry we are reading.; 1600 fReadEntry = entry;; 1601 ; 1602 bool enabled = !TestBit(kDoNotProcess);; 1603 if (R__unlikely(!enabled)",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:57368,Integrability,wrap,wrapped,57368,"= 0u; i < N; ++i, ++target); 1561/// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; 1562/// ~~~; 1563///; 1564/// where target is a pointer or array to the type stored on this branch.; 1565///; 1566/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1567/// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; 1568/// from the branchCount. After deserialization those value can be used to calculate; 1569/// the number of elements corresponding to each entries.; 1570///; 1571/// For each entry the number of elements is the multiplication of; 1572///; 1573/// ~~~{.cpp}; 1574/// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1575/// auto len = leaf->GetLen();; 1576/// ~~~; 1577///; 1578/// and the value in the BranchCount corresponding to that entry (can be obtained; 1579/// from `branch->GetBranchCount()`).; 1580///; 1581/// \note This interface is not meant to be exposed to end users, but rather it should; 1582/// be wrapped by higher-level interfaces.; 1583///; 1584/// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; 1585///; 1586Int_t TBranch::GetEntriesSerialized(Long64_t entry, TBuffer &user_buf, TBuffer *count_buf); 1587{; 1588 // TODO: Template this and TBranch::GetBulkEntries; only difference is the TLeaf function (ReadBasketFast vs; 1589 // ReadBasketSerialized; 1590 ; 1591 // TODO: eventually support multiple leaves.; 1592 if (R__unlikely(fNleaves != 1)) { return -1; }; 1593 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1594 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kDestructive)) {; 1595 Error(""GetEntriesSerialized"", ""Encountered a branch with destructive deserialization; failing."");; 1596 return -1;; 1597 }; 1598 ; 1599 // Remember which entry we are reading.; 1600 fReadEntry = entry;; 1601 ; 1602 bool enabled = !TestBit(kDoNotProcess);; 1603 if (R__unlikely(!enabled)",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:57392,Integrability,interface,interfaces,57392,"= 0u; i < N; ++i, ++target); 1561/// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; 1562/// ~~~; 1563///; 1564/// where target is a pointer or array to the type stored on this branch.; 1565///; 1566/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1567/// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; 1568/// from the branchCount. After deserialization those value can be used to calculate; 1569/// the number of elements corresponding to each entries.; 1570///; 1571/// For each entry the number of elements is the multiplication of; 1572///; 1573/// ~~~{.cpp}; 1574/// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1575/// auto len = leaf->GetLen();; 1576/// ~~~; 1577///; 1578/// and the value in the BranchCount corresponding to that entry (can be obtained; 1579/// from `branch->GetBranchCount()`).; 1580///; 1581/// \note This interface is not meant to be exposed to end users, but rather it should; 1582/// be wrapped by higher-level interfaces.; 1583///; 1584/// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; 1585///; 1586Int_t TBranch::GetEntriesSerialized(Long64_t entry, TBuffer &user_buf, TBuffer *count_buf); 1587{; 1588 // TODO: Template this and TBranch::GetBulkEntries; only difference is the TLeaf function (ReadBasketFast vs; 1589 // ReadBasketSerialized; 1590 ; 1591 // TODO: eventually support multiple leaves.; 1592 if (R__unlikely(fNleaves != 1)) { return -1; }; 1593 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1594 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kDestructive)) {; 1595 Error(""GetEntriesSerialized"", ""Encountered a branch with destructive deserialization; failing."");; 1596 return -1;; 1597 }; 1598 ; 1599 // Remember which entry we are reading.; 1600 fReadEntry = entry;; 1601 ; 1602 bool enabled = !TestBit(kDoNotProcess);; 1603 if (R__unlikely(!enabled)",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:127993,Integrability,depend,depending,127993,"et by either reusing an existing basket that needs to be drop (according to TTree:...Definition TBranch.cxx:1894; TBranch::GetBasketImplTBasket * GetBasketImpl(Int_t basket, TBuffer *user_buffer)Return pointer to basket basketnumber in this Branch.Definition TBranch.cxx:1226; TBranch::fEntryOffsetLenInt_t fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers.Definition TBranch.h:119; TBranch::DeleteBasketsvirtual void DeleteBaskets(Option_t *option="""")Loop on all branch baskets.Definition TBranch.cxx:726; TBranch::GetBasketSeekvirtual Long64_t GetBasketSeek(Int_t basket) constReturn address of basket in the file.Definition TBranch.cxx:1302; TBranch::TBranchTBranch()Default constructor. Used for I/O by default.Definition TBranch.cxx:87; TBranch::SetCompressionSettingsvoid SetCompressionSettings(Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault)Set compression settings.Definition TBranch.cxx:2805; TBranch::GetIconNameconst char * GetIconName() const overrideReturn icon name depending on type of branch.Definition TBranch.cxx:1332; TBranch::BackFillInt_t BackFill()Loop on all leaves of this branch to back fill Basket buffer.Definition TBranch.cxx:680; TBranch::~TBranch~TBranch() overrideDestructor.Definition TBranch.cxx:450; TBranch::fMaxBasketsInt_t fMaxBasketsMaximum number of Baskets so far.Definition TBranch.h:125; TBranch::fTotBytesLong64_t fTotBytesTotal number of bytes in all leaves before compression.Definition TBranch.h:136; TBranch::fTransientBufferTBuffer * fTransientBuffer! Pointer to the current transient buffer.Definition TBranch.h:151; TBranch::ReadBasketvirtual void ReadBasket(TBuffer &b)Loop on all leaves of this branch to read Basket buffer.Definition TBranch.cxx:2453; TBranch::GetTreeTTree * GetTree() constDefinition TBranch.h:252; TBranch::Classstatic TClass * Class(); TBranch::fFillLeavesFillLeaves_t fFillLeaves! Pointer to the FillLeaves implementation to use.Definition TBranch.h:163; TBranch::GetFullNamev",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:134276,Integrability,interface,interface,134276," ReadLeaves1Impl(TBuffer &b)Read one leaf without the overhead of a loop.Definition TBranch.cxx:2479; TBranch::GetBulkEntriesInt_t GetBulkEntries(Long64_t, TBuffer &)Read a basket of events into the given buffer with byte swapping.Definition TBranch.cxx:1472; TBranch::SetFilevirtual void SetFile(TFile *file=nullptr)Set file where this branch writes/reads its buffers.Definition TBranch.cxx:2863; TBranch::GetEntryExportvirtual Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray *list, Int_t n)Read all leaves of an entry and export buffers to real objects in a TClonesArray list.Definition TBranch.cxx:1762; TBranch::SetAutoDeletevirtual void SetAutoDelete(bool autodel=true)Set the automatic delete bit.Definition TBranch.cxx:2716; TBranch::fZipBytesLong64_t fZipBytesTotal number of bytes in all leaves after compression.Definition TBranch.h:137; TBranch::fIOFeaturesTIOFeatures fIOFeaturesIO features for newly-created baskets.Definition TBranch.h:123; TBranch::Browsevoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid stre",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:153095,Integrability,message,message,153095,"ject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::RemoveTObject * Remove(TObject *obj) overrideRemove object from array.Definition TObjArray.cxx:719; TObjArray::SetLastvoid SetLast(Int_t last)Set index of last object in array, effectively truncating the array.Definition TObjArray.cxx:775; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObjArray::LowerBoundInt_t LowerBound() constDefinition TObjArray.h:91; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStorage::ReAllocIntstatic Int_t * ReAllocInt(Int_t *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:258; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:153597,Integrability,message,message,153597," array.Definition TObjArray.cxx:577; TObjArray::LowerBoundInt_t LowerBound() constDefinition TObjArray.h:91; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStorage::ReAllocIntstatic Int_t * ReAllocInt(Int_t *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:258; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Clearvoid Clear()Clear string without changing its capacity.Definition TString.cxx:1235; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() cons",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:153733,Integrability,message,message,153733,"Object *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStorage::ReAllocIntstatic Int_t * ReAllocInt(Int_t *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:258; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Clearvoid Clear()Clear string without changing its capacity.Definition TString.cxx:1235; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::PrependTString & Prepend(const char *cs)Definition TString.h:673; TString::RemoveTString & Remove",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:3749,Modifiability,variab,variable,3749,"); 107, fFirstEntry(0); 108, fTotBytes(0); 109, fZipBytes(0); 110, fBranches(); 111, fLeaves(); 112, fBaskets(fMaxBaskets); 113, fBasketBytes(nullptr); 114, fBasketEntry(nullptr); 115, fBasketSeek(nullptr); 116, fTree(nullptr); 117, fMother(nullptr); 118, fParent(nullptr); 119, fAddress(nullptr); 120, fDirectory(nullptr); 121, fFileName(""""); 122, fEntryBuffer(nullptr); 123, fTransientBuffer(nullptr); 124, fBrowsables(nullptr); 125, fBulk(*this); 126, fSkipZip(false); 127, fReadLeaves(&TBranch::ReadLeavesImpl); 128, fFillLeaves(&TBranch::FillLeavesImpl); 129{; 130 SetBit(TBranch::kDoNotUseBufferMap);; 131}; 132 ; 133////////////////////////////////////////////////////////////////////////////////; 134/// Create a Branch as a child of a Tree; 135///; 136/// * address is the address of the first item of a structure; 137/// or the address of a pointer to an object (see example in TTree.cxx).; 138/// * leaflist is the concatenation of all the variable names and types; 139/// separated by a colon character :; 140/// The variable name and the variable type are separated by a; 141/// slash (/). The variable type must be 1 character. (Characters; 142/// after the first are legal and will be appended to the visible; 143/// name of the leaf, but have no effect.) If no type is given, the; 144/// type of the variable is assumed to be the same as the previous; 145/// variable. If the first variable does not have a type, it is; 146/// assumed of type F by default. The list of currently supported; 147/// types is given below:; 148/// - `C` : a character string terminated by the 0 character; 149/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 150/// - `b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Fl",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:3827,Modifiability,variab,variable,3827,"); 107, fFirstEntry(0); 108, fTotBytes(0); 109, fZipBytes(0); 110, fBranches(); 111, fLeaves(); 112, fBaskets(fMaxBaskets); 113, fBasketBytes(nullptr); 114, fBasketEntry(nullptr); 115, fBasketSeek(nullptr); 116, fTree(nullptr); 117, fMother(nullptr); 118, fParent(nullptr); 119, fAddress(nullptr); 120, fDirectory(nullptr); 121, fFileName(""""); 122, fEntryBuffer(nullptr); 123, fTransientBuffer(nullptr); 124, fBrowsables(nullptr); 125, fBulk(*this); 126, fSkipZip(false); 127, fReadLeaves(&TBranch::ReadLeavesImpl); 128, fFillLeaves(&TBranch::FillLeavesImpl); 129{; 130 SetBit(TBranch::kDoNotUseBufferMap);; 131}; 132 ; 133////////////////////////////////////////////////////////////////////////////////; 134/// Create a Branch as a child of a Tree; 135///; 136/// * address is the address of the first item of a structure; 137/// or the address of a pointer to an object (see example in TTree.cxx).; 138/// * leaflist is the concatenation of all the variable names and types; 139/// separated by a colon character :; 140/// The variable name and the variable type are separated by a; 141/// slash (/). The variable type must be 1 character. (Characters; 142/// after the first are legal and will be appended to the visible; 143/// name of the leaf, but have no effect.) If no type is given, the; 144/// type of the variable is assumed to be the same as the previous; 145/// variable. If the first variable does not have a type, it is; 146/// assumed of type F by default. The list of currently supported; 147/// types is given below:; 148/// - `C` : a character string terminated by the 0 character; 149/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 150/// - `b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Fl",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:3849,Modifiability,variab,variable,3849,"); 107, fFirstEntry(0); 108, fTotBytes(0); 109, fZipBytes(0); 110, fBranches(); 111, fLeaves(); 112, fBaskets(fMaxBaskets); 113, fBasketBytes(nullptr); 114, fBasketEntry(nullptr); 115, fBasketSeek(nullptr); 116, fTree(nullptr); 117, fMother(nullptr); 118, fParent(nullptr); 119, fAddress(nullptr); 120, fDirectory(nullptr); 121, fFileName(""""); 122, fEntryBuffer(nullptr); 123, fTransientBuffer(nullptr); 124, fBrowsables(nullptr); 125, fBulk(*this); 126, fSkipZip(false); 127, fReadLeaves(&TBranch::ReadLeavesImpl); 128, fFillLeaves(&TBranch::FillLeavesImpl); 129{; 130 SetBit(TBranch::kDoNotUseBufferMap);; 131}; 132 ; 133////////////////////////////////////////////////////////////////////////////////; 134/// Create a Branch as a child of a Tree; 135///; 136/// * address is the address of the first item of a structure; 137/// or the address of a pointer to an object (see example in TTree.cxx).; 138/// * leaflist is the concatenation of all the variable names and types; 139/// separated by a colon character :; 140/// The variable name and the variable type are separated by a; 141/// slash (/). The variable type must be 1 character. (Characters; 142/// after the first are legal and will be appended to the visible; 143/// name of the leaf, but have no effect.) If no type is given, the; 144/// type of the variable is assumed to be the same as the previous; 145/// variable. If the first variable does not have a type, it is; 146/// assumed of type F by default. The list of currently supported; 147/// types is given below:; 148/// - `C` : a character string terminated by the 0 character; 149/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 150/// - `b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Fl",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:3905,Modifiability,variab,variable,3905,"); 113, fBasketBytes(nullptr); 114, fBasketEntry(nullptr); 115, fBasketSeek(nullptr); 116, fTree(nullptr); 117, fMother(nullptr); 118, fParent(nullptr); 119, fAddress(nullptr); 120, fDirectory(nullptr); 121, fFileName(""""); 122, fEntryBuffer(nullptr); 123, fTransientBuffer(nullptr); 124, fBrowsables(nullptr); 125, fBulk(*this); 126, fSkipZip(false); 127, fReadLeaves(&TBranch::ReadLeavesImpl); 128, fFillLeaves(&TBranch::FillLeavesImpl); 129{; 130 SetBit(TBranch::kDoNotUseBufferMap);; 131}; 132 ; 133////////////////////////////////////////////////////////////////////////////////; 134/// Create a Branch as a child of a Tree; 135///; 136/// * address is the address of the first item of a structure; 137/// or the address of a pointer to an object (see example in TTree.cxx).; 138/// * leaflist is the concatenation of all the variable names and types; 139/// separated by a colon character :; 140/// The variable name and the variable type are separated by a; 141/// slash (/). The variable type must be 1 character. (Characters; 142/// after the first are legal and will be appended to the visible; 143/// name of the leaf, but have no effect.) If no type is given, the; 144/// type of the variable is assumed to be the same as the previous; 145/// variable. If the first variable does not have a type, it is; 146/// assumed of type F by default. The list of currently supported; 147/// types is given below:; 148/// - `C` : a character string terminated by the 0 character; 149/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 150/// - `b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Float_t`); 156/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 157/// - `D` : a 64 bit floating p",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:4114,Modifiability,variab,variable,4114,"1, fFileName(""""); 122, fEntryBuffer(nullptr); 123, fTransientBuffer(nullptr); 124, fBrowsables(nullptr); 125, fBulk(*this); 126, fSkipZip(false); 127, fReadLeaves(&TBranch::ReadLeavesImpl); 128, fFillLeaves(&TBranch::FillLeavesImpl); 129{; 130 SetBit(TBranch::kDoNotUseBufferMap);; 131}; 132 ; 133////////////////////////////////////////////////////////////////////////////////; 134/// Create a Branch as a child of a Tree; 135///; 136/// * address is the address of the first item of a structure; 137/// or the address of a pointer to an object (see example in TTree.cxx).; 138/// * leaflist is the concatenation of all the variable names and types; 139/// separated by a colon character :; 140/// The variable name and the variable type are separated by a; 141/// slash (/). The variable type must be 1 character. (Characters; 142/// after the first are legal and will be appended to the visible; 143/// name of the leaf, but have no effect.) If no type is given, the; 144/// type of the variable is assumed to be the same as the previous; 145/// variable. If the first variable does not have a type, it is; 146/// assumed of type F by default. The list of currently supported; 147/// types is given below:; 148/// - `C` : a character string terminated by the 0 character; 149/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 150/// - `b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Float_t`); 156/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 157/// - `D` : a 64 bit floating point (`Double_t`); 158/// - `d` : a 24 bit truncated floating point (`Double32_t`); 159/// - `L` : a 64 bit signed integer (`Long64_t`); 160/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 161/// - `G`",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:4173,Modifiability,variab,variable,4173,"1, fFileName(""""); 122, fEntryBuffer(nullptr); 123, fTransientBuffer(nullptr); 124, fBrowsables(nullptr); 125, fBulk(*this); 126, fSkipZip(false); 127, fReadLeaves(&TBranch::ReadLeavesImpl); 128, fFillLeaves(&TBranch::FillLeavesImpl); 129{; 130 SetBit(TBranch::kDoNotUseBufferMap);; 131}; 132 ; 133////////////////////////////////////////////////////////////////////////////////; 134/// Create a Branch as a child of a Tree; 135///; 136/// * address is the address of the first item of a structure; 137/// or the address of a pointer to an object (see example in TTree.cxx).; 138/// * leaflist is the concatenation of all the variable names and types; 139/// separated by a colon character :; 140/// The variable name and the variable type are separated by a; 141/// slash (/). The variable type must be 1 character. (Characters; 142/// after the first are legal and will be appended to the visible; 143/// name of the leaf, but have no effect.) If no type is given, the; 144/// type of the variable is assumed to be the same as the previous; 145/// variable. If the first variable does not have a type, it is; 146/// assumed of type F by default. The list of currently supported; 147/// types is given below:; 148/// - `C` : a character string terminated by the 0 character; 149/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 150/// - `b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Float_t`); 156/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 157/// - `D` : a 64 bit floating point (`Double_t`); 158/// - `d` : a 24 bit truncated floating point (`Double32_t`); 159/// - `L` : a 64 bit signed integer (`Long64_t`); 160/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 161/// - `G`",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:4196,Modifiability,variab,variable,4196,"); 125, fBulk(*this); 126, fSkipZip(false); 127, fReadLeaves(&TBranch::ReadLeavesImpl); 128, fFillLeaves(&TBranch::FillLeavesImpl); 129{; 130 SetBit(TBranch::kDoNotUseBufferMap);; 131}; 132 ; 133////////////////////////////////////////////////////////////////////////////////; 134/// Create a Branch as a child of a Tree; 135///; 136/// * address is the address of the first item of a structure; 137/// or the address of a pointer to an object (see example in TTree.cxx).; 138/// * leaflist is the concatenation of all the variable names and types; 139/// separated by a colon character :; 140/// The variable name and the variable type are separated by a; 141/// slash (/). The variable type must be 1 character. (Characters; 142/// after the first are legal and will be appended to the visible; 143/// name of the leaf, but have no effect.) If no type is given, the; 144/// type of the variable is assumed to be the same as the previous; 145/// variable. If the first variable does not have a type, it is; 146/// assumed of type F by default. The list of currently supported; 147/// types is given below:; 148/// - `C` : a character string terminated by the 0 character; 149/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 150/// - `b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Float_t`); 156/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 157/// - `D` : a 64 bit floating point (`Double_t`); 158/// - `d` : a 24 bit truncated floating point (`Double32_t`); 159/// - `L` : a 64 bit signed integer (`Long64_t`); 160/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 161/// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:5951,Modifiability,variab,variable,5951,"oint with truncated mantissa (`Float16_t`); 157/// - `D` : a 64 bit floating point (`Double_t`); 158/// - `d` : a 24 bit truncated floating point (`Double32_t`); 159/// - `L` : a 64 bit signed integer (`Long64_t`); 160/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 161/// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 162/// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned integer but held in memory usually as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 163/// - `O` : [the letter `o`, not a zero] a boolean (`bool`); 164///; 165/// Arrays of values are supported with the following syntax:; 166/// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; 167/// if nelem is a leaf name, it is used as the variable size of the array,; 168/// otherwise return 0.; 169/// The leaf referred to by nelem **MUST** be an int (/I),; 170/// - If leaf name has the form var[nelem], where nelem is a non-negative integers, then; 171/// it is used as the fixed size of the array.; 172/// - If leaf name has the form of a multi dimension array (e.g. var[nelem][nelem2]); 173/// where nelem and nelem2 are non-negative integers) then; 174/// it is used as a 2 dimensional array of fixed size.; 175/// - In case of the truncated floating point types (Float16_t and Double32_t) you can; 176/// furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; 177/// the type character. See `TStreamerElement::GetRange()` for further information.; 178/// - Any of other form is not supported.; 179///; 180/// Note that the TTree will assume that all the item are contiguous in memory.; 181/// On ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:14848,Modifiability,variab,variable,14848,"ype);; 384 } else if (*leaftype == 'f') {; 385 leaf = new TLeafF16(this, leafname, leaftype);; 386 } else if (*leaftype == 'L') {; 387 leaf = new TLeafL(this, leafname, leaftype);; 388 } else if (*leaftype == 'l') {; 389 leaf = new TLeafL(this, leafname, leaftype);; 390 leaf->SetUnsigned();; 391 } else if (*leaftype == 'D') {; 392 leaf = new TLeafD(this, leafname, leaftype);; 393 } else if (*leaftype == 'd') {; 394 leaf = new TLeafD32(this, leafname, leaftype);; 395 } else if (*leaftype == 'G') {; 396 leaf = new TLeafG(this, leafname, leaftype);; 397 } else if (*leaftype == 'g') {; 398 leaf = new TLeafG(this, leafname, leaftype);; 399 leaf->SetUnsigned();; 400 }; 401 if (!leaf) {; 402 Error(""TLeaf"", ""Illegal data type for %s/%s"", name, leaflist);; 403 delete[] leaftype;; 404 delete [] leafname;; 405 MakeZombie();; 406 return;; 407 }; 408 if (leaf->IsZombie()) {; 409 delete leaf;; 410 leaf = nullptr;; 411 auto msg = ""Illegal leaf: %s/%s. If this is a variable size C array it's possible that the branch holding the size is not available."";; 412 Error(""TBranch"", msg, name, leaflist);; 413 delete [] leafname;; 414 delete[] leaftype;; 415 MakeZombie();; 416 return;; 417 }; 418 leaf->SetBranch(this);; 419 leaf->SetAddress((char*) (fAddress + offset));; 420 leaf->SetOffset(offset);; 421 if (leaf->GetLeafCount()) {; 422 // -- Leaf is a varying length array, we need an offset array.; 423 fEntryOffsetLen = 1000;; 424 }; 425 if (leaf->InheritsFrom(TLeafC::Class())) {; 426 // -- Leaf is a character string, we need an offset array.; 427 fEntryOffsetLen = 1000;; 428 }; 429 ++fNleaves;; 430 fLeaves.Add(leaf);; 431 fTree->GetListOfLeaves()->Add(leaf);; 432 if (*pos == 0) {; 433 // -- We reached the end of the leaf specification.; 434 break;; 435 }; 436 nameBegin = pos + 1;; 437 offset += leaf->GetLenType() * leaf->GetLen();; 438 }; 439 }; 440 delete[] leafname;; 441 leafname = nullptr;; 442 delete[] leaftype;; 443 leaftype = nullptr;; 444 ; 445}; 446 ; 447///////////////////////////",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:129812,Modifiability,variab,variable,129812,"tatic TClass * Class(); TBranch::fFillLeavesFillLeaves_t fFillLeaves! Pointer to the FillLeaves implementation to use.Definition TBranch.h:163; TBranch::GetFullNamevirtual TString GetFullName() constReturn the 'full' name of the branch.Definition TBranch.cxx:2031; TBranch::kAutoDelete@ kAutoDeleteDefinition TBranch.h:110; TBranch::kDoNotUseBufferMap@ kDoNotUseBufferMapIf set, at least one of the entry in the branch will use the buffer's map of classname and objects.Definition TBranch.h:112; TBranch::kIsClone@ kIsCloneTo indicate a TBranchClones.Definition TBranch.h:106; TBranch::kDoNotProcess@ kDoNotProcessActive bit for branches.Definition TBranch.h:105; TBranch::fLeavesTObjArray fLeaves-> List of leaves of this branchDefinition TBranch.h:139; TBranch::GetBasketAndFirstInt_t GetBasketAndFirst(TBasket *&basket, Long64_t &first, TBuffer *user_buffer)A helper function to locate the correct basket - and its first entry.Definition TBranch.cxx:1353; TBranch::fAddresschar * fAddress! Address of 1st leaf (variable or object)Definition TBranch.h:147; TBranch::DropBasketsvirtual void DropBaskets(Option_t *option="""")Loop on all branch baskets.Definition TBranch.cxx:757; TBranch::GetListOfBranchesTObjArray * GetListOfBranches()Definition TBranch.h:246; TBranch::GetBrowsablesvirtual TList * GetBrowsables()Returns (and, if 0, creates) browsable objects for this branch See TVirtualBranchBrowsable::FillListO...Definition TBranch.cxx:1312; TBranch::fBrowsablesTList * fBrowsables! List of TVirtualBranchBrowsables used for Browse()Definition TBranch.h:152; TBranch::ReadLeavesImplvoid ReadLeavesImpl(TBuffer &b)Loop on all leaves of this branch to read Basket buffer.Definition TBranch.cxx:2461; TBranch::fOffsetInt_t fOffsetOffset of this branch.Definition TBranch.h:124; TBranch::fBasketEntryLong64_t * fBasketEntry[fMaxBaskets] Table of first entry in each basketDefinition TBranch.h:142; TBranch::GetEntriesSerializedInt_t GetEntriesSerialized(Long64_t N, TBuffer &user_buf)Definition TBra",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:148080,Modifiability,variab,variable,148080,"File::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TIterDefinition TCollection.h:235; TKey::GetSeekKeyvirtual Long64_t GetSeekKey() constDefinition TKey.h:89; TKey::GetKeylenInt_t GetKeylen() constDefinition TKey.h:84; TKey::GetObjlenInt_t GetObjlen() constDefinition TKey.h:87; TKey::GetNbytesInt_t GetNbytes() constDefinition TKey.h:86; TKey::SetParentvirtual void SetParent(const TObject *parent)Set parent in key buffer.Definition TKey.cxx:1295; TKey::GetBufferRefTBuffer * GetBufferRef() constDefinition TKey.h:79; TLeafBA TLeaf for an 8 bit Integer data type.Definition TLeafB.h:26; TLeafCA TLeaf for a variable length string.Definition TLeafC.h:26; TLeafC::Classstatic TClass * Class(); TLeafD32A TLeaf for a 24 bit truncated floating point data type.Definition TLeafD32.h:28; TLeafDA TLeaf for a 64 bit floating point data type.Definition TLeafD.h:26; TLeafF16A TLeaf for a 24 bit truncated floating point data type.Definition TLeafF16.h:27; TLeafFA TLeaf for a 32 bit floating point data type.Definition TLeafF.h:26; TLeafGA TLeaf for a 64 bit Integer data type.Definition TLeafG.h:27; TLeafIA TLeaf for an Integer data type.Definition TLeafI.h:27; TLeafLA TLeaf for a 64 bit Integer data type.Definition TLeafL.h:27; TLeafOA TLeaf for a bool data type.Definition TLeafO.h:26; TLeafSA TLeaf for a 16 bit Integer data type.Definition TLeafS.h:26; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TLeaf::GetLenTypevirtual Int_t GetLenType() constDefinition TLeaf.h:133; TLeaf::GetTypeNamevirtual const char * GetTypeName() constDefinition T",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:149311,Modifiability,variab,variable-sized,149311,"efinition TLeafD.h:26; TLeafF16A TLeaf for a 24 bit truncated floating point data type.Definition TLeafF16.h:27; TLeafFA TLeaf for a 32 bit floating point data type.Definition TLeafF.h:26; TLeafGA TLeaf for a 64 bit Integer data type.Definition TLeafG.h:27; TLeafIA TLeaf for an Integer data type.Definition TLeafI.h:27; TLeafLA TLeaf for a 64 bit Integer data type.Definition TLeafL.h:27; TLeafOA TLeaf for a bool data type.Definition TLeafO.h:26; TLeafSA TLeaf for a 16 bit Integer data type.Definition TLeafS.h:26; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TLeaf::GetLenTypevirtual Int_t GetLenType() constDefinition TLeaf.h:133; TLeaf::GetTypeNamevirtual const char * GetTypeName() constDefinition TLeaf.h:139; TLeaf::GetLenvirtual Int_t GetLen() constReturn the number of effective elements of this leaf, for the current entry.Definition TLeaf.cxx:404; TLeaf::GetLeafCountvirtual TLeaf * GetLeafCount() constIf this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has vari...Definition TLeaf.h:121; TLeaf::GetDeserializeTypevirtual DeserializeType GetDeserializeType() constDefinition TLeaf.h:117; TLeaf::ReadBasketExportvirtual void ReadBasketExport(TBuffer &, TClonesArray *, Int_t)Definition TLeaf.h:153; TLeaf::DeserializeType::kExternal@ kExternal; TLeaf::DeserializeType::kDestructive@ kDestructive; TLeaf::SetAddressvirtual void SetAddress(void *add=nullptr)Definition TLeaf.h:185; TLeaf::GetNdatavirtual Int_t GetNdata() constDefinition TLeaf.h:136; TLeaf::FillBasketvirtual void FillBasket(TBuffer &b)Pack leaf elements in Basket output buffer.Definition TLeaf.cxx:180; TLeaf::GetBranchTBranch * GetBranch() constDefinition TLeaf.h:116; TLeaf::SetOffsetvirtual void SetOffset(Int_t offset=0)Definition TLeaf.h:164; TLeaf::ReadBasketFastvirtual bool ReadBasketFast(TBuffer &, Long64_t)Definition TLeaf.h:154; TLeaf::SetBranchvirtual void SetBranch(TBranch *branch)Definition TLeaf.h",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:153443,Modifiability,inherit,inherits,153443,"rray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObjArray::LowerBoundInt_t LowerBound() constDefinition TObjArray.h:91; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStorage::ReAllocIntstatic Int_t * ReAllocInt(Int_t *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:258; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Clearvoid Clear()Clear string without changin",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:44132,Performance,cache,cache,44132," }; 1245 // if cluster pre-fetching or retaining is on, do not re-use existing baskets; 1246 // unless a new cluster is used.; 1247 if (fTree->GetMaxVirtualSize() < 0 || fTree->GetClusterPrefetch()); 1248 basket = GetFreshCluster(user_buffer);; 1249 else; 1250 basket = GetFreshBasket(basketnumber, user_buffer);; 1251 ; 1252 // fSkipZip is old stuff still maintained for CDF; 1253 if (fSkipZip) basket->SetBit(TBufferFile::kNotDecompressed);; 1254 if (fBasketBytes[basketnumber] == 0) {; 1255 fBasketBytes[basketnumber] = basket->ReadBasketBytes(fBasketSeek[basketnumber],file);; 1256 }; 1257 //add branch to cache (if any); 1258 {; 1259 R__LOCKGUARD_IMT(gROOTMutex); // Lock for parallel TTree I/O; 1260 TFileCacheRead *pf = fTree->GetReadCache(file);; 1261 if (pf){; 1262 if (pf->IsLearning()) pf->LearnBranch(this, false);; 1263 if (fSkipZip) pf->SetSkipZip();; 1264 }; 1265 }; 1266 ; 1267 //now read basket; 1268 Int_t badread = basket->ReadBasketBuffers(fBasketSeek[basketnumber],fBasketBytes[basketnumber],file);; 1269 if (R__unlikely(badread || basket->GetSeekKey() != fBasketSeek[basketnumber] || basket->IsZombie())) {; 1270 nerrors++;; 1271 if (nerrors > 10) return nullptr;; 1272 if (nerrors == 10) {; 1273 printf("" file probably overwritten: stopping reporting error messages\n"");; 1274 if (fBasketSeek[basketnumber] > 2000000000) {; 1275 printf(""===>File is more than 2 Gigabytes\n"");; 1276 return nullptr;; 1277 }; 1278 if (fBasketSeek[basketnumber] > 1000000000) {; 1279 printf(""===>Your file is may be bigger than the maximum file size allowed on your system\n"");; 1280 printf("" Check your AFS maximum file size limit for example\n"");; 1281 return nullptr;; 1282 }; 1283 }; 1284 Error(""GetBasket"",""File: %s at byte:%lld, branch:%s, entry:%lld, badread=%d, nerrors=%d, basketnumber=%d"",file->GetName(),basket->GetSeekKey(),GetName(),fReadEntry,badread,nerrors.load(),basketnumber);; 1285 return nullptr;; 1286 }; 1287 ; 1288 ++fNBaskets;; 1289 ; 1290 fCacheInfo.SetUsed(basketnumber);;",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:45398,Performance,load,load,45398,"read = basket->ReadBasketBuffers(fBasketSeek[basketnumber],fBasketBytes[basketnumber],file);; 1269 if (R__unlikely(badread || basket->GetSeekKey() != fBasketSeek[basketnumber] || basket->IsZombie())) {; 1270 nerrors++;; 1271 if (nerrors > 10) return nullptr;; 1272 if (nerrors == 10) {; 1273 printf("" file probably overwritten: stopping reporting error messages\n"");; 1274 if (fBasketSeek[basketnumber] > 2000000000) {; 1275 printf(""===>File is more than 2 Gigabytes\n"");; 1276 return nullptr;; 1277 }; 1278 if (fBasketSeek[basketnumber] > 1000000000) {; 1279 printf(""===>Your file is may be bigger than the maximum file size allowed on your system\n"");; 1280 printf("" Check your AFS maximum file size limit for example\n"");; 1281 return nullptr;; 1282 }; 1283 }; 1284 Error(""GetBasket"",""File: %s at byte:%lld, branch:%s, entry:%lld, badread=%d, nerrors=%d, basketnumber=%d"",file->GetName(),basket->GetSeekKey(),GetName(),fReadEntry,badread,nerrors.load(),basketnumber);; 1285 return nullptr;; 1286 }; 1287 ; 1288 ++fNBaskets;; 1289 ; 1290 fCacheInfo.SetUsed(basketnumber);; 1291 auto perfStats = GetTree()->GetPerfStats();; 1292 if (perfStats); 1293 perfStats->SetUsed(this, basketnumber);; 1294 ; 1295 fBaskets.AddAt(basket,basketnumber);; 1296 return basket;; 1297}; 1298 ; 1299////////////////////////////////////////////////////////////////////////////////; 1300/// Return address of basket in the file; 1301 ; 1302Long64_t TBranch::GetBasketSeek(Int_t basketnumber) const; 1303{; 1304 if (basketnumber <0 || basketnumber > fWriteBasket) return 0;; 1305 return fBasketSeek[basketnumber];; 1306}; 1307 ; 1308////////////////////////////////////////////////////////////////////////////////; 1309/// Returns (and, if 0, creates) browsable objects for this branch; 1310/// See TVirtualBranchBrowsable::FillListOfBrowsables.; 1311 ; 1312TList* TBranch::GetBrowsables() {; 1313 if (fBrowsables) return fBrowsables;; 1314 fBrowsables=new TList();; 1315 TVirtualBranchBrowsable::FillListOfBrowsables(*fB",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:50875,Performance,perform,perform,50875,"; 1402 GetBasket(i);; 1403 }; 1404 }; 1405 // Getting the next basket might reset the current one and; 1406 // cause a reset of the first / next basket entries back to -1.; 1407 fFirstBasketEntry = first;; 1408 fNextBasketEntry = updatedNext;; 1409 if (user_buffer) {; 1410 // Disassociate basket from memory buffer for bulk IO; 1411 // When the user provides a memory buffer (i.e., for bulk IO), we should; 1412 // make sure to drop all references to that buffer in the TTree afterward.; 1413 fCurrentBasket = nullptr;; 1414 fBaskets[fReadBasket] = nullptr;; 1415 } else {; 1416 fCurrentBasket = basket;; 1417 }; 1418 } else {; 1419 fCurrentBasket = basket;; 1420 }; 1421 return fReadBasket;; 1422 }; 1423}; 1424 ; 1425////////////////////////////////////////////////////////////////////////////////; 1426/// Returns true if this branch supports bulk IO, false otherwise.; 1427///; 1428/// This will return true if all the various preconditions necessary hold true; 1429/// to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may; 1430/// still fail, depending on the contents of the individual TBaskets loaded.; 1431bool TBranch::SupportsBulkRead() const {; 1432 return (fNleaves == 1) &&; 1433 (static_cast<TLeaf*>(fLeaves.UncheckedAt(0))->GetDeserializeType() != TLeaf::DeserializeType::kExternal);; 1434}; 1435 ; 1436////////////////////////////////////////////////////////////////////////////////; 1437/// \brief Read a basket of events into the given buffer with byte swapping.; 1438///; 1439/// \return On success, the number of events of the type held by this branch; 1440/// that have been read into the buffer. -1 on failure.; 1441///; 1442/// On success, the caller should be able to access the contents of buf as they; 1443/// are with:; 1444///; 1445/// ~~~{.cpp}; 1446/// static_cast<T*>(buf.GetCurrent()); 1447/// ~~~; 1448///; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:51019,Performance,load,loaded,51019,"; 1402 GetBasket(i);; 1403 }; 1404 }; 1405 // Getting the next basket might reset the current one and; 1406 // cause a reset of the first / next basket entries back to -1.; 1407 fFirstBasketEntry = first;; 1408 fNextBasketEntry = updatedNext;; 1409 if (user_buffer) {; 1410 // Disassociate basket from memory buffer for bulk IO; 1411 // When the user provides a memory buffer (i.e., for bulk IO), we should; 1412 // make sure to drop all references to that buffer in the TTree afterward.; 1413 fCurrentBasket = nullptr;; 1414 fBaskets[fReadBasket] = nullptr;; 1415 } else {; 1416 fCurrentBasket = basket;; 1417 }; 1418 } else {; 1419 fCurrentBasket = basket;; 1420 }; 1421 return fReadBasket;; 1422 }; 1423}; 1424 ; 1425////////////////////////////////////////////////////////////////////////////////; 1426/// Returns true if this branch supports bulk IO, false otherwise.; 1427///; 1428/// This will return true if all the various preconditions necessary hold true; 1429/// to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may; 1430/// still fail, depending on the contents of the individual TBaskets loaded.; 1431bool TBranch::SupportsBulkRead() const {; 1432 return (fNleaves == 1) &&; 1433 (static_cast<TLeaf*>(fLeaves.UncheckedAt(0))->GetDeserializeType() != TLeaf::DeserializeType::kExternal);; 1434}; 1435 ; 1436////////////////////////////////////////////////////////////////////////////////; 1437/// \brief Read a basket of events into the given buffer with byte swapping.; 1438///; 1439/// \return On success, the number of events of the type held by this branch; 1440/// that have been read into the buffer. -1 on failure.; 1441///; 1442/// On success, the caller should be able to access the contents of buf as they; 1443/// are with:; 1444///; 1445/// ~~~{.cpp}; 1446/// static_cast<T*>(buf.GetCurrent()); 1447/// ~~~; 1448///; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:52772,Performance,perform,perform,52772,"; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1452/// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; 1453/// from the branchCount. After deserialization those value can be used to calculate; 1454/// the number of elements corresponding to each entries.; 1455///; 1456/// For each entry the number of elements is the multiplication of; 1457/// ; 1458/// ~~~{.cpp}; 1459/// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1460/// auto len = leaf->GetLen();; 1461/// ~~~; 1462///; 1463/// and the value in the BranchCount corresponding to that entry (can be obtained; 1464/// from `branch->GetBranchCount()`).; 1465///; 1466/// \note This interface is not meant to be exposed to end users, but rather it should; 1467/// be wrapped by higher-level interfaces.; 1468///; 1469/// \note See TBranch::GetEntriesSerialized() for an alternative that does not; 1470/// perform byte swapping (useful to save one pass over data in some cases).; 1471///; 1472Int_t TBranch::GetBulkEntries(Long64_t entry, TBuffer &user_buf); 1473{; 1474 // TODO: eventually support multiple leaves.; 1475 if (R__unlikely(fNleaves != 1)) return -1;; 1476 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1477 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kExternal)) {; 1478 return -1;; 1479 }; 1480 ; 1481 // Remember which entry we are reading.; 1482 fReadEntry = entry;; 1483 ; 1484 bool enabled = !TestBit(kDoNotProcess);; 1485 if (R__unlikely(!enabled)) return -1;; 1486 TBasket *basket = nullptr;; 1487 Long64_t first;; 1488 Int_t result = GetBasketAndFirst(basket, first, &user_buf);; 1489 if (R__unlikely(result < 0)) return -1;; 1490 // Only support reading from full clusters.; 1491 if (R__unlikely(entry != first)) {; 1492 //printf(""Failed to read from full cluster; first entry is %ld; requested entry is %ld.\n"", first, entry);",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:57487,Performance,perform,performs,57487,"63///; 1564/// where target is a pointer or array to the type stored on this branch.; 1565///; 1566/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1567/// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; 1568/// from the branchCount. After deserialization those value can be used to calculate; 1569/// the number of elements corresponding to each entries.; 1570///; 1571/// For each entry the number of elements is the multiplication of; 1572///; 1573/// ~~~{.cpp}; 1574/// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1575/// auto len = leaf->GetLen();; 1576/// ~~~; 1577///; 1578/// and the value in the BranchCount corresponding to that entry (can be obtained; 1579/// from `branch->GetBranchCount()`).; 1580///; 1581/// \note This interface is not meant to be exposed to end users, but rather it should; 1582/// be wrapped by higher-level interfaces.; 1583///; 1584/// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; 1585///; 1586Int_t TBranch::GetEntriesSerialized(Long64_t entry, TBuffer &user_buf, TBuffer *count_buf); 1587{; 1588 // TODO: Template this and TBranch::GetBulkEntries; only difference is the TLeaf function (ReadBasketFast vs; 1589 // ReadBasketSerialized; 1590 ; 1591 // TODO: eventually support multiple leaves.; 1592 if (R__unlikely(fNleaves != 1)) { return -1; }; 1593 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1594 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kDestructive)) {; 1595 Error(""GetEntriesSerialized"", ""Encountered a branch with destructive deserialization; failing."");; 1596 return -1;; 1597 }; 1598 ; 1599 // Remember which entry we are reading.; 1600 fReadEntry = entry;; 1601 ; 1602 bool enabled = !TestBit(kDoNotProcess);; 1603 if (R__unlikely(!enabled)) { return -1; }; 1604 TBasket *basket = nullptr;; 1605 Long64_t first;; 1606 Int_t result = GetBasketAndFirst(basket, first, &u",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:68944,Performance,optimiz,optimize,68944,"3 fDirectory = file;; 1864 return file;; 1865 }; 1866 }; 1867 ; 1868 if (fFileName.Length() == 0) return nullptr;; 1869 ; 1870 TString bFileName( GetRealFileName() );; 1871 ; 1872 // Open file (new file if mode = 1); 1873 {; 1874 TDirectory::TContext ctxt;; 1875 if (mode) file = TFile::Open(bFileName, ""recreate"");; 1876 else file = TFile::Open(bFileName);; 1877 }; 1878 if (!file) return nullptr;; 1879 if (file->IsZombie()) {delete file; return nullptr;}; 1880 fDirectory = (TDirectory*)file;; 1881 return file;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Return a fresh basket by either reusing an existing basket that needs; 1886/// to be drop (according to TTree::MemoryFull) or create a new one.; 1887///; 1888/// If the user_buffer argument is non-null, then the memory in the; 1889/// user-provided buffer will be utilized by the underlying basket.; 1890///; 1891/// The basket number is used to estimate the required buffer size; 1892/// and try to optimize memory usage and number of memory allocation.; 1893 ; 1894TBasket* TBranch::GetFreshBasket(Int_t basketnumber, TBuffer* user_buffer); 1895{; 1896 TBasket *basket = nullptr;; 1897 if (user_buffer && fExtraBasket) {; 1898 basket = fExtraBasket;; 1899 fExtraBasket = nullptr;; 1900 basket->AdoptBuffer(user_buffer);; 1901 } else {; 1902 if (GetTree()->MemoryFull(0)) {; 1903 if (fNBaskets==1) {; 1904 // Steal the existing basket; 1905 Int_t oldindex = fBaskets.GetLast();; 1906 basket = (TBasket*)fBaskets.UncheckedAt(oldindex);; 1907 if (!basket) {; 1908 fBaskets.SetLast(-2); // For recalculation of Last.; 1909 oldindex = fBaskets.GetLast();; 1910 if (oldindex != fBaskets.LowerBound()-1) {; 1911 basket = (TBasket*)fBaskets.UncheckedAt(oldindex);; 1912 }; 1913 }; 1914 if (basket && fBasketBytes[oldindex]!=0) {; 1915 if (basket == fCurrentBasket) {; 1916 fCurrentBasket = nullptr;; 1917 fFirstBasketEntry = -1;; 1918 fNextBasketEntry = -1;; 1919 }; 1920 fBaskets.A",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:73375,Performance,perform,perform,73375,"1988 // basket, just iterate backwards until the correct basket is reached. This should; 1989 // be fast as long as the number of baskets per cluster is small; 1990 Int_t basketToUnload = fReadBasket;; 1991 while (fBasketEntry[basketToUnload] != entryToUnload) {; 1992 basketToUnload--;; 1993 if (basketToUnload < 0) {; 1994 return CreateOrReuseBasket();; 1995 }; 1996 }; 1997 ; 1998 // Retrieves the basket that is going to be unloaded from memory. If the basket did not; 1999 // exist, create a new one; 2000 basket = (TBasket *)fBaskets.UncheckedAt(basketToUnload);; 2001 if (basket) {; 2002 fBaskets.AddAt(nullptr, basketToUnload);; 2003 --fNBaskets;; 2004 } else {; 2005 basket = CreateOrReuseBasket();; 2006 }; 2007 ++basketToUnload;; 2008 ; 2009 // Clear the rest of the baskets. While it would be ideal to reuse these baskets; 2010 // for other baskets in the new cluster. It would require the function to go; 2011 // beyond its current scope. In the ideal case when each cluster only has 1 basket; 2012 // this will perform well; 2013 iter.Next();; 2014 while (fBasketEntry[basketToUnload] < iter.GetStartEntry()) {; 2015 TBasket *oldbasket = (TBasket *)fBaskets.UncheckedAt(basketToUnload);; 2016 if (oldbasket) {; 2017 oldbasket->DropBuffers();; 2018 delete oldbasket;; 2019 fBaskets.AddAt(nullptr, basketToUnload);; 2020 --fNBaskets;; 2021 }; 2022 ++basketToUnload;; 2023 }; 2024 fBaskets.SetLast(-1);; 2025 return basket;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Return the 'full' name of the branch. In particular prefix the mother's name; 2030/// when it does not end in a trailing dot and thus is not part of the branch name; 2031TString TBranch::GetFullName() const; 2032{; 2033 TBranch* mother = GetMother();; 2034 if (!mother || mother==this) {; 2035 return fName;; 2036 }; 2037 ; 2038 const auto motherName = mother->GetName();; 2039 const auto len = strlen(motherName);; 2040 if (len > 0 && (motherName[len-1] =",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:83801,Performance,load,load,83801,"ket*) fBaskets.UncheckedAt(0);; 2287 if (basket) basket->MoveEntries(dentries);; 2288 fEntries = maxEntries;; 2289 fEntryNumber = maxEntries;; 2290 //loop on sub branches; 2291 Int_t nb = fBranches.GetEntriesFast();; 2292 for (Int_t i = 0; i < nb; ++i) {; 2293 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 2294 branch->KeepCircular(maxEntries);; 2295 }; 2296}; 2297 ; 2298////////////////////////////////////////////////////////////////////////////////; 2299/// Baskets associated to this branch are forced to be in memory.; 2300/// You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; 2301/// the system that the total size of the imported baskets does not; 2302/// exceed maxmemory bytes.; 2303///; 2304/// The function returns the number of baskets that have been put in memory.; 2305/// This method may be called to force all baskets of one or more branches; 2306/// in memory when random access to entries in this branch is required.; 2307/// See also TTree::LoadBaskets to load all baskets of all branches in memory.; 2308 ; 2309Int_t TBranch::LoadBaskets(); 2310{; 2311 Int_t nimported = 0;; 2312 Int_t nbaskets = fWriteBasket;; 2313 TFile *file = GetFile(0);; 2314 if (!file) return 0;; 2315 TBasket *basket;; 2316 for (Int_t i=0;i<nbaskets;i++) {; 2317 basket = (TBasket*)fBaskets.UncheckedAt(i);; 2318 if (basket) continue;; 2319 basket = GetFreshBasket(i, nullptr);; 2320 if (fBasketBytes[i] == 0) {; 2321 fBasketBytes[i] = basket->ReadBasketBytes(fBasketSeek[i],file);; 2322 }; 2323 Int_t badread = basket->ReadBasketBuffers(fBasketSeek[i],fBasketBytes[i],file);; 2324 if (badread) {; 2325 Error(""Loadbaskets"",""Error while reading basket buffer %d of branch %s"",i,GetName());; 2326 return -1;; 2327 }; 2328 ++fNBaskets;; 2329 fBaskets.AddAt(basket,i);; 2330 nimported++;; 2331 }; 2332 return nimported;; 2333}; 2334 ; 2335////////////////////////////////////////////////////////////////////////////////; 2336/// Print TBranch parameters; 2337///; 2338/// If options co",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:88510,Performance,cache,cached,88510,"ld : Total Size=%11lld bytes File Size = %10lld *"",fEntries,totBytes,fZipBytes);; 2418 } else {; 2419 if (fWriteBasket > 0) {; 2420 Printf(""*Entries :%9lld : Total Size=%11lld bytes All baskets in memory *"",fEntries,totBytes);; 2421 } else {; 2422 Printf(""*Entries :%9lld : Total Size=%11lld bytes One basket in memory *"",fEntries,totBytes);; 2423 }; 2424 }; 2425 }; 2426 Printf(""*Baskets :%9d : Basket Size=%11d bytes Compression= %6.2f *"",fWriteBasket,fBasketSize,cx);; 2427 ; 2428 if (strncmp(option,""basketsInfo"",strlen(""basketsInfo""))==0) {; 2429 Int_t nbaskets = fWriteBasket;; 2430 for (Int_t i=0;i<nbaskets;i++) {; 2431 Printf(""*Basket #%4d entry=%6lld pos=%6lld size=%5d"",; 2432 i, fBasketEntry[i], fBasketSeek[i], fBasketBytes[i]);; 2433 }; 2434 }; 2435 ; 2436 Printf(""*............................................................................*"");; 2437 delete [] bline;; 2438 fgCount++;; 2439}; 2440 ; 2441////////////////////////////////////////////////////////////////////////////////; 2442/// Print the information we have about which basket is currently cached and; 2443/// whether they have been 'used'/'read' from the cache.; 2444 ; 2445void TBranch::PrintCacheInfo() const; 2446{; 2447 fCacheInfo.Print(GetName(), fBasketEntry);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Loop on all leaves of this branch to read Basket buffer.; 2452 ; 2453void TBranch::ReadBasket(TBuffer&); 2454{; 2455 // fLeaves->ReadBasket(basket);; 2456}; 2457 ; 2458////////////////////////////////////////////////////////////////////////////////; 2459/// Loop on all leaves of this branch to read Basket buffer.; 2460 ; 2461void TBranch::ReadLeavesImpl(TBuffer& b); 2462{; 2463 for (Int_t i = 0; i < fNleaves; ++i) {; 2464 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 2465 leaf->ReadBasket(b);; 2466 }; 2467}; 2468 ; 2469////////////////////////////////////////////////////////////////////////////////; 2470/// Read zero leaves without",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:88576,Performance,cache,cache,88576,"ld : Total Size=%11lld bytes File Size = %10lld *"",fEntries,totBytes,fZipBytes);; 2418 } else {; 2419 if (fWriteBasket > 0) {; 2420 Printf(""*Entries :%9lld : Total Size=%11lld bytes All baskets in memory *"",fEntries,totBytes);; 2421 } else {; 2422 Printf(""*Entries :%9lld : Total Size=%11lld bytes One basket in memory *"",fEntries,totBytes);; 2423 }; 2424 }; 2425 }; 2426 Printf(""*Baskets :%9d : Basket Size=%11d bytes Compression= %6.2f *"",fWriteBasket,fBasketSize,cx);; 2427 ; 2428 if (strncmp(option,""basketsInfo"",strlen(""basketsInfo""))==0) {; 2429 Int_t nbaskets = fWriteBasket;; 2430 for (Int_t i=0;i<nbaskets;i++) {; 2431 Printf(""*Basket #%4d entry=%6lld pos=%6lld size=%5d"",; 2432 i, fBasketEntry[i], fBasketSeek[i], fBasketBytes[i]);; 2433 }; 2434 }; 2435 ; 2436 Printf(""*............................................................................*"");; 2437 delete [] bline;; 2438 fgCount++;; 2439}; 2440 ; 2441////////////////////////////////////////////////////////////////////////////////; 2442/// Print the information we have about which basket is currently cached and; 2443/// whether they have been 'used'/'read' from the cache.; 2444 ; 2445void TBranch::PrintCacheInfo() const; 2446{; 2447 fCacheInfo.Print(GetName(), fBasketEntry);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Loop on all leaves of this branch to read Basket buffer.; 2452 ; 2453void TBranch::ReadBasket(TBuffer&); 2454{; 2455 // fLeaves->ReadBasket(basket);; 2456}; 2457 ; 2458////////////////////////////////////////////////////////////////////////////////; 2459/// Loop on all leaves of this branch to read Basket buffer.; 2460 ; 2461void TBranch::ReadLeavesImpl(TBuffer& b); 2462{; 2463 for (Int_t i = 0; i < fNleaves; ++i) {; 2464 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 2465 leaf->ReadBasket(b);; 2466 }; 2467}; 2468 ; 2469////////////////////////////////////////////////////////////////////////////////; 2470/// Read zero leaves without",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:134950,Performance,cache,cache,134950,"del=true)Set the automatic delete bit.Definition TBranch.cxx:2716; TBranch::fZipBytesLong64_t fZipBytesTotal number of bytes in all leaves after compression.Definition TBranch.h:137; TBranch::fIOFeaturesTIOFeatures fIOFeaturesIO features for newly-created baskets.Definition TBranch.h:123; TBranch::Browsevoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, ROOT::Internal::TBranchIMTHelper *)Write the current basket to disk and return the number of bytes written to the file.Definition TBranch.cxx:3202; TBranch::UpdateFilevirtual void UpdateFile()Refresh the value of fDirectory (i.e.Definition TBranch.cxx:3304; TBranch::fBasketBytesInt_t * fBasketBytes[fMaxBaskets] Length of baskets on fileDe",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:134997,Performance,cache,cache,134997,"del=true)Set the automatic delete bit.Definition TBranch.cxx:2716; TBranch::fZipBytesLong64_t fZipBytesTotal number of bytes in all leaves after compression.Definition TBranch.h:137; TBranch::fIOFeaturesTIOFeatures fIOFeaturesIO features for newly-created baskets.Definition TBranch.h:123; TBranch::Browsevoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, ROOT::Internal::TBranchIMTHelper *)Write the current basket to disk and return the number of bytes written to the file.Definition TBranch.cxx:3202; TBranch::UpdateFilevirtual void UpdateFile()Refresh the value of fDirectory (i.e.Definition TBranch.cxx:3304; TBranch::fBasketBytesInt_t * fBasketBytes[fMaxBaskets] Length of baskets on fileDe",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:137831,Performance,cache,cached,137831,"moryDefinition TBranch.cxx:2283; TBranch::SetStatusvirtual void SetStatus(bool status=true)Set branch status to Process or DoNotProcess.Definition TBranch.cxx:2947; TBranch::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Reset a Branch.Definition TBranch.cxx:2598; TBranch::ReadLeaves0Implvoid ReadLeaves0Impl(TBuffer &b)Read zero leaves without the overhead of a loop.Definition TBranch.cxx:2472; TBranch::SupportsBulkReadbool SupportsBulkRead() constReturns true if this branch supports bulk IO, false otherwise.Definition TBranch.cxx:1431; TBranch::GetRealFileNameTString GetRealFileName() constGet real file name.Definition TBranch.cxx:2068; TBranch::FindBranchvirtual TBranch * FindBranch(const char *name)Find the immediate sub-branch with passed name.Definition TBranch.cxx:1035; TBranch::fDirectoryTDirectory * fDirectory! Pointer to directory where this branch buffers are storedDefinition TBranch.h:148; TBranch::PrintCacheInfovoid PrintCacheInfo() constPrint the information we have about which basket is currently cached and whether they have been 'used...Definition TBranch.cxx:2445; TBranch::fBasketsTObjArray fBaskets-> List of baskets of this branchDefinition TBranch.h:140; TBranch::LoadBasketsvirtual Int_t LoadBaskets()Baskets associated to this branch are forced to be in memory.Definition TBranch.cxx:2309; TBranch::fMotherTBranch * fMother! Pointer to top-level parent branch in the tree.Definition TBranch.h:145; TBranch::GetTotBytesLong64_t GetTotBytes(Option_t *option="""") constReturn total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub...Definition TBranch.cxx:2220; TBranch::fParentTBranch * fParent! Pointer to parent branch.Definition TBranch.h:146; TBranch::WriteBasketInt_t WriteBasket(TBasket *basket, Int_t where)Definition TBranch.h:175; TBranch::FlushOneBasketInt_t FlushOneBasket(UInt_t which)If we have a write basket in memory and it contains some entries and has not yet been written to disk...Definition ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:146354,Performance,cache,cache,146354,"ay of clone (identical) objects.Definition TClonesArray.h:29; TCollection::RemoveAllvirtual void RemoveAll(TCollection *col)Remove all objects in collection col from this collection.Definition TCollection.cxx:594; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TDirectory::FindObjectTObject * FindObject(const char *name) const overrideFind object by name in the list of memory objects.Definition TDirectory.cxx:784; TDirectory::IsWritablevirtual Bool_t IsWritable() constDefinition TDirectory.h:237; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::SetSkipZipvirtual void SetSkipZip(Bool_t=kTRUE)Definition TFileCacheRead.h:112; TFileCacheRead::IsLearningvirtual Bool_t IsLearning() constDefinition TFileCacheRead.h:102; TFileCacheRead::LearnBranchvirtual Int_t LearnBranch(TBranch *, Bool_t=kFALSE)Definition TFileCacheRead.h:103; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TFile.h:397; TFile::GetCompressionLevelInt_t GetCompressionLevel() constDefinition TFile.h:391; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefau",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:27473,Safety,avoid,avoid,27473,"//////////////////////////////////////////////////////////////////////; 752/// Loop on all branch baskets. Drop all baskets from memory except readbasket.; 753/// If the option contains ""all"", drop all baskets including; 754/// read- and write-baskets (unless they are not stored individually on disk).; 755/// The option ""all"" also lead to DropBaskets being called on the sub-branches.; 756 ; 757void TBranch::DropBaskets(Option_t* options); 758{; 759 bool all = false;; 760 if (options && options[0]) {; 761 TString opt = options;; 762 opt.ToLower();; 763 if (opt.Contains(""all"")) all = true;; 764 }; 765 ; 766 TBasket *basket;; 767 Int_t nbaskets = fBaskets.GetEntriesFast();; 768 ; 769 if ( (fNBaskets>1) || all ) {; 770 //slow case; 771 for (Int_t i=0;i<nbaskets;i++) {; 772 basket = (TBasket*)fBaskets.UncheckedAt(i);; 773 if (!basket) continue;; 774 if ((i == fReadBasket || i == fWriteBasket) && !all) continue;; 775 // if the basket is not yet on file but already has event in it; 776 // we must continue to avoid dropping the basket (and thus losing data); 777 if (fBasketBytes[i]==0 && basket->GetNevBuf() > 0) continue;; 778 basket->DropBuffers();; 779 --fNBaskets;; 780 fBaskets.RemoveAt(i);; 781 if (basket == fCurrentBasket) {; 782 fCurrentBasket = nullptr;; 783 fFirstBasketEntry = -1;; 784 fNextBasketEntry = -1;; 785 }; 786 delete basket;; 787 }; 788 ; 789 // process subbranches; 790 if (all) {; 791 TObjArray *lb = GetListOfBranches();; 792 Int_t nb = lb->GetEntriesFast();; 793 for (Int_t j = 0; j < nb; j++) {; 794 TBranch* branch = (TBranch*) lb->UncheckedAt(j);; 795 if (!branch) continue;; 796 branch->DropBaskets(""all"");; 797 }; 798 }; 799 } else {; 800 //fast case; 801 if (nbaskets > 0) {; 802 Int_t i = fBaskets.GetLast();; 803 basket = (TBasket*)fBaskets.UncheckedAt(i);; 804 if (basket && fBasketBytes[i]!=0) {; 805 basket->DropBuffers();; 806 if (basket == fCurrentBasket) {; 807 fCurrentBasket = nullptr;; 808 fFirstBasketEntry = -1;; 809 fNextBasketEntry = -1;; 810 ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:42958,Safety,safe,safely,42958,"iteBasket) {; 1202 // Nothing to do.; 1203 } else {; 1204 basket->DropBuffers();; 1205 if (basket == fCurrentBasket) {; 1206 fCurrentBasket = nullptr;; 1207 fFirstBasketEntry = -1;; 1208 fNextBasketEntry = -1;; 1209 }; 1210 delete basket;; 1211 --fNBaskets;; 1212 fBaskets[ibasket] = nullptr;; 1213 }; 1214 }; 1215 }; 1216 }; 1217 return nbytes;; 1218}; 1219 ; 1220////////////////////////////////////////////////////////////////////////////////; 1221/// Return pointer to basket basketnumber in this Branch; 1222///; 1223/// If a new buffer must be created and the user_buffer argument is non-null,; 1224/// then the memory in the user_buffer will be shared with the returned TBasket.; 1225 ; 1226TBasket* TBranch::GetBasketImpl(Int_t basketnumber, TBuffer *user_buffer); 1227{; 1228 // This counter in the sequential case collects errors coming also from; 1229 // different files (suppose to have a program reading f1.root, f2.root ...); 1230 // In the mt case, it is made atomic: it safely collects errors from; 1231 // different files processed simultaneously.; 1232 static std::atomic<Int_t> nerrors(0);; 1233 ; 1234 // reference to an existing basket in memory ?; 1235 if (basketnumber <0 || basketnumber > fWriteBasket) return nullptr;; 1236 TBasket *basket = (TBasket*)fBaskets.UncheckedAt(basketnumber);; 1237 if (basket) return basket;; 1238 if (basketnumber == fWriteBasket) return nullptr;; 1239 ; 1240 // create/decode basket parameters from buffer; 1241 TFile *file = GetFile(0);; 1242 if (file == nullptr) {; 1243 return nullptr;; 1244 }; 1245 // if cluster pre-fetching or retaining is on, do not re-use existing baskets; 1246 // unless a new cluster is used.; 1247 if (fTree->GetMaxVirtualSize() < 0 || fTree->GetClusterPrefetch()); 1248 basket = GetFreshCluster(user_buffer);; 1249 else; 1250 basket = GetFreshBasket(basketnumber, user_buffer);; 1251 ; 1252 // fSkipZip is old stuff still maintained for CDF; 1253 if (fSkipZip) basket->SetBit(TBufferFile::kNotDecompressed);; 1254 if",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:74430,Safety,avoid,avoid,74430,"try[basketToUnload] < iter.GetStartEntry()) {; 2015 TBasket *oldbasket = (TBasket *)fBaskets.UncheckedAt(basketToUnload);; 2016 if (oldbasket) {; 2017 oldbasket->DropBuffers();; 2018 delete oldbasket;; 2019 fBaskets.AddAt(nullptr, basketToUnload);; 2020 --fNBaskets;; 2021 }; 2022 ++basketToUnload;; 2023 }; 2024 fBaskets.SetLast(-1);; 2025 return basket;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Return the 'full' name of the branch. In particular prefix the mother's name; 2030/// when it does not end in a trailing dot and thus is not part of the branch name; 2031TString TBranch::GetFullName() const; 2032{; 2033 TBranch* mother = GetMother();; 2034 if (!mother || mother==this) {; 2035 return fName;; 2036 }; 2037 ; 2038 const auto motherName = mother->GetName();; 2039 const auto len = strlen(motherName);; 2040 if (len > 0 && (motherName[len-1] == '.')) {; 2041 return fName;; 2042 }; 2043 ; 2044 // Reserve the final size to avoid allocations; 2045 TString result{static_cast<Ssiz_t>(len + 1 + fName.Length())};; 2046 result = motherName;; 2047 result += ""."";; 2048 result += fName;; 2049 return result;; 2050}; 2051 ; 2052////////////////////////////////////////////////////////////////////////////////; 2053/// Return pointer to the 1st Leaf named name in thisBranch; 2054 ; 2055TLeaf* TBranch::GetLeaf(const char* name) const; 2056{; 2057 Int_t i;; 2058 for (i=0;i<fNleaves;i++) {; 2059 TLeaf *leaf = (TLeaf*)fLeaves.UncheckedAt(i);; 2060 if (!strcmp(leaf->GetName(),name)) return leaf;; 2061 }; 2062 return nullptr;; 2063}; 2064 ; 2065////////////////////////////////////////////////////////////////////////////////; 2066/// Get real file name; 2067 ; 2068TString TBranch::GetRealFileName() const; 2069{; 2070 if (fFileName.Length()==0) {; 2071 return fFileName;; 2072 }; 2073 TString bFileName = fFileName;; 2074 ; 2075 // check if branch file name is absolute or a URL (e.g. root://host/...); 2076 char *bname = gSystem",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:97537,Safety,avoid,avoid,97537,"w object; 2710/// created by the default constructor, then read from disk by the streamer.; 2711///; 2712/// If autodel is false, the existing object is not deleted. Root assumes; 2713/// that the user is taking care of deleting any internal object or array; 2714/// (this can be done in the streamer).; 2715 ; 2716void TBranch::SetAutoDelete(bool autodel); 2717{; 2718 if (autodel) {; 2719 SetBit(kAutoDelete, true);; 2720 } else {; 2721 SetBit(kAutoDelete, false);; 2722 }; 2723}; 2724 ; 2725////////////////////////////////////////////////////////////////////////////////; 2726/// Set the basket size; 2727/// The function makes sure that the basket size is greater than fEntryOffsetlen; 2728 ; 2729void TBranch::SetBasketSize(Int_t buffsize); 2730{; 2731 Int_t minsize = 100 + fName.Length();; 2732 if (buffsize < minsize+fEntryOffsetLen) buffsize = minsize+fEntryOffsetLen;; 2733 fBasketSize = buffsize;; 2734 TBasket *basket = (TBasket*)fBaskets[fWriteBasket];; 2735 if (basket) {; 2736 basket->AdjustSize(fBasketSize);; 2737 }; 2738}; 2739 ; 2740////////////////////////////////////////////////////////////////////////////////; 2741/// Set address of this branch directly from a TBuffer to avoid streaming.; 2742///; 2743/// Note: We do not take ownership of the buffer.; 2744 ; 2745void TBranch::SetBufferAddress(TBuffer* buf); 2746{; 2747 // Check this is possible; 2748 if ( (fNleaves != 1); 2749 || (strcmp(""TLeafObject"",fLeaves.UncheckedAt(0)->ClassName())!=0) ) {; 2750 Error(""TBranch::SetAddress"",""Filling from a TBuffer can only be done with a not split object branch. Request ignored."");; 2751 } else {; 2752 fReadEntry = -1;; 2753 fNextBasketEntry = -1;; 2754 fFirstBasketEntry = -1;; 2755 // Note: We do not take ownership of the buffer.; 2756 fEntryBuffer = buf;; 2757 }; 2758}; 2759 ; 2760////////////////////////////////////////////////////////////////////////////////; 2761/// Set compression algorithm.; 2762 ; 2763void TBranch::SetCompressionAlgorithm(Int_t algorithm); 2764{;",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:114711,Safety,safe,safely,114711,"f();; 3205 if (fEntryOffsetLen > 10 && (4*nevbuf) < fEntryOffsetLen ) {; 3206 // Make sure that the fEntryOffset array does not stay large unnecessarily.; 3207 fEntryOffsetLen = nevbuf < 3 ? 10 : 4*nevbuf; // assume some fluctuations.; 3208 } else if (fEntryOffsetLen && nevbuf > fEntryOffsetLen) {; 3209 // Increase the array ...; 3210 fEntryOffsetLen = 2*nevbuf; // assume some fluctuations.; 3211 }; 3212 ; 3213 // Note: captures `basket`, `where`, and `this` by value; modifies the TBranch and basket,; 3214 // as we make a copy of the pointer. We cannot capture `basket` by reference as the pointer; 3215 // itself might be modified after `WriteBasketImpl` exits.; 3216 auto doUpdates = [this, basket, where]() {; 3217 Int_t nout = basket->WriteBuffer(); // Write buffer; 3218 if (nout < 0); 3219 Error(""WriteBasketImpl"", ""basket's WriteBuffer failed."");; 3220 fBasketBytes[where] = basket->GetNbytes();; 3221 fBasketSeek[where] = basket->GetSeekKey();; 3222 Int_t addbytes = basket->GetObjlen() + basket->GetKeylen();; 3223 TBasket *reusebasket = nullptr;; 3224 if (nout>0) {; 3225 // The Basket was written so we can now safely reuse it.; 3226 fBaskets[where] = nullptr;; 3227 ; 3228 reusebasket = basket;; 3229 reusebasket->WriteReset();; 3230 ; 3231 fZipBytes += nout;; 3232 fTotBytes += addbytes;; 3233 fTree->AddTotBytes(addbytes);; 3234 fTree->AddZipBytes(nout);; 3235#ifdef R__TRACK_BASKET_ALLOC_TIME; 3236 fTree->AddAllocationTime(reusebasket->GetResetAllocationTime());; 3237#endif; 3238 fTree->AddAllocationCount(reusebasket->GetResetAllocationCount());; 3239 }; 3240 ; 3241 if (where==fWriteBasket) {; 3242 ++fWriteBasket;; 3243 if (fWriteBasket >= fMaxBaskets) {; 3244 ExpandBasketArrays();; 3245 }; 3246 if (reusebasket && reusebasket == fCurrentBasket) {; 3247 // The 'current' basket has Reset, so if we need it we will need; 3248 // to reload it.; 3249 fCurrentBasket = nullptr;; 3250 fFirstBasketEntry = -1;; 3251 fNextBasketEntry = -1;; 3252 }; 3253 fBaskets.AddAtAndExpand(re",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:135240,Safety,avoid,avoid,135240,"reated baskets.Definition TBranch.h:123; TBranch::Browsevoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, ROOT::Internal::TBranchIMTHelper *)Write the current basket to disk and return the number of bytes written to the file.Definition TBranch.cxx:3202; TBranch::UpdateFilevirtual void UpdateFile()Refresh the value of fDirectory (i.e.Definition TBranch.cxx:3304; TBranch::fBasketBytesInt_t * fBasketBytes[fMaxBaskets] Length of baskets on fileDefinition TBranch.h:141; TBranch::fNextBasketEntryLong64_t fNextBasketEntry! Next entry that will requires us to go to the next basketDefinition TBranch.h:132; TBranch::IsAutoDeletebool IsAutoDelete() constReturn true if an existing object in a TBranc",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:7401,Security,access,access,7401,"/// it is used as a 2 dimensional array of fixed size.; 175/// - In case of the truncated floating point types (Float16_t and Double32_t) you can; 176/// furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; 177/// the type character. See `TStreamerElement::GetRange()` for further information.; 178/// - Any of other form is not supported.; 179///; 180/// Note that the TTree will assume that all the item are contiguous in memory.; 181/// On some platform, this is not always true of the member of a struct or a class,; 182/// due to padding and alignment. Sorting your data member in order of decreasing; 183/// sizeof usually leads to their being contiguous in memory.; 184///; 185/// * bufsize is the buffer size in bytes for this branch; 186/// The default value is 32000 bytes and should be ok for most cases.; 187/// You can specify a larger value (e.g. 256000) if your Tree is not split; 188/// and each entry is large (Megabytes); 189/// A small value for bufsize is optimum if you intend to access; 190/// the entries in the Tree randomly and your Tree is in split mode.; 191///; 192/// See an example of a Branch definition in the TTree constructor.; 193///; 194/// Note that in case the data type is an object, this branch can contain; 195/// only this object.; 196///; 197/// Note that this function is invoked by TTree::Branch; 198 ; 199TBranch::TBranch(TTree *tree, const char *name, void *address, const char *leaflist, Int_t basketsize, Int_t compress); 200 : TNamed(name, leaflist); 201, TAttFill(0, 1001); 202, fCompress(compress); 203, fBasketSize((basketsize < 100) ? 100 : basketsize); 204, fEntryOffsetLen(0); 205, fWriteBasket(0); 206, fEntryNumber(0); 207, fExtraBasket(nullptr); 208, fIOFeatures(tree ? tree->GetIOFeatures().GetFeatures() : 0); 209, fOffset(0); 210, fMaxBaskets(10); 211, fNBaskets(0); 212, fSplitLevel(0); 213, fNleaves(0); 214, fReadBasket(0); 215, fReadEntry(-1); 216, fFirstBasketEntry(-1); 217, fNextBasketEntry(-1); 218, ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:51610,Security,access,access,51610,"///////////////////////////////////////////////////////////////////////////////; 1426/// Returns true if this branch supports bulk IO, false otherwise.; 1427///; 1428/// This will return true if all the various preconditions necessary hold true; 1429/// to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may; 1430/// still fail, depending on the contents of the individual TBaskets loaded.; 1431bool TBranch::SupportsBulkRead() const {; 1432 return (fNleaves == 1) &&; 1433 (static_cast<TLeaf*>(fLeaves.UncheckedAt(0))->GetDeserializeType() != TLeaf::DeserializeType::kExternal);; 1434}; 1435 ; 1436////////////////////////////////////////////////////////////////////////////////; 1437/// \brief Read a basket of events into the given buffer with byte swapping.; 1438///; 1439/// \return On success, the number of events of the type held by this branch; 1440/// that have been read into the buffer. -1 on failure.; 1441///; 1442/// On success, the caller should be able to access the contents of buf as they; 1443/// are with:; 1444///; 1445/// ~~~{.cpp}; 1446/// static_cast<T*>(buf.GetCurrent()); 1447/// ~~~; 1448///; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1452/// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; 1453/// from the branchCount. After deserialization those value can be used to calculate; 1454/// the number of elements corresponding to each entries.; 1455///; 1456/// For each entry the number of elements is the multiplication of; 1457/// ; 1458/// ~~~{.cpp}; 1459/// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1460/// auto len = leaf->GetLen();; 1461/// ~~~; 1462///; 1463/// and the value in the BranchCount corresponding to that entry (can be obtained; 1464/// from `branch->GetBranchCount()`).; 1465///; 1466/// \note This interface is not meant to be exposed to end users, but rather it shou",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:52579,Security,expose,exposed,52579,"ould be able to access the contents of buf as they; 1443/// are with:; 1444///; 1445/// ~~~{.cpp}; 1446/// static_cast<T*>(buf.GetCurrent()); 1447/// ~~~; 1448///; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1452/// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; 1453/// from the branchCount. After deserialization those value can be used to calculate; 1454/// the number of elements corresponding to each entries.; 1455///; 1456/// For each entry the number of elements is the multiplication of; 1457/// ; 1458/// ~~~{.cpp}; 1459/// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1460/// auto len = leaf->GetLen();; 1461/// ~~~; 1462///; 1463/// and the value in the BranchCount corresponding to that entry (can be obtained; 1464/// from `branch->GetBranchCount()`).; 1465///; 1466/// \note This interface is not meant to be exposed to end users, but rather it should; 1467/// be wrapped by higher-level interfaces.; 1468///; 1469/// \note See TBranch::GetEntriesSerialized() for an alternative that does not; 1470/// perform byte swapping (useful to save one pass over data in some cases).; 1471///; 1472Int_t TBranch::GetBulkEntries(Long64_t entry, TBuffer &user_buf); 1473{; 1474 // TODO: eventually support multiple leaves.; 1475 if (R__unlikely(fNleaves != 1)) return -1;; 1476 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1477 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kExternal)) {; 1478 return -1;; 1479 }; 1480 ; 1481 // Remember which entry we are reading.; 1482 fReadEntry = entry;; 1483 ; 1484 bool enabled = !TestBit(kDoNotProcess);; 1485 if (R__unlikely(!enabled)) return -1;; 1486 TBasket *basket = nullptr;; 1487 Long64_t first;; 1488 Int_t result = GetBasketAndFirst(basket, first, &user_buf);; 1489 if (R__unlikely(result < 0)) return -1;; 1490 // Only support reading from full c",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:57313,Security,expose,exposed,57313,"= 0u; i < N; ++i, ++target); 1561/// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; 1562/// ~~~; 1563///; 1564/// where target is a pointer or array to the type stored on this branch.; 1565///; 1566/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1567/// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; 1568/// from the branchCount. After deserialization those value can be used to calculate; 1569/// the number of elements corresponding to each entries.; 1570///; 1571/// For each entry the number of elements is the multiplication of; 1572///; 1573/// ~~~{.cpp}; 1574/// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1575/// auto len = leaf->GetLen();; 1576/// ~~~; 1577///; 1578/// and the value in the BranchCount corresponding to that entry (can be obtained; 1579/// from `branch->GetBranchCount()`).; 1580///; 1581/// \note This interface is not meant to be exposed to end users, but rather it should; 1582/// be wrapped by higher-level interfaces.; 1583///; 1584/// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; 1585///; 1586Int_t TBranch::GetEntriesSerialized(Long64_t entry, TBuffer &user_buf, TBuffer *count_buf); 1587{; 1588 // TODO: Template this and TBranch::GetBulkEntries; only difference is the TLeaf function (ReadBasketFast vs; 1589 // ReadBasketSerialized; 1590 ; 1591 // TODO: eventually support multiple leaves.; 1592 if (R__unlikely(fNleaves != 1)) { return -1; }; 1593 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1594 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kDestructive)) {; 1595 Error(""GetEntriesSerialized"", ""Encountered a branch with destructive deserialization; failing."");; 1596 return -1;; 1597 }; 1598 ; 1599 // Remember which entry we are reading.; 1600 fReadEntry = entry;; 1601 ; 1602 bool enabled = !TestBit(kDoNotProcess);; 1603 if (R__unlikely(!enabled)",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:83715,Security,access,access,83715,"ircular(Long64_t maxEntries); 2284{; 2285 Int_t dentries = (Int_t) (fEntries - maxEntries);; 2286 TBasket* basket = (TBasket*) fBaskets.UncheckedAt(0);; 2287 if (basket) basket->MoveEntries(dentries);; 2288 fEntries = maxEntries;; 2289 fEntryNumber = maxEntries;; 2290 //loop on sub branches; 2291 Int_t nb = fBranches.GetEntriesFast();; 2292 for (Int_t i = 0; i < nb; ++i) {; 2293 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 2294 branch->KeepCircular(maxEntries);; 2295 }; 2296}; 2297 ; 2298////////////////////////////////////////////////////////////////////////////////; 2299/// Baskets associated to this branch are forced to be in memory.; 2300/// You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; 2301/// the system that the total size of the imported baskets does not; 2302/// exceed maxmemory bytes.; 2303///; 2304/// The function returns the number of baskets that have been put in memory.; 2305/// This method may be called to force all baskets of one or more branches; 2306/// in memory when random access to entries in this branch is required.; 2307/// See also TTree::LoadBaskets to load all baskets of all branches in memory.; 2308 ; 2309Int_t TBranch::LoadBaskets(); 2310{; 2311 Int_t nimported = 0;; 2312 Int_t nbaskets = fWriteBasket;; 2313 TFile *file = GetFile(0);; 2314 if (!file) return 0;; 2315 TBasket *basket;; 2316 for (Int_t i=0;i<nbaskets;i++) {; 2317 basket = (TBasket*)fBaskets.UncheckedAt(i);; 2318 if (basket) continue;; 2319 basket = GetFreshBasket(i, nullptr);; 2320 if (fBasketBytes[i] == 0) {; 2321 fBasketBytes[i] = basket->ReadBasketBytes(fBasketSeek[i],file);; 2322 }; 2323 Int_t badread = basket->ReadBasketBuffers(fBasketSeek[i],fBasketBytes[i],file);; 2324 if (badread) {; 2325 Error(""Loadbaskets"",""Error while reading basket buffer %d of branch %s"",i,GetName());; 2326 return -1;; 2327 }; 2328 ++fNBaskets;; 2329 fBaskets.AddAt(basket,i);; 2330 nimported++;; 2331 }; 2332 return nimported;; 2333}; 2334 ; 2335//////////////////////////",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:101652,Security,access,access,101652," = (TBranch*)next() ) ) {; 2830 b->SetEntryOffsetLen( newdefault, true );; 2831 }; 2832 }; 2833}; 2834 ; 2835////////////////////////////////////////////////////////////////////////////////; 2836/// Set the number of entries in this branch.; 2837 ; 2838void TBranch::SetEntries(Long64_t entries); 2839{; 2840 fEntries = entries;; 2841 fEntryNumber = entries;; 2842}; 2843 ; 2844////////////////////////////////////////////////////////////////////////////////; 2845/// Set file where this branch writes/reads its buffers.; 2846/// By default the branch buffers reside in the file where the; 2847/// Tree was created.; 2848/// If the file name where the tree was created is an absolute; 2849/// path name or an URL (e.g. or root://host/...); 2850/// and if the fname is not an absolute path name or an URL then; 2851/// the path of the tree file is prepended to fname to make the; 2852/// branch file relative to the tree file. In this case one can; 2853/// move the tree + all branch files to a different location in; 2854/// the file system and still access the branch files.; 2855/// The ROOT file will be connected only when necessary.; 2856/// If called by TBranch::Fill (via TBasket::WriteFile), the file; 2857/// will be created with the option ""recreate"".; 2858/// If called by TBranch::GetEntry (via TBranch::GetBasket), the file; 2859/// will be opened in read mode.; 2860/// To open a file in ""update"" mode or with a certain compression; 2861/// level, use TBranch::SetFile(TFile *file).; 2862 ; 2863void TBranch::SetFile(TFile* file); 2864{; 2865 if (file == nullptr) file = fTree->GetCurrentFile();; 2866 fDirectory = (TDirectory*)file;; 2867 if (file == fTree->GetCurrentFile()) fFileName = """";; 2868 else fFileName = file->GetName();; 2869 ; 2870 if (file && fCompress == -1) {; 2871 fCompress = file->GetCompressionLevel();; 2872 }; 2873 ; 2874 // Apply to all existing baskets.; 2875 TIter nextb(GetListOfBaskets());; 2876 TBasket *basket;; 2877 while ((basket = (TBasket*)nextb())) {;",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:103519,Security,access,access,103519," to all existing baskets.; 2875 TIter nextb(GetListOfBaskets());; 2876 TBasket *basket;; 2877 while ((basket = (TBasket*)nextb())) {; 2878 basket->SetParent(file);; 2879 }; 2880 ; 2881 // Apply to sub-branches as well.; 2882 TIter next(GetListOfBranches());; 2883 TBranch *branch;; 2884 while ((branch = (TBranch*)next())) {; 2885 branch->SetFile(file);; 2886 }; 2887}; 2888 ; 2889////////////////////////////////////////////////////////////////////////////////; 2890/// Set file where this branch writes/reads its buffers.; 2891/// By default the branch buffers reside in the file where the; 2892/// Tree was created.; 2893/// If the file name where the tree was created is an absolute; 2894/// path name or an URL (e.g. root://host/...); 2895/// and if the fname is not an absolute path name or an URL then; 2896/// the path of the tree file is prepended to fname to make the; 2897/// branch file relative to the tree file. In this case one can; 2898/// move the tree + all branch files to a different location in; 2899/// the file system and still access the branch files.; 2900/// The ROOT file will be connected only when necessary.; 2901/// If called by TBranch::Fill (via TBasket::WriteFile), the file; 2902/// will be created with the option ""recreate"".; 2903/// If called by TBranch::GetEntry (via TBranch::GetBasket), the file; 2904/// will be opened in read mode.; 2905/// To open a file in ""update"" mode or with a certain compression; 2906/// level, use TBranch::SetFile(TFile *file).; 2907 ; 2908void TBranch::SetFile(const char* fname); 2909{; 2910 fFileName = fname;; 2911 fDirectory = nullptr;; 2912 ; 2913 //apply to sub-branches as well; 2914 TIter next(GetListOfBranches());; 2915 TBranch *branch;; 2916 while ((branch = (TBranch*)next())) {; 2917 branch->SetFile(fname);; 2918 }; 2919}; 2920 ; 2921////////////////////////////////////////////////////////////////////////////////; 2922/// Set the branch in a mode where the object are decomposed; 2923/// (Also known as MakeClass m",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8cxx_source.html:62861,Testability,test,test,62861,"e of a TChain, the entry number in the current Tree must be found; 1692/// before calling this function. For example:; 1693///; 1694///~~~ {.cpp}; 1695/// TChain* chain = ...;; 1696/// Long64_t localEntry = chain->LoadTree(entry);; 1697/// branch->GetEntry(localEntry);; 1698///~~~; 1699///; 1700/// The function returns the number of bytes read from the input buffer.; 1701/// If entry does not exist, the function returns 0.; 1702/// If an I/O error occurs, the function returns -1.; 1703///; 1704/// See IMPORTANT REMARKS in TTree::GetEntry.; 1705 ; 1706Int_t TBranch::GetEntry(Long64_t entry, Int_t getall); 1707{; 1708 // Remember which entry we are reading.; 1709 fReadEntry = entry;; 1710 ; 1711 if (R__unlikely(TestBit(kDoNotProcess) && !getall)) { return 0; }; 1712 ; 1713 TBasket *basket; // will be initialized in the if/then clauses.; 1714 Long64_t first;; 1715 ; 1716 Int_t result = GetBasketAndFirst(basket, first, nullptr);; 1717 if (R__unlikely(result < 0)) { return result + 1; }; 1718 ; 1719 basket->PrepareBasket(entry);; 1720 TBuffer* buf = basket->GetBufferRef();; 1721 ; 1722 // This test necessary to read very old Root files (NvE).; 1723 if (R__unlikely(!buf)) {; 1724 TFile* file = GetFile(0);; 1725 if (!file) return -1;; 1726 basket->ReadBasketBuffers(fBasketSeek[fReadBasket], fBasketBytes[fReadBasket], file);; 1727 buf = basket->GetBufferRef();; 1728 }; 1729 ; 1730 // Set entry offset in buffer.; 1731 if (!TestBit(kDoNotUseBufferMap)) {; 1732 buf->ResetMap();; 1733 }; 1734 if (R__unlikely(!buf->IsReading())) {; 1735 basket->SetReadMode();; 1736 }; 1737 ; 1738 Int_t* entryOffset = basket->GetEntryOffset();; 1739 Int_t bufbegin = 0;; 1740 if (entryOffset) {; 1741 bufbegin = entryOffset[entry-first];; 1742 buf->SetBufferOffset(bufbegin);; 1743 Int_t* displacement = basket->GetDisplacement();; 1744 if (R__unlikely(displacement)) {; 1745 buf->SetBufferDisplacement(displacement[entry-first]);; 1746 }; 1747 } else {; 1748 bufbegin = basket->GetKeylen() + ((entry-fi",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
https://root.cern/doc/master/TBranch_8h_source.html:13244,Deployability,update,updateSubBranches,13244,"Print(Option_t *option="""") const override;; 263 void PrintCacheInfo() const;; 264 virtual void ReadBasket(TBuffer &b);; 265 virtual void Refresh(TBranch *b);; 266 virtual void Reset(Option_t *option="""");; 267 virtual void ResetAfterMerge(TFileMergeInfo *);; 268 virtual void ResetAddress();; 269 virtual void ResetReadEntry() {fReadEntry = -1;}; 270 virtual void SetAddress(void *add);; 271 virtual void SetObject(void *objadd);; 272 virtual void SetAutoDelete(bool autodel=true);; 273 virtual void SetBasketSize(Int_t buffsize);; 274 virtual void SetBufferAddress(TBuffer *entryBuffer);; 275 void SetCompressionAlgorithm(Int_t algorithm = ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);; 276 void SetCompressionLevel(Int_t level = ROOT::RCompressionSetting::ELevel::kUseMin);; 277 void SetCompressionSettings(Int_t settings = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 278 virtual void SetEntries(Long64_t entries);; 279 virtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches = false);; 280 virtual void SetFirstEntry(Long64_t entry);; 281 virtual void SetFile(TFile *file = nullptr);; 282 virtual void SetFile(const char *filename);; 283 void SetIOFeatures(TIOFeatures &features) {fIOFeatures = features;}; 284 virtual bool SetMakeClass(bool decomposeObj = true);; 285 virtual void SetOffset(Int_t offset=0) {fOffset=offset;}; 286 virtual void SetStatus(bool status=true);; 287 virtual void SetTree(TTree *tree) { fTree = tree; }; 288 virtual void SetupAddresses();; 289 bool SupportsBulkRead() const;; 290 virtual void UpdateAddress() {}; 291 virtual void UpdateFile();; 292 ; 293 static void ResetCount();; 294 ; 295 ClassDefOverride(TBranch, 13); // Branch descriptor; 296};; 297 ; 298//______________________________________________________________________________; 299inline Int_t TBranch::GetCompressionAlgorithm() const; 300{; 301 return (fCompress < 0) ? -1 : fCompress / 100;; 302}; 303 ; 304//_______________________________________________________________",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:31150,Deployability,update,updateSubBranches,31150,"sArray *list, Int_t n)Read all leaves of an entry and export buffers to real objects in a TClonesArray list.Definition TBranch.cxx:1762; TBranch::SetAutoDeletevirtual void SetAutoDelete(bool autodel=true)Set the automatic delete bit.Definition TBranch.cxx:2716; TBranch::fZipBytesLong64_t fZipBytesTotal number of bytes in all leaves after compression.Definition TBranch.h:137; TBranch::fIOFeaturesTIOFeatures fIOFeaturesIO features for newly-created baskets.Definition TBranch.h:123; TBranch::Browsevoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::UpdateAddressvirtual void UpdateAddress()Definition TBranch.h:290; TBranch::GetOffsetInt_t GetOffset() constDefinition TBranch.h:235; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fBulkBulkObj fBulk! Helper for performing bulk IODefinition TBranch.h:153; TBranch::GetReadEntryLong64_t GetReadEntry() constDefinition TBranch.h:237; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; ",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:2854,Integrability,interface,interfaces,2854,"space Internal {; 48class TBulkBranchRead;; 49}; 50}; 51namespace Internal {; 52class TBranchIMTHelper; ///< A helper class for managing IMT work during TTree:Fill operations.; 53}; 54}; 55 ; 56const Int_t kDoNotProcess = BIT(10); // Active bit for branches; 57const Int_t kIsClone = BIT(11); // to indicate a TBranchClones; 58const Int_t kBranchObject = BIT(12); // branch is a TObject*; 59const Int_t kBranchAny = BIT(17); // branch is an object*; 60const Int_t kMapObject = kBranchObject | kBranchAny;; 61 ; 62namespace ROOT {; 63namespace Experimental {; 64namespace Internal {; 65 ; 66///\class TBulkBranchRead; 67/// Helper class for reading many branch entries at once to optimize throughput.; 68class TBulkBranchRead {; 69 ; 70 friend class ::TBranch;; 71 ; 72public:; 73 /// See TBranch::GetBulkEntries(Long64_t evt, TBuffer &user_buf);; 74 Int_t GetBulkEntries(Long64_t evt, TBuffer &user_buf);; 75 /// See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);; 76 Int_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);; 77 /// See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf, TBuffer *count_buf);; 78 Int_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf, TBuffer *count_buf);; 79 /// Return true if the branch can be read through the bulk interfaces.; 80 bool SupportsBulkRead() const;; 81 ; 82private:; 83 TBulkBranchRead(TBranch &parent); 84 : fParent(parent); 85 {}; 86 ; 87 TBranch &fParent;; 88};; 89}; 90}; 91}; 92 ; 93class TBranch : public TNamed, public TAttFill {; 94 using TIOFeatures = ROOT::TIOFeatures;; 95 ; 96protected:; 97 friend class TTreeCache;; 98 friend class TTreeCloner;; 99 friend class TTree;; 100 friend class TBranchElement;; 101 friend class ROOT::Experimental::Internal::TBulkBranchRead;; 102 ; 103 /// TBranch status bits; 104 enum EStatusBits {; 105 kDoNotProcess = ::kDoNotProcess, ///< Active bit for branches; 106 kIsClone = ::kIsClone, ///< To indicate a TBranchClones; 107 kBranchObject = ::kBranchObject, ///< B",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:20208,Integrability,interface,interfaces,20208,"onst char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TIOFeatures.hxx; TNamed.h; TObjArray.h; ROOT::Experimental::Internal::TBulkBranchReadHelper class for reading many branch entries at once to optimize throughput.Definition TBranch.h:68; ROOT::Experimental::Internal::TBulkBranchRead::TBulkBranchReadTBulkBranchRead(TBranch &parent)Definition TBranch.h:83; ROOT::Experimental::Internal::TBulkBranchRead::GetEntriesSerializedInt_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf)See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);.Definition TBranch.h:321; ROOT::Experimental::Internal::TBulkBranchRead::fParentTBranch & fParentDefinition TBranch.h:87; ROOT::Experimental::Internal::TBulkBranchRead::SupportsBulkReadbool SupportsBulkRead() constReturn true if the branch can be read through the bulk interfaces.Definition TBranch.h:323; ROOT::Experimental::Internal::TBulkBranchRead::GetBulkEntriesInt_t GetBulkEntries(Long64_t evt, TBuffer &user_buf)See TBranch::GetBulkEntries(Long64_t evt, TBuffer &user_buf);.Definition TBranch.h:320; ROOT::Internal::TBranchCacheInfoDefinition TBranchCacheInfo.h:35; ROOT::Internal::TBranchIMTHelperA helper class for managing IMT work during TTree:Fill operations.Definition TBranchIMTHelper.h:28; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; TAttFillFill Area Attributes class.Definition TAttFill.h:19; TBasketManages buffers for branches of a Tree.Definition TBasket.h:34; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::GetLeafvirtual TLeaf * GetLeaf(const char *name) constR",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:23217,Integrability,depend,depending,23217,"ree:...Definition TBranch.cxx:1894; TBranch::GetBasketImplTBasket * GetBasketImpl(Int_t basket, TBuffer *user_buffer)Return pointer to basket basketnumber in this Branch.Definition TBranch.cxx:1226; TBranch::fEntryOffsetLenInt_t fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers.Definition TBranch.h:119; TBranch::DeleteBasketsvirtual void DeleteBaskets(Option_t *option="""")Loop on all branch baskets.Definition TBranch.cxx:726; TBranch::GetBasketSeekvirtual Long64_t GetBasketSeek(Int_t basket) constReturn address of basket in the file.Definition TBranch.cxx:1302; TBranch::TBranchTBranch()Default constructor. Used for I/O by default.Definition TBranch.cxx:87; TBranch::GetAddressvirtual char * GetAddress() constDefinition TBranch.h:212; TBranch::SetCompressionSettingsvoid SetCompressionSettings(Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault)Set compression settings.Definition TBranch.cxx:2805; TBranch::GetIconNameconst char * GetIconName() const overrideReturn icon name depending on type of branch.Definition TBranch.cxx:1332; TBranch::BackFillInt_t BackFill()Loop on all leaves of this branch to back fill Basket buffer.Definition TBranch.cxx:680; TBranch::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TBranch.h:311; TBranch::~TBranch~TBranch() overrideDestructor.Definition TBranch.cxx:450; TBranch::GetCompressionLevelInt_t GetCompressionLevel() constDefinition TBranch.h:305; TBranch::GetCompressionAlgorithmInt_t GetCompressionAlgorithm() constDefinition TBranch.h:299; TBranch::fMaxBasketsInt_t fMaxBasketsMaximum number of Baskets so far.Definition TBranch.h:125; TBranch::fTotBytesLong64_t fTotBytesTotal number of bytes in all leaves before compression.Definition TBranch.h:136; TBranch::fTransientBufferTBuffer * fTransientBuffer! Pointer to the current transient buffer.Definition TBranch.h:151; TBranch::ReadBasketvirtual void ReadBasket(TBuffer &b)Loop on all leaves of this branch to read Basket buffer",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:30714,Integrability,interface,interface,30714,"oop.Definition TBranch.cxx:2479; TBranch::GetNleavesInt_t GetNleaves() constDefinition TBranch.h:249; TBranch::GetBulkEntriesInt_t GetBulkEntries(Long64_t, TBuffer &)Read a basket of events into the given buffer with byte swapping.Definition TBranch.cxx:1472; TBranch::SetFilevirtual void SetFile(TFile *file=nullptr)Set file where this branch writes/reads its buffers.Definition TBranch.cxx:2863; TBranch::GetEntryExportvirtual Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray *list, Int_t n)Read all leaves of an entry and export buffers to real objects in a TClonesArray list.Definition TBranch.cxx:1762; TBranch::SetAutoDeletevirtual void SetAutoDelete(bool autodel=true)Set the automatic delete bit.Definition TBranch.cxx:2716; TBranch::fZipBytesLong64_t fZipBytesTotal number of bytes in all leaves after compression.Definition TBranch.h:137; TBranch::fIOFeaturesTIOFeatures fIOFeaturesIO features for newly-created baskets.Definition TBranch.h:123; TBranch::Browsevoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::UpdateAddressvirtual void UpdateAddress()Definition TBranch.h:290; TBranch::GetOffsetInt_t GetOffset() constDefinition TBranch.h:235; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fBulkBulkObj fBulk! Helper for performing bulk IODefinition TBranch.h:153; TBranch::GetReadEntryLong64_t GetReadEntry() constDefinition TBranch.h:237; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in t",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:6067,Modifiability,variab,variable,6067,"n this branch; 136 Long64_t fTotBytes; ///< Total number of bytes in all leaves before compression; 137 Long64_t fZipBytes; ///< Total number of bytes in all leaves after compression; 138 TObjArray fBranches; ///< -> List of Branches of this branch; 139 TObjArray fLeaves; ///< -> List of leaves of this branch; 140 TObjArray fBaskets; ///< -> List of baskets of this branch; 141 Int_t *fBasketBytes; ///<[fMaxBaskets] Length of baskets on file; 142 Long64_t *fBasketEntry; ///<[fMaxBaskets] Table of first entry in each basket; 143 Long64_t *fBasketSeek; ///<[fMaxBaskets] Addresses of baskets on file; 144 TTree *fTree; ///<! Pointer to Tree header; 145 TBranch *fMother; ///<! Pointer to top-level parent branch in the tree.; 146 TBranch *fParent; ///<! Pointer to parent branch.; 147 char *fAddress; ///<! Address of 1st leaf (variable or object); 148 TDirectory *fDirectory; ///<! Pointer to directory where this branch buffers are stored; 149 TString fFileName; ///< Name of file where buffers are stored ("""" if in same file as Tree header); 150 TBuffer *fEntryBuffer; ///<! Buffer used to directly pass the content without streaming; 151 TBuffer *fTransientBuffer; ///<! Pointer to the current transient buffer.; 152 TList *fBrowsables; ///<! List of TVirtualBranchBrowsables used for Browse(); 153 BulkObj fBulk; ///<! Helper for performing bulk IO; 154 ; 155 bool fSkipZip; ///<! After being read, the buffer will not be unzipped.; 156 ; 157 using CacheInfo_t = ROOT::Internal::TBranchCacheInfo;; 158 CacheInfo_t fCacheInfo; ///<! Hold info about which basket are in the cache and if they have been retrieved from the cache.; 159 ; 160 typedef void (TBranch::*ReadLeaves_t)(TBuffer &b);; 161 ReadLeaves_t fReadLeaves; ///<! Pointer to the ReadLeaves implementation to use.; 162 typedef void (TBranch::*FillLeaves_t)(TBuffer &b);; 163 FillLeaves_t fFillLeaves; ///<! Pointer to the FillLeaves implementation to use.; 164 void ReadLeavesImpl(TBuffer &b);; 165 void ReadLeaves0Impl(TBuffer &b);",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:25676,Modifiability,variab,variable,25676,"Definition TBranch.h:160; TBranch::EStatusBitsEStatusBitsTBranch status bits.Definition TBranch.h:104; TBranch::kAutoDelete@ kAutoDeleteDefinition TBranch.h:110; TBranch::kDoNotUseBufferMap@ kDoNotUseBufferMapIf set, at least one of the entry in the branch will use the buffer's map of classname and objects.Definition TBranch.h:112; TBranch::kBranchAny@ kBranchAnyBranch is an object*.Definition TBranch.h:108; TBranch::kIsClone@ kIsCloneTo indicate a TBranchClones.Definition TBranch.h:106; TBranch::kBranchObject@ kBranchObjectBranch is a TObject*.Definition TBranch.h:107; TBranch::kDoNotProcess@ kDoNotProcessActive bit for branches.Definition TBranch.h:105; TBranch::fLeavesTObjArray fLeaves-> List of leaves of this branchDefinition TBranch.h:139; TBranch::GetBasketAndFirstInt_t GetBasketAndFirst(TBasket *&basket, Long64_t &first, TBuffer *user_buffer)A helper function to locate the correct basket - and its first entry.Definition TBranch.cxx:1353; TBranch::fAddresschar * fAddress! Address of 1st leaf (variable or object)Definition TBranch.h:147; TBranch::DropBasketsvirtual void DropBaskets(Option_t *option="""")Loop on all branch baskets.Definition TBranch.cxx:757; TBranch::GetListOfBranchesTObjArray * GetListOfBranches()Definition TBranch.h:246; TBranch::GetBrowsablesvirtual TList * GetBrowsables()Returns (and, if 0, creates) browsable objects for this branch See TVirtualBranchBrowsable::FillListO...Definition TBranch.cxx:1312; TBranch::fBrowsablesTList * fBrowsables! List of TVirtualBranchBrowsables used for Browse()Definition TBranch.h:152; TBranch::ReadLeavesImplvoid ReadLeavesImpl(TBuffer &b)Loop on all leaves of this branch to read Basket buffer.Definition TBranch.cxx:2461; TBranch::SetTreevirtual void SetTree(TTree *tree)Definition TBranch.h:287; TBranch::fOffsetInt_t fOffsetOffset of this branch.Definition TBranch.h:124; TBranch::fBasketEntryLong64_t * fBasketEntry[fMaxBaskets] Table of first entry in each basketDefinition TBranch.h:142; TBranch::GetEntriesSeriali",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:42800,Modifiability,inherit,inherited,42800,"f clone (identical) objects.Definition TClonesArray.h:29; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; int; nconst Int_t nDefinition legend1.C:16; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::RCompressionSetting::EAlgorithm::kUseGlobal@ kUseGlobalUse the global compression algorithm.Definition Compression.h:93; ROOT::RCompressionSetting::EAlgorithm::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:91; ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault@ kUseCompiledDefaultUse the compile-time default setting.Definition Compression.h:53; ROOT::RCompressionSetting::ELevel::kUseMin@ kUseMinCompression level reserved when we are not sure what to use (1 is for the fastest compression)Definition Compression.h:72. treetreeincTBranch.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:2243,Performance,optimiz,optimize,2243,"ranch description) //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TNamed.h""; 27#include ""TAttFill.h""; 28#include ""TObjArray.h""; 29#include ""TBranchCacheInfo.h""; 30#include ""TDataType.h""; 31#include ""Compression.h""; 32#include ""ROOT/TIOFeatures.hxx""; 33 ; 34class TTree;; 35class TBasket;; 36class TBranchElement;; 37class TLeaf;; 38class TBrowser;; 39class TDirectory;; 40class TFile;; 41class TClonesArray;; 42class TTreeCloner;; 43class TTreeCache;; 44 ; 45namespace ROOT {; 46namespace Experimental {; 47namespace Internal {; 48class TBulkBranchRead;; 49}; 50}; 51namespace Internal {; 52class TBranchIMTHelper; ///< A helper class for managing IMT work during TTree:Fill operations.; 53}; 54}; 55 ; 56const Int_t kDoNotProcess = BIT(10); // Active bit for branches; 57const Int_t kIsClone = BIT(11); // to indicate a TBranchClones; 58const Int_t kBranchObject = BIT(12); // branch is a TObject*; 59const Int_t kBranchAny = BIT(17); // branch is an object*; 60const Int_t kMapObject = kBranchObject | kBranchAny;; 61 ; 62namespace ROOT {; 63namespace Experimental {; 64namespace Internal {; 65 ; 66///\class TBulkBranchRead; 67/// Helper class for reading many branch entries at once to optimize throughput.; 68class TBulkBranchRead {; 69 ; 70 friend class ::TBranch;; 71 ; 72public:; 73 /// See TBranch::GetBulkEntries(Long64_t evt, TBuffer &user_buf);; 74 Int_t GetBulkEntries(Long64_t evt, TBuffer &user_buf);; 75 /// See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);; 76 Int_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);; 77 /// See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf, TBuffer *count_buf);; 78 Int_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf, TBuffer *count_buf);; 79 /// Return true if the branch can be read through the bulk interfaces.; 80 bool SupportsBulkRead() const;; 81 ; 82private:; 83 TBulkBranchRead(TBranch &parent); 84 : fParent(parent); 85 {}; 86 ; 87 TBranch ",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:2252,Performance,throughput,throughput,2252,"ranch description) //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TNamed.h""; 27#include ""TAttFill.h""; 28#include ""TObjArray.h""; 29#include ""TBranchCacheInfo.h""; 30#include ""TDataType.h""; 31#include ""Compression.h""; 32#include ""ROOT/TIOFeatures.hxx""; 33 ; 34class TTree;; 35class TBasket;; 36class TBranchElement;; 37class TLeaf;; 38class TBrowser;; 39class TDirectory;; 40class TFile;; 41class TClonesArray;; 42class TTreeCloner;; 43class TTreeCache;; 44 ; 45namespace ROOT {; 46namespace Experimental {; 47namespace Internal {; 48class TBulkBranchRead;; 49}; 50}; 51namespace Internal {; 52class TBranchIMTHelper; ///< A helper class for managing IMT work during TTree:Fill operations.; 53}; 54}; 55 ; 56const Int_t kDoNotProcess = BIT(10); // Active bit for branches; 57const Int_t kIsClone = BIT(11); // to indicate a TBranchClones; 58const Int_t kBranchObject = BIT(12); // branch is a TObject*; 59const Int_t kBranchAny = BIT(17); // branch is an object*; 60const Int_t kMapObject = kBranchObject | kBranchAny;; 61 ; 62namespace ROOT {; 63namespace Experimental {; 64namespace Internal {; 65 ; 66///\class TBulkBranchRead; 67/// Helper class for reading many branch entries at once to optimize throughput.; 68class TBulkBranchRead {; 69 ; 70 friend class ::TBranch;; 71 ; 72public:; 73 /// See TBranch::GetBulkEntries(Long64_t evt, TBuffer &user_buf);; 74 Int_t GetBulkEntries(Long64_t evt, TBuffer &user_buf);; 75 /// See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);; 76 Int_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);; 77 /// See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf, TBuffer *count_buf);; 78 Int_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf, TBuffer *count_buf);; 79 /// Return true if the branch can be read through the bulk interfaces.; 80 bool SupportsBulkRead() const;; 81 ; 82private:; 83 TBulkBranchRead(TBranch &parent); 84 : fParent(parent); 85 {}; 86 ; 87 TBranch ",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:6574,Performance,perform,performing,6574,"askets; ///< -> List of baskets of this branch; 141 Int_t *fBasketBytes; ///<[fMaxBaskets] Length of baskets on file; 142 Long64_t *fBasketEntry; ///<[fMaxBaskets] Table of first entry in each basket; 143 Long64_t *fBasketSeek; ///<[fMaxBaskets] Addresses of baskets on file; 144 TTree *fTree; ///<! Pointer to Tree header; 145 TBranch *fMother; ///<! Pointer to top-level parent branch in the tree.; 146 TBranch *fParent; ///<! Pointer to parent branch.; 147 char *fAddress; ///<! Address of 1st leaf (variable or object); 148 TDirectory *fDirectory; ///<! Pointer to directory where this branch buffers are stored; 149 TString fFileName; ///< Name of file where buffers are stored ("""" if in same file as Tree header); 150 TBuffer *fEntryBuffer; ///<! Buffer used to directly pass the content without streaming; 151 TBuffer *fTransientBuffer; ///<! Pointer to the current transient buffer.; 152 TList *fBrowsables; ///<! List of TVirtualBranchBrowsables used for Browse(); 153 BulkObj fBulk; ///<! Helper for performing bulk IO; 154 ; 155 bool fSkipZip; ///<! After being read, the buffer will not be unzipped.; 156 ; 157 using CacheInfo_t = ROOT::Internal::TBranchCacheInfo;; 158 CacheInfo_t fCacheInfo; ///<! Hold info about which basket are in the cache and if they have been retrieved from the cache.; 159 ; 160 typedef void (TBranch::*ReadLeaves_t)(TBuffer &b);; 161 ReadLeaves_t fReadLeaves; ///<! Pointer to the ReadLeaves implementation to use.; 162 typedef void (TBranch::*FillLeaves_t)(TBuffer &b);; 163 FillLeaves_t fFillLeaves; ///<! Pointer to the FillLeaves implementation to use.; 164 void ReadLeavesImpl(TBuffer &b);; 165 void ReadLeaves0Impl(TBuffer &b);; 166 void ReadLeaves1Impl(TBuffer &b);; 167 void ReadLeaves2Impl(TBuffer &b);; 168 void FillLeavesImpl(TBuffer &b);; 169 ; 170 void SetSkipZip(bool skip = true) { fSkipZip = skip; }; 171 void Init(const char *name, const char *leaflist, Int_t compress);; 172 ; 173 TBasket *GetFreshBasket(Int_t basketnumber, TBuffer *user_buffe",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:6816,Performance,cache,cache,6816,"g64_t *fBasketSeek; ///<[fMaxBaskets] Addresses of baskets on file; 144 TTree *fTree; ///<! Pointer to Tree header; 145 TBranch *fMother; ///<! Pointer to top-level parent branch in the tree.; 146 TBranch *fParent; ///<! Pointer to parent branch.; 147 char *fAddress; ///<! Address of 1st leaf (variable or object); 148 TDirectory *fDirectory; ///<! Pointer to directory where this branch buffers are stored; 149 TString fFileName; ///< Name of file where buffers are stored ("""" if in same file as Tree header); 150 TBuffer *fEntryBuffer; ///<! Buffer used to directly pass the content without streaming; 151 TBuffer *fTransientBuffer; ///<! Pointer to the current transient buffer.; 152 TList *fBrowsables; ///<! List of TVirtualBranchBrowsables used for Browse(); 153 BulkObj fBulk; ///<! Helper for performing bulk IO; 154 ; 155 bool fSkipZip; ///<! After being read, the buffer will not be unzipped.; 156 ; 157 using CacheInfo_t = ROOT::Internal::TBranchCacheInfo;; 158 CacheInfo_t fCacheInfo; ///<! Hold info about which basket are in the cache and if they have been retrieved from the cache.; 159 ; 160 typedef void (TBranch::*ReadLeaves_t)(TBuffer &b);; 161 ReadLeaves_t fReadLeaves; ///<! Pointer to the ReadLeaves implementation to use.; 162 typedef void (TBranch::*FillLeaves_t)(TBuffer &b);; 163 FillLeaves_t fFillLeaves; ///<! Pointer to the FillLeaves implementation to use.; 164 void ReadLeavesImpl(TBuffer &b);; 165 void ReadLeaves0Impl(TBuffer &b);; 166 void ReadLeaves1Impl(TBuffer &b);; 167 void ReadLeaves2Impl(TBuffer &b);; 168 void FillLeavesImpl(TBuffer &b);; 169 ; 170 void SetSkipZip(bool skip = true) { fSkipZip = skip; }; 171 void Init(const char *name, const char *leaflist, Int_t compress);; 172 ; 173 TBasket *GetFreshBasket(Int_t basketnumber, TBuffer *user_buffer);; 174 TBasket *GetFreshCluster(TBuffer *user_buffer);; 175 Int_t WriteBasket(TBasket* basket, Int_t where) { return WriteBasketImpl(basket, where, nullptr); }; 176 ; 177 TString GetRealFileName() const;; ",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:6863,Performance,cache,cache,6863,"g64_t *fBasketSeek; ///<[fMaxBaskets] Addresses of baskets on file; 144 TTree *fTree; ///<! Pointer to Tree header; 145 TBranch *fMother; ///<! Pointer to top-level parent branch in the tree.; 146 TBranch *fParent; ///<! Pointer to parent branch.; 147 char *fAddress; ///<! Address of 1st leaf (variable or object); 148 TDirectory *fDirectory; ///<! Pointer to directory where this branch buffers are stored; 149 TString fFileName; ///< Name of file where buffers are stored ("""" if in same file as Tree header); 150 TBuffer *fEntryBuffer; ///<! Buffer used to directly pass the content without streaming; 151 TBuffer *fTransientBuffer; ///<! Pointer to the current transient buffer.; 152 TList *fBrowsables; ///<! List of TVirtualBranchBrowsables used for Browse(); 153 BulkObj fBulk; ///<! Helper for performing bulk IO; 154 ; 155 bool fSkipZip; ///<! After being read, the buffer will not be unzipped.; 156 ; 157 using CacheInfo_t = ROOT::Internal::TBranchCacheInfo;; 158 CacheInfo_t fCacheInfo; ///<! Hold info about which basket are in the cache and if they have been retrieved from the cache.; 159 ; 160 typedef void (TBranch::*ReadLeaves_t)(TBuffer &b);; 161 ReadLeaves_t fReadLeaves; ///<! Pointer to the ReadLeaves implementation to use.; 162 typedef void (TBranch::*FillLeaves_t)(TBuffer &b);; 163 FillLeaves_t fFillLeaves; ///<! Pointer to the FillLeaves implementation to use.; 164 void ReadLeavesImpl(TBuffer &b);; 165 void ReadLeaves0Impl(TBuffer &b);; 166 void ReadLeaves1Impl(TBuffer &b);; 167 void ReadLeaves2Impl(TBuffer &b);; 168 void FillLeavesImpl(TBuffer &b);; 169 ; 170 void SetSkipZip(bool skip = true) { fSkipZip = skip; }; 171 void Init(const char *name, const char *leaflist, Int_t compress);; 172 ; 173 TBasket *GetFreshBasket(Int_t basketnumber, TBuffer *user_buffer);; 174 TBasket *GetFreshCluster(TBuffer *user_buffer);; 175 Int_t WriteBasket(TBasket* basket, Int_t where) { return WriteBasketImpl(basket, where, nullptr); }; 176 ; 177 TString GetRealFileName() const;; ",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:19581,Performance,optimiz,optimize,19581,"GWin32VirtualXProxy.cxx:68; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TIOFeatures.hxx; TNamed.h; TObjArray.h; ROOT::Experimental::Internal::TBulkBranchReadHelper class for reading many branch entries at once to optimize throughput.Definition TBranch.h:68; ROOT::Experimental::Internal::TBulkBranchRead::TBulkBranchReadTBulkBranchRead(TBranch &parent)Definition TBranch.h:83; ROOT::Experimental::Internal::TBulkBranchRead::GetEntriesSerializedInt_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf)See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);.Definition TBranch.h:321; ROOT::Experimental::Internal::TBulkBranchRead::fParentTBranch & fParentDefinition TBranch.h:87; ROOT::Experimental::Internal::TBulkBranchRead::SupportsBulkReadbool SupportsBulkRead() constReturn true if the branch can be read through the bulk interfaces.Definition TBranch.h:323; ROOT::Experimental::Internal::TBulkBranchRead::GetBulkEntriesInt_t GetBulkEntries(Long64_t evt, TBuffer &user_buf)See TBranch::GetBulkEntries(Long64_t evt, TBuffer &user_buf);.Definition TBranch.h:320; ROOT::Internal::TBranchCacheInfoDefinition TBranchCacheInfo.h:35; ROOT::Internal::TBranchIMT",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:19590,Performance,throughput,throughput,19590,"GWin32VirtualXProxy.cxx:68; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TIOFeatures.hxx; TNamed.h; TObjArray.h; ROOT::Experimental::Internal::TBulkBranchReadHelper class for reading many branch entries at once to optimize throughput.Definition TBranch.h:68; ROOT::Experimental::Internal::TBulkBranchRead::TBulkBranchReadTBulkBranchRead(TBranch &parent)Definition TBranch.h:83; ROOT::Experimental::Internal::TBulkBranchRead::GetEntriesSerializedInt_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf)See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);.Definition TBranch.h:321; ROOT::Experimental::Internal::TBulkBranchRead::fParentTBranch & fParentDefinition TBranch.h:87; ROOT::Experimental::Internal::TBulkBranchRead::SupportsBulkReadbool SupportsBulkRead() constReturn true if the branch can be read through the bulk interfaces.Definition TBranch.h:323; ROOT::Experimental::Internal::TBulkBranchRead::GetBulkEntriesInt_t GetBulkEntries(Long64_t evt, TBuffer &user_buf)See TBranch::GetBulkEntries(Long64_t evt, TBuffer &user_buf);.Definition TBranch.h:320; ROOT::Internal::TBranchCacheInfoDefinition TBranchCacheInfo.h:35; ROOT::Internal::TBranchIMT",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:31488,Performance,perform,performing,31488,"er of bytes in all leaves after compression.Definition TBranch.h:137; TBranch::fIOFeaturesTIOFeatures fIOFeaturesIO features for newly-created baskets.Definition TBranch.h:123; TBranch::Browsevoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::UpdateAddressvirtual void UpdateAddress()Definition TBranch.h:290; TBranch::GetOffsetInt_t GetOffset() constDefinition TBranch.h:235; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fBulkBulkObj fBulk! Helper for performing bulk IODefinition TBranch.h:153; TBranch::GetReadEntryLong64_t GetReadEntry() constDefinition TBranch.h:237; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, ROOT::Internal::TBranchIMTHelper *)Write the current basket to disk and return the number of bytes written to the file.Definition TBranch.cxx:3202; TBr",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:31691,Performance,cache,cache,31691,"evoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::UpdateAddressvirtual void UpdateAddress()Definition TBranch.h:290; TBranch::GetOffsetInt_t GetOffset() constDefinition TBranch.h:235; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fBulkBulkObj fBulk! Helper for performing bulk IODefinition TBranch.h:153; TBranch::GetReadEntryLong64_t GetReadEntry() constDefinition TBranch.h:237; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, ROOT::Internal::TBranchIMTHelper *)Write the current basket to disk and return the number of bytes written to the file.Definition TBranch.cxx:3202; TBranch::UpdateFilevirtual void UpdateFile()Refresh the value of fDirectory (i.e.Definition TBranch.cxx:3304; TBranch::SetSkipZipvoid SetSkipZip(bool skip=true)Definition TBranch.h:170; TBranch:",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:31738,Performance,cache,cache,31738,"evoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::UpdateAddressvirtual void UpdateAddress()Definition TBranch.h:290; TBranch::GetOffsetInt_t GetOffset() constDefinition TBranch.h:235; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fBulkBulkObj fBulk! Helper for performing bulk IODefinition TBranch.h:153; TBranch::GetReadEntryLong64_t GetReadEntry() constDefinition TBranch.h:237; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, ROOT::Internal::TBranchIMTHelper *)Write the current basket to disk and return the number of bytes written to the file.Definition TBranch.cxx:3202; TBranch::UpdateFilevirtual void UpdateFile()Refresh the value of fDirectory (i.e.Definition TBranch.cxx:3304; TBranch::SetSkipZipvoid SetSkipZip(bool skip=true)Definition TBranch.h:170; TBranch:",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:35067,Performance,cache,cached,35067,"tProcess.Definition TBranch.cxx:2947; TBranch::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Reset a Branch.Definition TBranch.cxx:2598; TBranch::ReadLeaves0Implvoid ReadLeaves0Impl(TBuffer &b)Read zero leaves without the overhead of a loop.Definition TBranch.cxx:2472; TBranch::SupportsBulkReadbool SupportsBulkRead() constReturns true if this branch supports bulk IO, false otherwise.Definition TBranch.cxx:1431; TBranch::ResetReadEntryvirtual void ResetReadEntry()Definition TBranch.h:269; TBranch::GetRealFileNameTString GetRealFileName() constGet real file name.Definition TBranch.cxx:2068; TBranch::FindBranchvirtual TBranch * FindBranch(const char *name)Find the immediate sub-branch with passed name.Definition TBranch.cxx:1035; TBranch::TBranchTBranch(const TBranch &)=delete; TBranch::fDirectoryTDirectory * fDirectory! Pointer to directory where this branch buffers are storedDefinition TBranch.h:148; TBranch::PrintCacheInfovoid PrintCacheInfo() constPrint the information we have about which basket is currently cached and whether they have been 'used...Definition TBranch.cxx:2445; TBranch::fBasketsTObjArray fBaskets-> List of baskets of this branchDefinition TBranch.h:140; TBranch::SetAddressImplvirtual void SetAddressImpl(void *addr, bool)Definition TBranch.h:179; TBranch::LoadBasketsvirtual Int_t LoadBaskets()Baskets associated to this branch are forced to be in memory.Definition TBranch.cxx:2309; TBranch::SetIOFeaturesvoid SetIOFeatures(TIOFeatures &features)Definition TBranch.h:283; TBranch::fMotherTBranch * fMother! Pointer to top-level parent branch in the tree.Definition TBranch.h:145; TBranch::GetTotBytesLong64_t GetTotBytes(Option_t *option="""") constReturn total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub...Definition TBranch.cxx:2220; TBranch::fParentTBranch * fParent! Pointer to parent branch.Definition TBranch.h:146; TBranch::WriteBasketInt_t WriteBasket(TBasket *basket, Int_t where)Definition TBra",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:42047,Performance,cache,cache,42047,"inition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; int; nconst Int_t nDefinition legend1.C:16; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::RCompressionSetting::EAlgorithm::kUseGlobal@ kUseGlobalUse the global compression algorithm.Definition Compression.h:93; ROOT::RCompressionSetting::EAlgorithm::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:91; ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault@ kUseCompiledDefaultUse the compile-time default setting.Definition Compression.h:53; ROOT::RCompressionSetting::ELevel::kUseMin@ kUseMinCompression ",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBranch_8h_source.html:31981,Safety,avoid,avoid,31981,"nch.cxx:2763; TBranch::UpdateAddressvirtual void UpdateAddress()Definition TBranch.h:290; TBranch::GetOffsetInt_t GetOffset() constDefinition TBranch.h:235; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fBulkBulkObj fBulk! Helper for performing bulk IODefinition TBranch.h:153; TBranch::GetReadEntryLong64_t GetReadEntry() constDefinition TBranch.h:237; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, ROOT::Internal::TBranchIMTHelper *)Write the current basket to disk and return the number of bytes written to the file.Definition TBranch.cxx:3202; TBranch::UpdateFilevirtual void UpdateFile()Refresh the value of fDirectory (i.e.Definition TBranch.cxx:3304; TBranch::SetSkipZipvoid SetSkipZip(bool skip=true)Definition TBranch.h:170; TBranch::GetReadBasketInt_t GetReadBasket() constDefinition TBranch.h:236; TBranch::fBasketBytesInt_t * fBasketBytes[fMaxBaskets] Length of baskets on fileDefinition TBranch.h:141; TBranch::fNextBasketEntryLong64_t fNextBasketEntry! Next entry that will re",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:22782,Availability,error,error,22782,"s).Definition TClass.h:517; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TGuiFactory::CreateBrowserImpvirtual TBrowserImp * CreateBrowserImp(TBrowser *b, const char *title, UInt_t width, UInt_t height, Option_t *opt="""")Create a batch version of TBrowserImp.Definition TGuiFactory.cxx:92; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TStringBasic string class.Definition TString.h:139; TStyle::GetScreenFactorFloat_t GetScreenFactor() constDefinition TStyle.h:256; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; bool; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17. coreguisrcTBrowser.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:2422,Integrability,wrap,wrap,2422,"4/00**; 25 ; 26TBrowser invokes by default the Web-based %ROOT file browser [RBrowser](ROOT::RBrowser); 27To change this behaviour, and invoke the standard TBrowser, one should put; 28the following directive in the `.rootrc` file:; 29```; 30Browser.Name: TRootBrowser; 31```; 32*/; 33 ; 34#include ""TBrowser.h""; 35#include ""TGuiFactory.h""; 36#include ""TROOT.h""; 37#include ""TEnv.h""; 38#include ""TSystem.h""; 39#include ""TStyle.h""; 40#include ""TTimer.h""; 41#include ""TContextMenu.h""; 42#include ""TInterpreter.h""; 43#include ""TVirtualMutex.h""; 44#include ""TClass.h""; 45#include ""TApplication.h""; 46 ; 47/** \class TBrowserTimer; 48Called whenever timer times out.; 49*/; 50 ; 51class TBrowserTimer : public TTimer {; 52 ; 53protected:; 54 TBrowser *fBrowser{nullptr};; 55 Bool_t fActivate{kFALSE};; 56 ; 57public:; 58 TBrowserTimer(TBrowser *b, Long_t ms = 1000) : TTimer(ms, kTRUE), fBrowser(b), fActivate(kFALSE) {}; 59 Bool_t Notify() override; 60 {; 61 if (fBrowser) {; 62 if (fBrowser->GetRefreshFlag()) {; 63 fBrowser->SetRefreshFlag(kFALSE);; 64 fActivate = kTRUE;; 65 } else if (fActivate) {; 66 fActivate = kFALSE;; 67 fBrowser->Refresh();; 68 }; 69 }; 70 Reset();; 71 ; 72 return kFALSE;; 73 }; 74};; 75 ; 76/** \class TBrowserObject; 77This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system.; 78*/; 79 ; 80class TBrowserObject : public TNamed {; 81 ; 82public:; 83 TBrowserObject(void *obj, TClass *cl, const char *brname); 84 : TNamed(brname, cl ? cl->GetName() : """"), fObj(obj), fClass(cl); 85 {; 86 if (!cl); 87 Fatal(""Constructor"", ""Class parameter should not be null"");; 88 SetBit(kCanDelete);; 89 }; 90 ; 91 ~TBrowserObject() {}; 92 ; 93 void Browse(TBrowser *b) override { fClass->Browse(fObj, b); }; 94 Bool_t IsFolder() const override { return fClass->IsFolder(fObj); }; 95 TClass *IsA() const override { return fClass; }; 96 ; 97private:; 98 void *fObj; ///<! pointer to the foreign object; 99 TClass *fClass; ///<! pointer to class of the f",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:2456,Integrability,inject,inject,2456,"4/00**; 25 ; 26TBrowser invokes by default the Web-based %ROOT file browser [RBrowser](ROOT::RBrowser); 27To change this behaviour, and invoke the standard TBrowser, one should put; 28the following directive in the `.rootrc` file:; 29```; 30Browser.Name: TRootBrowser; 31```; 32*/; 33 ; 34#include ""TBrowser.h""; 35#include ""TGuiFactory.h""; 36#include ""TROOT.h""; 37#include ""TEnv.h""; 38#include ""TSystem.h""; 39#include ""TStyle.h""; 40#include ""TTimer.h""; 41#include ""TContextMenu.h""; 42#include ""TInterpreter.h""; 43#include ""TVirtualMutex.h""; 44#include ""TClass.h""; 45#include ""TApplication.h""; 46 ; 47/** \class TBrowserTimer; 48Called whenever timer times out.; 49*/; 50 ; 51class TBrowserTimer : public TTimer {; 52 ; 53protected:; 54 TBrowser *fBrowser{nullptr};; 55 Bool_t fActivate{kFALSE};; 56 ; 57public:; 58 TBrowserTimer(TBrowser *b, Long_t ms = 1000) : TTimer(ms, kTRUE), fBrowser(b), fActivate(kFALSE) {}; 59 Bool_t Notify() override; 60 {; 61 if (fBrowser) {; 62 if (fBrowser->GetRefreshFlag()) {; 63 fBrowser->SetRefreshFlag(kFALSE);; 64 fActivate = kTRUE;; 65 } else if (fActivate) {; 66 fActivate = kFALSE;; 67 fBrowser->Refresh();; 68 }; 69 }; 70 Reset();; 71 ; 72 return kFALSE;; 73 }; 74};; 75 ; 76/** \class TBrowserObject; 77This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system.; 78*/; 79 ; 80class TBrowserObject : public TNamed {; 81 ; 82public:; 83 TBrowserObject(void *obj, TClass *cl, const char *brname); 84 : TNamed(brname, cl ? cl->GetName() : """"), fObj(obj), fClass(cl); 85 {; 86 if (!cl); 87 Fatal(""Constructor"", ""Class parameter should not be null"");; 88 SetBit(kCanDelete);; 89 }; 90 ; 91 ~TBrowserObject() {}; 92 ; 93 void Browse(TBrowser *b) override { fClass->Browse(fObj, b); }; 94 Bool_t IsFolder() const override { return fClass->IsFolder(fObj); }; 95 TClass *IsA() const override { return fClass; }; 96 ; 97private:; 98 void *fObj; ///<! pointer to the foreign object; 99 TClass *fClass; ///<! pointer to class of the f",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:4408,Integrability,depend,depending,4408,"bs are loaded; 106 ; 107Bool_t TBrowser::InitGraphics(); 108{; 109 // Make sure the application environment exists. It is need for graphics; 110 // (colors are initialized in the TApplication ctor).; 111 if (!gApplication); 112 TApplication::CreateApplication();; 113 // make sure that the Gpad and GUI libs are loaded; 114 TApplication::NeedGraphicsLibs();; 115 ; 116 TString hname = gEnv->GetValue(""Browser.Name"", ""TRootBrowserLite"");; 117 ; 118 Bool_t isweb = gROOT->IsWebDisplay() || (hname == ""ROOT::RWebBrowserImp"");; 119 ; 120 if (gApplication); 121 gApplication->InitializeGraphics(isweb);; 122 ; 123 if (!gROOT->IsBatch() || (isweb && !gROOT->IsWebDisplayBatch())); 124 return kTRUE;; 125 ; 126 Warning(""TBrowser"", ""The ROOT browser cannot run in batch mode"");; 127 return kFALSE;; 128}; 129 ; 130////////////////////////////////////////////////////////////////////////////////; 131/// Create a new browser with a name, title. Width and height are by; 132/// default set to 640x400 and (optionally) adjusted by the screen factor; 133/// (depending on Rint.Canvas.UseScreenFactor to be true or false, default; 134/// is true).; 135 ; 136TBrowser::TBrowser(const char *name, const char *title, TBrowserImp *extimp, Option_t *opt); 137 : TNamed(name, title), fImp(extimp); 138{; 139 if (!InitGraphics()); 140 return;; 141 if (TClass::IsCallingNew() != TClass::kRealNew) {; 142 fImp = nullptr;; 143 } else {; 144 Float_t cx = gStyle->GetScreenFactor();; 145 UInt_t w = UInt_t(cx*800);; 146 UInt_t h = UInt_t(cx*500);; 147 if (!fImp); 148 fImp = gGuiFactory->CreateBrowserImp(this, title, w, h, opt);; 149 Create();; 150 }; 151}; 152 ; 153////////////////////////////////////////////////////////////////////////////////; 154/// Create a new browser with a name, title, width and height.; 155 ; 156TBrowser::TBrowser(const char *name, const char *title, UInt_t width,; 157 UInt_t height, TBrowserImp *extimp, Option_t *opt); 158 : TNamed(name, title), fImp(extimp); 159{; 160 if (!InitGraphics());",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:16265,Integrability,protocol,protocol,16265,"t heightDefinition TGWin32VirtualXProxy.cxx:164; namechar name[80]Definition TGX11.cxx:110; TGuiFactory.h; gGuiFactoryR__EXTERN TGuiFactory * gGuiFactoryDefinition TGuiFactory.h:66; TInterpreter.h; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTimer.h; TVirtualMutex.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TApplication::InitializeGraphicsvoid InitializeGraphics(Bool_t only_web=kFALSE)Initialize the graphics environment.Definition TApplication.cxx:244; TApplication::CreateApplicationstatic void CreateApplication()Static function used to create a default application environment.Definition TApplication.cxx:1975; TApplication::NeedGraphicsLibsstatic void NeedGraphicsLibs()Static method.Definition TApplication.cxx:235; TBrowserImpABC describing GUI independent browser implementation protocol.Definition TBrowserImp.h:29; TBrowserImp::ExecuteDefaultActionvirtual void ExecuteDefaultAction(TObject *)Definition TBrowserImp.h:51; TBrowserImp::CloseTabsvirtual void CloseTabs()Definition TBrowserImp.h:50; TBrowserImp::RemoveCheckBoxvirtual void RemoveCheckBox(TObject *)Definition TBrowserImp.h:47; TBrowserImp::AddCheckBoxvirtual void AddCheckBox(TObject *, Bool_t=kFALSE)Definition TBrowserImp.h:45; TBrowserImp::BrowseObjvirtual void BrowseObj(TObject *)Definition TBrowserImp.h:48; TBrowserImp::RecursiveRemovevirtual void RecursiveRemove(TObject *)Definition TBrowserImp.h:53; TBrowserImp::Refreshvirtual void Refresh(Bool_t=kFALSE)Definition TBrowserImp.h:54; TBrowserImp::CheckObjectItemvirtual void CheckObjectItem(TObject *, Bool_t=kFALSE)Definition TBrowserImp.h:46; TBrowserImp::Addvirtual void Add(TObject *, const char *, Int_t)Definition TBrowserImp.h:44; TBrowserObjectThis class is designed to wrap a Foreign object in order to inject it ",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:17189,Integrability,wrap,wrap,17189,"BrowserImpABC describing GUI independent browser implementation protocol.Definition TBrowserImp.h:29; TBrowserImp::ExecuteDefaultActionvirtual void ExecuteDefaultAction(TObject *)Definition TBrowserImp.h:51; TBrowserImp::CloseTabsvirtual void CloseTabs()Definition TBrowserImp.h:50; TBrowserImp::RemoveCheckBoxvirtual void RemoveCheckBox(TObject *)Definition TBrowserImp.h:47; TBrowserImp::AddCheckBoxvirtual void AddCheckBox(TObject *, Bool_t=kFALSE)Definition TBrowserImp.h:45; TBrowserImp::BrowseObjvirtual void BrowseObj(TObject *)Definition TBrowserImp.h:48; TBrowserImp::RecursiveRemovevirtual void RecursiveRemove(TObject *)Definition TBrowserImp.h:53; TBrowserImp::Refreshvirtual void Refresh(Bool_t=kFALSE)Definition TBrowserImp.h:54; TBrowserImp::CheckObjectItemvirtual void CheckObjectItem(TObject *, Bool_t=kFALSE)Definition TBrowserImp.h:46; TBrowserImp::Addvirtual void Add(TObject *, const char *, Int_t)Definition TBrowserImp.h:44; TBrowserObjectThis class is designed to wrap a Foreign object in order to inject it into the Browse sub-system.Definition TBrowser.cxx:80; TBrowserObject::TBrowserObjectTBrowserObject(void *obj, TClass *cl, const char *brname)Definition TBrowser.cxx:83; TBrowserObject::IsATClass * IsA() const overrideDefinition TBrowser.cxx:95; TBrowserObject::~TBrowserObject~TBrowserObject()Definition TBrowser.cxx:91; TBrowserObject::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TBrowser.cxx:94; TBrowserObject::fClassTClass * fClass! pointer to class of the foreign objectDefinition TBrowser.cxx:99; TBrowserObject::fObjvoid * fObj! pointer to the foreign objectDefinition TBrowser.cxx:98; TBrowserObject::Browsevoid Browse(TBrowser *b) overrideBrowse object. May be overridden for another default action.Definition TBrowser.cxx:93; TBrowserTimerCalled whenever timer times out.Definition TBrowser.cxx:51; TBrowserTimer::NotifyBool_t Notify() overrideThis me",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:17223,Integrability,inject,inject,17223,"BrowserImpABC describing GUI independent browser implementation protocol.Definition TBrowserImp.h:29; TBrowserImp::ExecuteDefaultActionvirtual void ExecuteDefaultAction(TObject *)Definition TBrowserImp.h:51; TBrowserImp::CloseTabsvirtual void CloseTabs()Definition TBrowserImp.h:50; TBrowserImp::RemoveCheckBoxvirtual void RemoveCheckBox(TObject *)Definition TBrowserImp.h:47; TBrowserImp::AddCheckBoxvirtual void AddCheckBox(TObject *, Bool_t=kFALSE)Definition TBrowserImp.h:45; TBrowserImp::BrowseObjvirtual void BrowseObj(TObject *)Definition TBrowserImp.h:48; TBrowserImp::RecursiveRemovevirtual void RecursiveRemove(TObject *)Definition TBrowserImp.h:53; TBrowserImp::Refreshvirtual void Refresh(Bool_t=kFALSE)Definition TBrowserImp.h:54; TBrowserImp::CheckObjectItemvirtual void CheckObjectItem(TObject *, Bool_t=kFALSE)Definition TBrowserImp.h:46; TBrowserImp::Addvirtual void Add(TObject *, const char *, Int_t)Definition TBrowserImp.h:44; TBrowserObjectThis class is designed to wrap a Foreign object in order to inject it into the Browse sub-system.Definition TBrowser.cxx:80; TBrowserObject::TBrowserObjectTBrowserObject(void *obj, TClass *cl, const char *brname)Definition TBrowser.cxx:83; TBrowserObject::IsATClass * IsA() const overrideDefinition TBrowser.cxx:95; TBrowserObject::~TBrowserObject~TBrowserObject()Definition TBrowser.cxx:91; TBrowserObject::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TBrowser.cxx:94; TBrowserObject::fClassTClass * fClass! pointer to class of the foreign objectDefinition TBrowser.cxx:99; TBrowserObject::fObjvoid * fObj! pointer to the foreign objectDefinition TBrowser.cxx:98; TBrowserObject::Browsevoid Browse(TBrowser *b) overrideBrowse object. May be overridden for another default action.Definition TBrowser.cxx:93; TBrowserTimerCalled whenever timer times out.Definition TBrowser.cxx:51; TBrowserTimer::NotifyBool_t Notify() overrideThis me",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:21709,Integrability,interface,interface,21709,"th name to browser.Definition TBrowser.cxx:303; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2077; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::IsCallingNewstatic ENewType IsCallingNew()Static method returning the defConstructor flag passed to TClass::New().Definition TClass.cxx:5969; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TGuiFactory::CreateBrowserImpvirtual TBrowserImp * CreateBrowserImp(TBrowser *b, const char *title, UInt_t width, UInt_t height, Option_t *opt="""")Create a batch version of TBrowserImp.Definition TGuiFactory.cxx:92; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual ",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:22485,Integrability,message,message,22485,"ition TClass.cxx:6005; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TGuiFactory::CreateBrowserImpvirtual TBrowserImp * CreateBrowserImp(TBrowser *b, const char *title, UInt_t width, UInt_t height, Option_t *opt="""")Create a batch version of TBrowserImp.Definition TGuiFactory.cxx:92; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TStringBasic string class.Definition TString.h:139; TStyle::GetScreenFactorFloat_t GetScreenFactor() constDefinition TStyle.h:256; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; bool; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; ",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:22788,Integrability,message,message,22788,"s).Definition TClass.h:517; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TGuiFactory::CreateBrowserImpvirtual TBrowserImp * CreateBrowserImp(TBrowser *b, const char *title, UInt_t width, UInt_t height, Option_t *opt="""")Create a batch version of TBrowserImp.Definition TGuiFactory.cxx:92; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TStringBasic string class.Definition TString.h:139; TStyle::GetScreenFactorFloat_t GetScreenFactor() constDefinition TStyle.h:256; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; bool; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17. coreguisrcTBrowser.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:21451,Modifiability,inherit,inherits,21451,"ion is specified in the $HOME/.root....Definition TBrowser.cxx:399; TBrowser::AddCheckBoxvoid AddCheckBox(TObject *obj, Bool_t check=kFALSE)Add checkbox for this item.Definition TBrowser.cxx:336; TBrowser::Addvoid Add(TObject *obj, const char *name=nullptr, Int_t check=-1)Add object with name to browser.Definition TBrowser.cxx:303; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2077; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::IsCallingNewstatic ENewType IsCallingNew()Static method returning the defConstructor flag passed to TClass::New().Definition TClass.cxx:5969; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TGuiFactory::CreateBrowserImpvirtual TBrowserImp * CreateBrowserImp(TBrowser *b, const char *title, UInt_t width, UInt_t height, Option_t *opt="""")Create a batch version of TBrowserImp.Definition TGuiFactory.cxx:92; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(co",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:3368,Performance,load,loaded,3368,"owser *b, Long_t ms = 1000) : TTimer(ms, kTRUE), fBrowser(b), fActivate(kFALSE) {}; 59 Bool_t Notify() override; 60 {; 61 if (fBrowser) {; 62 if (fBrowser->GetRefreshFlag()) {; 63 fBrowser->SetRefreshFlag(kFALSE);; 64 fActivate = kTRUE;; 65 } else if (fActivate) {; 66 fActivate = kFALSE;; 67 fBrowser->Refresh();; 68 }; 69 }; 70 Reset();; 71 ; 72 return kFALSE;; 73 }; 74};; 75 ; 76/** \class TBrowserObject; 77This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system.; 78*/; 79 ; 80class TBrowserObject : public TNamed {; 81 ; 82public:; 83 TBrowserObject(void *obj, TClass *cl, const char *brname); 84 : TNamed(brname, cl ? cl->GetName() : """"), fObj(obj), fClass(cl); 85 {; 86 if (!cl); 87 Fatal(""Constructor"", ""Class parameter should not be null"");; 88 SetBit(kCanDelete);; 89 }; 90 ; 91 ~TBrowserObject() {}; 92 ; 93 void Browse(TBrowser *b) override { fClass->Browse(fObj, b); }; 94 Bool_t IsFolder() const override { return fClass->IsFolder(fObj); }; 95 TClass *IsA() const override { return fClass; }; 96 ; 97private:; 98 void *fObj; ///<! pointer to the foreign object; 99 TClass *fClass; ///<! pointer to class of the foreign object; 100};; 101 ; 102ClassImp(TBrowser);; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105// Make sure the application environment exists and the GUI libs are loaded; 106 ; 107Bool_t TBrowser::InitGraphics(); 108{; 109 // Make sure the application environment exists. It is need for graphics; 110 // (colors are initialized in the TApplication ctor).; 111 if (!gApplication); 112 TApplication::CreateApplication();; 113 // make sure that the Gpad and GUI libs are loaded; 114 TApplication::NeedGraphicsLibs();; 115 ; 116 TString hname = gEnv->GetValue(""Browser.Name"", ""TRootBrowserLite"");; 117 ; 118 Bool_t isweb = gROOT->IsWebDisplay() || (hname == ""ROOT::RWebBrowserImp"");; 119 ; 120 if (gApplication); 121 gApplication->InitializeGraphics(isweb);; 122 ; 123 if (!gROOT->IsB",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:3673,Performance,load,loaded,3673," : """"), fObj(obj), fClass(cl); 85 {; 86 if (!cl); 87 Fatal(""Constructor"", ""Class parameter should not be null"");; 88 SetBit(kCanDelete);; 89 }; 90 ; 91 ~TBrowserObject() {}; 92 ; 93 void Browse(TBrowser *b) override { fClass->Browse(fObj, b); }; 94 Bool_t IsFolder() const override { return fClass->IsFolder(fObj); }; 95 TClass *IsA() const override { return fClass; }; 96 ; 97private:; 98 void *fObj; ///<! pointer to the foreign object; 99 TClass *fClass; ///<! pointer to class of the foreign object; 100};; 101 ; 102ClassImp(TBrowser);; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105// Make sure the application environment exists and the GUI libs are loaded; 106 ; 107Bool_t TBrowser::InitGraphics(); 108{; 109 // Make sure the application environment exists. It is need for graphics; 110 // (colors are initialized in the TApplication ctor).; 111 if (!gApplication); 112 TApplication::CreateApplication();; 113 // make sure that the Gpad and GUI libs are loaded; 114 TApplication::NeedGraphicsLibs();; 115 ; 116 TString hname = gEnv->GetValue(""Browser.Name"", ""TRootBrowserLite"");; 117 ; 118 Bool_t isweb = gROOT->IsWebDisplay() || (hname == ""ROOT::RWebBrowserImp"");; 119 ; 120 if (gApplication); 121 gApplication->InitializeGraphics(isweb);; 122 ; 123 if (!gROOT->IsBatch() || (isweb && !gROOT->IsWebDisplayBatch())); 124 return kTRUE;; 125 ; 126 Warning(""TBrowser"", ""The ROOT browser cannot run in batch mode"");; 127 return kFALSE;; 128}; 129 ; 130////////////////////////////////////////////////////////////////////////////////; 131/// Create a new browser with a name, title. Width and height are by; 132/// default set to 640x400 and (optionally) adjusted by the screen factor; 133/// (depending on Rint.Canvas.UseScreenFactor to be true or false, default; 134/// is true).; 135 ; 136TBrowser::TBrowser(const char *name, const char *title, TBrowserImp *extimp, Option_t *opt); 137 : TNamed(name, title), fImp(extimp); 138{; 139 if (!InitGraphi",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:2456,Security,inject,inject,2456,"4/00**; 25 ; 26TBrowser invokes by default the Web-based %ROOT file browser [RBrowser](ROOT::RBrowser); 27To change this behaviour, and invoke the standard TBrowser, one should put; 28the following directive in the `.rootrc` file:; 29```; 30Browser.Name: TRootBrowser; 31```; 32*/; 33 ; 34#include ""TBrowser.h""; 35#include ""TGuiFactory.h""; 36#include ""TROOT.h""; 37#include ""TEnv.h""; 38#include ""TSystem.h""; 39#include ""TStyle.h""; 40#include ""TTimer.h""; 41#include ""TContextMenu.h""; 42#include ""TInterpreter.h""; 43#include ""TVirtualMutex.h""; 44#include ""TClass.h""; 45#include ""TApplication.h""; 46 ; 47/** \class TBrowserTimer; 48Called whenever timer times out.; 49*/; 50 ; 51class TBrowserTimer : public TTimer {; 52 ; 53protected:; 54 TBrowser *fBrowser{nullptr};; 55 Bool_t fActivate{kFALSE};; 56 ; 57public:; 58 TBrowserTimer(TBrowser *b, Long_t ms = 1000) : TTimer(ms, kTRUE), fBrowser(b), fActivate(kFALSE) {}; 59 Bool_t Notify() override; 60 {; 61 if (fBrowser) {; 62 if (fBrowser->GetRefreshFlag()) {; 63 fBrowser->SetRefreshFlag(kFALSE);; 64 fActivate = kTRUE;; 65 } else if (fActivate) {; 66 fActivate = kFALSE;; 67 fBrowser->Refresh();; 68 }; 69 }; 70 Reset();; 71 ; 72 return kFALSE;; 73 }; 74};; 75 ; 76/** \class TBrowserObject; 77This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system.; 78*/; 79 ; 80class TBrowserObject : public TNamed {; 81 ; 82public:; 83 TBrowserObject(void *obj, TClass *cl, const char *brname); 84 : TNamed(brname, cl ? cl->GetName() : """"), fObj(obj), fClass(cl); 85 {; 86 if (!cl); 87 Fatal(""Constructor"", ""Class parameter should not be null"");; 88 SetBit(kCanDelete);; 89 }; 90 ; 91 ~TBrowserObject() {}; 92 ; 93 void Browse(TBrowser *b) override { fClass->Browse(fObj, b); }; 94 Bool_t IsFolder() const override { return fClass->IsFolder(fObj); }; 95 TClass *IsA() const override { return fClass; }; 96 ; 97private:; 98 void *fObj; ///<! pointer to the foreign object; 99 TClass *fClass; ///<! pointer to class of the f",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8cxx_source.html:17223,Security,inject,inject,17223,"BrowserImpABC describing GUI independent browser implementation protocol.Definition TBrowserImp.h:29; TBrowserImp::ExecuteDefaultActionvirtual void ExecuteDefaultAction(TObject *)Definition TBrowserImp.h:51; TBrowserImp::CloseTabsvirtual void CloseTabs()Definition TBrowserImp.h:50; TBrowserImp::RemoveCheckBoxvirtual void RemoveCheckBox(TObject *)Definition TBrowserImp.h:47; TBrowserImp::AddCheckBoxvirtual void AddCheckBox(TObject *, Bool_t=kFALSE)Definition TBrowserImp.h:45; TBrowserImp::BrowseObjvirtual void BrowseObj(TObject *)Definition TBrowserImp.h:48; TBrowserImp::RecursiveRemovevirtual void RecursiveRemove(TObject *)Definition TBrowserImp.h:53; TBrowserImp::Refreshvirtual void Refresh(Bool_t=kFALSE)Definition TBrowserImp.h:54; TBrowserImp::CheckObjectItemvirtual void CheckObjectItem(TObject *, Bool_t=kFALSE)Definition TBrowserImp.h:46; TBrowserImp::Addvirtual void Add(TObject *, const char *, Int_t)Definition TBrowserImp.h:44; TBrowserObjectThis class is designed to wrap a Foreign object in order to inject it into the Browse sub-system.Definition TBrowser.cxx:80; TBrowserObject::TBrowserObjectTBrowserObject(void *obj, TClass *cl, const char *brname)Definition TBrowser.cxx:83; TBrowserObject::IsATClass * IsA() const overrideDefinition TBrowser.cxx:95; TBrowserObject::~TBrowserObject~TBrowserObject()Definition TBrowser.cxx:91; TBrowserObject::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TBrowser.cxx:94; TBrowserObject::fClassTClass * fClass! pointer to class of the foreign objectDefinition TBrowser.cxx:99; TBrowserObject::fObjvoid * fObj! pointer to the foreign objectDefinition TBrowser.cxx:98; TBrowserObject::Browsevoid Browse(TBrowser *b) overrideBrowse object. May be overridden for another default action.Definition TBrowser.cxx:93; TBrowserTimerCalled whenever timer times out.Definition TBrowser.cxx:51; TBrowserTimer::NotifyBool_t Notify() overrideThis me",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
https://root.cern/doc/master/TBrowser_8h_source.html:7101,Integrability,protocol,protocol,7101,"mbedding(name); }; 120 ; 121 ClassDefOverride(TBrowser,0) //ROOT Object Browser; 122};; 123 ; 124#endif; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TBrowserImp.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TBrowserImpABC describing GUI independent browser implementation protocol.Definition TBrowserImp.h:29; TBrowserImp::Iconifyvirtual void Iconify()Definition TBrowserImp.h:52; TBrowserImp::GetDrawOptionvirtual Option_t * GetDrawOption() constDefinition TBrowserImp.h:57; TBrowserImp::StartEmbeddingvirtual void StartEmbedding(Int_t, Int_t)Definition TBrowserImp.h:62; TBrowserImp::SetStatusTextvirtual void SetStatusText(const char *, Int_t)Definition TBrowserImp.h:61; TBrowserImp::BrowseObjvirtual void BrowseObj(TObject *)Definition TBrowserImp.h:48; TBrowserImp::ExecPluginvirtual Longptr_t ExecPlugin(const char *, const char *, const char *, Int_t, Int_t)Definition TBrowserImp.h:60; TBrowserImp::SetDrawOptionvirtual void SetDrawOption(Option_t *="""")Definition TBrowserImp.h:56; TBrowserImp::IsWebvirtual Bool_t IsWeb() constDefinition TBrowserImp.h:58; TBrowserImp::Showvirtual void Show()Definition TBrowserImp.h:55; TBrowserImp::StopEmbeddingvirtual void StopEmbedding(const char *)Definition TBrowserImp.h:63; TBrowserTimerCall",MatchSource.WIKI,doc/master/TBrowser_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8h_source.html
https://root.cern/doc/master/TBrowser_8h_source.html:11971,Integrability,interface,interface,11971,"void SetSelected(TObject *clickedObject)Assign the last selected object.Definition TBrowser.cxx:429; TBrowser::fNeedRefreshBool_t fNeedRefreshContext menu pointer.Definition TBrowser.h:49; TBrowser::GetSelectedTObject * GetSelected() constDefinition TBrowser.h:99; TBrowser::GetRefreshFlagBool_t GetRefreshFlag() constDefinition TBrowser.h:98; TBrowser::ExecuteDefaultActionvoid ExecuteDefaultAction(TObject *obj)Execute default action for selected object (action is specified in the $HOME/.root....Definition TBrowser.cxx:399; TBrowser::GetBrowserImpTBrowserImp * GetBrowserImp() constDefinition TBrowser.h:94; TBrowser::GetDrawOptionOption_t * GetDrawOption() const overrideGet option used by the graphics system to draw this object.Definition TBrowser.h:107; TBrowser::AddCheckBoxvoid AddCheckBox(TObject *obj, Bool_t check=kFALSE)Add checkbox for this item.Definition TBrowser.cxx:336; TBrowser::operator=TBrowser & operator=(const TBrowser &)=delete; TBrowser::BrowseObjectvoid BrowseObject(TObject *obj)Definition TBrowser.h:92; TBrowser::IsWebBool_t IsWeb() constDefinition TBrowser.h:95; TBrowser::SetStatusTextvoid SetStatusText(const char *txt, Int_t col)Definition TBrowser.h:113; TBrowser::Addvoid Add(TObject *obj, const char *name=nullptr, Int_t check=-1)Add object with name to browser.Definition TBrowser.cxx:303; TBrowser::SetBrowserImpvoid SetBrowserImp(TBrowserImp *i)Definition TBrowser.h:96; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; bool; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17. coreguiincTBrowser.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBrowser_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8h_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:3512,Availability,error,error,3512,"); 74{; 75 if (bufsiz < 0); 76 Fatal(""TBuffer"",""Request to create a buffer with a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", bufsiz, kMaxBufferSize);; 77 if (bufsiz < kMinimalSize) bufsiz = kMinimalSize;; 78 fBufSize = bufsiz;; 79 fMode = mode;; 80 fVersion = 0;; 81 fParent = nullptr;; 82 ; 83 SetBit(kIsOwner);; 84 ; 85 fBuffer = new char[fBufSize+kExtraSpace];; 86 ; 87 fBufCur = fBuffer;; 88 fBufMax = fBuffer + fBufSize;; 89 ; 90 SetReAllocFunc( nullptr );; 91}; 92 ; 93////////////////////////////////////////////////////////////////////////////////; 94/// Create an I/O buffer object. Mode should be either TBuffer::kRead or; 95/// TBuffer::kWrite. By default the I/O buffer has a size of; 96/// TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; 97/// to TBuffer via the buf argument. By default this buffer will be adopted; 98/// unless adopt is false.; 99///; 100/// If the new buffer is _not_ adopted and no memory allocation routine; 101/// is provided, a Fatal error will be issued if the Buffer attempts to; 102/// expand.; 103 ; 104TBuffer::TBuffer(EMode mode, Int_t bufsiz, void *buf, Bool_t adopt, ReAllocCharFun_t reallocfunc); 105{; 106 if (bufsiz < 0); 107 Fatal(""TBuffer"",""Request to create a buffer with a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", bufsiz, kMaxBufferSize);; 108 fBufSize = bufsiz;; 109 fMode = mode;; 110 fVersion = 0;; 111 fParent = nullptr;; 112 ; 113 SetBit(kIsOwner);; 114 ; 115 if (buf) {; 116 fBuffer = (char *)buf;; 117 if ( (fMode&kWrite)!=0 ) {; 118 fBufSize -= kExtraSpace;; 119 }; 120 if (!adopt) ResetBit(kIsOwner);; 121 } else {; 122 if (fBufSize < kMinimalSize) {; 123 fBufSize = kMinimalSize;; 124 }; 125 fBuffer = new char[(Long64_t)fBufSize+kExtraSpace];; 126 }; 127 fBufCur = fBuffer;; 128 fBufMax = fBuffer + fBufSize;; 129 ; 130 SetReAllocFunc( reallocfunc );; 131 ; 132 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 133 Expand( kMinimalSize );; 134 ",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:6446,Availability,error,error,6446,"oExpand"",""Request to expand to a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", size_needed, kMaxBufferSize);; 162 }; 163 if (size_needed > fBufSize) {; 164 Long64_t doubling = 2LLU * fBufSize;; 165 if (doubling > kMaxBufferSize); 166 doubling = kMaxBufferSize;; 167 if (size_needed > doubling) {; 168 Expand(size_needed);; 169 } else {; 170 Expand(doubling);; 171 }; 172 }; 173}; 174 ; 175////////////////////////////////////////////////////////////////////////////////; 176/// Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; 177/// new buffer is expected to have the same size as the previous buffer.; 178/// The current buffer position is reset to the start of the buffer.; 179/// If the TBuffer owned the previous buffer, it will be deleted prior; 180/// to accepting the new buffer. By default the new buffer will be; 181/// adopted unless adopt is false.; 182///; 183/// If the new buffer is _not_ adopted and no memory allocation routine; 184/// is provided, a Fatal error will be issued if the Buffer attempts to; 185/// expand.; 186 ; 187void TBuffer::SetBuffer(void *buf, UInt_t newsiz, Bool_t adopt, ReAllocCharFun_t reallocfunc); 188{; 189 if (fBuffer && TestBit(kIsOwner)); 190 delete [] fBuffer;; 191 ; 192 if (adopt); 193 SetBit(kIsOwner);; 194 else; 195 ResetBit(kIsOwner);; 196 ; 197 fBuffer = (char *)buf;; 198 fBufCur = fBuffer;; 199 if (newsiz > 0) {; 200 if ( (fMode&kWrite)!=0 ) {; 201 fBufSize = newsiz - kExtraSpace;; 202 } else {; 203 fBufSize = newsiz;; 204 }; 205 }; 206 fBufMax = fBuffer + fBufSize;; 207 ; 208 SetReAllocFunc( reallocfunc );; 209 ; 210 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 211 Expand( kMinimalSize );; 212 }; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Expand (or shrink) the I/O buffer to newsize bytes.; 217/// If copy is true (the default), the existing content of the; 218/// buffer is preserved, otherwise the buffer is re",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:7568,Availability,down,down,7568,"87void TBuffer::SetBuffer(void *buf, UInt_t newsiz, Bool_t adopt, ReAllocCharFun_t reallocfunc); 188{; 189 if (fBuffer && TestBit(kIsOwner)); 190 delete [] fBuffer;; 191 ; 192 if (adopt); 193 SetBit(kIsOwner);; 194 else; 195 ResetBit(kIsOwner);; 196 ; 197 fBuffer = (char *)buf;; 198 fBufCur = fBuffer;; 199 if (newsiz > 0) {; 200 if ( (fMode&kWrite)!=0 ) {; 201 fBufSize = newsiz - kExtraSpace;; 202 } else {; 203 fBufSize = newsiz;; 204 }; 205 }; 206 fBufMax = fBuffer + fBufSize;; 207 ; 208 SetReAllocFunc( reallocfunc );; 209 ; 210 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 211 Expand( kMinimalSize );; 212 }; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Expand (or shrink) the I/O buffer to newsize bytes.; 217/// If copy is true (the default), the existing content of the; 218/// buffer is preserved, otherwise the buffer is returned zero-ed out.; 219///; 220/// In order to avoid losing data, if the current length is greater than; 221/// the requested size, we only shrink down to the current length.; 222 ; 223void TBuffer::Expand(Int_t newsize, Bool_t copy); 224{; 225 Int_t l = Length();; 226 if ( (l > newsize) && copy ) {; 227 newsize = l;; 228 }; 229 const Int_t extraspace = (fMode&kWrite)!=0 ? kExtraSpace : 0;; 230 ; 231 if ( ((Long64_t)newsize+extraspace) > kMaxBufferSize) {; 232 if (l < kMaxBufferSize) {; 233 newsize = kMaxBufferSize - extraspace;; 234 } else {; 235 Fatal(""Expand"",""Requested size (%d) is too large (max is %d)."", newsize, kMaxBufferSize);; 236 }; 237 }; 238 if ( (fMode&kWrite)!=0 ) {; 239 fBuffer = fReAllocFunc(fBuffer, newsize+kExtraSpace,; 240 copy ? fBufSize+kExtraSpace : 0);; 241 } else {; 242 fBuffer = fReAllocFunc(fBuffer, newsize,; 243 copy ? fBufSize : 0);; 244 }; 245 if (fBuffer == nullptr) {; 246 if (fReAllocFunc == TStorage::ReAllocChar) {; 247 Fatal(""Expand"",""Failed to expand the data buffer using TStorage::ReAllocChar."");; 248 } else if (fReAllocFunc == R__NoReAllocChar",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:21331,Availability,error,error,21331,"efinition TBuffer.h:54; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TBuffer::fVersionInt_t fVersionDefinition TBuffer.h:49; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::GetPIDstatic TProcessID * GetPID()static: returns pointer to current TProcessIDDefinition TProcessID.cxx:343; TStorage::ReAllocCharstatic char * ReAllocChar(char *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:228; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; lTLine lDefinition textangle.C:4. corebasesrcTBuffer.cxx. ROOT master - Reference G",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:10352,Deployability,release,release,10352,"///////////////////////////////////; 275/// Return the reallocation method currently used.; 276 ; 277ReAllocCharFun_t TBuffer::GetReAllocFunc() const; 278{; 279 return fReAllocFunc;; 280}; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Set which memory reallocation method to use. If reallocafunc is null,; 284/// reset it to the default value (TStorage::ReAlloc); 285 ; 286void TBuffer::SetReAllocFunc(ReAllocCharFun_t reallocfunc ); 287{; 288 if (reallocfunc) {; 289 fReAllocFunc = reallocfunc;; 290 } else {; 291 if (TestBit(kIsOwner)) {; 292 fReAllocFunc = TStorage::ReAllocChar;; 293 } else {; 294 fReAllocFunc = R__NoReAllocChar;; 295 }; 296 }; 297}; 298 ; 299////////////////////////////////////////////////////////////////////////////////; 300/// Set buffer in read mode.; 301 ; 302void TBuffer::SetReadMode(); 303{; 304 if ( (fMode&kWrite)!=0 ) {; 305 // We had reserved space for the free block count,; 306 // release it,; 307 fBufSize += kExtraSpace;; 308 }; 309 fMode = kRead;; 310}; 311 ; 312////////////////////////////////////////////////////////////////////////////////; 313/// Set buffer in write mode.; 314 ; 315void TBuffer::SetWriteMode(); 316{; 317 if ( (fMode&kWrite)==0 ) {; 318 // We had not yet reserved space for the free block count,; 319 // reserve it now.; 320 fBufSize -= kExtraSpace;; 321 }; 322 fMode = kWrite;; 323}; 324 ; 325////////////////////////////////////////////////////////////////////////////////; 326/// Forward to TROOT::GetClass().; 327 ; 328TClass *TBuffer::GetClass(const std::type_info &typeinfo); 329{; 330 return TClass::GetClass(typeinfo);; 331}; 332 ; 333////////////////////////////////////////////////////////////////////////////////; 334/// Forward to TROOT::GetClass().; 335 ; 336TClass *TBuffer::GetClass(const char *className); 337{; 338 return TClass::GetClass(className);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Return the ",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:3475,Integrability,rout,routine,3475,"); 74{; 75 if (bufsiz < 0); 76 Fatal(""TBuffer"",""Request to create a buffer with a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", bufsiz, kMaxBufferSize);; 77 if (bufsiz < kMinimalSize) bufsiz = kMinimalSize;; 78 fBufSize = bufsiz;; 79 fMode = mode;; 80 fVersion = 0;; 81 fParent = nullptr;; 82 ; 83 SetBit(kIsOwner);; 84 ; 85 fBuffer = new char[fBufSize+kExtraSpace];; 86 ; 87 fBufCur = fBuffer;; 88 fBufMax = fBuffer + fBufSize;; 89 ; 90 SetReAllocFunc( nullptr );; 91}; 92 ; 93////////////////////////////////////////////////////////////////////////////////; 94/// Create an I/O buffer object. Mode should be either TBuffer::kRead or; 95/// TBuffer::kWrite. By default the I/O buffer has a size of; 96/// TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; 97/// to TBuffer via the buf argument. By default this buffer will be adopted; 98/// unless adopt is false.; 99///; 100/// If the new buffer is _not_ adopted and no memory allocation routine; 101/// is provided, a Fatal error will be issued if the Buffer attempts to; 102/// expand.; 103 ; 104TBuffer::TBuffer(EMode mode, Int_t bufsiz, void *buf, Bool_t adopt, ReAllocCharFun_t reallocfunc); 105{; 106 if (bufsiz < 0); 107 Fatal(""TBuffer"",""Request to create a buffer with a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", bufsiz, kMaxBufferSize);; 108 fBufSize = bufsiz;; 109 fMode = mode;; 110 fVersion = 0;; 111 fParent = nullptr;; 112 ; 113 SetBit(kIsOwner);; 114 ; 115 if (buf) {; 116 fBuffer = (char *)buf;; 117 if ( (fMode&kWrite)!=0 ) {; 118 fBufSize -= kExtraSpace;; 119 }; 120 if (!adopt) ResetBit(kIsOwner);; 121 } else {; 122 if (fBufSize < kMinimalSize) {; 123 fBufSize = kMinimalSize;; 124 }; 125 fBuffer = new char[(Long64_t)fBufSize+kExtraSpace];; 126 }; 127 fBufCur = fBuffer;; 128 fBufMax = fBuffer + fBufSize;; 129 ; 130 SetReAllocFunc( reallocfunc );; 131 ; 132 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 133 Expand( kMinimalSize );; 134 ",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:6409,Integrability,rout,routine,6409,"oExpand"",""Request to expand to a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", size_needed, kMaxBufferSize);; 162 }; 163 if (size_needed > fBufSize) {; 164 Long64_t doubling = 2LLU * fBufSize;; 165 if (doubling > kMaxBufferSize); 166 doubling = kMaxBufferSize;; 167 if (size_needed > doubling) {; 168 Expand(size_needed);; 169 } else {; 170 Expand(doubling);; 171 }; 172 }; 173}; 174 ; 175////////////////////////////////////////////////////////////////////////////////; 176/// Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; 177/// new buffer is expected to have the same size as the previous buffer.; 178/// The current buffer position is reset to the start of the buffer.; 179/// If the TBuffer owned the previous buffer, it will be deleted prior; 180/// to accepting the new buffer. By default the new buffer will be; 181/// adopted unless adopt is false.; 182///; 183/// If the new buffer is _not_ adopted and no memory allocation routine; 184/// is provided, a Fatal error will be issued if the Buffer attempts to; 185/// expand.; 186 ; 187void TBuffer::SetBuffer(void *buf, UInt_t newsiz, Bool_t adopt, ReAllocCharFun_t reallocfunc); 188{; 189 if (fBuffer && TestBit(kIsOwner)); 190 delete [] fBuffer;; 191 ; 192 if (adopt); 193 SetBit(kIsOwner);; 194 else; 195 ResetBit(kIsOwner);; 196 ; 197 fBuffer = (char *)buf;; 198 fBufCur = fBuffer;; 199 if (newsiz > 0) {; 200 if ( (fMode&kWrite)!=0 ) {; 201 fBufSize = newsiz - kExtraSpace;; 202 } else {; 203 fBufSize = newsiz;; 204 }; 205 }; 206 fBufMax = fBuffer + fBufSize;; 207 ; 208 SetReAllocFunc( reallocfunc );; 209 ; 210 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 211 Expand( kMinimalSize );; 212 }; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Expand (or shrink) the I/O buffer to newsize bytes.; 217/// If copy is true (the default), the existing content of the; 218/// buffer is preserved, otherwise the buffer is re",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:21337,Integrability,message,message,21337,"efinition TBuffer.h:54; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TBuffer::fVersionInt_t fVersionDefinition TBuffer.h:49; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::GetPIDstatic TProcessID * GetPID()static: returns pointer to current TProcessIDDefinition TProcessID.cxx:343; TStorage::ReAllocCharstatic char * ReAllocChar(char *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:228; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; lTLine lDefinition textangle.C:4. corebasesrcTBuffer.cxx. ROOT master - Reference G",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:17246,Modifiability,extend,extending,17246,"y GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TProcessID.h; ReAllocCharFun_tchar *(* ReAllocCharFun_t)(char *, size_t, size_t)Definition TStorage.h:30; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::TBufferTBuffer()Definition TBuffer.h:59; TBuffer::SetWriteModevoid SetWriteMode()Set buffer in write mode.Definition TBuffer.cxx:315; TBuffer::ByteSwapBufferBool_t ByteSwapBuffer(Long64_t n, EDataType type)Byte-swap N primitive-elements in the buffer.Definition TBuffer.cxx:392; TBuffer::fCacheStackCacheList_t fCacheStackRealloc function to be used when extending the buffer.Definition TBuffer.h:56; TBuffer::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)=0Return the current Process-ID.Definition TBuffer.cxx:344; TBuffer::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)=0Always return 0 (current processID).Definition TBuffer.cxx:353; TBuffer::fBufSizeInt_t fBufSizeDefinition TBuffer.h:50; TBuffer::SetParentvoid SetParent(TObject *parent)Set parent owning this buffer.Definition TBuffer.cxx:270; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::GetCurrentchar * GetCurrent() constDefinition TBuffer.h:97; TBuffer::Expandvoid Expand(Int_t newsize, Bool_t copy=kTRUE)Expand (or shrink) the I/O buffer to newsize bytes.Definition TBuffer.cxx:223; TBuffer::kIsOwner@ kIsOwnerDefinition TBuffer.h:75; TBuffer::SetBuffervoid SetBuffer(void *buf, UInt_t bufsiz=0, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr)",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:11910,Performance,cache,cache,11910,/////////////; 326/// Forward to TROOT::GetClass().; 327 ; 328TClass *TBuffer::GetClass(const std::type_info &typeinfo); 329{; 330 return TClass::GetClass(typeinfo);; 331}; 332 ; 333////////////////////////////////////////////////////////////////////////////////; 334/// Forward to TROOT::GetClass().; 335 ; 336TClass *TBuffer::GetClass(const char *className); 337{; 338 return TClass::GetClass(className);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Return the current Process-ID.; 343 ; 344TProcessID *TBuffer::ReadProcessID(UShort_t pidf); 345{; 346 if (!pidf) return TProcessID::GetPID(); //may happen when cloning an object; 347 return nullptr;; 348}; 349 ; 350////////////////////////////////////////////////////////////////////////////////; 351/// Always return 0 (current processID).; 352 ; 353UShort_t TBuffer::WriteProcessID(TProcessID *); 354{; 355 return 0;; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// Push a new data cache area onto the list of area to be used for; 360/// temporarily store 'missing' data members.; 361 ; 362void TBuffer::PushDataCache(TVirtualArray *obj); 363{; 364 fCacheStack.push_back(obj);; 365}; 366 ; 367////////////////////////////////////////////////////////////////////////////////; 368/// Return the 'current' data cache area from the list of area to be used for; 369/// temporarily store 'missing' data members.; 370 ; 371TVirtualArray *TBuffer::PeekDataCache() const; 372{; 373 if (fCacheStack.empty()) return nullptr;; 374 return fCacheStack.back();; 375}; 376 ; 377////////////////////////////////////////////////////////////////////////////////; 378/// Pop and Return the 'current' data cache area from the list of area to be used for; 379/// temporarily store 'missing' data members.; 380 ; 381TVirtualArray *TBuffer::PopDataCache(); 382{; 383 TVirtualArray *val = PeekDataCache();; 384 fCacheStack.pop_back();; 385 return val;; 386,MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:12236,Performance,cache,cache,12236,"sName); 337{; 338 return TClass::GetClass(className);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Return the current Process-ID.; 343 ; 344TProcessID *TBuffer::ReadProcessID(UShort_t pidf); 345{; 346 if (!pidf) return TProcessID::GetPID(); //may happen when cloning an object; 347 return nullptr;; 348}; 349 ; 350////////////////////////////////////////////////////////////////////////////////; 351/// Always return 0 (current processID).; 352 ; 353UShort_t TBuffer::WriteProcessID(TProcessID *); 354{; 355 return 0;; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// Push a new data cache area onto the list of area to be used for; 360/// temporarily store 'missing' data members.; 361 ; 362void TBuffer::PushDataCache(TVirtualArray *obj); 363{; 364 fCacheStack.push_back(obj);; 365}; 366 ; 367////////////////////////////////////////////////////////////////////////////////; 368/// Return the 'current' data cache area from the list of area to be used for; 369/// temporarily store 'missing' data members.; 370 ; 371TVirtualArray *TBuffer::PeekDataCache() const; 372{; 373 if (fCacheStack.empty()) return nullptr;; 374 return fCacheStack.back();; 375}; 376 ; 377////////////////////////////////////////////////////////////////////////////////; 378/// Pop and Return the 'current' data cache area from the list of area to be used for; 379/// temporarily store 'missing' data members.; 380 ; 381TVirtualArray *TBuffer::PopDataCache(); 382{; 383 TVirtualArray *val = PeekDataCache();; 384 fCacheStack.pop_back();; 385 return val;; 386}; 387 ; 388////////////////////////////////////////////////////////////////////////////////; 389/// Byte-swap N primitive-elements in the buffer.; 390/// Bulk API relies on this function.; 391 ; 392Bool_t TBuffer::ByteSwapBuffer(Long64_t n, EDataType type); 393{; 394 char *input_buf = GetCurrent();; 395 if ((type == EDataType::kShort_t) || (type == ",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:12613,Performance,cache,cache,12613,"/////////////////////////////////////////////////////////////////////////////; 351/// Always return 0 (current processID).; 352 ; 353UShort_t TBuffer::WriteProcessID(TProcessID *); 354{; 355 return 0;; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// Push a new data cache area onto the list of area to be used for; 360/// temporarily store 'missing' data members.; 361 ; 362void TBuffer::PushDataCache(TVirtualArray *obj); 363{; 364 fCacheStack.push_back(obj);; 365}; 366 ; 367////////////////////////////////////////////////////////////////////////////////; 368/// Return the 'current' data cache area from the list of area to be used for; 369/// temporarily store 'missing' data members.; 370 ; 371TVirtualArray *TBuffer::PeekDataCache() const; 372{; 373 if (fCacheStack.empty()) return nullptr;; 374 return fCacheStack.back();; 375}; 376 ; 377////////////////////////////////////////////////////////////////////////////////; 378/// Pop and Return the 'current' data cache area from the list of area to be used for; 379/// temporarily store 'missing' data members.; 380 ; 381TVirtualArray *TBuffer::PopDataCache(); 382{; 383 TVirtualArray *val = PeekDataCache();; 384 fCacheStack.pop_back();; 385 return val;; 386}; 387 ; 388////////////////////////////////////////////////////////////////////////////////; 389/// Byte-swap N primitive-elements in the buffer.; 390/// Bulk API relies on this function.; 391 ; 392Bool_t TBuffer::ByteSwapBuffer(Long64_t n, EDataType type); 393{; 394 char *input_buf = GetCurrent();; 395 if ((type == EDataType::kShort_t) || (type == EDataType::kUShort_t)) {; 396#ifdef R__BYTESWAP; 397 Short_t *buf __attribute__((aligned(8))) = reinterpret_cast<Short_t*>(input_buf);; 398 for (int idx=0; idx<n; idx++) {; 399 Short_t tmp = *reinterpret_cast<Short_t*>(buf + idx); // Makes a copy of the values; frombuf can't handle aliasing.; 400 char *tmp_ptr = reinterpret_cast<char *>(&tmp);; 401 frombuf(tmp_ptr, buf + idx",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:18371,Performance,cache,cache,18371,"rn the current Process-ID.Definition TBuffer.cxx:344; TBuffer::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)=0Always return 0 (current processID).Definition TBuffer.cxx:353; TBuffer::fBufSizeInt_t fBufSizeDefinition TBuffer.h:50; TBuffer::SetParentvoid SetParent(TObject *parent)Set parent owning this buffer.Definition TBuffer.cxx:270; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::GetCurrentchar * GetCurrent() constDefinition TBuffer.h:97; TBuffer::Expandvoid Expand(Int_t newsize, Bool_t copy=kTRUE)Expand (or shrink) the I/O buffer to newsize bytes.Definition TBuffer.cxx:223; TBuffer::kIsOwner@ kIsOwnerDefinition TBuffer.h:75; TBuffer::SetBuffervoid SetBuffer(void *buf, UInt_t bufsiz=0, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr)Sets a new buffer in an existing TBuffer object.Definition TBuffer.cxx:187; TBuffer::PushDataCachevirtual void PushDataCache(TVirtualArray *)Push a new data cache area onto the list of area to be used for temporarily store 'missing' data memb...Definition TBuffer.cxx:362; TBuffer::SetReAllocFuncvoid SetReAllocFunc(ReAllocCharFun_t reallocfunc=nullptr)Set which memory reallocation method to use.Definition TBuffer.cxx:286; TBuffer::PopDataCachevirtual TVirtualArray * PopDataCache()Pop and Return the 'current' data cache area from the list of area to be used for temporarily store '...Definition TBuffer.cxx:381; TBuffer::EModeEModeDefinition TBuffer.h:73; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::kRead@ kReadDefinition TBuffer.h:73; TBuffer::fBufMaxchar * fBufMaxDefinition TBuffer.h:53; TBuffer::fBufCurchar * fBufCurDefinition TBuffer.h:52; TBuffer::AutoExpandvoid AutoExpand(Int_t size_needed)Automatically calculate a new size and expand the buffer to fit at least size_needed.Definition TBuffer.cxx:158; TBuffer::PeekDataCachevirtual TVirtualArray * PeekDataCache() constReturn the 'current' data cache area from the list of area",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:18732,Performance,cache,cache,18732,"xx:270; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::GetCurrentchar * GetCurrent() constDefinition TBuffer.h:97; TBuffer::Expandvoid Expand(Int_t newsize, Bool_t copy=kTRUE)Expand (or shrink) the I/O buffer to newsize bytes.Definition TBuffer.cxx:223; TBuffer::kIsOwner@ kIsOwnerDefinition TBuffer.h:75; TBuffer::SetBuffervoid SetBuffer(void *buf, UInt_t bufsiz=0, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr)Sets a new buffer in an existing TBuffer object.Definition TBuffer.cxx:187; TBuffer::PushDataCachevirtual void PushDataCache(TVirtualArray *)Push a new data cache area onto the list of area to be used for temporarily store 'missing' data memb...Definition TBuffer.cxx:362; TBuffer::SetReAllocFuncvoid SetReAllocFunc(ReAllocCharFun_t reallocfunc=nullptr)Set which memory reallocation method to use.Definition TBuffer.cxx:286; TBuffer::PopDataCachevirtual TVirtualArray * PopDataCache()Pop and Return the 'current' data cache area from the list of area to be used for temporarily store '...Definition TBuffer.cxx:381; TBuffer::EModeEModeDefinition TBuffer.h:73; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::kRead@ kReadDefinition TBuffer.h:73; TBuffer::fBufMaxchar * fBufMaxDefinition TBuffer.h:53; TBuffer::fBufCurchar * fBufCurDefinition TBuffer.h:52; TBuffer::AutoExpandvoid AutoExpand(Int_t size_needed)Automatically calculate a new size and expand the buffer to fit at least size_needed.Definition TBuffer.cxx:158; TBuffer::PeekDataCachevirtual TVirtualArray * PeekDataCache() constReturn the 'current' data cache area from the list of area to be used for temporarily store 'missing'...Definition TBuffer.cxx:371; TBuffer::ReadClassBuffervirtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, const TClass *onfile_class=nullptr)=0; TBuffer::kMinimalSize@ kMinimalSizeDefinition TBuffer.h:78; TBuffer::kInitialSize@ kInitialSizeDefinition TBuffer.h:78; TBuffer::~TBuffervirtual ~",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:19337,Performance,cache,cache,19337," PushDataCache(TVirtualArray *)Push a new data cache area onto the list of area to be used for temporarily store 'missing' data memb...Definition TBuffer.cxx:362; TBuffer::SetReAllocFuncvoid SetReAllocFunc(ReAllocCharFun_t reallocfunc=nullptr)Set which memory reallocation method to use.Definition TBuffer.cxx:286; TBuffer::PopDataCachevirtual TVirtualArray * PopDataCache()Pop and Return the 'current' data cache area from the list of area to be used for temporarily store '...Definition TBuffer.cxx:381; TBuffer::EModeEModeDefinition TBuffer.h:73; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::kRead@ kReadDefinition TBuffer.h:73; TBuffer::fBufMaxchar * fBufMaxDefinition TBuffer.h:53; TBuffer::fBufCurchar * fBufCurDefinition TBuffer.h:52; TBuffer::AutoExpandvoid AutoExpand(Int_t size_needed)Automatically calculate a new size and expand the buffer to fit at least size_needed.Definition TBuffer.cxx:158; TBuffer::PeekDataCachevirtual TVirtualArray * PeekDataCache() constReturn the 'current' data cache area from the list of area to be used for temporarily store 'missing'...Definition TBuffer.cxx:371; TBuffer::ReadClassBuffervirtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, const TClass *onfile_class=nullptr)=0; TBuffer::kMinimalSize@ kMinimalSizeDefinition TBuffer.h:78; TBuffer::kInitialSize@ kInitialSizeDefinition TBuffer.h:78; TBuffer::~TBuffervirtual ~TBuffer()Delete an I/O buffer object.Definition TBuffer.cxx:140; TBuffer::GetClassstatic TClass * GetClass(const std::type_info &typeinfo)Forward to TROOT::GetClass().Definition TBuffer.cxx:328; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::fModeBool_t fModeDefinition TBuffer.h:48; TBuffer::GetReAllocFuncReAllocCharFun_t GetReAllocFunc() constReturn the reallocation method currently used.Definition TBuffer.cxx:277; TBuffer::fReAllocFuncReAllocCharFun_t fReAllocFuncDefinition TBuffer.h:55; TBuffer::fBufferchar * fBufferDefinition TBuffer.h:51; TBuffer::fParentTObject * fPar",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:20830,Performance,load,load,20830,"ypeinfo)Forward to TROOT::GetClass().Definition TBuffer.cxx:328; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::fModeBool_t fModeDefinition TBuffer.h:48; TBuffer::GetReAllocFuncReAllocCharFun_t GetReAllocFunc() constReturn the reallocation method currently used.Definition TBuffer.cxx:277; TBuffer::fReAllocFuncReAllocCharFun_t fReAllocFuncDefinition TBuffer.h:55; TBuffer::fBufferchar * fBufferDefinition TBuffer.h:51; TBuffer::fParentTObject * fParentDefinition TBuffer.h:54; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TBuffer::fVersionInt_t fVersionDefinition TBuffer.h:49; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::GetPIDstatic TProcessID * GetPID()static: returns pointer to current TProcessIDDefinition TProcessID.cxx:343; TStorage::ReAllocCharstatic char * ReAllocChar(char *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:228; TVirtualArrayWrapper around an object and givin",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:1121,Safety,avoid,avoid,1121,"oading...; Searching...; No Matches. TBuffer.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id: 6da0b5b613bbcfaa3a5cd4074e7b2be2448dfb31 $; 2// Author: Fons Rademakers 04/05/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TBuffer; 13\ingroup Base; 14 ; 15Buffer base class used for serializing objects.; 16*/; 17 ; 18#include ""TBuffer.h""; 19#include ""TClass.h""; 20#include ""TProcessID.h""; 21 ; 22constexpr Int_t kExtraSpace = 8; // extra space at end of buffer (used for free block count); 23constexpr Int_t kMaxBufferSize = 0x7FFFFFFE; // largest possible size.; 24 ; 25 ; 26ClassImp(TBuffer);; 27 ; 28/// Default streamer implementation used by ClassDefInline to avoid; 29/// requirement to include TBuffer.h; 30void ROOT::Internal::DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer); 31{; 32 if (R__b.IsReading()); 33 R__b.ReadClassBuffer(cl, objpointer);; 34 else; 35 R__b.WriteClassBuffer(cl, objpointer);; 36}; 37 ; 38////////////////////////////////////////////////////////////////////////////////; 39/// The user has provided memory than we don't own, thus we can not extent it; 40/// either.; 41 ; 42static char *R__NoReAllocChar(char *, size_t, size_t); 43{; 44 return nullptr;; 45}; 46 ; 47////////////////////////////////////////////////////////////////////////////////; 48/// Create an I/O buffer object. Mode should be either TBuffer::kRead or; 49/// TBuffer::kWrite. By default the I/O buffer has a size of; 50/// TBuffer::kInitialSize (1024) bytes.; 51 ; 52TBuffer::TBuffer(EMode mode); 53{; 54 fBufSize = kInitialSize;; 55 fMode = mode;; 56 fVersion = 0;; 57 fParent = nullptr;; 58 ; 59 SetBit(kIsOwner)",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:5114,Safety,avoid,avoiding,5114," -= kExtraSpace;; 119 }; 120 if (!adopt) ResetBit(kIsOwner);; 121 } else {; 122 if (fBufSize < kMinimalSize) {; 123 fBufSize = kMinimalSize;; 124 }; 125 fBuffer = new char[(Long64_t)fBufSize+kExtraSpace];; 126 }; 127 fBufCur = fBuffer;; 128 fBufMax = fBuffer + fBufSize;; 129 ; 130 SetReAllocFunc( reallocfunc );; 131 ; 132 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 133 Expand( kMinimalSize );; 134 }; 135}; 136 ; 137////////////////////////////////////////////////////////////////////////////////; 138/// Delete an I/O buffer object.; 139 ; 140TBuffer::~TBuffer(); 141{; 142 if (TestBit(kIsOwner)) {; 143 //printf(""Deleting fBuffer=%lx\n"", fBuffer);; 144 delete [] fBuffer;; 145 }; 146 fBuffer = nullptr;; 147 fParent = nullptr;; 148}; 149 ; 150////////////////////////////////////////////////////////////////////////////////; 151/// Automatically calculate a new size and expand the buffer to fit at least size_needed.; 152/// The goals is to minimize the number of memory allocation and the memory allocation; 153/// which avoiding too much memory wastage.; 154///; 155/// If the size_needed is larger than the current size, the policy; 156/// is to expand to double the current size or the size_needed which ever is largest.; 157 ; 158void TBuffer::AutoExpand(Int_t size_needed); 159{; 160 if (size_needed < 0) {; 161 Fatal(""AutoExpand"",""Request to expand to a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", size_needed, kMaxBufferSize);; 162 }; 163 if (size_needed > fBufSize) {; 164 Long64_t doubling = 2LLU * fBufSize;; 165 if (doubling > kMaxBufferSize); 166 doubling = kMaxBufferSize;; 167 if (size_needed > doubling) {; 168 Expand(size_needed);; 169 } else {; 170 Expand(doubling);; 171 }; 172 }; 173}; 174 ; 175////////////////////////////////////////////////////////////////////////////////; 176/// Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; 177/// new buffer is expected to have the same size as the previous buffer.; 17",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:7468,Safety,avoid,avoid,7468,"87void TBuffer::SetBuffer(void *buf, UInt_t newsiz, Bool_t adopt, ReAllocCharFun_t reallocfunc); 188{; 189 if (fBuffer && TestBit(kIsOwner)); 190 delete [] fBuffer;; 191 ; 192 if (adopt); 193 SetBit(kIsOwner);; 194 else; 195 ResetBit(kIsOwner);; 196 ; 197 fBuffer = (char *)buf;; 198 fBufCur = fBuffer;; 199 if (newsiz > 0) {; 200 if ( (fMode&kWrite)!=0 ) {; 201 fBufSize = newsiz - kExtraSpace;; 202 } else {; 203 fBufSize = newsiz;; 204 }; 205 }; 206 fBufMax = fBuffer + fBufSize;; 207 ; 208 SetReAllocFunc( reallocfunc );; 209 ; 210 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 211 Expand( kMinimalSize );; 212 }; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Expand (or shrink) the I/O buffer to newsize bytes.; 217/// If copy is true (the default), the existing content of the; 218/// buffer is preserved, otherwise the buffer is returned zero-ed out.; 219///; 220/// In order to avoid losing data, if the current length is greater than; 221/// the requested size, we only shrink down to the current length.; 222 ; 223void TBuffer::Expand(Int_t newsize, Bool_t copy); 224{; 225 Int_t l = Length();; 226 if ( (l > newsize) && copy ) {; 227 newsize = l;; 228 }; 229 const Int_t extraspace = (fMode&kWrite)!=0 ? kExtraSpace : 0;; 230 ; 231 if ( ((Long64_t)newsize+extraspace) > kMaxBufferSize) {; 232 if (l < kMaxBufferSize) {; 233 newsize = kMaxBufferSize - extraspace;; 234 } else {; 235 Fatal(""Expand"",""Requested size (%d) is too large (max is %d)."", newsize, kMaxBufferSize);; 236 }; 237 }; 238 if ( (fMode&kWrite)!=0 ) {; 239 fBuffer = fReAllocFunc(fBuffer, newsize+kExtraSpace,; 240 copy ? fBufSize+kExtraSpace : 0);; 241 } else {; 242 fBuffer = fReAllocFunc(fBuffer, newsize,; 243 copy ? fBufSize : 0);; 244 }; 245 if (fBuffer == nullptr) {; 246 if (fReAllocFunc == TStorage::ReAllocChar) {; 247 Fatal(""Expand"",""Failed to expand the data buffer using TStorage::ReAllocChar."");; 248 } else if (fReAllocFunc == R__NoReAllocChar",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:22179,Safety,avoid,avoid,22179," mode.Definition TBuffer.cxx:302; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TBuffer::fVersionInt_t fVersionDefinition TBuffer.h:49; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::GetPIDstatic TProcessID * GetPID()static: returns pointer to current TProcessIDDefinition TProcessID.cxx:343; TStorage::ReAllocCharstatic char * ReAllocChar(char *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:228; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; lTLine lDefinition textangle.C:4. corebasesrcTBuffer.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8cxx_source.html:21857,Security,access,access,21857," mode.Definition TBuffer.cxx:302; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TBuffer::fVersionInt_t fVersionDefinition TBuffer.h:49; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::GetPIDstatic TProcessID * GetPID()static: returns pointer to current TProcessIDDefinition TProcessID.cxx:343; TStorage::ReAllocCharstatic char * ReAllocChar(char *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:228; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; lTLine lDefinition textangle.C:4. corebasesrcTBuffer.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:1854,Modifiability,extend,extending,1854,"terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TBuffer; 13#define ROOT_TBuffer; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TBuffer //; 19// //; 20// Buffer base class used for serializing objects. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TDataType.h""; 25#include ""TObject.h""; 26#include ""TClass.h""; 27#include ""Bytes.h""; 28 ; 29#include <vector>; 30#include <string>; 31 ; 32class TVirtualStreamerInfo;; 33class TStreamerElement;; 34class TString;; 35class TProcessID;; 36class TClonesArray;; 37class TRefTable;; 38class TVirtualArray;; 39namespace TStreamerInfoActions {; 40 class TActionSequence;; 41}; 42 ; 43class TBuffer : public TObject {; 44 ; 45protected:; 46 typedef std::vector<TVirtualArray*> CacheList_t;; 47 ; 48 Bool_t fMode; //Read or write mode; 49 Int_t fVersion; //Buffer format version; 50 Int_t fBufSize; //Size of buffer; 51 char *fBuffer; //Buffer used to store objects; 52 char *fBufCur; //Current position in buffer; 53 char *fBufMax; //End of buffer; 54 TObject *fParent; //Pointer to parent object owning this buffer; 55 ReAllocCharFun_t fReAllocFunc; //! Realloc function to be used when extending the buffer.; 56 CacheList_t fCacheStack; //Stack of pointers to the cache where to temporarily store the value of 'missing' data members; 57 ; 58 // Default ctor; 59 TBuffer() : TObject(), fMode(0), fVersion(0), fBufSize(0), fBuffer(nullptr),; 60 fBufCur(nullptr), fBufMax(nullptr), fParent(nullptr), fReAllocFunc(nullptr), fCacheStack(0, (TVirtualArray*)nullptr) {}; 61 ; 62 // TBuffer objects cannot be copied or assigned; 63 TBuffer(const TBuffer &) = delete;; 64 void operator=(const TBuffer &) = delete;; 65 ; 66 Int_t Read(const char *name) override { return TObject::Read(name); }; 67 Int_t Writ",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:28567,Modifiability,extend,extending,28567,"ithFactor(Double_t *ptr, Int_t n, Double_t factor, Double_t minvalue)=0; TBuffer::Resetvirtual void Reset()=0; TBuffer::WriteStdStringvirtual void WriteStdString(std::string &s)Definition TBuffer.h:312; TBuffer::WriteDouble32virtual void WriteDouble32(Double_t *d, TStreamerElement *ele=nullptr)=0; TBuffer::ReadDouble32virtual void ReadDouble32(Double_t *d, TStreamerElement *ele=nullptr)=0; TBuffer::WriteStringvirtual void WriteString(const char *s)=0; TBuffer::ByteSwapBufferBool_t ByteSwapBuffer(Long64_t n, EDataType type)Byte-swap N primitive-elements in the buffer.Definition TBuffer.cxx:392; TBuffer::GetMappedObjectvirtual void GetMappedObject(UInt_t tag, void *&ptr, TClass *&ClassPtr) const =0; TBuffer::WriteFastArrayStringvirtual void WriteFastArrayString(const Char_t *c, Long64_t n)=0; TBuffer::ReadTStringvirtual void ReadTString(TString &s)=0; TBuffer::ReadBoolvirtual void ReadBool(Bool_t &b)=0; TBuffer::GetTRefExecIdvirtual UInt_t GetTRefExecId()=0; TBuffer::WriteULongvirtual void WriteULong(ULong_t l)=0; TBuffer::ReadFastArrayvirtual void ReadFastArray(UShort_t *h, Int_t n)=0; TBuffer::GetInfovirtual TVirtualStreamerInfo * GetInfo()=0; TBuffer::ClassBeginvirtual void ClassBegin(const TClass *, Version_t=-1)=0; TBuffer::WriteArrayvirtual void WriteArray(const UShort_t *h, Int_t n)=0; TBuffer::fCacheStackCacheList_t fCacheStackRealloc function to be used when extending the buffer.Definition TBuffer.h:56; TBuffer::ReadShortvirtual void ReadShort(Short_t &s)=0; TBuffer::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)=0Return the current Process-ID.Definition TBuffer.cxx:344; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(Int_t *i)=0; TBuffer::WriteVersionMemberWisevirtual UInt_t WriteVersionMemberWise(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(UInt_t *i)=0; TBuffer::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)=0Always return 0 (current processID).Definition TBuffer.cxx:",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:1932,Performance,cache,cache,1932,; 56 CacheList_t fCacheStack; //Stack of pointers to the cache where to temporarily store the value of 'missing' data members;,MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:7102,Performance,cache,cacheReuse,7102,"id SkipObjectAny() = 0;; 138 ; 139 virtual void TagStreamerInfo(TVirtualStreamerInfo* info) = 0;; 140 virtual void IncrementLevel(TVirtualStreamerInfo* info) = 0;; 141 virtual void SetStreamerElementNumber(TStreamerElement *elem, Int_t comp_type) = 0;; 142 virtual void DecrementLevel(TVirtualStreamerInfo*) = 0;; 143 ; 144 virtual void ClassBegin(const TClass*, Version_t = -1) = 0;; 145 virtual void ClassEnd(const TClass*) = 0;; 146 virtual void ClassMember(const char*, const char * = nullptr, Int_t = -1, Int_t = -1) = 0;; 147 virtual TVirtualStreamerInfo *GetInfo() = 0;; 148 ; 149 virtual TVirtualArray *PeekDataCache() const;; 150 virtual TVirtualArray *PopDataCache();; 151 virtual void PushDataCache(TVirtualArray *);; 152 ; 153 virtual TClass *ReadClass(const TClass *cl = nullptr, UInt_t *objTag = nullptr) = 0;; 154 virtual void WriteClass(const TClass *cl) = 0;; 155 ; 156 virtual TObject *ReadObject(const TClass *cl) = 0;; 157 virtual void WriteObject(const TObject *obj, Bool_t cacheReuse) = 0;; 158 ; 159 template <class T> Int_t WriteObject(const T *objptr, Bool_t cacheReuse = kTRUE);; 160 ; 161 virtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse = kTRUE) = 0;; 162 ; 163 virtual UShort_t GetPidOffset() const = 0;; 164 virtual void SetPidOffset(UShort_t offset) = 0;; 165 virtual Int_t GetBufferDisplacement() const = 0;; 166 virtual void SetBufferDisplacement() = 0;; 167 virtual void SetBufferDisplacement(Int_t skipped) = 0;; 168 ; 169 // basic types and arrays of basic types; 170 virtual void ReadFloat16 (Float_t *f, TStreamerElement *ele = nullptr) = 0;; 171 virtual void WriteFloat16(Float_t *f, TStreamerElement *ele = nullptr) = 0;; 172 virtual void ReadDouble32 (Double_t *d, TStreamerElement *ele = nullptr) = 0;; 173 virtual void WriteDouble32(Double_t *d, TStreamerElement *ele = nullptr) = 0;; 174 virtual void ReadWithFactor(Float_t *ptr, Double_t factor, Double_t minvalue) = 0;; 175 virtual void ReadWithNbits(Float_t *ptr, I",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:7191,Performance,cache,cacheReuse,7191,"o) = 0;; 140 virtual void IncrementLevel(TVirtualStreamerInfo* info) = 0;; 141 virtual void SetStreamerElementNumber(TStreamerElement *elem, Int_t comp_type) = 0;; 142 virtual void DecrementLevel(TVirtualStreamerInfo*) = 0;; 143 ; 144 virtual void ClassBegin(const TClass*, Version_t = -1) = 0;; 145 virtual void ClassEnd(const TClass*) = 0;; 146 virtual void ClassMember(const char*, const char * = nullptr, Int_t = -1, Int_t = -1) = 0;; 147 virtual TVirtualStreamerInfo *GetInfo() = 0;; 148 ; 149 virtual TVirtualArray *PeekDataCache() const;; 150 virtual TVirtualArray *PopDataCache();; 151 virtual void PushDataCache(TVirtualArray *);; 152 ; 153 virtual TClass *ReadClass(const TClass *cl = nullptr, UInt_t *objTag = nullptr) = 0;; 154 virtual void WriteClass(const TClass *cl) = 0;; 155 ; 156 virtual TObject *ReadObject(const TClass *cl) = 0;; 157 virtual void WriteObject(const TObject *obj, Bool_t cacheReuse) = 0;; 158 ; 159 template <class T> Int_t WriteObject(const T *objptr, Bool_t cacheReuse = kTRUE);; 160 ; 161 virtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse = kTRUE) = 0;; 162 ; 163 virtual UShort_t GetPidOffset() const = 0;; 164 virtual void SetPidOffset(UShort_t offset) = 0;; 165 virtual Int_t GetBufferDisplacement() const = 0;; 166 virtual void SetBufferDisplacement() = 0;; 167 virtual void SetBufferDisplacement(Int_t skipped) = 0;; 168 ; 169 // basic types and arrays of basic types; 170 virtual void ReadFloat16 (Float_t *f, TStreamerElement *ele = nullptr) = 0;; 171 virtual void WriteFloat16(Float_t *f, TStreamerElement *ele = nullptr) = 0;; 172 virtual void ReadDouble32 (Double_t *d, TStreamerElement *ele = nullptr) = 0;; 173 virtual void WriteDouble32(Double_t *d, TStreamerElement *ele = nullptr) = 0;; 174 virtual void ReadWithFactor(Float_t *ptr, Double_t factor, Double_t minvalue) = 0;; 175 virtual void ReadWithNbits(Float_t *ptr, Int_t nbits) = 0;; 176 virtual void ReadWithFactor(Double_t *ptr, Double_t factor, Double_",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:7300,Performance,cache,cacheReuse,7300,"tNumber(TStreamerElement *elem, Int_t comp_type) = 0;; 142 virtual void DecrementLevel(TVirtualStreamerInfo*) = 0;; 143 ; 144 virtual void ClassBegin(const TClass*, Version_t = -1) = 0;; 145 virtual void ClassEnd(const TClass*) = 0;; 146 virtual void ClassMember(const char*, const char * = nullptr, Int_t = -1, Int_t = -1) = 0;; 147 virtual TVirtualStreamerInfo *GetInfo() = 0;; 148 ; 149 virtual TVirtualArray *PeekDataCache() const;; 150 virtual TVirtualArray *PopDataCache();; 151 virtual void PushDataCache(TVirtualArray *);; 152 ; 153 virtual TClass *ReadClass(const TClass *cl = nullptr, UInt_t *objTag = nullptr) = 0;; 154 virtual void WriteClass(const TClass *cl) = 0;; 155 ; 156 virtual TObject *ReadObject(const TClass *cl) = 0;; 157 virtual void WriteObject(const TObject *obj, Bool_t cacheReuse) = 0;; 158 ; 159 template <class T> Int_t WriteObject(const T *objptr, Bool_t cacheReuse = kTRUE);; 160 ; 161 virtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse = kTRUE) = 0;; 162 ; 163 virtual UShort_t GetPidOffset() const = 0;; 164 virtual void SetPidOffset(UShort_t offset) = 0;; 165 virtual Int_t GetBufferDisplacement() const = 0;; 166 virtual void SetBufferDisplacement() = 0;; 167 virtual void SetBufferDisplacement(Int_t skipped) = 0;; 168 ; 169 // basic types and arrays of basic types; 170 virtual void ReadFloat16 (Float_t *f, TStreamerElement *ele = nullptr) = 0;; 171 virtual void WriteFloat16(Float_t *f, TStreamerElement *ele = nullptr) = 0;; 172 virtual void ReadDouble32 (Double_t *d, TStreamerElement *ele = nullptr) = 0;; 173 virtual void WriteDouble32(Double_t *d, TStreamerElement *ele = nullptr) = 0;; 174 virtual void ReadWithFactor(Float_t *ptr, Double_t factor, Double_t minvalue) = 0;; 175 virtual void ReadWithNbits(Float_t *ptr, Int_t nbits) = 0;; 176 virtual void ReadWithFactor(Double_t *ptr, Double_t factor, Double_t minvalue) = 0;; 177 virtual void ReadWithNbits(Double_t *ptr, Int_t nbits) = 0;; 178 ; 179 virtual Int_t Re",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:21917,Performance,cache,cacheReuse,21917,"381template <class Tmpl> TBuffer &operator>>(TBuffer &buf, Tmpl *&obj); 382{; 383 // Read TObject derived classes from a TBuffer. Need to provide; 384 // custom version for non-TObject derived classes.; 385 ; 386 // This operator has to be a templated and/or automatically; 387 // generated if we want to be able to check the type of the; 388 // incoming object. I.e. a operator>>(TBuffer &buf, TObject *&); 389 // would not be sufficient to pass the information 'which class do we want'; 390 // since the pointer could be zero (so typeid(*obj) is not usable).; 391 ; 392 auto cl = TClass::GetClass<Tmpl>();; 393 obj = (Tmpl *) ( (void*) buf.ReadObjectAny(cl) );; 394 return buf;; 395}; 396 ; 397template <class Tmpl> TBuffer &operator<<(TBuffer &buf, const Tmpl *obj); 398{; 399 auto cl = (obj) ? TClass::GetClass<Tmpl>() : nullptr;; 400 buf.WriteObjectAny(obj, cl);; 401 return buf;; 402}; 403 ; 404template <class T>; 405inline Int_t TBuffer::WriteObject(const T *objptr, Bool_t cacheReuse); 406{; 407 auto cl = (objptr) ? TClass::GetClass<T>() : nullptr;; 408 return WriteObjectAny(objptr, cl, cacheReuse);; 409}; 410 ; 411#endif // ROOT_TBuffer; Bytes.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Char_tchar Char_tDefinition RtypesCore.h:37; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition Rtypes",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:22033,Performance,cache,cacheReuse,22033,"381template <class Tmpl> TBuffer &operator>>(TBuffer &buf, Tmpl *&obj); 382{; 383 // Read TObject derived classes from a TBuffer. Need to provide; 384 // custom version for non-TObject derived classes.; 385 ; 386 // This operator has to be a templated and/or automatically; 387 // generated if we want to be able to check the type of the; 388 // incoming object. I.e. a operator>>(TBuffer &buf, TObject *&); 389 // would not be sufficient to pass the information 'which class do we want'; 390 // since the pointer could be zero (so typeid(*obj) is not usable).; 391 ; 392 auto cl = TClass::GetClass<Tmpl>();; 393 obj = (Tmpl *) ( (void*) buf.ReadObjectAny(cl) );; 394 return buf;; 395}; 396 ; 397template <class Tmpl> TBuffer &operator<<(TBuffer &buf, const Tmpl *obj); 398{; 399 auto cl = (obj) ? TClass::GetClass<Tmpl>() : nullptr;; 400 buf.WriteObjectAny(obj, cl);; 401 return buf;; 402}; 403 ; 404template <class T>; 405inline Int_t TBuffer::WriteObject(const T *objptr, Bool_t cacheReuse); 406{; 407 auto cl = (objptr) ? TClass::GetClass<T>() : nullptr;; 408 return WriteObjectAny(objptr, cl, cacheReuse);; 409}; 410 ; 411#endif // ROOT_TBuffer; Bytes.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Char_tchar Char_tDefinition RtypesCore.h:37; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition Rtypes",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:33719,Performance,cache,cacheReuse,33719," TBuffer::WriteArrayvirtual void WriteArray(const ULong64_t *l, Int_t n)=0; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(Long_t *l)=0; TBuffer::WriteFastArrayvirtual void WriteFastArray(const Double_t *d, Long64_t n)=0; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(Float_t *f)=0; TBuffer::ReadFastArrayvirtual void ReadFastArray(Int_t *i, Int_t n)=0; TBuffer::ReadArrayvirtual Int_t ReadArray(Double_t *&d)=0; TBuffer::BufferSizeInt_t BufferSize() constDefinition TBuffer.h:98; TBuffer::ReadFastArrayvirtual void ReadFastArray(UChar_t *c, Int_t n)=0; TBuffer::EStatusBitsEStatusBitsDefinition TBuffer.h:74; TBuffer::kCannotHandleMemberWiseStreaming@ kCannotHandleMemberWiseStreamingDefinition TBuffer.h:76; TBuffer::kIsOwner@ kIsOwnerDefinition TBuffer.h:75; TBuffer::WriteFastArrayvirtual void WriteFastArray(const Short_t *h, Long64_t n)=0; TBuffer::WriteClonesvirtual Int_t WriteClones(TClonesArray *a, Int_t nobjects)=0; TBuffer::WriteObjectAnyvirtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE)=0; TBuffer::SetBuffervoid SetBuffer(void *buf, UInt_t bufsiz=0, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr)Sets a new buffer in an existing TBuffer object.Definition TBuffer.cxx:187; TBuffer::SetStreamerElementNumbervirtual void SetStreamerElementNumber(TStreamerElement *elem, Int_t comp_type)=0; TBuffer::ReadFastArrayvirtual void ReadFastArray(Float_t *f, Int_t n)=0; TBuffer::WriteShortvirtual void WriteShort(Short_t s)=0; TBuffer::WriteFastArrayvirtual void WriteFastArray(const ULong64_t *l, Long64_t n)=0; TBuffer::PushDataCachevirtual void PushDataCache(TVirtualArray *)Push a new data cache area onto the list of area to be used for temporarily store 'missing' data memb...Definition TBuffer.cxx:362; TBuffer::ReadCharPvirtual void ReadCharP(Char_t *c)=0; TBuffer::ReadFastArrayDouble32virtual void ReadFastArrayDouble32(Double_t *d, Int_t n, TStreamerElement *ele=nullptr)=0; TBuffer::SetReAllocFuncvoid SetReAllocF",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:34346,Performance,cache,cache,34346,"r::ReadFastArrayvirtual void ReadFastArray(UChar_t *c, Int_t n)=0; TBuffer::EStatusBitsEStatusBitsDefinition TBuffer.h:74; TBuffer::kCannotHandleMemberWiseStreaming@ kCannotHandleMemberWiseStreamingDefinition TBuffer.h:76; TBuffer::kIsOwner@ kIsOwnerDefinition TBuffer.h:75; TBuffer::WriteFastArrayvirtual void WriteFastArray(const Short_t *h, Long64_t n)=0; TBuffer::WriteClonesvirtual Int_t WriteClones(TClonesArray *a, Int_t nobjects)=0; TBuffer::WriteObjectAnyvirtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE)=0; TBuffer::SetBuffervoid SetBuffer(void *buf, UInt_t bufsiz=0, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr)Sets a new buffer in an existing TBuffer object.Definition TBuffer.cxx:187; TBuffer::SetStreamerElementNumbervirtual void SetStreamerElementNumber(TStreamerElement *elem, Int_t comp_type)=0; TBuffer::ReadFastArrayvirtual void ReadFastArray(Float_t *f, Int_t n)=0; TBuffer::WriteShortvirtual void WriteShort(Short_t s)=0; TBuffer::WriteFastArrayvirtual void WriteFastArray(const ULong64_t *l, Long64_t n)=0; TBuffer::PushDataCachevirtual void PushDataCache(TVirtualArray *)Push a new data cache area onto the list of area to be used for temporarily store 'missing' data memb...Definition TBuffer.cxx:362; TBuffer::ReadCharPvirtual void ReadCharP(Char_t *c)=0; TBuffer::ReadFastArrayDouble32virtual void ReadFastArrayDouble32(Double_t *d, Int_t n, TStreamerElement *ele=nullptr)=0; TBuffer::SetReAllocFuncvoid SetReAllocFunc(ReAllocCharFun_t reallocfunc=nullptr)Set which memory reallocation method to use.Definition TBuffer.cxx:286; TBuffer::WriteArrayvirtual void WriteArray(const Bool_t *b, Int_t n)=0; TBuffer::PopDataCachevirtual TVirtualArray * PopDataCache()Pop and Return the 'current' data cache area from the list of area to be used for temporarily store '...Definition TBuffer.cxx:381; TBuffer::ReadArrayvirtual Int_t ReadArray(Bool_t *&b)=0; TBuffer::EModeEModeDefinition TBuffer.h:73; TBuffer::kWrite@ kWriteDe",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:34955,Performance,cache,cache,34955,"ect.Definition TBuffer.cxx:187; TBuffer::SetStreamerElementNumbervirtual void SetStreamerElementNumber(TStreamerElement *elem, Int_t comp_type)=0; TBuffer::ReadFastArrayvirtual void ReadFastArray(Float_t *f, Int_t n)=0; TBuffer::WriteShortvirtual void WriteShort(Short_t s)=0; TBuffer::WriteFastArrayvirtual void WriteFastArray(const ULong64_t *l, Long64_t n)=0; TBuffer::PushDataCachevirtual void PushDataCache(TVirtualArray *)Push a new data cache area onto the list of area to be used for temporarily store 'missing' data memb...Definition TBuffer.cxx:362; TBuffer::ReadCharPvirtual void ReadCharP(Char_t *c)=0; TBuffer::ReadFastArrayDouble32virtual void ReadFastArrayDouble32(Double_t *d, Int_t n, TStreamerElement *ele=nullptr)=0; TBuffer::SetReAllocFuncvoid SetReAllocFunc(ReAllocCharFun_t reallocfunc=nullptr)Set which memory reallocation method to use.Definition TBuffer.cxx:286; TBuffer::WriteArrayvirtual void WriteArray(const Bool_t *b, Int_t n)=0; TBuffer::PopDataCachevirtual TVirtualArray * PopDataCache()Pop and Return the 'current' data cache area from the list of area to be used for temporarily store '...Definition TBuffer.cxx:381; TBuffer::ReadArrayvirtual Int_t ReadArray(Bool_t *&b)=0; TBuffer::EModeEModeDefinition TBuffer.h:73; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::kRead@ kReadDefinition TBuffer.h:73; TBuffer::fBufMaxchar * fBufMaxDefinition TBuffer.h:53; TBuffer::ReadStdStringvirtual void ReadStdString(std::string &s)Definition TBuffer.h:292; TBuffer::fBufCurchar * fBufCurDefinition TBuffer.h:52; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(Short_t *h)=0; TBuffer::ClassEndvirtual void ClassEnd(const TClass *)=0; TBuffer::WriteLong64virtual void WriteLong64(Long64_t l)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::AutoExpandvoid AutoExpand(Int_t size_needed)Automatically calculate a new size and expand the buffer to fit at least size_needed.Definition TBuffer.cxx:1",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:36300,Performance,cache,cache,36300,"kWriteDefinition TBuffer.h:73; TBuffer::kRead@ kReadDefinition TBuffer.h:73; TBuffer::fBufMaxchar * fBufMaxDefinition TBuffer.h:53; TBuffer::ReadStdStringvirtual void ReadStdString(std::string &s)Definition TBuffer.h:292; TBuffer::fBufCurchar * fBufCurDefinition TBuffer.h:52; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(Short_t *h)=0; TBuffer::ClassEndvirtual void ClassEnd(const TClass *)=0; TBuffer::WriteLong64virtual void WriteLong64(Long64_t l)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::AutoExpandvoid AutoExpand(Int_t size_needed)Automatically calculate a new size and expand the buffer to fit at least size_needed.Definition TBuffer.cxx:158; TBuffer::IsWritingBool_t IsWriting() constDefinition TBuffer.h:87; TBuffer::WriteCharvirtual void WriteChar(Char_t c)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char *classname)=0; TBuffer::ReadFastArrayvirtual void ReadFastArray(Bool_t *b, Int_t n)=0; TBuffer::PeekDataCachevirtual TVirtualArray * PeekDataCache() constReturn the 'current' data cache area from the list of area to be used for temporarily store 'missing'...Definition TBuffer.cxx:371; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(ULong64_t *l)=0; TBuffer::ReadClassBuffervirtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, const TClass *onfile_class=nullptr)=0; TBuffer::WriteBoolvirtual void WriteBool(Bool_t b)=0; TBuffer::ReadFastArrayvirtual void ReadFastArray(Short_t *h, Int_t n)=0; TBuffer::ReadArrayvirtual Int_t ReadArray(Long_t *&l)=0; TBuffer::WriteArrayvirtual void WriteArray(const Long_t *l, Int_t n)=0; TBuffer::ReadClassBuffervirtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, Int_t version, UInt_t start, UInt_t count, const TClass *onfile_class=nullptr)=0; TBuffer::kMinimalSize@ kMinimalSizeDefinition TBuffer.h:78; TBuffer::kInitialSize@ kInitialSizeDefinition TBuffer.h:78; TBuffer::WriteUShortvirt",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:41004,Performance,cache,cacheReuse,41004,"0; TBuffer::operator=void operator=(const TBuffer &)=delete; TBuffer::SetPidOffsetvirtual void SetPidOffset(UShort_t offset)=0; TBuffer::TBufferTBuffer(const TBuffer &)=delete; TBuffer::InitMapvirtual void InitMap()=0; TBuffer::GetReAllocFuncReAllocCharFun_t GetReAllocFunc() constReturn the reallocation method currently used.Definition TBuffer.cxx:277; TBuffer::fReAllocFuncReAllocCharFun_t fReAllocFuncDefinition TBuffer.h:55; TBuffer::fBufferchar * fBufferDefinition TBuffer.h:51; TBuffer::fParentTObject * fParentDefinition TBuffer.h:54; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(Bool_t *b)=0; TBuffer::WriteObjectvirtual void WriteObject(const TObject *obj, Bool_t cacheReuse)=0; TBuffer::WriteFastArrayFloat16virtual void WriteFastArrayFloat16(const Float_t *f, Long64_t n, TStreamerElement *ele=nullptr)=0; TBuffer::WriteFastArrayvirtual void WriteFastArray(const Bool_t *b, Long64_t n)=0; TBuffer::ReadFastArrayWithNbitsvirtual void ReadFastArrayWithNbits(Double_t *ptr, Int_t n, Int_t nbits)=0; TBuffer::ReadArrayvirtual Int_t ReadArray(Long64_t *&l)=0; TBuffer::ReadStaticArrayvirtual Int_t ReadStaticArray(Long64_t *l)=0; TBuffer::StreamObjectvirtual void StreamObject(void *obj, const TClass *cl, const TClass *onFileClass=nullptr)=0; TBuffer::WriteFastArrayvirtual void WriteFastArray(const Char_t *c, Long64_t n)=0; TBuffer::GetMapCountvirtual Int_t GetMapCount() const =0; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::GetLastProcessIDvirtual TProcessID * GetLastProcessID(TRefTable *reftable) const =0; TBuffer::ReadFastArrayWithFactorvirtual void ReadFastArrayWithFactor(Float_t *ptr, Int_t n, Double_t factor, Double_t minvalue)=0; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::GetBufferVersionInt_t GetBufferVersion() constDefinition TBuffer.h:85; TBuffer::ReadUCharvirtual void ReadUChar(UChar_t &c)=0; TBuffer::ReadArrayvirtual Int_t ReadArray(ULong64_t *&l",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:46774,Security,access,access,46774,"rray(const ULong_t *l, Int_t n)=0; TBuffer::ReadClassEmulatedvirtual Int_t ReadClassEmulated(const TClass *cl, void *object, const TClass *onfile_class=nullptr)=0; TBuffer::Bufferchar * Buffer() constDefinition TBuffer.h:96; TBuffer::ReadArrayvirtual Int_t ReadArray(Char_t *&c)=0; TBuffer::StreamObjectvirtual void StreamObject(void *obj, const std::type_info &typeinfo, const TClass *onFileClass=nullptr)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TMemberStreamerDefinition TMemberStreamer.h:26; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definition TObject.cxx:654; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TRefTableA TRefTable maintains the association between a referenced object and the parent object supporting th...Definition TRefTable.h:35; TStreamerElementDefinition TStreamerElement.h:32; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStringBasic string class.Definition TString.h:139; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; TStreamerInfoActionsDefinition TBuffer.h:39; lTLine lDefinition textangle.C:4. corebaseincTBuffer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:03 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TBuffer_8h_source.html:21487,Usability,usab,usable,21487,"TBuffer &buf, ULong64_t l){ buf.WriteULong64(l);return buf; }; 372inline TBuffer &operator<<(TBuffer &buf, Float_t f) { buf.WriteFloat(f); return buf; }; 373inline TBuffer &operator<<(TBuffer &buf, Double_t d) { buf.WriteDouble(d); return buf; }; 374inline TBuffer &operator<<(TBuffer &buf, const Char_t *c) { buf.WriteCharP(c); return buf; }; 375inline TBuffer &operator<<(TBuffer &buf, const TString &s) { buf.WriteTString(s);return buf; }; 376 ; 377#if defined(R__SOLARIS) && defined(R__GNU); 378#include <typeinfo>; 379#endif; 380 ; 381template <class Tmpl> TBuffer &operator>>(TBuffer &buf, Tmpl *&obj); 382{; 383 // Read TObject derived classes from a TBuffer. Need to provide; 384 // custom version for non-TObject derived classes.; 385 ; 386 // This operator has to be a templated and/or automatically; 387 // generated if we want to be able to check the type of the; 388 // incoming object. I.e. a operator>>(TBuffer &buf, TObject *&); 389 // would not be sufficient to pass the information 'which class do we want'; 390 // since the pointer could be zero (so typeid(*obj) is not usable).; 391 ; 392 auto cl = TClass::GetClass<Tmpl>();; 393 obj = (Tmpl *) ( (void*) buf.ReadObjectAny(cl) );; 394 return buf;; 395}; 396 ; 397template <class Tmpl> TBuffer &operator<<(TBuffer &buf, const Tmpl *obj); 398{; 399 auto cl = (obj) ? TClass::GetClass<Tmpl>() : nullptr;; 400 buf.WriteObjectAny(obj, cl);; 401 return buf;; 402}; 403 ; 404template <class T>; 405inline Int_t TBuffer::WriteObject(const T *objptr, Bool_t cacheReuse); 406{; 407 auto cl = (objptr) ? TClass::GetClass<T>() : nullptr;; 408 return WriteObjectAny(objptr, cl, cacheReuse);; 409}; 410 ; 411#endif // ROOT_TBuffer; Bytes.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsign",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:3384,Availability,avail,available,3384," display; 91manager. A ROOT session may have several canvases open at any given time.; 92 ; 93A Canvas may be subdivided into independent graphical areas: the __Pads__.; 94A canvas has a default pad which has the name of the canvas itself.; 95An example of a Canvas layout is sketched in the picture below.; 96 ; 97\image html gpad_canvas.png; 98 ; 99This canvas contains two pads named P1 and P2. Both Canvas, P1 and P2 can be; 100moved, grown, shrunk using the normal rules of the Display manager.; 101 ; 102Once objects have been drawn in a canvas, they can be edited/moved by pointing; 103directly to them. The cursor shape is changed to suggest the type of action that; 104one can do on this object. Clicking with the right mouse button on an object; 105pops-up a contextmenu with a complete list of actions possible on this object.; 106 ; 107A graphical editor may be started from the canvas ""View"" menu under the menu; 108entry ""Toolbar"".; 109 ; 110An interactive HELP is available by clicking on the HELP button at the top right; 111of the canvas. It gives a short explanation about the canvas' menus.; 112 ; 113A canvas may be automatically divided into pads via `TPad::Divide`.; 114 ; 115At creation time, no matter if in interactive or batch mode, the constructor; 116defines the size of the canvas window (including the size of the window; 117manager's decoration). To define precisely the graphics area size of a canvas in; 118the interactive mode, the following four lines of code should be used:; 119~~~ {.cpp}; 120 {; 121 Double_t w = 600;; 122 Double_t h = 600;; 123 auto c = new TCanvas(""c"", ""c"", w, h);; 124 c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; 125 }; 126~~~; 127and in the batch mode simply do:; 128~~~ {.cpp}; 129 c->SetCanvasSize(w,h);; 130~~~; 131 ; 132If the canvas size exceeds the window size, scroll bars will be added to the canvas; 133This allows to display very large canvases (even bigger than the screen size). The; 134Following example shows",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:23349,Availability,failure,failure,23349,"///////////////////; 675/// Canvas destructor; 676 ; 677TCanvas::~TCanvas(); 678{; 679 Destructor();; 680}; 681 ; 682////////////////////////////////////////////////////////////////////////////////; 683/// Browse.; 684 ; 685void TCanvas::Browse(TBrowser *b); 686{; 687 Draw();; 688 cd();; 689 if (fgIsFolder) fPrimitives->Browse(b);; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Actual canvas destructor.; 694 ; 695void TCanvas::Destructor(); 696{; 697 if (gThreadXAR) {; 698 void *arr[2];; 699 arr[1] = this;; 700 if ((*gThreadXAR)(""CDEL"", 2, arr, nullptr)) return;; 701 }; 702 ; 703 if (ROOT::Detail::HasBeenDeleted(this)) return;; 704 ; 705 SafeDelete(fContextMenu);; 706 if (!gPad) return;; 707 ; 708 Close();; 709 ; 710 //If not yet (batch mode?).; 711 SafeDelete(fPainter);; 712}; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Set current canvas & pad. Returns the new current pad,; 716/// or 0 in case of failure.; 717/// See TPad::cd() for an explanation of the parameter.; 718 ; 719TVirtualPad *TCanvas::cd(Int_t subpadnumber); 720{; 721 if (fCanvasID == -1) return nullptr;; 722 ; 723 TPad::cd(subpadnumber);; 724 ; 725 // in case doublebuffer is off, draw directly onto display window; 726 if (!IsBatch() && !IsWeb() && !fDoubleBuffer); 727 gVirtualX->SelectWindow(fCanvasID);//Ok, does not matter for glpad.; 728 ; 729 return gPad;; 730}; 731 ; 732////////////////////////////////////////////////////////////////////////////////; 733/// Remove all primitives from the canvas.; 734/// If option ""D"" is specified, direct sub-pads are cleared but not deleted.; 735/// This option is not recursive, i.e. pads in direct sub-pads are deleted.; 736 ; 737void TCanvas::Clear(Option_t *option); 738{; 739 if (fCanvasID == -1) return;; 740 ; 741 R__LOCKGUARD(gROOTMutex);; 742 ; 743 TString opt = option;; 744 opt.ToLower();; 745 if (opt.Contains(""d"")) {; 746 // clear subpads, but do no",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:39617,Availability,down,down,39617,"FillColor());; 1202 gStyle->SetCanvasBorderSize(fBorderSize);; 1203 gStyle->SetCanvasBorderMode(fBorderMode);; 1204 }; 1205}; 1206 ; 1207////////////////////////////////////////////////////////////////////////////////; 1208/// Returns current top x position of window on screen.; 1209 ; 1210Int_t TCanvas::GetWindowTopX(); 1211{; 1212 if (fCanvasImp) fCanvasImp->GetWindowGeometry(fWindowTopX, fWindowTopY,; 1213 fWindowWidth,fWindowHeight);; 1214 ; 1215 return fWindowTopX;; 1216}; 1217 ; 1218////////////////////////////////////////////////////////////////////////////////; 1219/// Returns current top y position of window on screen.; 1220 ; 1221Int_t TCanvas::GetWindowTopY(); 1222{; 1223 if (fCanvasImp) fCanvasImp->GetWindowGeometry(fWindowTopX, fWindowTopY,; 1224 fWindowWidth,fWindowHeight);; 1225 ; 1226 return fWindowTopY;; 1227}; 1228 ; 1229////////////////////////////////////////////////////////////////////////////////; 1230/// Handle Input Events.; 1231///; 1232/// Handle input events, like button up/down in current canvas.; 1233 ; 1234void TCanvas::HandleInput(EEventType event, Int_t px, Int_t py); 1235{; 1236 TPad *pad;; 1237 TPad *prevSelPad = fSelectedPad;; 1238 TObject *prevSelObj = fSelected;; 1239 ; 1240 fPadSave = (TPad*)gPad;; 1241 cd(); // make sure this canvas is the current canvas; 1242 ; 1243 fEvent = event;; 1244 fEventX = px;; 1245 fEventY = py;; 1246 ; 1247 switch (event) {; 1248 ; 1249 case kMouseMotion:; 1250 // highlight object tracked over; 1251 pad = Pick(px, py, prevSelObj);; 1252 if (!pad) return;; 1253 ; 1254 EnterLeave(prevSelPad, prevSelObj);; 1255 ; 1256 gPad = pad; // don't use cd() we will use the current; 1257 // canvas via the GetCanvas member and not via; 1258 // gPad->GetCanvas; 1259 ; 1260 if (fSelected) {; 1261 fSelected->ExecuteEvent(event, px, py);; 1262 RunAutoExec();; 1263 }; 1264 ; 1265 break;; 1266 ; 1267 case kMouseEnter:; 1268 // mouse enters canvas; 1269 if (!fDoubleBuffer) FeedbackMode(kTRUE);; 1270 break;; 1271 ; 1272 ca",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:41048,Availability,down,down,41048,"0 // highlight object tracked over; 1251 pad = Pick(px, py, prevSelObj);; 1252 if (!pad) return;; 1253 ; 1254 EnterLeave(prevSelPad, prevSelObj);; 1255 ; 1256 gPad = pad; // don't use cd() we will use the current; 1257 // canvas via the GetCanvas member and not via; 1258 // gPad->GetCanvas; 1259 ; 1260 if (fSelected) {; 1261 fSelected->ExecuteEvent(event, px, py);; 1262 RunAutoExec();; 1263 }; 1264 ; 1265 break;; 1266 ; 1267 case kMouseEnter:; 1268 // mouse enters canvas; 1269 if (!fDoubleBuffer) FeedbackMode(kTRUE);; 1270 break;; 1271 ; 1272 case kMouseLeave:; 1273 // mouse leaves canvas; 1274 {; 1275 // force popdown of tooltips; 1276 TObject *sobj = fSelected;; 1277 TPad *spad = fSelectedPad;; 1278 fSelected = nullptr;; 1279 fSelectedPad = nullptr;; 1280 EnterLeave(prevSelPad, prevSelObj);; 1281 fSelected = sobj;; 1282 fSelectedPad = spad;; 1283 if (!fDoubleBuffer) FeedbackMode(kFALSE);; 1284 }; 1285 break;; 1286 ; 1287 case kButton1Double:; 1288 // triggered on the second button down within 350ms and within; 1289 // 3x3 pixels of the first button down, button up finishes action; 1290 ; 1291 case kButton1Down:; 1292 // find pad in which input occurred; 1293 pad = Pick(px, py, prevSelObj);; 1294 if (!pad) return;; 1295 ; 1296 gPad = pad; // don't use cd() because we won't draw in pad; 1297 // we will only use its coordinate system; 1298 ; 1299 if (fSelected) {; 1300 FeedbackMode(kTRUE); // to draw in rubberband mode; 1301 fSelected->ExecuteEvent(event, px, py);; 1302 ; 1303 RunAutoExec();; 1304 }; 1305 ; 1306 break;; 1307 ; 1308 case kArrowKeyPress:; 1309 case kArrowKeyRelease:; 1310 case kButton1Motion:; 1311 case kButton1ShiftMotion: //8 == kButton1Motion + shift modifier; 1312 if (fSelected) {; 1313 gPad = fSelectedPad;; 1314 ; 1315 fSelected->ExecuteEvent(event, px, py);; 1316 if (!IsWeb()); 1317 gVirtualX->Update();; 1318 if (fSelected && !fSelected->InheritsFrom(TAxis::Class())) {; 1319 Bool_t resize = kFALSE;; 1320 if (fSelected->InheritsFrom(TBox::Class()))",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:41117,Availability,down,down,41117,"j);; 1252 if (!pad) return;; 1253 ; 1254 EnterLeave(prevSelPad, prevSelObj);; 1255 ; 1256 gPad = pad; // don't use cd() we will use the current; 1257 // canvas via the GetCanvas member and not via; 1258 // gPad->GetCanvas; 1259 ; 1260 if (fSelected) {; 1261 fSelected->ExecuteEvent(event, px, py);; 1262 RunAutoExec();; 1263 }; 1264 ; 1265 break;; 1266 ; 1267 case kMouseEnter:; 1268 // mouse enters canvas; 1269 if (!fDoubleBuffer) FeedbackMode(kTRUE);; 1270 break;; 1271 ; 1272 case kMouseLeave:; 1273 // mouse leaves canvas; 1274 {; 1275 // force popdown of tooltips; 1276 TObject *sobj = fSelected;; 1277 TPad *spad = fSelectedPad;; 1278 fSelected = nullptr;; 1279 fSelectedPad = nullptr;; 1280 EnterLeave(prevSelPad, prevSelObj);; 1281 fSelected = sobj;; 1282 fSelectedPad = spad;; 1283 if (!fDoubleBuffer) FeedbackMode(kFALSE);; 1284 }; 1285 break;; 1286 ; 1287 case kButton1Double:; 1288 // triggered on the second button down within 350ms and within; 1289 // 3x3 pixels of the first button down, button up finishes action; 1290 ; 1291 case kButton1Down:; 1292 // find pad in which input occurred; 1293 pad = Pick(px, py, prevSelObj);; 1294 if (!pad) return;; 1295 ; 1296 gPad = pad; // don't use cd() because we won't draw in pad; 1297 // we will only use its coordinate system; 1298 ; 1299 if (fSelected) {; 1300 FeedbackMode(kTRUE); // to draw in rubberband mode; 1301 fSelected->ExecuteEvent(event, px, py);; 1302 ; 1303 RunAutoExec();; 1304 }; 1305 ; 1306 break;; 1307 ; 1308 case kArrowKeyPress:; 1309 case kArrowKeyRelease:; 1310 case kButton1Motion:; 1311 case kButton1ShiftMotion: //8 == kButton1Motion + shift modifier; 1312 if (fSelected) {; 1313 gPad = fSelectedPad;; 1314 ; 1315 fSelected->ExecuteEvent(event, px, py);; 1316 if (!IsWeb()); 1317 gVirtualX->Update();; 1318 if (fSelected && !fSelected->InheritsFrom(TAxis::Class())) {; 1319 Bool_t resize = kFALSE;; 1320 if (fSelected->InheritsFrom(TBox::Class())); 1321 resize = ((TBox*)fSelected)->IsBeingResized();; 1322 if (fSele",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:62796,Availability,avail,available,62796,"always stays set.; 1959 ; 1960void TCanvas::SetBatch(Bool_t batch); 1961{; 1962 if (gROOT->IsBatch() || IsWeb()); 1963 fBatch = kTRUE;; 1964 else; 1965 fBatch = batch;; 1966}; 1967 ; 1968////////////////////////////////////////////////////////////////////////////////; 1969/// Set Width and Height of canvas to ww and wh respectively. If ww and/or wh; 1970/// are greater than the current canvas window a scroll bar is automatically; 1971/// generated. Use this function to zoom in a canvas and navigate via; 1972/// the scroll bars. The Width and Height in this method are different from those; 1973/// given in the TCanvas constructors where these two dimension include the size; 1974/// of the window decoration whereas they do not in this method.; 1975/// When both ww==0 and wh==0, auto resize mode will be enabled again and; 1976/// canvas drawing area will automatically fit available window size; 1977 ; 1978void TCanvas::SetCanvasSize(UInt_t ww, UInt_t wh); 1979{; 1980 if (fCanvasImp) {; 1981 fCw = ww;; 1982 fCh = wh;; 1983 fCanvasImp->SetCanvasSize(ww, wh);; 1984 TContext ctxt(this, kTRUE);; 1985 ResizePad();; 1986 }; 1987}; 1988 ; 1989////////////////////////////////////////////////////////////////////////////////; 1990/// Set cursor.; 1991 ; 1992void TCanvas::SetCursor(ECursor cursor); 1993{; 1994 if (!IsBatch() && !IsWeb()); 1995 gVirtualX->SetCursor(fCanvasID, cursor);; 1996}; 1997 ; 1998////////////////////////////////////////////////////////////////////////////////; 1999/// Set Double Buffer On/Off.; 2000 ; 2001void TCanvas::SetDoubleBuffer(Int_t mode); 2002{; 2003 if (IsBatch() || IsWeb()); 2004 return;; 2005 fDoubleBuffer = mode;; 2006 gVirtualX->SetDoubleBuffer(fCanvasID, mode);; 2007 ; 2008 // depending of the buffer mode set the drawing window to either; 2009 // the canvas pixmap or to the canvas on-screen window; 2010 if (fDoubleBuffer) {; 2011 if (fPixmapID != -1) fPainter->SelectDrawable(fPixmapID);; 2012 } else; 2013 if (fCanvasID != -1) fPainter->SelectDr",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:65593,Availability,error,error,65593,"ot fix aspect ratio, height of canvas is 0"");; 2027 return;; 2028 }; 2029 fFixedAspectRatio = kTRUE;; 2030 }; 2031 } else {; 2032 fFixedAspectRatio = kFALSE;; 2033 fAspectRatio = 0;; 2034 }; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// If isfolder=kTRUE, the canvas can be browsed like a folder; 2039/// by default a canvas is not browsable.; 2040 ; 2041void TCanvas::SetFolder(Bool_t isfolder); 2042{; 2043 fgIsFolder = isfolder;; 2044}; 2045 ; 2046////////////////////////////////////////////////////////////////////////////////; 2047/// Set canvas name. In case `name` is an empty string, a default name is set.; 2048/// Canvas automatically marked as modified when SetName method called; 2049 ; 2050void TCanvas::SetName(const char *name); 2051{; 2052 fName = GetNewCanvasName(name);; 2053 ; 2054 Modified();; 2055}; 2056 ; 2057 ; 2058////////////////////////////////////////////////////////////////////////////////; 2059/// Function to resize a canvas so that the plot inside is shown in real aspect; 2060/// ratio; 2061///; 2062/// \param[in] axis 1 for resizing horizontally (x-axis) in order to get real; 2063/// aspect ratio, 2 for the resizing vertically (y-axis); 2064/// \return false if error is encountered, true otherwise; 2065///; 2066/// ~~~ {.cpp}; 2067/// hpxpy->Draw();; 2068/// c1->SetRealAspectRatio();; 2069/// ~~~; 2070///; 2071/// - For defining the concept of real aspect ratio, it is assumed that x and y; 2072/// axes are in same units, e.g. both in MeV or both in ns.; 2073/// - You can resize either the width of the canvas or the height, but not both; 2074/// at the same time; 2075/// - Call this function AFTER drawing AND zooming (SetUserRange) your TGraph or; 2076/// Histogram, otherwise it cannot infer your actual axes lengths; 2077/// - This function ensures that the TFrame has a real aspect ratio, this does not; 2078/// mean that the full pad (i.e. the canvas or png output) including margins has",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:121023,Availability,error,error,121023,"ject::Clearvirtual void Clear(Option_t *="""")Definition TObject.h:119; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::ExecuteEventvirtual void ExecuteEvent(Int_t event, Int_t px, Int_t py)Execute action corresponding to an event at (px,py).Definition TObject.cxx:398; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::GetObjectInfovirtual char * GetObjectInfo(Int_t px, Int_t py) constReturns string containing info about the object at position (px,py).Definition TObject.cxx:473; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::Popvirtual void Pop()Pop on object drawn in a pad to the top of the display ",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:121783,Availability,error,error,121783,"ject::ExecuteEventvirtual void ExecuteEvent(Int_t event, Int_t px, Int_t py)Execute action corresponding to an event at (px,py).Definition TObject.cxx:398; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::GetObjectInfovirtual char * GetObjectInfo(Int_t px, Int_t py) constReturns string containing info about the object at position (px,py).Definition TObject.cxx:473; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::Popvirtual void Pop()Pop on object drawn in a pad to the top of the display list.Definition TObject.cxx:621; TObject::kNoContextMenu@ kNoContextMenuif object does not want context menuDefinition TObject.h:69; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPadPainterImplement TVirtualPadPainter which abstracts painting operations.Definition TPadPainter.h:26; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::GetBorderModeShort_t GetBorderMode() const overrideDefinition TPad.h:199; TPad::SetBorderSizevoid SetBorderSize(Short_t bordersize) overrideDefinition TPad.h:326; TPad::GetTickyInt_t GetTicky() const overrideDe",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:127503,Availability,down,down,127503,"as * GetCanvas() const overrideDefinition TPad.h:262; TPad::fBorderSizeShort_t fBorderSizepad bordersize in pixelsDefinition TPad.h:97; TPad::Paintvoid Paint(Option_t *option="""") overridePaint all primitives in pad.Definition TPad.cxx:3584; TPad::fNameTString fNamePad name.Definition TPad.h:109; TPad::fPixmapIDInt_t fPixmapID! Off-screen pixmap identifierDefinition TPad.h:84; TPad::FindObjectTObject * FindObject(const char *name) const overrideSearch if object named name is inside this pad or in pads inside this pad.Definition TPad.cxx:2700; TPad::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet Current pad.Definition TPad.cxx:693; TPad::GetLogyInt_t GetLogy() const overrideDefinition TPad.h:257; TPad::SetBorderModevoid SetBorderMode(Short_t bordermode) overrideDefinition TPad.h:325; TPad::SetTicksvoid SetTicks(Int_t valuex=1, Int_t valuey=1) overrideDefinition TPad.h:355; TPad::fY2Double_t fY2Y of upper Y coordinate.Definition TPad.h:39; TPad::fBorderModeShort_t fBorderModeBordermode (-1=down, 0 = no border, 1=up)Definition TPad.h:98; TPad::SetLogxvoid SetLogx(Int_t value=1) overrideSet Lin/Log scale for X.Definition TPad.cxx:6086; TPad::GetLogxInt_t GetLogx() const overrideDefinition TPad.h:256; TPad::GetX2Double_t GetX2() const overrideDefinition TPad.h:241; TPad::GetX1Double_t GetX1() const overrideDefinition TPad.h:240; TPad::fMotherTPad * fMother! pointer to mother of the listDefinition TPad.h:105; TPad::GetNameconst char * GetName() const overrideReturns name of object.Definition TPad.h:260; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887;",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:37813,Deployability,update,update,37813,"/////////; 1143/// Flush canvas buffers.; 1144 ; 1145void TCanvas::Flush(); 1146{; 1147 if ((fCanvasID == -1) || IsWeb()) return;; 1148 ; 1149 TContext ctxt(this, kTRUE);; 1150 if (!IsBatch()) {; 1151 if (!UseGL() || fGLDevice == -1) {; 1152 gVirtualX->SelectWindow(fCanvasID);; 1153 gPad = ctxt.GetSaved(); //don't do cd() because than also the pixmap is changed; 1154 CopyPixmaps();; 1155 gVirtualX->UpdateWindow(1);; 1156 } else {; 1157 TVirtualPS *tvps = gVirtualPS;; 1158 gVirtualPS = nullptr;; 1159 gGLManager->MakeCurrent(fGLDevice);; 1160 fPainter->InitPainter();; 1161 Paint();; 1162 if (ctxt.GetSaved() && ctxt.GetSaved()->GetCanvas() == this) {; 1163 ctxt.GetSaved()->cd();; 1164 ctxt.GetSaved()->HighLight(ctxt.GetSaved()->GetHighLightColor());; 1165 //cd();; 1166 }; 1167 fPainter->LockPainter();; 1168 gGLManager->Flush(fGLDevice);; 1169 gVirtualPS = tvps;; 1170 }; 1171 }; 1172}; 1173 ; 1174////////////////////////////////////////////////////////////////////////////////; 1175/// Force canvas update; 1176 ; 1177void TCanvas::ForceUpdate(); 1178{; 1179 if (fCanvasImp) fCanvasImp->ForceUpdate();; 1180}; 1181 ; 1182////////////////////////////////////////////////////////////////////////////////; 1183/// Force a copy of current style for all objects in canvas.; 1184 ; 1185void TCanvas::UseCurrentStyle(); 1186{; 1187 if (!gROOT->IsLineProcessing() && !gVirtualX->IsCmdThread()) {; 1188 gInterpreter->Execute(this, IsA(), ""UseCurrentStyle"", """");; 1189 return;; 1190 }; 1191 ; 1192 R__LOCKGUARD(gROOTMutex);; 1193 ; 1194 TPad::UseCurrentStyle();; 1195 ; 1196 if (gStyle->IsReading()) {; 1197 SetFillColor(gStyle->GetCanvasColor());; 1198 fBorderSize = gStyle->GetCanvasBorderSize();; 1199 fBorderMode = gStyle->GetCanvasBorderMode();; 1200 } else {; 1201 gStyle->SetCanvasColor(GetFillColor());; 1202 gStyle->SetCanvasBorderSize(fBorderSize);; 1203 gStyle->SetCanvasBorderMode(fBorderMode);; 1204 }; 1205}; 1206 ; 1207//////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:42774,Deployability,update,update,42774,"; 1313 gPad = fSelectedPad;; 1314 ; 1315 fSelected->ExecuteEvent(event, px, py);; 1316 if (!IsWeb()); 1317 gVirtualX->Update();; 1318 if (fSelected && !fSelected->InheritsFrom(TAxis::Class())) {; 1319 Bool_t resize = kFALSE;; 1320 if (fSelected->InheritsFrom(TBox::Class())); 1321 resize = ((TBox*)fSelected)->IsBeingResized();; 1322 if (fSelected->InheritsFrom(TVirtualPad::Class())); 1323 resize = ((TVirtualPad*)fSelected)->IsBeingResized();; 1324 ; 1325 if ((!resize && TestBit(kMoveOpaque)) || (resize && TestBit(kResizeOpaque))) {; 1326 gPad = fPadSave;; 1327 Update();; 1328 FeedbackMode(kTRUE);; 1329 }; 1330 }; 1331 ; 1332 RunAutoExec();; 1333 }; 1334 ; 1335 break;; 1336 ; 1337 case kButton1Up:; 1338 ; 1339 if (fSelected) {; 1340 gPad = fSelectedPad;; 1341 ; 1342 fSelected->ExecuteEvent(event, px, py);; 1343 ; 1344 RunAutoExec();; 1345 ; 1346 if (fPadSave); 1347 gPad = fPadSave;; 1348 else {; 1349 gPad = this;; 1350 fPadSave = this;; 1351 }; 1352 ; 1353 Update(); // before calling update make sure gPad is reset; 1354 }; 1355 break;; 1356 ; 1357//*-*----------------------------------------------------------------------; 1358 ; 1359 case kButton2Down:; 1360 // find pad in which input occurred; 1361 pad = Pick(px, py, prevSelObj);; 1362 if (!pad) return;; 1363 ; 1364 gPad = pad; // don't use cd() because we won't draw in pad; 1365 // we will only use its coordinate system; 1366 ; 1367 FeedbackMode(kTRUE);; 1368 ; 1369 if (fSelected) fSelected->Pop(); // pop object to foreground; 1370 pad->cd(); // and make its pad the current pad; 1371 if (gDebug); 1372 printf(""Current Pad: %s / %s\n"", pad->GetName(), pad->GetTitle());; 1373 ; 1374 // loop over all canvases to make sure that only one pad is highlighted; 1375 {; 1376 TIter next(gROOT->GetListOfCanvases());; 1377 TCanvas *tc;; 1378 while ((tc = (TCanvas *)next())); 1379 tc->Update();; 1380 }; 1381 ; 1382 //if (pad->GetGLDevice() != -1 && fSelected); 1383 // fSelected->ExecuteEvent(event, px, py);; 1384 ; 1385 break; // d",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:72390,Deployability,update,update,72390,"nvas = this;; 2231 if (v>7) b.ClassBegin(TCanvas::IsA());; 2232 if (v>7) b.ClassMember(""TPad"");; 2233 TPad::Streamer(b);; 2234 gPad = this;; 2235 //restore the colors; 2236 auto colors = dynamic_cast<TObjArray *>(fPrimitives->FindObject(""ListOfColors""));; 2237 if (colors) {; 2238 auto root_colors = dynamic_cast<TObjArray *>(gROOT->GetListOfColors());; 2239 ; 2240 TIter next(colors);; 2241 while (auto colold = static_cast<TColor *>(next())) {; 2242 Int_t cn = colold->GetNumber();; 2243 TColor *colcur = gROOT->GetColor(cn);; 2244 if (colcur && (colcur->IsA() == TColor::Class()) && (colold->IsA() == TColor::Class())) {; 2245 colcur->SetName(colold->GetName());; 2246 colcur->SetRGB(colold->GetRed(), colold->GetGreen(), colold->GetBlue());; 2247 colcur->SetAlpha(colold->GetAlpha());; 2248 } else {; 2249 if (colcur) {; 2250 if (root_colors) root_colors->Remove(colcur);; 2251 delete colcur;; 2252 }; 2253 colors->Remove(colold);; 2254 if (root_colors) {; 2255 if (colcur) {; 2256 root_colors->AddAtAndExpand(colold, cn);; 2257 }; 2258 else {; 2259 // Copy to current session; 2260 // do not use copy constructor which does not update highest color index; 2261 [[maybe_unused]] TColor* const colnew = new TColor(cn, colold->GetRed(), colold->GetGreen(), colold->GetBlue(), colold->GetName(), colold->GetAlpha());; 2262 delete colold;; 2263 // No need to delete colnew, as the constructor adds it to global list of colors; 2264 assert(root_colors->At(cn) == colnew);; 2265 }; 2266 }; 2267 }; 2268 }; 2269 //restore the palette if needed; 2270 auto palette = dynamic_cast<TObjArray *>(fPrimitives->FindObject(""CurrentColorPalette""));; 2271 if (palette) {; 2272 TIter nextcol(palette);; 2273 Int_t number = palette->GetEntries();; 2274 TArrayI palcolors(number);; 2275 Int_t i = 0;; 2276 while (auto col = static_cast<TColor *>(nextcol())); 2277 palcolors[i++] = col->GetNumber();; 2278 gStyle->SetPalette(number, palcolors.GetArray());; 2279 fPrimitives->Remove(palette);; 2280 delete palette;; 228",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:82344,Deployability,update,update,82344,"/////////////; 2490/// Update canvas pad buffers.; 2491 ; 2492void TCanvas::Update(); 2493{; 2494 fUpdated = kTRUE;; 2495 ; 2496 if (fUpdating) return;; 2497 ; 2498 if (fPixmapID == -1) return;; 2499 ; 2500 static const union CastFromFuncToVoidPtr_t {; 2501 CastFromFuncToVoidPtr_t(): fFuncPtr(ROOT_TCanvas_Update) {}; 2502 void (*fFuncPtr)(void*);; 2503 void* fVoidPtr;; 2504 } castFromFuncToVoidPtr;; 2505 ; 2506 if (gThreadXAR) {; 2507 void *arr[3];; 2508 arr[1] = this;; 2509 arr[2] = castFromFuncToVoidPtr.fVoidPtr;; 2510 if ((*gThreadXAR)(""CUPD"", 3, arr, nullptr)) return;; 2511 }; 2512 ; 2513 if (!fCanvasImp) return;; 2514 ; 2515 if (!gVirtualX->IsCmdThread()) {; 2516 // Why do we have this (which uses the interpreter to funnel the Update(); 2517 // through the main thread) when the gThreadXAR mechanism does seemingly; 2518 // the same?; 2519 gInterpreter->Execute(this, IsA(), ""Update"", """");; 2520 return;; 2521 }; 2522 ; 2523 R__LOCKGUARD(gROOTMutex);; 2524 ; 2525 fUpdating = kTRUE;; 2526 ; 2527 if (!fCanvasImp->PerformUpdate(kFALSE)) {; 2528 ; 2529 if (!IsBatch()) FeedbackMode(kFALSE); // Goto double buffer mode; 2530 ; 2531 if (!UseGL() || fGLDevice == -1) PaintModified(); // Repaint all modified pad's; 2532 ; 2533 Flush(); // Copy all pad pixmaps to the screen; 2534 ; 2535 SetCursor(kCross);; 2536 }; 2537 ; 2538 fUpdating = kFALSE;; 2539}; 2540 ; 2541////////////////////////////////////////////////////////////////////////////////; 2542/// Asynchronous pad update.; 2543/// In case of web-based canvas triggers update of the canvas on the client side,; 2544/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2545/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2546/// In case of normal canvas just canvas->Update() is performed.; 2547 ; 2548void TCanvas::UpdateAsync(); 2549{; 2550 fUpdated = kTRUE;; 2551 ; 2552 if (IsWeb()); 2553 fCanvasImp->PerformUpdate(kTRUE);; 2554 else; 2555 Update();; 2556",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:82398,Deployability,update,update,82398,"ullptr)) return;; 2511 }; 2512 ; 2513 if (!fCanvasImp) return;; 2514 ; 2515 if (!gVirtualX->IsCmdThread()) {; 2516 // Why do we have this (which uses the interpreter to funnel the Update(); 2517 // through the main thread) when the gThreadXAR mechanism does seemingly; 2518 // the same?; 2519 gInterpreter->Execute(this, IsA(), ""Update"", """");; 2520 return;; 2521 }; 2522 ; 2523 R__LOCKGUARD(gROOTMutex);; 2524 ; 2525 fUpdating = kTRUE;; 2526 ; 2527 if (!fCanvasImp->PerformUpdate(kFALSE)) {; 2528 ; 2529 if (!IsBatch()) FeedbackMode(kFALSE); // Goto double buffer mode; 2530 ; 2531 if (!UseGL() || fGLDevice == -1) PaintModified(); // Repaint all modified pad's; 2532 ; 2533 Flush(); // Copy all pad pixmaps to the screen; 2534 ; 2535 SetCursor(kCross);; 2536 }; 2537 ; 2538 fUpdating = kFALSE;; 2539}; 2540 ; 2541////////////////////////////////////////////////////////////////////////////////; 2542/// Asynchronous pad update.; 2543/// In case of web-based canvas triggers update of the canvas on the client side,; 2544/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2545/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2546/// In case of normal canvas just canvas->Update() is performed.; 2547 ; 2548void TCanvas::UpdateAsync(); 2549{; 2550 fUpdated = kTRUE;; 2551 ; 2552 if (IsWeb()); 2553 fCanvasImp->PerformUpdate(kTRUE);; 2554 else; 2555 Update();; 2556}; 2557 ; 2558////////////////////////////////////////////////////////////////////////////////; 2559/// Used by friend class TCanvasImp.; 2560 ; 2561void TCanvas::DisconnectWidget(); 2562{; 2563 fCanvasID = 0;; 2564 fContextMenu = nullptr;; 2565}; 2566 ; 2567////////////////////////////////////////////////////////////////////////////////; 2568/// Check whether this canvas is to be drawn in grayscale mode.; 2569 ; 2570Bool_t TCanvas::IsGrayscale(); 2571{; 2572 return TestBit(kIsGrayscale);; 2573}; 2574 ; 2575/////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:82476,Deployability,update,update,82476,"ullptr)) return;; 2511 }; 2512 ; 2513 if (!fCanvasImp) return;; 2514 ; 2515 if (!gVirtualX->IsCmdThread()) {; 2516 // Why do we have this (which uses the interpreter to funnel the Update(); 2517 // through the main thread) when the gThreadXAR mechanism does seemingly; 2518 // the same?; 2519 gInterpreter->Execute(this, IsA(), ""Update"", """");; 2520 return;; 2521 }; 2522 ; 2523 R__LOCKGUARD(gROOTMutex);; 2524 ; 2525 fUpdating = kTRUE;; 2526 ; 2527 if (!fCanvasImp->PerformUpdate(kFALSE)) {; 2528 ; 2529 if (!IsBatch()) FeedbackMode(kFALSE); // Goto double buffer mode; 2530 ; 2531 if (!UseGL() || fGLDevice == -1) PaintModified(); // Repaint all modified pad's; 2532 ; 2533 Flush(); // Copy all pad pixmaps to the screen; 2534 ; 2535 SetCursor(kCross);; 2536 }; 2537 ; 2538 fUpdating = kFALSE;; 2539}; 2540 ; 2541////////////////////////////////////////////////////////////////////////////////; 2542/// Asynchronous pad update.; 2543/// In case of web-based canvas triggers update of the canvas on the client side,; 2544/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2545/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2546/// In case of normal canvas just canvas->Update() is performed.; 2547 ; 2548void TCanvas::UpdateAsync(); 2549{; 2550 fUpdated = kTRUE;; 2551 ; 2552 if (IsWeb()); 2553 fCanvasImp->PerformUpdate(kTRUE);; 2554 else; 2555 Update();; 2556}; 2557 ; 2558////////////////////////////////////////////////////////////////////////////////; 2559/// Used by friend class TCanvasImp.; 2560 ; 2561void TCanvas::DisconnectWidget(); 2562{; 2563 fCanvasID = 0;; 2564 fContextMenu = nullptr;; 2565}; 2566 ; 2567////////////////////////////////////////////////////////////////////////////////; 2568/// Check whether this canvas is to be drawn in grayscale mode.; 2569 ; 2570Bool_t TCanvas::IsGrayscale(); 2571{; 2572 return TestBit(kIsGrayscale);; 2573}; 2574 ; 2575/////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:83796,Deployability,update,update,83796,"ate(kTRUE);; 2554 else; 2555 Update();; 2556}; 2557 ; 2558////////////////////////////////////////////////////////////////////////////////; 2559/// Used by friend class TCanvasImp.; 2560 ; 2561void TCanvas::DisconnectWidget(); 2562{; 2563 fCanvasID = 0;; 2564 fContextMenu = nullptr;; 2565}; 2566 ; 2567////////////////////////////////////////////////////////////////////////////////; 2568/// Check whether this canvas is to be drawn in grayscale mode.; 2569 ; 2570Bool_t TCanvas::IsGrayscale(); 2571{; 2572 return TestBit(kIsGrayscale);; 2573}; 2574 ; 2575////////////////////////////////////////////////////////////////////////////////; 2576/// Set whether this canvas should be painted in grayscale, and re-paint; 2577/// it if necessary.; 2578 ; 2579void TCanvas::SetGrayscale(Bool_t set /*= kTRUE*/); 2580{; 2581 if (IsGrayscale() == set) return;; 2582 SetBit(kIsGrayscale, set);; 2583 if (IsWeb()) {; 2584 Modified();; 2585 UpdateAsync();; 2586 } else {; 2587 Paint(); // update canvas and all sub-pads, unconditionally!; 2588 }; 2589}; 2590 ; 2591////////////////////////////////////////////////////////////////////////////////; 2592/// Probably, TPadPainter must be placed in a separate ROOT module -; 2593/// ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; 2594/// gpad dir, so, in case of default painter, no *.so should be loaded,; 2595/// no need in plugin managers.; 2596/// May change in future.; 2597 ; 2598void TCanvas::CreatePainter(); 2599{; 2600 //Even for batch mode painter is still required, just to delegate; 2601 //some calls to batch ""virtual X"".; 2602 if (!UseGL() || fBatch) {; 2603 fPainter = nullptr;; 2604 if (fCanvasImp) fPainter = fCanvasImp->CreatePadPainter();; 2605 if (!fPainter) fPainter = new TPadPainter; // Do not need plugin manager for this!; 2606 } else {; 2607 fPainter = TVirtualPadPainter::PadPainter(""gl"");; 2608 if (!fPainter) {; 2609 Error(""CreatePainter"", ""GL Painter creation failed! Will use default!"");; 2610 fPainter = new ",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:108079,Deployability,update,update,108079," canvas is to be drawn in grayscale mode.Definition TCanvas.cxx:2567; TCanvas::fClickSelectedPadTPad * fClickSelectedPad! Pad containing currently click-selected objectDefinition TCanvas.h:55; TCanvas::fUpdatingBool_t fUpdating! True when Updating the canvasDefinition TCanvas.h:60; TCanvas::SaveSourcevoid SaveSource(const char *filename="""", Option_t *option="""")Save primitives in this canvas as a C++ macro file.Definition TCanvas.cxx:1822; TCanvas::fHighLightColorColor_t fHighLightColorHighlight color of active pad.Definition TCanvas.h:37; TCanvas::Sizevirtual void Size(Float_t xsizeuser=0, Float_t ysizeuser=0)Set the canvas scale in centimeters.Definition TCanvas.cxx:2201; TCanvas::ProcessedEventvirtual void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject *selected)Emit ProcessedEvent() signal.Definition TCanvas.cxx:1653; TCanvas::HandleInputvirtual void HandleInput(EEventType button, Int_t x, Int_t y)Handle Input Events.Definition TCanvas.cxx:1234; TCanvas::UpdateAsyncvoid UpdateAsync() overrideAsynchronous pad update.Definition TCanvas.cxx:2545; TCanvas::fXsizeUserSize_t fXsizeUserUser specified size of canvas along X in CM.Definition TCanvas.h:33; TCanvas::fEventYInt_t fEventY! Last Y mouse position in canvasDefinition TCanvas.h:47; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TCanvas::fWindowHeightUInt_t fWindowHeightHeight of window (including menubar, borders, etc.)Definition TCanvas.h:42; TCanvas::GetWindowTopYInt_t GetWindowTopY()Returns current top y position of window on screen.Definition TCanvas.cxx:1221; TCanvas::fClickSelectedTObject * fClickSelected! Currently click-selected objectDefinition TCanvas.h:50; TCanvas::SetCanvasSizevoid SetCanvasSize(UInt_t ww, UInt_t wh) overrideSet Width and Height of canvas to ww and wh respectively.Definition TCanvas.cxx:1975; TCanvas::Showvoid Show()Show canvas.Definition TCanvas.cxx:2212; TCanvas::fSelectedPadTPad * fSelectedPad! Pad containing cur",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:113782,Deployability,update,update,113782,"rrideExecute action corresponding to one event.Definition TCanvas.cxx:1110; TCanvas::RunAutoExecvoid RunAutoExec()Execute the list of TExecs in the current pad.Definition TCanvas.cxx:1767; TCanvas::Clearedvirtual void Cleared(TVirtualPad *pad)Emit pad Cleared signal.Definition TCanvas.cxx:770; TCanvas::GetWwUInt_t GetWw() const overrideDefinition TCanvas.h:163; TCanvas::fCanvasImpTCanvasImp * fCanvasImp! Window system specific canvas implementationDefinition TCanvas.h:57; TCanvas::GetWhUInt_t GetWh() const overrideDefinition TCanvas.h:164; TCanvas::Highlightedvirtual void Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)Emit Highlighted() signal.Definition TCanvas.cxx:1612; TCanvas::Flushvoid Flush()Flush canvas buffers.Definition TCanvas.cxx:1145; TCanvas::fYsizeUserSize_t fYsizeUserUser specified size of canvas along Y in CM.Definition TCanvas.h:34; TCanvas::fDoubleBufferInt_t fDoubleBufferDouble buffer flag (0=off, 1=on)Definition TCanvas.h:38; TCanvas::ForceUpdatevoid ForceUpdate()Force canvas update.Definition TCanvas.cxx:1177; TCanvas::CreatePaintervoid CreatePainter()Probably, TPadPainter must be placed in a separate ROOT module - ""padpainter"" (the same as ""histpaint...Definition TCanvas.cxx:2595; TCanvas::SetSelectedvoid SetSelected(TObject *obj) overrideSet selected canvas.Definition TCanvas.cxx:2146; TCanvas::MoveOpaquevoid MoveOpaque(Int_t set=1)Set option to move objects/pads in a canvas.Definition TCanvas.cxx:1535; TCanvas::fgIsFolderstatic Bool_t fgIsFolderIndicates if canvas can be browsed as a folder.Definition TCanvas.h:68; TCanvas::Closedvoid Closed() overrideEmit Closed signal.Definition TCanvas.cxx:778; TCanvas::IsWebBool_t IsWeb() const overrideIs web canvas.Definition TCanvas.cxx:1496; TCanvas::SetWindowPositionvoid SetWindowPosition(Int_t x, Int_t y)Set canvas window position.Definition TCanvas.cxx:2164; TCanvas::fDISPLAYTString fDISPLAYName of destination screen.Definition TCanvas.h:32; TCanvas::SetRealAspectRatiobool SetRealAspec",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:70554,Energy Efficiency,allocate,allocated,70554,"p->SetWindowSize(ww, wh);; 2182}; 2183 ; 2184////////////////////////////////////////////////////////////////////////////////; 2185/// Set the canvas scale in centimeters.; 2186///; 2187/// This information is used by PostScript to set the page size.; 2188///; 2189/// \param[in] xsize size of the canvas in centimeters along X; 2190/// \param[in] ysize size of the canvas in centimeters along Y; 2191///; 2192/// if xsize and ysize are not equal to 0, then the scale factors will; 2193/// be computed to keep the ratio ysize/xsize independently of the canvas; 2194/// size (parts of the physical canvas will be unused).; 2195///; 2196/// if xsize = 0 and ysize is not zero, then xsize will be computed; 2197/// to fit to the current canvas scale. If the canvas is resized,; 2198/// a new value for xsize will be recomputed. In this case the aspect; 2199/// ratio is not preserved.; 2200///; 2201/// if both xsize = 0 and ysize = 0, then the scaling is automatic.; 2202/// the largest dimension will be allocated a size of 20 centimeters.; 2203 ; 2204void TCanvas::Size(Float_t xsize, Float_t ysize); 2205{; 2206 fXsizeUser = xsize;; 2207 fYsizeUser = ysize;; 2208 ; 2209 Resize();; 2210}; 2211 ; 2212////////////////////////////////////////////////////////////////////////////////; 2213/// Show canvas; 2214 ; 2215void TCanvas::Show(); 2216{; 2217 if (fCanvasImp); 2218 fCanvasImp->Show();; 2219}; 2220 ; 2221////////////////////////////////////////////////////////////////////////////////; 2222/// Stream a class object.; 2223 ; 2224void TCanvas::Streamer(TBuffer &b); 2225{; 2226 UInt_t R__s, R__c;; 2227 if (b.IsReading()) {; 2228 Version_t v = b.ReadVersion(&R__s, &R__c);; 2229 gPad = this;; 2230 fCanvas = this;; 2231 if (v>7) b.ClassBegin(TCanvas::IsA());; 2232 if (v>7) b.ClassMember(""TPad"");; 2233 TPad::Streamer(b);; 2234 gPad = this;; 2235 //restore the colors; 2236 auto colors = dynamic_cast<TObjArray *>(fPrimitives->FindObject(""ListOfColors""));; 2237 if (colors) {; 2238 auto root_colo",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:34537,Integrability,depend,depending,34537,"return;; 1030 }; 1031 }; 1032 // default; 1033 fCanvasImp->SetStatusText(selected->GetObjectInfo(px,py),3);; 1034}; 1035 ; 1036////////////////////////////////////////////////////////////////////////////////; 1037/// Get editor bar.; 1038 ; 1039void TCanvas::EditorBar(); 1040{; 1041 TVirtualPadEditor::GetPadEditor();; 1042}; 1043 ; 1044////////////////////////////////////////////////////////////////////////////////; 1045/// Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; 1046/// via TRootEmbeddedCanvas::AdoptCanvas.; 1047 ; 1048void TCanvas::EmbedInto(Int_t winid, Int_t ww, Int_t wh); 1049{; 1050 // If fCanvasImp already exists, no need to go further.; 1051 if(fCanvasImp) return;; 1052 ; 1053 fCanvasID = winid;; 1054 fWindowTopX = 0;; 1055 fWindowTopY = 0;; 1056 fWindowWidth = ww;; 1057 fWindowHeight = wh;; 1058 fCw = ww;; 1059 fCh = wh;; 1060 fBatch = kFALSE;; 1061 fUpdating = kFALSE;; 1062 ; 1063 fCanvasImp = gBatchGuiFactory->CreateCanvasImp(this, GetName(), fCw, fCh);; 1064 if (!fCanvasImp) return;; 1065 Build();; 1066 Resize();; 1067}; 1068 ; 1069////////////////////////////////////////////////////////////////////////////////; 1070/// Generate kMouseEnter and kMouseLeave events depending on the previously; 1071/// selected object and the currently selected object. Does nothing if the; 1072/// selected object does not change.; 1073 ; 1074void TCanvas::EnterLeave(TPad *prevSelPad, TObject *prevSelObj); 1075{; 1076 if (prevSelObj == fSelected) return;; 1077 ; 1078 TContext ctxt(kFALSE);; 1079 Int_t sevent = fEvent;; 1080 ; 1081 if (prevSelObj) {; 1082 gPad = prevSelPad;; 1083 prevSelObj->ExecuteEvent(kMouseLeave, fEventX, fEventY);; 1084 fEvent = kMouseLeave;; 1085 RunAutoExec();; 1086 ProcessedEvent(kMouseLeave, fEventX, fEventY, prevSelObj); // emit signal; 1087 }; 1088 ; 1089 gPad = fSelectedPad;; 1090 ; 1091 if (fSelected) {; 1092 fSelected->ExecuteEvent(kMouseEnter, fEventX, fEventY);; 1093 fEvent = kMouseEnter;; 1094 RunAutoExec();;",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:63643,Integrability,depend,depending,63643,"ea will automatically fit available window size; 1977 ; 1978void TCanvas::SetCanvasSize(UInt_t ww, UInt_t wh); 1979{; 1980 if (fCanvasImp) {; 1981 fCw = ww;; 1982 fCh = wh;; 1983 fCanvasImp->SetCanvasSize(ww, wh);; 1984 TContext ctxt(this, kTRUE);; 1985 ResizePad();; 1986 }; 1987}; 1988 ; 1989////////////////////////////////////////////////////////////////////////////////; 1990/// Set cursor.; 1991 ; 1992void TCanvas::SetCursor(ECursor cursor); 1993{; 1994 if (!IsBatch() && !IsWeb()); 1995 gVirtualX->SetCursor(fCanvasID, cursor);; 1996}; 1997 ; 1998////////////////////////////////////////////////////////////////////////////////; 1999/// Set Double Buffer On/Off.; 2000 ; 2001void TCanvas::SetDoubleBuffer(Int_t mode); 2002{; 2003 if (IsBatch() || IsWeb()); 2004 return;; 2005 fDoubleBuffer = mode;; 2006 gVirtualX->SetDoubleBuffer(fCanvasID, mode);; 2007 ; 2008 // depending of the buffer mode set the drawing window to either; 2009 // the canvas pixmap or to the canvas on-screen window; 2010 if (fDoubleBuffer) {; 2011 if (fPixmapID != -1) fPainter->SelectDrawable(fPixmapID);; 2012 } else; 2013 if (fCanvasID != -1) fPainter->SelectDrawable(fCanvasID);; 2014}; 2015 ; 2016////////////////////////////////////////////////////////////////////////////////; 2017/// Fix canvas aspect ratio to current value if fixed is true.; 2018 ; 2019void TCanvas::SetFixedAspectRatio(Bool_t fixed); 2020{; 2021 if (fixed) {; 2022 if (!fFixedAspectRatio) {; 2023 if (fCh != 0); 2024 fAspectRatio = Double_t(fCw) / fCh;; 2025 else {; 2026 Error(""SetAspectRatio"", ""cannot fix aspect ratio, height of canvas is 0"");; 2027 return;; 2028 }; 2029 fFixedAspectRatio = kTRUE;; 2030 }; 2031 } else {; 2032 fFixedAspectRatio = kFALSE;; 2033 fAspectRatio = 0;; 2034 }; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// If isfolder=kTRUE, the canvas can be browsed like a folder; 2039/// by default a canvas is not browsable.; 2040 ; 2041void TCanvas::SetFolder(",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:102697,Integrability,depend,depending,102697,"inition TCanvas.h:43; TCanvas::~TCanvas~TCanvas() overrideCanvas destructor.Definition TCanvas.cxx:677; TCanvas::EmbedIntovoid EmbedInto(Int_t winid, Int_t ww, Int_t wh)Embedded a canvas into a TRootEmbeddedCanvas.Definition TCanvas.cxx:1048; TCanvas::SetWindowSizevoid SetWindowSize(UInt_t ww, UInt_t wh)Set canvas window size.Definition TCanvas.cxx:2173; TCanvas::SetFolderstatic void SetFolder(Bool_t isfolder=kTRUE)If isfolder=kTRUE, the canvas can be browsed like a folder by default a canvas is not browsable.Definition TCanvas.cxx:2038; TCanvas::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TCanvas.cxx:685; TCanvas::GetWindowHeightUInt_t GetWindowHeight() constDefinition TCanvas.h:162; TCanvas::EditorBarvirtual void EditorBar()Get editor bar.Definition TCanvas.cxx:1039; TCanvas::MakeDefCanvasstatic TCanvas * MakeDefCanvas()Static function to build a default canvas.Definition TCanvas.cxx:1516; TCanvas::EnterLeavevoid EnterLeave(TPad *prevSelPad, TObject *prevSelObj)Generate kMouseEnter and kMouseLeave events depending on the previously selected object and the curre...Definition TCanvas.cxx:1074; TCanvas::fYsizeRealSize_t fYsizeRealCurrent size of canvas along Y in CM.Definition TCanvas.h:36; TCanvas::Constructorvoid Constructor()Canvas default constructor.Definition TCanvas.cxx:191; TCanvas::ToggleAutoExecvirtual void ToggleAutoExec()Toggle pad auto execution of list of TExecs.Definition TCanvas.cxx:2422; TCanvas::TCanvasTCanvas(const TCanvas &canvas)=delete; TCanvas::fWindowTopXInt_t fWindowTopXTop X position of window (in pixels)Definition TCanvas.h:39; TCanvas::Drawvoid Draw(Option_t *option="""") overrideDraw a canvas.Definition TCanvas.cxx:854; TCanvas::SetDoubleBuffervoid SetDoubleBuffer(Int_t mode=1) overrideSet Double Buffer On/Off.Definition TCanvas.cxx:1998; TCanvas::ToggleToolTipsvirtual void ToggleToolTips()Toggle tooltip display.Definition TCanvas.cxx:2464; TCanvas::Clearvoid Clear(Option_t *option="""") overrideRemove all primitives from the canv",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:117652,Integrability,interface,interface,117652,"const TArrayI & GetPalette()Static function returning the current active palette.Definition TColor.cxx:1516; TColor::SaveColorstatic Bool_t SaveColor(std::ostream &out, Int_t ci)Save a color with index > 228 as a C++ statement(s) on output stream out.Definition TColor.cxx:2543; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::SetNamevoid SetName(const char *name) overrideSet the color name and change also the name of the ""dark"" and ""bright"" associated colors if they exis...Definition TColor.cxx:1826; TColor::Classstatic TClass * Class(); TColor::DefinedColorsstatic Bool_t DefinedColors(Int_t set_always_on=0)Static method returning kTRUE if some new colors have been defined after initialisation or since the ...Definition TColor.cxx:1537; TColor::SetAlphavirtual void SetAlpha(Float_t a)Definition TColor.h:70; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TContextMenu::Popupvirtual void Popup(Int_t x, Int_t y, TObject *obj, TVirtualPad *c=nullptr, TVirtualPad *p=nullptr)Popup context menu at given location in canvas c and pad p for selected object.Definition TContextMenu.cxx:411; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::AsSQLStringconst char * AsSQLString() constReturn the date & time in SQL compatible string format, like: 1997-01-15 20:16:28.Definition TDatime.cxx:152; TDatime::ConvertUInt_t Convert(Bool_t toGMT=kFALSE) constConvert fDatime from TDatime format to the standard time_t format.Definition TDatime.cxx:182; TDatime::AsStringconst char * AsString() constReturn the date & time as a string (ctime() format).Definition TDatime.cxx:102; TDialogCanvas::Classstatic TClass * Class(); TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:120744,Integrability,message,message,120744,"nd a TObject so it can be stored in a TList.Definition TList.h:123; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::GetOptionvirtual Option_t * GetOption() constDefinition TList.h:149; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Clearvirtual void Clear(Option_t *="""")Definition TObject.h:119; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::ExecuteEventvirtual void ExecuteEvent(Int_t event, Int_t px, Int_t py)Execute action corresponding to an event at (px,py).Definition TObject.cxx:398; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::GetObjectInfovirtual char * GetObjectInfo(Int_t px, Int_t py) constReturns string containing info about the object at position (px,py).Definition TObject.cxx:473; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:121789,Integrability,message,message,121789,"ject::ExecuteEventvirtual void ExecuteEvent(Int_t event, Int_t px, Int_t py)Execute action corresponding to an event at (px,py).Definition TObject.cxx:398; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::GetObjectInfovirtual char * GetObjectInfo(Int_t px, Int_t py) constReturns string containing info about the object at position (px,py).Definition TObject.cxx:473; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::Popvirtual void Pop()Pop on object drawn in a pad to the top of the display list.Definition TObject.cxx:621; TObject::kNoContextMenu@ kNoContextMenuif object does not want context menuDefinition TObject.h:69; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPadPainterImplement TVirtualPadPainter which abstracts painting operations.Definition TPadPainter.h:26; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::GetBorderModeShort_t GetBorderMode() const overrideDefinition TPad.h:199; TPad::SetBorderSizevoid SetBorderSize(Short_t bordersize) overrideDefinition TPad.h:326; TPad::GetTickyInt_t GetTicky() const overrideDe",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:122348,Integrability,message,message,122348,"on_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::Popvirtual void Pop()Pop on object drawn in a pad to the top of the display list.Definition TObject.cxx:621; TObject::kNoContextMenu@ kNoContextMenuif object does not want context menuDefinition TObject.h:69; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPadPainterImplement TVirtualPadPainter which abstracts painting operations.Definition TPadPainter.h:26; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::GetBorderModeShort_t GetBorderMode() const overrideDefinition TPad.h:199; TPad::SetBorderSizevoid SetBorderSize(Short_t bordersize) overrideDefinition TPad.h:326; TPad::GetTickyInt_t GetTicky() const overrideDefinition TPad.h:239; TPad::PaintBordervoid PaintBorder(Color_t color, Bool_t tops)Paint the pad border.Definition TPad.cxx:3644; TPad::ResizePadvoid ResizePad(Option_t *option="""") overrideCompute pad conversion coefficients.Definition TPad.cxx:5624; TPad::SetGridvoid SetGrid(Int_t valuex=1, Int_t valuey=1) overrideDefinition TPad.h:335; TPad::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitives in this pad on the C++ source file out.Definition TPad.cxx:5847; TPad::GetGridxBool_t GetGridx() const overrideDefinit",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:132811,Integrability,interface,interface,132811,"ridX() constDefinition TStyle.h:215; TStyle::GetPadTickYInt_t GetPadTickY() constDefinition TStyle.h:218; TStyle::GetCanvasColorColor_t GetCanvasColor() constDefinition TStyle.h:188; TStyle::GetPadBottomMarginFloat_t GetPadBottomMargin() constDefinition TStyle.h:211; TStyle::GetCanvasDefWInt_t GetCanvasDefW() constDefinition TStyle.h:192; TStyle::GetOptLogxInt_t GetOptLogx() constDefinition TStyle.h:247; TStyle::GetCanvasBorderModeInt_t GetCanvasBorderMode() constDefinition TStyle.h:190; TStyle::GetCanvasBorderSizeWidth_t GetCanvasBorderSize() constDefinition TStyle.h:189; TStyle::GetOptFitInt_t GetOptFit() constDefinition TStyle.h:244; TStyle::GetOptLogzInt_t GetOptLogz() constDefinition TStyle.h:249; TStyle::GetPadTopMarginFloat_t GetPadTopMargin() constDefinition TStyle.h:212; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TView::Classstatic TClass * Class(); TVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG.Definition TVirtualPS.h:30; TVirtualPadEditor::GetPadEditorstatic TVirtualPadEditor * GetPadEditor(Bool_t load=kTRUE)Returns the pad editor dialog. Static method.Definition TVirtualPadEditor.cxx:74; TVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas.Definition TVirtualPadPainter.h:19; TVirtualPadPainter::LockPaintervirtual void LockPainter()Empty definition.Definition TVirtualPadPainter.cxx:51; TVirtualPadPainter::PadPainterstatic TVirtualPadPainter * PadPainter(Option_t *opt="""")Create a pad painter of specified type.Definition TVirtualPadPainter.cxx:58; TVirtualPadPainter::SelectDrawablevirtual void SelectDrawable(Int_t device)=0; TVirtualPadPainter::InitPaintervirtual void InitPainter()Empty definition.Definition TVirtualPadPainter.cxx:37; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; TVirtualPad::TContext::GetSavedauto GetSaved()",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:57158,Modifiability,variab,variable,57158,""" ""<<GetName()<<""->ToggleToolTips();""<<std::endl;; 1798 }; 1799 if (GetShowToolBar()) {; 1800 out<<"" ""<<GetName()<<""->ToggleToolBar();""<<std::endl;; 1801 }; 1802 if (GetHighLightColor() != 5) {; 1803 if (TColor::SaveColor(out, GetHighLightColor())); 1804 out<<"" ""<<GetName()<<""->SetHighLightColor(ci);"" << std::endl;; 1805 else; 1806 out<<"" ""<<GetName()<<""->SetHighLightColor(""<<GetHighLightColor()<<"");""<<std::endl;; 1807 }; 1808 ; 1809 // Now recursively scan all pads of this canvas; 1810 cd();; 1811 TPad::SavePrimitive(out,option);; 1812}; 1813 ; 1814////////////////////////////////////////////////////////////////////////////////; 1815/// Save primitives in this canvas as a C++ macro file.; 1816/// This function loops on all the canvas primitives and for each primitive; 1817/// calls the object SavePrimitive function.; 1818/// When outputting floating point numbers, the default precision is 7 digits.; 1819/// The precision can be changed (via system.rootrc) by changing the value; 1820/// of the environment variable ""Canvas.SavePrecision""; 1821 ; 1822void TCanvas::SaveSource(const char *filename, Option_t * /*option*/); 1823{; 1824 // Reset the ClassSaved status of all classes; 1825 gROOT->ResetClassSaved();; 1826 ; 1827 char quote = '""';; 1828 TString cname0 = GetName();; 1829 Bool_t invalid = kFALSE;; 1830 ; 1831 TString cname = cname0.Strip(TString::kBoth);; 1832 if (cname.IsNull()) {; 1833 invalid = kTRUE;; 1834 cname = ""c1"";; 1835 }; 1836 ; 1837 // if filename is given, open this file, otherwise create a file; 1838 // with a name equal to the canvasname.C; 1839 TString fname;; 1840 if (filename && *filename) {; 1841 fname = filename;; 1842 } else {; 1843 fname = cname + "".C"";; 1844 }; 1845 ; 1846 std::ofstream out;; 1847 out.open(fname.Data(), std::ios::out);; 1848 if (!out.good()) {; 1849 Error(""SaveSource"", ""Cannot open file: %s"", fname.Data());; 1850 return;; 1851 }; 1852 ; 1853 //set precision; 1854 Int_t precision = gEnv->GetValue(""Canvas.SavePrecision"",7);; ",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:84203,Modifiability,plugin,plugin,84203,"///////////; 2568/// Check whether this canvas is to be drawn in grayscale mode.; 2569 ; 2570Bool_t TCanvas::IsGrayscale(); 2571{; 2572 return TestBit(kIsGrayscale);; 2573}; 2574 ; 2575////////////////////////////////////////////////////////////////////////////////; 2576/// Set whether this canvas should be painted in grayscale, and re-paint; 2577/// it if necessary.; 2578 ; 2579void TCanvas::SetGrayscale(Bool_t set /*= kTRUE*/); 2580{; 2581 if (IsGrayscale() == set) return;; 2582 SetBit(kIsGrayscale, set);; 2583 if (IsWeb()) {; 2584 Modified();; 2585 UpdateAsync();; 2586 } else {; 2587 Paint(); // update canvas and all sub-pads, unconditionally!; 2588 }; 2589}; 2590 ; 2591////////////////////////////////////////////////////////////////////////////////; 2592/// Probably, TPadPainter must be placed in a separate ROOT module -; 2593/// ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; 2594/// gpad dir, so, in case of default painter, no *.so should be loaded,; 2595/// no need in plugin managers.; 2596/// May change in future.; 2597 ; 2598void TCanvas::CreatePainter(); 2599{; 2600 //Even for batch mode painter is still required, just to delegate; 2601 //some calls to batch ""virtual X"".; 2602 if (!UseGL() || fBatch) {; 2603 fPainter = nullptr;; 2604 if (fCanvasImp) fPainter = fCanvasImp->CreatePadPainter();; 2605 if (!fPainter) fPainter = new TPadPainter; // Do not need plugin manager for this!; 2606 } else {; 2607 fPainter = TVirtualPadPainter::PadPainter(""gl"");; 2608 if (!fPainter) {; 2609 Error(""CreatePainter"", ""GL Painter creation failed! Will use default!"");; 2610 fPainter = new TPadPainter;; 2611 fUseGL = kFALSE;; 2612 }; 2613 }; 2614}; 2615 ; 2616////////////////////////////////////////////////////////////////////////////////; 2617/// Access and (probably) creation of pad painter.; 2618 ; 2619TVirtualPadPainter *TCanvas::GetCanvasPainter(); 2620{; 2621 if (!fPainter) CreatePainter();; 2622 return fPainter;; 2623}; 2624 ; 2625 ; 2626///////////",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:84600,Modifiability,plugin,plugin,84600,"()) {; 2584 Modified();; 2585 UpdateAsync();; 2586 } else {; 2587 Paint(); // update canvas and all sub-pads, unconditionally!; 2588 }; 2589}; 2590 ; 2591////////////////////////////////////////////////////////////////////////////////; 2592/// Probably, TPadPainter must be placed in a separate ROOT module -; 2593/// ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; 2594/// gpad dir, so, in case of default painter, no *.so should be loaded,; 2595/// no need in plugin managers.; 2596/// May change in future.; 2597 ; 2598void TCanvas::CreatePainter(); 2599{; 2600 //Even for batch mode painter is still required, just to delegate; 2601 //some calls to batch ""virtual X"".; 2602 if (!UseGL() || fBatch) {; 2603 fPainter = nullptr;; 2604 if (fCanvasImp) fPainter = fCanvasImp->CreatePadPainter();; 2605 if (!fPainter) fPainter = new TPadPainter; // Do not need plugin manager for this!; 2606 } else {; 2607 fPainter = TVirtualPadPainter::PadPainter(""gl"");; 2608 if (!fPainter) {; 2609 Error(""CreatePainter"", ""GL Painter creation failed! Will use default!"");; 2610 fPainter = new TPadPainter;; 2611 fUseGL = kFALSE;; 2612 }; 2613 }; 2614}; 2615 ; 2616////////////////////////////////////////////////////////////////////////////////; 2617/// Access and (probably) creation of pad painter.; 2618 ; 2619TVirtualPadPainter *TCanvas::GetCanvasPainter(); 2620{; 2621 if (!fPainter) CreatePainter();; 2622 return fPainter;; 2623}; 2624 ; 2625 ; 2626////////////////////////////////////////////////////////////////////////////////; 2627///assert on IsBatch() == false?; 2628 ; 2629void TCanvas::DeleteCanvasPainter(); 2630{; 2631 if (fGLDevice != -1) {; 2632 //fPainter has a font manager.; 2633 //Font manager will delete textures.; 2634 //If context is wrong (we can have several canvases) -; 2635 //wrong texture will be deleted, damaging some of our fonts.; 2636 gGLManager->MakeCurrent(fGLDevice);; 2637 }; 2638 ; 2639 SafeDelete(fPainter);; 2640 ; 2641 if (fGLDevice != -1) {; 2642 g",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:121635,Modifiability,inherit,inherits,121635," the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::ExecuteEventvirtual void ExecuteEvent(Int_t event, Int_t px, Int_t py)Execute action corresponding to an event at (px,py).Definition TObject.cxx:398; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::GetObjectInfovirtual char * GetObjectInfo(Int_t px, Int_t py) constReturns string containing info about the object at position (px,py).Definition TObject.cxx:473; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::Popvirtual void Pop()Pop on object drawn in a pad to the top of the display list.Definition TObject.cxx:621; TObject::kNoContextMenu@ kNoContextMenuif object does not want context menuDefinition TObject.h:69; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPadPainterImplement TVirtualPadPainter which abstracts painting operations.Definition TPadPainter.h:26; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::GetBorderModeShort_t G",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:47938,Performance,response time,response time,47938,"anvas Name="" <<GetName()<<"" Title=""<<GetTitle()<<"" Option=""<<option<<std::endl;; 1508 TROOT::IncreaseDirLevel();; 1509 TPad::ls(option);; 1510 TROOT::DecreaseDirLevel();; 1511}; 1512 ; 1513////////////////////////////////////////////////////////////////////////////////; 1514/// Static function to build a default canvas.; 1515 ; 1516TCanvas *TCanvas::MakeDefCanvas(); 1517{; 1518 auto cdef = GetNewCanvasName();; 1519 ; 1520 auto c = new TCanvas(cdef.Data(), cdef.Data(), 1);; 1521 ; 1522 ::Info(""TCanvas::MakeDefCanvas"","" created default TCanvas with name %s"", cdef.Data());; 1523 return c;; 1524}; 1525 ; 1526////////////////////////////////////////////////////////////////////////////////; 1527/// Set option to move objects/pads in a canvas.; 1528///; 1529/// - set = 1 (default) graphics objects are moved in opaque mode; 1530/// - set = 0 only the outline of objects is drawn when moving them; 1531///; 1532/// The option opaque produces the best effect. It requires however a; 1533/// a reasonably fast workstation or response time.; 1534 ; 1535void TCanvas::MoveOpaque(Int_t set); 1536{; 1537 SetBit(kMoveOpaque,set);; 1538}; 1539 ; 1540////////////////////////////////////////////////////////////////////////////////; 1541/// Paint canvas.; 1542 ; 1543void TCanvas::Paint(Option_t *option); 1544{; 1545 if (fCanvas); 1546 TPad::Paint(option);; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Prepare for pick, call TPad::Pick() and when selected object; 1551/// is different from previous then emit Picked() signal.; 1552 ; 1553TPad *TCanvas::Pick(Int_t px, Int_t py, TObject *prevSelObj); 1554{; 1555 TObjLink *pickobj = nullptr;; 1556 ; 1557 fSelected = nullptr;; 1558 fSelectedOpt = """";; 1559 fSelectedPad = nullptr;; 1560 ; 1561 TPad *pad = Pick(px, py, pickobj);; 1562 if (!pad) return nullptr;; 1563 ; 1564 if (!pickobj) {; 1565 fSelected = pad;; 1566 fSelectedOpt = """";; 1567 } else {; 1568 if (!fSelected) { // can be set v",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:54896,Performance,response time,response time,54896,"6 ; 1727 if (fCw < fCh) {; 1728 fYsizeReal = kDefaultCanvasSize;; 1729 fXsizeReal = fYsizeReal*Double_t(fCw)/Double_t(fCh);; 1730 }; 1731 else {; 1732 fXsizeReal = kDefaultCanvasSize;; 1733 fYsizeReal = fXsizeReal*Double_t(fCh)/Double_t(fCw);; 1734 }; 1735 ; 1736//*-*- Loop on all pads to recompute conversion coefficients; 1737 TPad::ResizePad();; 1738}; 1739 ; 1740 ; 1741////////////////////////////////////////////////////////////////////////////////; 1742/// Raise canvas window; 1743 ; 1744void TCanvas::RaiseWindow(); 1745{; 1746 if (fCanvasImp); 1747 fCanvasImp->RaiseWindow();; 1748}; 1749 ; 1750////////////////////////////////////////////////////////////////////////////////; 1751/// Set option to resize objects/pads in a canvas.; 1752///; 1753/// - set = 1 (default) graphics objects are resized in opaque mode; 1754/// - set = 0 only the outline of objects is drawn when resizing them; 1755///; 1756/// The option opaque produces the best effect. It requires however a; 1757/// a reasonably fast workstation or response time.; 1758 ; 1759void TCanvas::ResizeOpaque(Int_t set); 1760{; 1761 SetBit(kResizeOpaque,set);; 1762}; 1763 ; 1764////////////////////////////////////////////////////////////////////////////////; 1765/// Execute the list of TExecs in the current pad.; 1766 ; 1767void TCanvas::RunAutoExec(); 1768{; 1769 if (!TestBit(kAutoExec)); 1770 return;; 1771 if (gPad); 1772 ((TPad*)gPad)->AutoExec();; 1773}; 1774 ; 1775////////////////////////////////////////////////////////////////////////////////; 1776/// Save primitives in this canvas in C++ macro file with GUI.; 1777 ; 1778void TCanvas::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1779{; 1780 // Write canvas options (in $TROOT or $TStyle); 1781 if (gStyle->GetOptFit()) {; 1782 out<<"" gStyle->SetOptFit(1);""<<std::endl;; 1783 }; 1784 if (!gStyle->GetOptStat()) {; 1785 out<<"" gStyle->SetOptStat(0);""<<std::endl;; 1786 }; 1787 if (!gStyle->GetOptTitle()) {; 1788 out<<"" gStyle->SetOptTitle(0);""<<std",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:58837,Performance,optimiz,optimize,58837,"32 if (cname.IsNull()) {; 1833 invalid = kTRUE;; 1834 cname = ""c1"";; 1835 }; 1836 ; 1837 // if filename is given, open this file, otherwise create a file; 1838 // with a name equal to the canvasname.C; 1839 TString fname;; 1840 if (filename && *filename) {; 1841 fname = filename;; 1842 } else {; 1843 fname = cname + "".C"";; 1844 }; 1845 ; 1846 std::ofstream out;; 1847 out.open(fname.Data(), std::ios::out);; 1848 if (!out.good()) {; 1849 Error(""SaveSource"", ""Cannot open file: %s"", fname.Data());; 1850 return;; 1851 }; 1852 ; 1853 //set precision; 1854 Int_t precision = gEnv->GetValue(""Canvas.SavePrecision"",7);; 1855 out.precision(precision);; 1856 ; 1857 // Write macro header and date/time stamp; 1858 TDatime t;; 1859 Float_t cx = gStyle->GetScreenFactor();; 1860 Int_t topx,topy;; 1861 UInt_t w, h;; 1862 if (!fCanvasImp) {; 1863 Error(""SaveSource"", ""Cannot open TCanvas"");; 1864 return;; 1865 }; 1866 UInt_t editorWidth = fCanvasImp->GetWindowGeometry(topx,topy,w,h);; 1867 w = UInt_t((fWindowWidth - editorWidth)/cx);; 1868 h = UInt_t((fWindowHeight)/cx);; 1869 topx = GetWindowTopX();; 1870 topy = GetWindowTopY();; 1871 ; 1872 if (w == 0) {; 1873 w = GetWw()+4; h = GetWh()+4;; 1874 topx = 1; topy = 1;; 1875 }; 1876 ; 1877 TString mname = fname;; 1878 out << R""CODE(#ifdef __CLING__; 1879#pragma cling optimize(0); 1880#endif; 1881)CODE"";; 1882 Int_t p = mname.Last('.');; 1883 Int_t s = mname.Last('/')+1;; 1884 ; 1885 // A named macro is generated only if the function name is valid. If not, the; 1886 // macro is unnamed.; 1887 TString first(mname(s,s+1));; 1888 if (!first.IsDigit()) out <<""void "" << mname(s,p-s) << ""()"" << std::endl;; 1889 ; 1890 out <<""{""<<std::endl;; 1891 out <<""//=========Macro generated from canvas: ""<<GetName()<<""/""<<GetTitle()<<std::endl;; 1892 out <<""//========= (""<<t.AsString()<<"") by ROOT version ""<<gROOT->GetVersion()<<std::endl;; 1893 ; 1894 if (gStyle->GetCanvasPreferGL()); 1895 out <<std::endl<<"" gStyle->SetCanvasPreferGL(kTRUE);""<<std::endl<<st",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:82682,Performance,perform,performed,82682,"hreadXAR mechanism does seemingly; 2518 // the same?; 2519 gInterpreter->Execute(this, IsA(), ""Update"", """");; 2520 return;; 2521 }; 2522 ; 2523 R__LOCKGUARD(gROOTMutex);; 2524 ; 2525 fUpdating = kTRUE;; 2526 ; 2527 if (!fCanvasImp->PerformUpdate(kFALSE)) {; 2528 ; 2529 if (!IsBatch()) FeedbackMode(kFALSE); // Goto double buffer mode; 2530 ; 2531 if (!UseGL() || fGLDevice == -1) PaintModified(); // Repaint all modified pad's; 2532 ; 2533 Flush(); // Copy all pad pixmaps to the screen; 2534 ; 2535 SetCursor(kCross);; 2536 }; 2537 ; 2538 fUpdating = kFALSE;; 2539}; 2540 ; 2541////////////////////////////////////////////////////////////////////////////////; 2542/// Asynchronous pad update.; 2543/// In case of web-based canvas triggers update of the canvas on the client side,; 2544/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2545/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2546/// In case of normal canvas just canvas->Update() is performed.; 2547 ; 2548void TCanvas::UpdateAsync(); 2549{; 2550 fUpdated = kTRUE;; 2551 ; 2552 if (IsWeb()); 2553 fCanvasImp->PerformUpdate(kTRUE);; 2554 else; 2555 Update();; 2556}; 2557 ; 2558////////////////////////////////////////////////////////////////////////////////; 2559/// Used by friend class TCanvasImp.; 2560 ; 2561void TCanvas::DisconnectWidget(); 2562{; 2563 fCanvasID = 0;; 2564 fContextMenu = nullptr;; 2565}; 2566 ; 2567////////////////////////////////////////////////////////////////////////////////; 2568/// Check whether this canvas is to be drawn in grayscale mode.; 2569 ; 2570Bool_t TCanvas::IsGrayscale(); 2571{; 2572 return TestBit(kIsGrayscale);; 2573}; 2574 ; 2575////////////////////////////////////////////////////////////////////////////////; 2576/// Set whether this canvas should be painted in grayscale, and re-paint; 2577/// it if necessary.; 2578 ; 2579void TCanvas::SetGrayscale(Bool_t set /*= kTRUE*/); 2580{; 2581 if (IsGrayscale() == ",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:84175,Performance,load,loaded,84175,"///////////; 2568/// Check whether this canvas is to be drawn in grayscale mode.; 2569 ; 2570Bool_t TCanvas::IsGrayscale(); 2571{; 2572 return TestBit(kIsGrayscale);; 2573}; 2574 ; 2575////////////////////////////////////////////////////////////////////////////////; 2576/// Set whether this canvas should be painted in grayscale, and re-paint; 2577/// it if necessary.; 2578 ; 2579void TCanvas::SetGrayscale(Bool_t set /*= kTRUE*/); 2580{; 2581 if (IsGrayscale() == set) return;; 2582 SetBit(kIsGrayscale, set);; 2583 if (IsWeb()) {; 2584 Modified();; 2585 UpdateAsync();; 2586 } else {; 2587 Paint(); // update canvas and all sub-pads, unconditionally!; 2588 }; 2589}; 2590 ; 2591////////////////////////////////////////////////////////////////////////////////; 2592/// Probably, TPadPainter must be placed in a separate ROOT module -; 2593/// ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; 2594/// gpad dir, so, in case of default painter, no *.so should be loaded,; 2595/// no need in plugin managers.; 2596/// May change in future.; 2597 ; 2598void TCanvas::CreatePainter(); 2599{; 2600 //Even for batch mode painter is still required, just to delegate; 2601 //some calls to batch ""virtual X"".; 2602 if (!UseGL() || fBatch) {; 2603 fPainter = nullptr;; 2604 if (fCanvasImp) fPainter = fCanvasImp->CreatePadPainter();; 2605 if (!fPainter) fPainter = new TPadPainter; // Do not need plugin manager for this!; 2606 } else {; 2607 fPainter = TVirtualPadPainter::PadPainter(""gl"");; 2608 if (!fPainter) {; 2609 Error(""CreatePainter"", ""GL Painter creation failed! Will use default!"");; 2610 fPainter = new TPadPainter;; 2611 fUseGL = kFALSE;; 2612 }; 2613 }; 2614}; 2615 ; 2616////////////////////////////////////////////////////////////////////////////////; 2617/// Access and (probably) creation of pad painter.; 2618 ; 2619TVirtualPadPainter *TCanvas::GetCanvasPainter(); 2620{; 2621 if (!fPainter) CreatePainter();; 2622 return fPainter;; 2623}; 2624 ; 2625 ; 2626///////////",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:132951,Performance,load,load,132951,"asColor() constDefinition TStyle.h:188; TStyle::GetPadBottomMarginFloat_t GetPadBottomMargin() constDefinition TStyle.h:211; TStyle::GetCanvasDefWInt_t GetCanvasDefW() constDefinition TStyle.h:192; TStyle::GetOptLogxInt_t GetOptLogx() constDefinition TStyle.h:247; TStyle::GetCanvasBorderModeInt_t GetCanvasBorderMode() constDefinition TStyle.h:190; TStyle::GetCanvasBorderSizeWidth_t GetCanvasBorderSize() constDefinition TStyle.h:189; TStyle::GetOptFitInt_t GetOptFit() constDefinition TStyle.h:244; TStyle::GetOptLogzInt_t GetOptLogz() constDefinition TStyle.h:249; TStyle::GetPadTopMarginFloat_t GetPadTopMargin() constDefinition TStyle.h:212; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TView::Classstatic TClass * Class(); TVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG.Definition TVirtualPS.h:30; TVirtualPadEditor::GetPadEditorstatic TVirtualPadEditor * GetPadEditor(Bool_t load=kTRUE)Returns the pad editor dialog. Static method.Definition TVirtualPadEditor.cxx:74; TVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas.Definition TVirtualPadPainter.h:19; TVirtualPadPainter::LockPaintervirtual void LockPainter()Empty definition.Definition TVirtualPadPainter.cxx:51; TVirtualPadPainter::PadPainterstatic TVirtualPadPainter * PadPainter(Option_t *opt="""")Create a pad painter of specified type.Definition TVirtualPadPainter.cxx:58; TVirtualPadPainter::SelectDrawablevirtual void SelectDrawable(Int_t device)=0; TVirtualPadPainter::InitPaintervirtual void InitPainter()Empty definition.Definition TVirtualPadPainter.cxx:37; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; TVirtualPad::TContext::GetSavedauto GetSaved() constDefinition TVirtualPad.h:69; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51;",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
https://root.cern/doc/master/TCanvas_8cxx_source.html:7609,Safety,avoid,avoid,7609,"vas, i.e. a canvas that is in a TGCanvas widget; 218/// which is placed in a TGFrame. This ctor is only called via the; 219/// TRootEmbeddedCanvas class.; 220///; 221/// If ""name"" starts with ""gl"" the canvas is ready to receive GL output.; 222 ; 223TCanvas::TCanvas(const char *name, Int_t ww, Int_t wh, Int_t winid) : TPad(), fDoubleBuffer(0); 224{; 225 fCanvasImp = nullptr;; 226 fPainter = nullptr;; 227 Init();; 228 ; 229 fCanvasID = winid;; 230 fWindowTopX = 0;; 231 fWindowTopY = 0;; 232 fWindowWidth = ww;; 233 fWindowHeight = wh;; 234 fCw = ww + 4;; 235 fCh = wh +28;; 236 fBatch = kFALSE;; 237 fUpdating = kFALSE;; 238 ; 239 //This is a very special ctor. A window exists already!; 240 //Can create painter now.; 241 fUseGL = gStyle->GetCanvasPreferGL();; 242 ; 243 if (fUseGL) {; 244 fGLDevice = gGLManager->CreateGLContext(winid);; 245 if (fGLDevice == -1); 246 fUseGL = kFALSE;; 247 }; 248 ; 249 fCanvasImp = gBatchGuiFactory->CreateCanvasImp(this, name, fCw, fCh);; 250 if (!fCanvasImp) return;; 251 ; 252 CreatePainter();; 253 fName = GetNewCanvasName(name); // avoid Modified() signal from SetName; 254 Build();; 255}; 256 ; 257////////////////////////////////////////////////////////////////////////////////; 258/// Create a new canvas with a predefined size form.; 259/// If form < 0 the menubar is not shown.; 260///; 261/// - form = 1 700x500 at 10,10 (set by TStyle::SetCanvasDefH,W,X,Y); 262/// - form = 2 500x500 at 20,20; 263/// - form = 3 500x500 at 30,30; 264/// - form = 4 500x500 at 40,40; 265/// - form = 5 500x500 at 50,50; 266///; 267/// If ""name"" starts with ""gl"" the canvas is ready to receive GL output.; 268 ; 269TCanvas::TCanvas(const char *name, const char *title, Int_t form) : TPad(), fDoubleBuffer(0); 270{; 271 fPainter = nullptr;; 272 fUseGL = gStyle->GetCanvasPreferGL();; 273 ; 274 Constructor(name, title, form);; 275}; 276 ; 277////////////////////////////////////////////////////////////////////////////////; 278/// Create a new canvas with a predefined ",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
